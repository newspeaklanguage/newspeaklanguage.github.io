let sources = [
 null,
 "class RuntimeForV8 packageUsing: manifest = (\r(* Provides the platform object for Newspeak on Javascript.\r\rCopyright 2012 Google Inc.\rCopyright 2013 Ryan Macnak\r\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)\r|\r	Kernel = manifest KernelForV8.\r	Actors = manifest ActorsForV8.\r	Aliens = manifest AliensForV8.\r	Collections = manifest Collections.\r	Mirrors = manifest MirrorsForV8.\r	public MirrorGroups = manifest MirrorGroups.\r	Streams = manifest Streams.\r|)",
 " ",
 " ",
 "public using: vmmirror = (\r	Object enclosingObject augmentPrototypes.\r	^Platform usingVmMirror: vmmirror\r)",
 "class Platform usingVmMirror: vmmirror = (\r	|\r	public kernel = Object enclosingObject. (* Instantiated specially to avoid bootstrapping issues. *)\r	public actors = Future computing: [Actors usingPlatform: self].\r	public js = Future computing: [Aliens usingPlatform: self].\r	public collections = Future computing: [Collections usingPlatform: self].\r	public mirrors = Future computing: [Mirrors usingPlatform: self runtime: outer RuntimeForV8 vmMirror: vmmirror].\r	public streams = Future computing: [Streams usingPlatform: self].\r	|\r	kernel platform: self.\r	actors yourself.\r)",
 " ",
 " ",
 "public Exception = (\r	^Error\r)",
 "public Message = (\r	^kernel Message\r)",
 "public MessageNotUnderstood = (\r	^kernel MessageNotUnderstood\r)",
 "public UnhandledError = (\r	^Error\r)",
 "class KernelForV8 usingVmMirror: vmm = (\r(*\rKernel classes for the Javscript-based implementation of Newspeak.\rCopyright 2008 Cadence Design Systems, Inc.\rCopyright 2009-2010 Gilad Bracha.\rCopyright 2012 SAP AG.\rCopyright 2012 Google Inc.\rCopyright 2013 Ryan Macnak\r\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)\r|\rvmmirror = vmm.\rpublic platform\r|)",
 " ",
 " ",
 "public Error = (\r	(* Squeak compatibility *)\r	^Exception\r)",
 "public UnhandledError = (\r	(* Squeak compatibility *)\r	^Exception\r)",
 "augment: prototype withPropertiesOf: runtimeClass = (\r	| keys = js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'keys')) with: {runtimeClass}. |\r	js call: (js propertyOf: keys at: (js literal: 'forEach')) with: {js functionOf: {'key'} body: (js block: {\r		(*js if: (js operator: '||' with: (js call: (js propertyOf: (js ident: 'key') at: (js literal: 'startsWith')) with: {js literal: '$'}) and:\r			(js call: (js propertyOf: (js ident: 'key') at: (js literal: 'startsWith')) with: {js literal: '_$'})) then: (js block: {*)\r			js assign: (js propertyOf: prototype at: (js ident: 'key'))\r				toBe: (js propertyOf: runtimeClass at: (js ident: 'key')).\r			(*(js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'defineProperty')) with: {\r				prototype.\r				(js ident: 'key').\r				js objectLiteralSlotNames: {js literal: 'enumerable'} values: {js literal: false}.\r			})\r		}).*)\r	})}.\r)",
 "public augmentPrototypes = (\r	js call: (js ident: 'installDnuHandlersOn') with: {js verbatim: 'Object.prototype'}.\r	augment: (js verbatim: 'Array.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Array.prototype') withPropertiesOf: (js propertyOf: Array at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Boolean.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Boolean.prototype') withPropertiesOf: (js propertyOf: Boolean at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Function.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Function.prototype') withPropertiesOf: (js propertyOf: Closure at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Number.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Number.prototype') withPropertiesOf: (js propertyOf: Number at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'String.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'String.prototype') withPropertiesOf: (js propertyOf: String at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Uint8Array.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Uint8Array.prototype') withPropertiesOf: (js propertyOf: ByteArray at: (js literal: 'runtimeClass')).\r)",
 "private classOf: object = (\r	(js prefixOperator: 'typeof ' on: object) == 'string' ifTrue: [^String].\r	(js prefixOperator: 'typeof ' on: object) == 'number' ifTrue: [^Number].\r	(js prefixOperator: 'typeof ' on: object) == 'boolean' ifTrue: [^Boolean].\r	(js prefixOperator: 'typeof ' on: object) == 'function' ifTrue: [^Closure].\r	(js operator: 'instanceof' with: object and: (js ident: 'Array')) ifTrue: [^Array].\r	(js operator: 'instanceof' with: object and: (js ident: 'Uint8Array')) ifTrue: [^ByteArray].\r	^js propertyOf: object at: (js literal: 'newspeakClass')\r)",
 "private print: string = (\r	js\r		ternaryIf: ((js prefixOperator: 'typeof ' on: (js ident: 'console')) == 'undefined')\r		then: (js call: (js ident: 'print') with: {string})\r		else: (js call: (js propertyOf: (js ident: 'console') at: (js literal: 'log')) with: {string})\r)",
 "public class Array uninstantiable = ()",
 " ",
 " ",
 "public , otherSequence = (\r	^js call: (js propertyOf: self at: (js literal: 'concat')) with: {otherSequence asArray}\r)",
 "public asArray = (\r	^self\r)",
 "public asOrderedCollection = (\r	^platform collections List withAll: self\r)",
 "public at: index <Integer> ^<E> = (\r	| jsIndex |\r	(js prefixOperator: 'typeof ' on: index) == 'number' ifFalse: [^Error signal: 'ArgumentError'].\r	jsIndex:: js operator: '-' with: index and: (js literal: 1).\r	(js operator: '<' with: jsIndex and: (js literal: 0)) ifTrue: [^Error signal: 'ArgumentError'].\r	(js operator: '>=' with: jsIndex and: (js verbatim: 'this.length')) ifTrue: [^Error signal: 'ArgumentError'].\r	^js propertyOf: (js ident: 'this') at: jsIndex\r)",
 "public at: index <Integer> put: value <E> ^<E> = (\r	| jsIndex |\r	(js prefixOperator: 'typeof ' on: index) == 'number' ifFalse: [^Error signal: 'ArgumentError'].\r	jsIndex:: js operator: '-' with: index and: (js literal: 1).\r	(js operator: '<' with: jsIndex and: (js literal: 0)) ifTrue: [^Error signal: 'ArgumentError'].\r	(js operator: '>=' with: jsIndex and: (js verbatim: 'this.length')) ifTrue: [^Error signal: 'ArgumentError'].\r	^js assign: (js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1)))\r	 toBe: value\r)",
 "public binarySearchFor: el between: start and: end toCompare: compare = (\r	(* This does a binary search for the index such that if el was inserted before it\r	  the receiver would remain sorted.  The receiver must be sorted relative to the\r	  comparison block.  The comparison block should return true if the first block argument\r	  cannot appear after the second block argument *)\r\r	| low high |\r	low:: start.\r	high:: end.\r	[ low <= high ]\r		whileTrue:\r				[ | mid |\r					mid:: (low + high) // 2.\r	  				(compare value: (self at: mid) value: el)\r						ifTrue: [ low:: mid + 1 ]\r						ifFalse: [ high:: mid - 1 ].\r				].\r	^low\r)",
 "public collect: block = (\r	^js call: (js propertyOf: self at: (js literal: 'map')) with: {block}.\r)",
 "public copyFrom: start to: end = (\r	^js call: (js propertyOf: self at: (js literal: 'slice')) with: {start - 1. end}\r)",
 "public copyWith: extraElement = (\r	| newSize ::= self size + 1. a |\r	a:: (Array new: newSize) replaceFrom: 1 to: self size with: self.\r	a at: newSize put: extraElement.\r	^a\r)",
 "public copyWithSize: s = (\r	^(Array new: s) replaceFrom: 1 to: (s min: self size) with: self\r)",
 "defaultMedianOf: a <Int> and: b <Int> and: c <Int> ^<Int> = (\r	(* This is an untypesafe method that only works for MutableLists of elements that\r		have Magnitude relationships with each other.  It is used by the default sorting\r		method. *)\r\r	| atA <E> atB <E> atC <E> |\r	atA:: at: a.\r	atB:: at: b.\r	atC:: at: c.\r	^atB <= atA\r		ifFalse: [ atC <= atB\r							ifFalse: [ b ]\r							ifTrue: [ atC <= atA\r												ifFalse: [ c ]\r												ifTrue: [ a ] 	] ]\r		ifTrue: [ atB <= atC\r							ifFalse: [ b ]\r							ifTrue: [ atA <= atC\r												ifFalse: [ c ]\r												ifTrue: [ a ] 	] ]\r)",
 "public defaultSort: l <Int> to: r <Int> = (\r	(* This is an untypesafe method that only works for MutableLists of elements that\r		have Magnitude relationships with each other *)\r\r	| i <Int> j <Int> x <E> m <Int> n <Int> |\r	i:: l.\r	j:: r.\r	n:: ((r - l) + 1).\r	n == 0\r		ifTrue: [ ^self ].\r\r	(* Pick the partition value.  For <=7 elements, use the middle element.\r		For more than 7 but <= 40, use a median of three elements.  For > 40,\r		use a median of three medians of three *)\r	m:: (l + r) // 2.\r	n > 7\r		ifTrue: [ | pl <Int> pn <Int> s <Int> |\r						pl:: l.\r						pn:: r.\r						n > 40\r							ifTrue: [ s:: n // 8.\r											pl:: defaultMedianOf: pl and: pl+s and: pl+s+s.\r											m:: defaultMedianOf: m-s and: m and: m+s.\r											pn:: defaultMedianOf: (pn-s)-s and: pn-s and: pn.	].\r						m:: defaultMedianOf: pl and: m and: pn.		].\r	x:: at: m.\r\r	[i <= j]\r		whileTrue:\r			[ | ati <E> atj <E> |\r			 	[ x <= (ati:: at: i)]\r					whileFalse: [i:: i + 1].\r				[(atj:: at: j) <= x]\r					whileFalse: [j:: j - 1].\r				i <= j\r					ifTrue: [ at: i put: atj.\r									at: j put: ati.\r									i:: i + 1.\r									j:: j - 1]\r			].\r	l < j ifTrue: [defaultSort: l to: j ].\r	i < r ifTrue: [defaultSort: i to: r ].\r)",
 "public do: block = (\r	js call: (js propertyOf: self at: (js literal: 'forEach')) with: {block}.\r)",
 "public do: block separatedBy: betweenBlock = (\r	| firstTime ::= true. |\r\r	self do: [:element |\r		firstTime ifTrue: [ firstTime:: false ] ifFalse: [betweenBlock value].\r		block value: element].\r)",
 "public first = (\r	^self at: 1\r)",
 "public flatMap: map <[:E | R def]> ^<Collection[R]> = (\r	^self flatten collect: map\r)",
 "public flatten ^ <Array> = (\r	| totalSize <Integer> ::= 0. c <Array> index <Integer> ::= 1. |\r	self do: [:e <E> | totalSize:: totalSize + (e isKindOfCollection ifTrue: [e size] ifFalse: [1])].\r	c:: Array new: totalSize.\r	do: [:e <E> | e isKindOfCollection\r					ifTrue: [e do: [:x | c at: index put: x. index:: index + 1]]\r					ifFalse: [c at: index put: e. index:: index + 1]\r		].\r	^c\r)",
 "public includes: element = (\r	self do: [:each | each = element ifTrue: [^true]].\r	^false\r)",
 "public indexOf: element <E> ^<Integer> = (\r	1 to: self size do: [:index | (self at: index) = element ifTrue: [^index]].\r	^0\r)",
 "public inject: initialValue into: accumulator = (\r	^js call: (js propertyOf: self at: (js literal: 'reduce')) with: {accumulator. initialValue}.\r)",
 "public isArray = (\r	^true\r)",
 "public isCollection ^<Boolean> = (\r	^true\r)",
 "public isEmpty = (\r	^0 == size\r)",
 "public isKindOfArray ^<Boolean> = (\r	^true\r)",
 "public isKindOfCollection ^<Boolean> = (\r	^true\r)",
 "public keysAndValuesDo: binaryBlock <[:Integer :E]> = (\r	1 to: self size do: [:index | binaryBlock value: index value: (self at: index)]\r)",
 "public last = (\r	^self at: self size\r)",
 "public mergeSortFrom: startIndex to: stopIndex by: aBlock = (\r	(*Sort the given range of indices using the mergesort algorithm.\r	Mergesort is a worst-case O(N log N) sorting algorithm that usually\r	does only half as many comparisons as heapsort or quicksort.\r\r	Details: recursively split the range to be sorted into two halves,\r	mergesort each half, then merge the two halves together. An extra\r	copy of the data is used as temporary storage and successive merge\r	phases copy data back and forth between the receiver and this copy.\r	The recursion is set up so that the final merge is performed into the\r	receiver, resulting in the receiver being completely sorted.*)\r\r	self size <= 1 ifTrue: [^self]. (* nothing to do *)\r	startIndex = stopIndex ifTrue: [^self].\r	self assert: [startIndex >= 1 and: [startIndex < stopIndex]]. (* bad start index *)\r	self assert: [stopIndex <= self size]. (* bad stop index *)\r	self (* BOGUS: probably replace with splice, sort and replace *)\r		mergeSortFrom: startIndex\r		to: stopIndex\r		src: self clone\r		dst: self\r		by: aBlock\r)",
 "public printString = (\r	| x ::= '{'. |\r	#FLAG. (* This is not safe for arrays that contain themselves. *)\r	self do: [:ea | x:: x , ea printString] separatedBy: [x:: x, '. '].\r	^x , '}'\r)",
 "public replaceFrom: start to: stop with: replacement = (\r	(* This destructively replaces elements from start to stop in the receiver.\r	Answer the receiver itself. Use copyReplaceFrom:to:with: for\r	insertion/deletion which may alter the size of the result. *)\r\r	replacement size = (stop - start + 1)\r		ifFalse: [self error: 'Size of replacement doesnt match'].\r	^self replaceFrom: start to: stop with: replacement startingAt: 1\r)",
 "public replaceFrom: start to: stop with: replacement startingAt: repStart = (\r	(* This destructively replaces elements from start to stop in the receiver\r	starting at index, repStart, in the sequenceable collection,\r	replacementCollection. Answer the receiver. No range checks are\r	performed. *)\r\r	| index repOff |\r	repOff:: repStart - start.\r	index:: start - 1.\r	[(index:: index + 1) <= stop]\r		whileTrue: [self at: index put: (replacement at: repOff + index)]\r)",
 "public select: block = (\r	^js call: (js propertyOf: self at: (js literal: 'filter')) with: {block}.\r)",
 "public size ^<Integer> = (\r	^js propertyOf: self at: (js literal: 'length')\r)",
 "public sort: binaryBlock = (\r	js\r		call: (js propertyOf: self at: (js literal: 'sort'))\r		with: {js functionOf: {'a'. 'b'} body: (js block: {\r			js return: ((binaryBlock value: (js ident: 'a') value: (js ident: 'b'))\r				ifTrue: [-1] ifFalse: [1])\r		})}.\r)",
 "public new: size <Integer> = (\r(* should be private but does not work that way! Possible compiler bug. *)\r	^self new: size withAll: nil\r)",
 "new: size <Integer> withAll: initialElement <E> ^<Array[E]> = (\r	| array index |\r	(js prefixOperator: 'typeof ' on: size) == 'number' ifFalse: [^Error signal: 'ArgumentError'].\r	(js operator: '<' with: size and: (js literal: 0)) ifTrue: [^Error signal: 'ArgumentError'].\r\r	array:: js new: (js ident: 'Array') with: {size}.\r	js\r		for: (index:: 0)\r		while: (js operator: '<' with: index and: size)\r		step: (js postfixOperator: '++' on: index)\r		do: (js block: {\r			js assign: (js propertyOf: array at: index) toBe: initialElement}).\r	^array\r)",
 "public with: element = (\r	^{element}\r)",
 "public class Boolean uninstantiable = ()",
 " ",
 " ",
 "public & other = (\r	(* Evaluating conjunction. *)\r	^js operator: '&&' with: self and: other\r)",
 "public and: alternative <[Boolean]> ^ <Boolean> = (\r  (* Non-evaluating conjunction *)\r  ^js ternaryIf: self then: (js call: alternative with: {}) else: self\r)",
 "public asString = (\r	^self ifTrue: ['true'] ifFalse: ['false']\r)",
 "public ifFalse: else = (\r	^js ternaryIf: self then: nil else: (js call: else with: {})\r)",
 "public ifFalse: else ifTrue: then = (\r	^js ternaryIf: self then: (js call: then with: {}) else: (js call: else with: {})\r)",
 "public ifTrue: onTrue = (\r	^js ternaryIf: self then: (js call: onTrue with: {}) else: nil\r)",
 "public ifTrue: then ifFalse: else = (\r	^js ternaryIf: self then: (js call: then with: {}) else: (js call: else with: {})\r)",
 "public isKindOfBoolean = (\r	^true\r)",
 "public not = (\r	^js prefixOperator: '!' on: self.\r)",
 "public or: alternative <[Boolean]> ^ <Boolean> = (\r  (* Non-evaluating disjunction *)\r  ^js ternaryIf: self then: self else:  (js call: alternative with: {})\r)",
 "public printString = (\r	^self ifTrue: ['true'] ifFalse: ['false']\r)",
 "public value = (\r	^self\r)",
 "public | other = (\r	(* Evaluating disjunction. *)\r	^js operator: '||' with: self and: other\r)",
 "public class ByteArray uninstantiable = (\r)",
 " ",
 " ",
 "public at: index <Integer> ^<E> = (\r	| jsIndex |\r	(js prefixOperator: 'typeof ' on: index) == 'number' ifFalse: [^Error signal: 'ArgumentError'].\r	jsIndex:: js operator: '-' with: index and: (js literal: 1).\r	(js operator: '<' with: jsIndex and: (js literal: 0)) ifTrue: [^Error signal: 'ArgumentError'].\r	(js operator: '>=' with: jsIndex and: (js verbatim: 'this.length')) ifTrue: [^Error signal: 'ArgumentError'].\r	^js propertyOf: (js ident: 'this') at: jsIndex\r)",
 "public at: index <Integer> put: value <E> ^<E> = (\r	| jsIndex |\r	(js prefixOperator: 'typeof ' on: index) == 'number' ifFalse: [^Error signal: 'ArgumentError'].\r	jsIndex:: js operator: '-' with: index and: (js literal: 1).\r	(js operator: '<' with: jsIndex and: (js literal: 0)) ifTrue: [^Error signal: 'ArgumentError'].\r	(js operator: '>=' with: jsIndex and: (js verbatim: 'this.length')) ifTrue: [^Error signal: 'ArgumentError'].\r	^js assign: (js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1)))\r	 toBe: value\r)",
 "public isEmpty = (\r	^0 == size\r)",
 "public keysAndValuesDo: binaryBlock <[:Integer :Integer]> = (\r	1 to: self size do: [:index | binaryBlock value: index value: (self at: index)]\r)",
 "public size ^<Integer> = (\r	^js propertyOf: self at: (js literal: 'length')\r)",
 "public new: size <Integer> ^<ByteArray> = (\r	(js prefixOperator: 'typeof ' on: size) == 'number' ifFalse: [^Error signal: 'ArgumentError'].\r	size < 0 ifTrue: [^Error signal: 'ArgumentError'].\r	^js new: (js ident: 'Uint8Array') with: {size}\r)",
 "public class Class = (|\rpublic superclass\rpublic mixin\rpublic enclosingObject (* Remove me *)\rpublic enclosingObjects\rpublic name\r|)",
 " ",
 " ",
 "public isKindOfBehavior = (\r	^true\r)",
 "public isKindOfClass = (\r	^true\r)",
 "public isMeta = (\r	^true\r)",
 "public mixinApply: newSuperclass = (\r	^vmmirror\r		applyMixin: (js propertyOf: self mixin at: (js literal: 'runtimeMixin'))\r		toSuperclass: newSuperclass\r		withEnclosingObjects: self enclosingObjects\r)",
 "public simpleName = (\r	^mixin name\r)",
 "public class Closure uninstantiable = ()",
 " ",
 " ",
 "public cull: a1 = (\r	^js call: (js ident: 'this') with: {a1}\r)",
 "public cull: a1 cull: a2 = (\r	^js call: (js ident: 'this') with: {a1. a2}\r)",
 "public cull: a1 cull: a2 cull: a3 = (\r	^js call: (js ident: 'this') with: {a1. a2. a3}\r)",
 "public ensure: onUnwind = (\r	| result |\r	js try: (js block: {\r		result:: self value.\r	})\r	catch: (js ident: 'e')\r	with: (js block: {\r		onUnwind value.\r		js throw: (js ident: 'e').\r	}).\r	onUnwind value.\r	^result\r)",
 "public isKindOfClosure ^<Boolean> = (\r	^true\r)",
 "public numArgs ^<Integer> = (\r	^js propertyOf: self at: (js literal: 'length')\r)",
 "public on: errorClass do: handler = (\r	(* Perhaps we should match on mixin instead of class... *)\r	| c |\r	js try: (js block: {js return: self value})\r	catch: (js ident: 'e')\r	with: (js block: {\r		js if: (js operator: '===' with: (js propertyOf: (js ident: 'e') at: (js literal: 'newspeakClass')) and: (js ident: 'undefined'))\r		then: (js block: {js throw: (js ident: 'e')}).\r		js for: (c:: classOf: (js ident: 'e')) while: (js operator: '!==' with: c and: nil) step: (js verbatim: '') do: (js block: {\r			js if: (js operator: '===' with: c and: errorClass)\r			then: (js block: {js return: (handler value: (js ident: 'e'))}).\r			c:: c superclass.\r		}).\r		js throw: (js ident: 'e').\r	})\r)",
 "public value = (\r	^js call: (js ident: 'this') with: {}\r)",
 "public value: a1 = (\r	^js call: (js ident: 'this') with: {a1}\r)",
 "public value: a1 value: a2 = (\r	^js call: (js ident: 'this') with: {a1. a2}\r)",
 "public value: a1 value: a2 value: a3 = (\r	^js call: (js ident: 'this') with: {a1. a2. a3}\r)",
 "public valueWithArguments: args = (\r	^js call: (js propertyOf: (js ident: 'this') at: (js literal: 'apply')) with: {js ident: 'this'. args}\r)",
 "public whileFalse: aBlock = (\r	[self value] whileFalse: [aBlock value].\r	^nil\r)",
 "public class Exception = (|\r	public messageText (* squeak compatibility for Minitest *)\r|)",
 " ",
 " ",
 "public isError = (\r	^true\r)",
 "public printString = (\r	nil = messageText ifTrue: [^super class name].\r	^super class name, ': ', messageText\r)",
 "public signal = (\r	js verbatim: 'this.trace = new Error().stack'.\r	js throw: self.\r)",
 "public signal: message = (\r	(* squeak compatibility for Minitest *)\r	messageText:: message.\r	^self signal\r)",
 "public signal: message = (\r	^(self new messageText: message) signal\r)",
 "public class Future computing: block <[E]> = (\r(* The simplest possible future. It evalutes its closure in response to nearly every message. *)\r|\r	private blockOrValue000 <[E] | E> ::= block.\r	private state000 <Symbol> ::= #unresolved.\r|)",
 " ",
 " ",
 "protected doesNotUnderstand: message = (\r	^message sendTo: self resolve\r)",
 "public isKindOfFuture ^<Boolean> = (\r	^true\r)",
 "resolve = (\r	state000 = #resolving ifTrue: [\r		Error signal: 'Divergent evaluation of ', blockOrValue000 printString].\r	state000 = #unresolved ifTrue: [\r		state000: #resolving.\r		blockOrValue000: blockOrValue000 value.\r		[blockOrValue000 isKindOfFuture] whileTrue:\r			[blockOrValue000: blockOrValue000 resolve].\r		state000: #resolved.\r	].\r	^blockOrValue000\r)",
 "public yourself = (\r	(* See InstanceMixin>>apply:withName: *)\r	^self resolve\r)",
 "public class Message mangledSelector: s arguments: a = (\r(* FIXME: This factory should not be public. *)\r|\r	public mangledSelector = s.\r	public arguments = a.\r|)",
 " ",
 " ",
 "public printString = (\r	^'#',selector\r)",
 "public selector = (\r	^vmmirror unmangleSelector: mangledSelector\r)",
 "public sendTo: receiver = (\r	^js call: (js propertyOf: (js propertyOf: receiver at: mangledSelector) at: (js literal: 'apply')) with: {receiver. arguments}\r)",
 "mangle: selector = (\r	^((('$', selector)\r		replaceAll: \":\" with: \"$\") (* Keyword *)\r		replaceAll: \"`\" with: \"$\") (* Qualified *)\r		replaceAll: \".\" with: \"$\" (* limit temp *)\r)",
 "public selector: selector = (\r	^self mangledSelector: (mangle: selector) arguments: {}\r)",
 "public selector: selector arguments: arguments = (\r	^self mangledSelector: (mangle: selector) arguments: arguments\r)",
 "public class MessageNotUnderstood receiver: r message: m = Exception (|\r	public receiver = r.\r	public message = m.\r|)",
 "Exception",
 "Exception",
 "public messageText = (\r	(* squeak compatibility for Minitest *)\r	^self printString\r)",
 "public printString ^<String> = (\r	^'MessageNotUnderstood: ', (classOf: receiver) name, ' ', message selector\r)",
 "public class Metaclass = (\r|\rpublic superclass\rpublic mixin\rpublic enclosingObject\rpublic name\rpublic thisClass\r|)",
 " ",
 " ",
 "public isKindOfBehavior = (\r	^true\r)",
 "public isMeta = (\r	^true\r)",
 "public class Mixin fromRuntimeMixin: rm = (js assign: (js propertyOf: self at: (js literal: 'runtimeMixin')) toBe: rm)",
 " ",
 " ",
 "public applyTo: superclass <Class> ^<Class> = (\r	(* assert: [isTopLevel] message: 'Only top-level mixins may be applied directly' *)\r	assert: [isMeta not] message: 'Only instance-side mixins may be applied directly'.\r	^self applyTo: superclass withName: (superclass name, ' <: ', name)\r)",
 "public applyTo: superclass <Class> withName: name <String> ^<Class> = (\r	^vmmirror\r		applyMixin: (js propertyOf: self at: (js literal: 'runtimeMixin'))\r		toSuperclass: superclass\r		withEnclosingObjects: {nil}\r)",
 "public isMeta ^<Boolean> = (\r	^js operator: '===' with: (js propertyOf: (js propertyOf: self at: (js literal: 'runtimeMixin')) at: (js literal: 'meta')) and: (js ident: 'undefined')\r)",
 "public name ^<Symbol> = (\r	^isMeta\r		ifTrue: [(js propertyOf: (js propertyOf: (js propertyOf: self at: (js literal: 'runtimeMixin')) at: (js literal: 'nonMeta')) at: (js literal: 'name')), ' class']\r		ifFalse: [js propertyOf: (js propertyOf: self at: (js literal: 'runtimeMixin')) at: (js literal: 'name')].\r)",
 "public printString ^<String> = (\r	^name, ' mixin'\r)",
 "public class Number uninstantiable = ()",
 " ",
 " ",
 "public * other = (\r	^js operator: '*' with: self and: other\r)",
 "public ** exponent = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'pow')) with: {self. exponent}\r)",
 "public + other = (\r	^js operator: '+' with: self and: other\r)",
 "public - other = (\r	^js operator: '-' with: self and: other\r)",
 "public / other = (\r	^js operator: '/' with: self and: other\r)",
 "public // other = (\r	^(self / other) floor\r)",
 "public < other = (\r	^js operator: '<' with: self and: other\r)",
 "public << other = (\r	^js operator: '<<' with: self and: other\r)",
 "public <= other = (\r	^js operator: '<=' with: self and: other\r)",
 "public = other = (\r	^js operator: '===' with: self and: other\r)",
 "public > other = (\r	^js operator: '>' with: self and: other\r)",
 "public >= other = (\r	^js operator: '>=' with: self and: other\r)",
 "public >> other = (\r	^js operator: '>>' with: self and: other\r)",
 "public \\\\ other = (\r	^self - (self // other * other)\r)",
 "public abs = (\r	self >= 0 ifTrue: [^self] ifFalse: [^-1.0 * self]\r)",
 "public asFloat = (\r	^self * 1.0\r)",
 "public asInteger = (\r	^self truncated\r)",
 "public asString ^<String> = (\r	^js call: (js propertyOf: self at: (js literal: 'toString')) with: {}\r)",
 "public asStringExponential: fractionDigits <Integer> ^<String> = (\r	fractionDigits < 0 ifTrue: [^Error signal].\r	fractionDigits > 20 ifTrue: [^Error signal].\r	^js call: (js propertyOf: self at: (js literal: 'toExponential')) with: {fractionDigits}\r)",
 "public asStringFixed: fractionDigits <Integer> ^<String> = (\r	fractionDigits < 0 ifTrue: [^Error signal].\r	fractionDigits > 100 ifTrue: [^Error signal].\r	^js call: (js propertyOf: self at: (js literal: 'toFixed')) with: {fractionDigits}\r)",
 "public asStringPrecision: precision <Integer> ^<String> = (\r	precision < 1 ifTrue: [^Error signal].\r	precision > 100 ifTrue: [^Error signal].\r	^js call: (js propertyOf: self at: (js literal: 'toPrecision')) with: {precision}\r)",
 "public asStringRadix: radix <Integer> ^<String> = (\r	^js call: (js propertyOf: (js call: (js propertyOf: self at: (js literal: 'toString')) with: {radix}) at: (js literal: 'toUpperCase')) with: {}\r)",
 "public between: min and: max = (\r	^self <= max and: [ self >= min ]\r)",
 "public bitAnd: other = (\r	^js operator: '&' with: self and: other\r)",
 "public bitInvert = (\r	^-1 - self\r)",
 "public bitOr: other = (\r	^js operator: '|' with: self and: other\r)",
 "public bitXor: other = (\r	^js operator: '^' with: self and: other\r)",
 "public ceiling = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'ceil')) with: {self}\r)",
 "public cos = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'cos')) with: {self}\r)",
 "public exp = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'exp')) with: {self}\r)",
 "public floor = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'floor')) with: {self}\r)",
 "public hash = (\r	(* Truncate to signed 32-bit integer. *)\r	^js operator: '|' with: self and: (js literal: 0)\r)",
 "public isKindOfFloat = (\r	^true\r)",
 "public isKindOfInteger = (\r	^self = self asInteger\r)",
 "public isKindOfNumber = (\r	^true\r)",
 "public isNumber = (\r	^true\r)",
 "public ln = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'log')) with: {self}\r)",
 "public max: other = (\r	^self > other ifTrue: [ self ] ifFalse: [ other ]\r)",
 "public min: other = (\r	^self < other ifTrue: [ self ] ifFalse: [ other ]\r)",
 "public printString = (\r	^js call: (js propertyOf: self at: (js literal: 'toString')) with: {}\r)",
 "public quo: other = (\r	^(self / other) truncated\r)",
 "public rem: other = (\r	^self - ((self quo: other) * other)\r)",
 "public rounded = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'round')) with: {self}\r)",
 "public sign = (\r	self > 0 ifTrue: [^1].\r	self < 0 ifTrue: [^-1].\r	^0\r)",
 "public sin = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'sin')) with: {self}\r)",
 "public sqrt = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'sqrt')) with: {self}\r)",
 "public tan = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'tan')) with: {self}\r)",
 "public timesRepeat: block = (\r	| i ::= 0. |\r	js\r		for: (js verbatim: '')\r		while: (js operator: '<' with: i and: (js ident: 'this'))\r		step: (js postfixOperator: '++' on: i)\r		do: (js block: {js call: block with: {}})\r)",
 "public to: stop = (\r	^platform collections Interval from: self to: stop\r)",
 "public to: limit do: block = (\r	| i ::= self. |\r	js\r		for: (js verbatim: '')\r		while: (js operator: '<=' with: i and: limit)\r		step: (js postfixOperator: '++' on: i)\r		do: (js block: {js call: block with: {i}})\r)",
 "public truncated = (\r	^self > 0 ifTrue: [self floor] ifFalse: [self ceiling]\r)",
 "public parse: str <String> ^<Float> = (\r	^js call: (js ident: 'parseFloat') with: {str}\r)",
 "public class Object = ImplementationBase ()",
 "ImplementationBase",
 "ImplementationBase",
 "public = other = (\r	^js operator: '===' with: self and: other\r)",
 "public == other = (\r	^js operator: '===' with: self and: other\r)",
 "Array ^ <KernelForV8 Array class>= (\r	^outer KernelForV8 Array\r)",
 "ByteArray ^ <KernelForV8 ByteArray class>= (\r	^outer KernelForV8 ByteArray\r)",
 "Character ^ <KernelForV8 Character class>= (\r	^outer KernelForV8 String\r)",
 "Error ^ <KernelForV8 Error class>= (\r	^outer KernelForV8 Error\r)",
 "Float ^ <KernelForV8 Float class>= (\r	^outer KernelForV8 Number\r)",
 "Future ^ <KernelForV8 Future class> = (\r	^outer KernelForV8 Future\r)",
 "Object ^ <KernelForV8 Object class>= (\r	^outer KernelForV8 Object\r)",
 "String ^ <KernelForV8 String class>= (\r	^outer KernelForV8 String\r)",
 "assert: condition <[Boolean]> message: message = (\r	(* Raises an error with the given message if and only if condition evaluates to false. *)\r	condition isKindOfClosure ifFalse: [Error signal: 'Block required'].\r	condition value ifFalse: [Error signal: 'Assertion failed: ', message]\r)",
 "private cannotReturn: value = (\r	(* compiler entry *)\r	Exception signal: 'CannotReturn: ', value printString.\r)",
 "protected class = (\r	^classOf: self\r)",
 "protected doesNotUnderstand: message = (\r	((message selector startsWith: 'is') and: [message arguments size = 0])\r		ifTrue: [^false].\r	^(MessageNotUnderstood receiver: self message: message) signal\r)",
 "public hash ^<Integer> = (\r	(* It might be worth giving every object the hashCode field at instantiation to avoid map transitions. *)\r	js verbatim: 'while(this.hashCode === 0) this.hashCode = Math.random() * 0x3FFFFFF | 0'.\r	^js verbatim: 'this.hashCode'\r)",
 "public ifNil: nilBlock = (\r	^self\r)",
 "public ifNil: nilBlock ifNotNil: notNilBlock = (\r	^notNilBlock value: self\r)",
 "public ifNotNil: nonNilBlock = (\r	^nonNilBlock value: self\r)",
 "public isAlien = (\r	^false\r)",
 "public isExpat = (\r	^false\r)",
 "public isKindOfFuture = (\r	^false\r)",
 "public isNil = (\r	^false\r)",
 "public notNil = (\r	^true\r)",
 "public out = (\r	print: self printString\r)",
 "public printString = (\r	^'instance of ', self class name\r)",
 "public yourself = (\r	^self\r)",
 "public ~= other = (\r	^(self = other) not\r)",
 "public class Stopwatch = (|\rprivate cumulativeMillis ::= 0.\rprivate startMillis\r|)",
 " ",
 " ",
 "private currentMonotonicMillis = (\r	^js verbatim: 'performance.now()'\r)",
 "public elapsedMicroseconds ^<Integer> = (\r	^elapsedMilliseconds * 1000\r)",
 "public elapsedMilliseconds ^<Integer> = (\r	nil = startMillis ifTrue: [^cumulativeMillis].\r	^cumulativeMillis + (currentMonotonicMillis - startMillis)\r)",
 "public start = (\r	nil = startMillis ifFalse: [^self (* Already running. *)].\r	startMillis:: currentMonotonicMillis\r)",
 "public stop = (\r	nil = startMillis ifTrue: [^self (* Already stopped. *)].\r	cumulativeMillis:: cumulativeMillis + (currentMonotonicMillis - startMillis).\r	startMillis:: nil.\r)",
 "public class String uninstantiable = ()",
 " ",
 " ",
 "public , other = (\r	^js call: (js propertyOf: self at: (js literal: 'concat')) with: {other}\r)",
 "public = other = (\r	^js operator: '===' with: self and: other\r)",
 "public asString = (\r	^self\r)",
 "public asSymbol = (\r	^self\r)",
 "public at: index = (\r	^js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1))\r)",
 "public copyFrom: start to: end = (\r	^js call: (js propertyOf: self at: (js literal: 'substring')) with: {start - 1. end}\r)",
 "public do: action = (\r	|\r	i ::= 0.\r	len ::= js verbatim: 'this.length'.\r	|\r	js\r		for: (js verbatim: '')\r		while: (js operator: '<' with: i and: len)\r		step: (js postfixOperator: '++' on: i)\r		do: (js block: {\r			js call: action with: {js propertyOf: self at: i}}).\r)",
 "public endsWith: substring = (\r	^js call: (js propertyOf: self at: (js literal: 'endsWith')) with: {substring}\r)",
 "public first = (\r	^self at: 1\r)",
 "public hash = (\r	js var: 'l' value: (js propertyOf: (js ident: 'this') at: (js literal: 'length')).\r	^js ternaryIf: (js operator: '==' with: (js ident: 'l') and: (js literal: 0))\r		then: (js literal: 0)\r		else: (js verbatim: '(l * 32 ^ this.charCodeAt(0)) * 32 ^ this.charCodeAt(l - 1)')\r)",
 "public includes: object = (\r	self do: [:element | object = element ifTrue: [^true]].\r	^false\r)",
 "public indexOf: substring <String> ^ <Integer> = (\r	^1 + (js call: (js propertyOf: self at: (js literal: 'indexOf')) with: {substring})\r)",
 "public indexOf: substring <String> startingAt: index <Integer> ^<Integer> = (\r	^1 + (js call: (js propertyOf: self at: (js literal: 'indexOf')) with: {substring. index - 1})\r)",
 "public isEmpty ^ <Boolean> = (\r  ^0 = size\r)",
 "public isKindOfString ^ <Boolean> = (\r	^true\r)",
 "public isString ^ <Boolean> = (\r	^true\r)",
 "public last = (\r	^self at: self size\r)",
 "public lastIndexOf: substring <String> ^<Integer> = (\r	^1 + (js call: (js propertyOf: self at: (js literal: 'lastIndexOf')) with: {substring})\r)",
 "public out = (\r	print: self.\r)",
 "public printString = (\r	^js verbatim: '\"''\"+this.toString()+\"''\"'\r)",
 "public replaceAll: substring with: newSubstring = (\r	#BOGUS. (* Ought to be able to say this.replace(target, replacement, 'g'). *)\r	js var: 'target' value: substring.\r	js var: 'replacement' value: newSubstring.\r	^js verbatim: 'this.replace(new RegExp(target.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"), \"g\"), replacement)'\r)",
 "public runeAt: index = (\r	(* This is wrong for surrogate pairs. *)\r	^js call: (js propertyOf: self at: (js literal: 'charCodeAt')) with: {index - 1}\r)",
 "public size = (\r	^js verbatim: 'this.length'\r)",
 "public splitBy: str = (\r	^js call: (js propertyOf: self at: (js literal: 'split')) with: {str}\r)",
 "public startsWith: substring = (\r	^js call: (js propertyOf: self at: (js literal: 'startsWith')) with: {substring}\r)",
 "public cr = (\r	^js verbatim: '\"\\r\"'\r)",
 "public fromRune: rune = (\r	^js call: (js propertyOf: (js ident: 'String') at: (js literal: 'fromCharCode')) with: {rune}\r)",
 "public fromRunes: runes = (\r	^js call: (js propertyOf: (js propertyOf: (js ident: 'String') at: (js literal: 'fromCharCode')) at: (js literal: 'apply')) with: {js ident: 'null'. runes asArray}.\r)",
 "public lf = (\r	^js verbatim: '\"\\n\"'\r)",
 "public space = (\r	^\" \"\r)",
 "public tab = (\r	^js verbatim: '\"\\t\"'\r)",
 "public withAll: characters = (\r	^js call: (js propertyOf: characters asArray at: (js literal: 'join')) with: {js literal: ''}\r)",
 "public class StringBuilder = (|\rprotected parts = platform collections List new.\rprotected sizeX ::= 0.\r|)",
 " ",
 " ",
 "public add: string = (\r	sizeX:: sizeX + string size.\r	^parts add: string\r)",
 "public asString = (\r	^js call: (js propertyOf: parts asArray at: (js literal: 'join')) with: {js literal: ''}\r)",
 "public size = (\r	^sizeX\r)",
 "public writeln: line = (\r	self add: line.\r	self add: String lf.\r)",
 "public class UndefinedObject uninstantiable = ()",
 " ",
 " ",
 "public ifNil: nilBlock = (\r	^nilBlock value\r)",
 "public ifNil: nilBlock ifNotNil: notNilBlock = (\r	^nilBlock value\r)",
 "public ifNotNil: notNilBlock = (\r	^self\r)",
 "public isNil = (\r	^true\r)",
 "public notNil = (\r	^false\r)",
 "public printString = (\r	^'nil'\r)",
 "class ActorsForV8 usingPlatform: p = (|\rprivate WeakMap = p collections IdentityMap.\rprivate List = p collections List.\rprivate Message = p kernel Message.\r\rprivate internalRefs <WeakMap[FarReference, InternalFarReference]> = WeakMap new.\r\rpublic Promise = PromiseUtils new.\r\rdefaultActor = DOMActor named: 'Default actor'.\r|js assign: (js ident: 'currentActor') toBe: defaultActor)",
 " ",
 " ",
 "private asInternalRef: externalRefOrUnboxedNearRef = (\r	^(isRef: externalRefOrUnboxedNearRef)\r		ifTrue: [internalRefs at: externalRefOrUnboxedNearRef ifAbsent: [halt]]\r		ifFalse: [InternalNearRef wrapping: externalRefOrUnboxedNearRef __owner: currentActor]\r)",
 "private check: object allowedIn: actor = (\r	assert: [nil ~= actor] message: 'Invalid actor'.\r\r	(isRef: object) ifTrue: [object __owner == actor ifFalse: [halt]].\r	(* Otherwise near reference *)\r)",
 "private createFarReferenceTo: target in: targetActor for: sourceActor = (\r	^(InternalFarReference target: target targetsActor: targetActor __owner: sourceActor) externalRef.\r)",
 "private createRemotePromiseOf: resolverInTarget in: targetActor for: sourceActor = (\r	| sourceResolver redirector message remotePromise |\r	sourceActor == targetActor ifTrue: [halt].\r\r	sourceResolver:: InternalLocalPromise __owner: sourceActor.\r	sourceResolver state: #remote.\r	sourceResolver _targetPromise: resolverInTarget.\r	sourceResolver _targetActor: targetActor.\r\r	redirector:: RedirectReactor\r		from: targetActor\r		to: sourceActor\r		resolver: sourceResolver.\r\r	message:: PendingDelivery\r		receiver: resolverInTarget\r		selector: #addReactor:\r		arguments: {redirector}\r		resolver: nil.\r	targetActor enqueueMessage: message.\r\r	^Ref wrapping: sourceResolver __owner: sourceActor.\r)",
 "private currentActor = (\r	^js ident: 'currentActor'\r)",
 "private isRef: object <Object> ^<Boolean> = (\r	^Ref == (js propertyOf: object at: (js literal: 'newspeakClass'))\r)",
 "private isValueObject: object <Object> ^<Boolean> = (\r	nil == object ifTrue: [^true].\r	true == object ifTrue: [^true].\r	false == object ifTrue: [^true].\r	object isString ifTrue: [^true].\r	object isNumber ifTrue: [^true].\r	object isCharacter ifTrue: [^true].\r	object isBehavior ifTrue: [^isValueObject: object enclosingClass].\r	Promise == object ifTrue: [^true].\r	^false\r)",
 "private wrapArgument: argument from: sourceActor to: targetActor = (\r	(* [argument] lives in [sourceActor], answer the corresponding proxy that lives in [targetActor] *)\r\r	sourceActor == targetActor ifTrue: [halt. (* We can't tell which side a near reference belongs to here, so we must have decided this earlier. *) ].\r\r	^(asInternalRef: argument) wrapFor: targetActor\r)",
 "private wrapArguments: arguments from: sourceActor to: targetActor = (\r	^arguments collect: [:argument | wrapArgument: argument from: sourceActor to: targetActor].\r)",
 "public class Actor named: debugName <String> = (|\rprivate (* N.B. Do not leak to subinstances. *) internalActor = DOMActor named: debugName.\r|)",
 " ",
 " ",
 "public interrupt = (\r	unimplemented\r)",
 "public onError: onError <[:E]> = (\r	unimplemented.\r)",
 "public seed: value <Value> ^<FarReference[Value]> = (\r	(* Creating a far reference to a PassByCopy is questionable. It may be that this should be seed: receiver perform: selector with: argument. *)\r	(isValueObject: value) ifFalse: [Error signal: 'Cannot seed an actor with a non-Value.'].\r	^createFarReferenceTo: value in: internalActor for: currentActor.\r)",
 "public terminate = (\r	unimplemented\r)",
 "class DOMActor named: n = InternalActor (\r(* An actor whose turns run in the DOM Context. *)\r|\r	protected name <String> = n.\r|)",
 "InternalActor",
 "InternalActor",
 "public enqueueMessage: actorMessage = (\r	actorMessage postedTo: self.\r\r	(* bogus - should drain an explicit queue to allow for a randomizing scheduler *)\r	js\r		call: (js propertyOf: (js ident: 'theGlobalObject') at: (js literal: 'setTimeout'))\r		with: {[js assign: (js ident: 'currentActor') toBe: self.\r				actorMessage deliverIn: self]. js literal: 0}.\r)",
 "protected class EventualSendReactor selector: s arguments: a resolver: r = (\r(* An eventual-send to a promise.\r\rNote that all slots contain objects that belong to the actor which performed the eventual send. *)\r|\rprotected selector <Symbol> = s.\rprotected arguments <Array> = a.\rprotected resolver <InternalResolver> = r.\r|)",
 " ",
 " ",
 "public reactBroken: error = (\r	(* Broken promise contagion. *)\r	resolver __owner == currentActor ifFalse: [halt].\r	(* Should this be immediate? *)\r	(* resolver internalBreak: error. ? *)\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: resolver\r			selector: #internalResolve:\r			arguments: {InternalBrokenRef problem: error __owner: resolver __owner}\r			resolver: nil)\r)",
 "public reactMoreResolved: internalRef = (\r	resolver internalResolve: (asInternalRef: (internalRef eventualSend: selector arguments: arguments)).\r)",
 "public reactResolved: value = (\r	resolver __owner == currentActor ifFalse: [halt].\r	resolver internalResolve:\r		(asInternalRef: (currentActor\r			eventualSendTo: value\r			selector: selector\r			arguments: arguments))\r)",
 "class InternalActor = ()",
 " ",
 " ",
 "public currentActor = (\r	(* BOGUS. Polymorphic with other actor system. *)\r	^self\r)",
 "public eventualSendTo: receiver selector: selector arguments: arguments ^<Ref> = (\r	(* Sent from the compilation of an eventual send, via the same method in ProcessScheduler. *)\r	^(asInternalRef: receiver) eventualSend: selector arguments: arguments\r)",
 "class InternalBrokenRef problem: p __owner: o = InternalRef __owner: o (|\rprotected problem = p.\r|)",
 "__owner: o",
 "__owner: o",
 "public addReactor: reactor = (\r	reactor reactBroken: problem.\r)",
 "public checkCycle ^<Boolean> = (\r	^false\r)",
 "public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (\r	^self externalRef (* I.e., broken with same problem. Should this wait for the next turn? *)\r)",
 "public immediateSend: message <Message> ^<Object> = (\r	^Error signal: 'Cannot immediate-send to a broken ref: ', message selector\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'InternalBrokenRef: '.\r	problem printOn: stream.\r)",
 "public refPrintOn: stream = (\r	stream nextPutAll: '<broken ref: '.\r	problem printOn: stream.\r	stream nextPutAll: '>'.\r)",
 "public shorten ^<InternalRef> = (\r	^self\r)",
 "public whenFulfilled: onValue whenBroken: onError ^<Ref> = (\r	| localPromise = InternalLocalPromise __owner: __owner. |\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: onError\r			selector: #cull:\r			arguments: {problem}\r			resolver: localPromise).\r	^localPromise externalRef\r)",
 "public wrapFor: targetActor = (\r	self checkCurrentActor.\r	#BOGUS.\r	^(InternalBrokenRef problem: problem __owner: targetActor) externalRef\r)",
 "class InternalFarReference target: t targetsActor: ta __owner: o = InternalRef __owner: o (|\rprotected target = t.\rprotected targetsActor = ta.\r|)",
 "__owner: o",
 "__owner: o",
 "public addReactor: reactor = (\r	reactor reactResolved: externalRef\r)",
 "public checkCycle ^<Boolean> = (\r	^false\r)",
 "public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (\r	| resolverInTarget remotePromise redirector |\r	resolverInTarget:: InternalLocalPromise __owner: targetsActor.\r	targetsActor enqueueMessage:\r		(PendingDelivery\r			receiver: target\r			selector: selector\r			arguments: (wrapArguments: arguments from: currentActor to: targetsActor)\r			resolver: resolverInTarget).\r\r	remotePromise:: InternalRemotePromise\r		target: resolverInTarget\r		targetsActor: targetsActor\r		__owner: currentActor.\r\r	redirector:: RedirectReactor\r		from: targetsActor\r		to: currentActor\r		resolver: remotePromise.\r	targetsActor enqueueMessage:\r		(PendingDelivery\r			receiver: resolverInTarget\r			selector: #addReactor:\r			arguments: {redirector}\r			resolver: nil).\r\r	^remotePromise externalRef\r)",
 "public immediateSend: message <Message> ^<Object> = (\r	^Error signal: 'Cannot immediate-send to an eventual ref: ', message selector\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'InternalFarRef: '.\r	target printOn: stream.\r)",
 "public refPrintOn: stream = (\r	stream nextPutAll: '<far ref: '.\r	target printOn: stream.\r	stream nextPutAll: '>'.\r)",
 "public shorten ^<InternalRef> = (\r	^self\r)",
 "public whenFulfilled: onValue whenBroken: onError ^<Ref> = (\r	| localPromise = InternalLocalPromise __owner: __owner. |\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: onValue\r			selector: #cull:\r			arguments: {externalRef}\r			resolver: localPromise).\r	^localPromise externalRef\r)",
 "public wrapFor: targetActor = (\r	targetsActor == targetActor ifTrue: [^target].\r	^(InternalFarReference target: target targetsActor: targetsActor __owner: targetActor) externalRef.\r)",
 "class InternalLocalPromise __owner: o = InternalRef __owner: o (|\rprotected state ::= #unresolved. (* resolving. resolved *)\rprotected resolution <InternalRef>\rprotected reactors\r|)",
 "__owner: o",
 "__owner: o",
 "public addReactor: reactor = (\r	state == #unresolved ifTrue:\r		[reactors == nil ifTrue: [reactors:: List new].\r		reactors add: reactor.\r		^self].\r	state == #resolved ifTrue:\r		[^resolution addReactor: reactor].\r	halt.\r)",
 "public checkCycle ^<Boolean> = (\r	state == #resolving ifTrue: [^true].\r	state == #unresolved ifTrue: [^false].\r	state == #resolved ifTrue: [^resolution checkCycle].\r	halt.\r)",
 "public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (\r	| localPromise |\r	self checkCurrentActor.\r	state == #resolved ifTrue: [^resolution eventualSend: selector arguments: arguments].\r	localPromise:: InternalLocalPromise __owner: __owner.\r	self addReactor: (EventualSendReactor selector: selector arguments: arguments resolver: localPromise).\r	^localPromise externalRef\r)",
 "public immediateSend: message <Message> ^<Object> = (\r	state == #resolved ifTrue: [^resolution immediateSend: message].\r	^Error signal: 'Cannot immediate-send to an eventual ref: ', message selector\r)",
 "public internalResolve: internalRef <InternalRef> = (\r	state == #unresolved ifFalse: [^Error signal: 'Already resolved'].\r	internalRef isInternalRef ifFalse: [halt].\r\r	state:: #resolving.\r	internalRef checkCycle\r		ifTrue: [resolution:: InternalBrokenRef problem: (Error new messageText: 'Cyclic resolution') __owner: __owner]\r		ifFalse: [resolution:: internalRef].\r	state:: #resolved.\r\r	nil == reactors ifFalse:\r		[reactors do: [:reactor | resolution addReactor: reactor].\r		reactors:: nil].\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'InternalLocalPromise: '.\r	state printOn: stream.\r)",
 "public refPrintOn: stream = (\r	state == #resolved\r		ifTrue: [resolution refPrintOn: stream]\r		ifFalse: [stream nextPutAll: '<local promise>'].\r)",
 "public shorten ^<InternalRef> = (\r	state == #unresolved ifTrue: [^self].\r	state == #resolved ifTrue: [^resolution].\r	halt.\r)",
 "public whenFulfilled: onValue whenBroken: onError ^<Ref> = (\r	| localPromise |\r	self checkCurrentActor.\r	state == #resolved ifTrue: [^resolution whenFulfilled: onValue whenBroken: onError].\r	localPromise:: InternalLocalPromise __owner: __owner.\r	self addReactor: (WhenReactor onValue: onValue onError: onError resolver: localPromise).\r	^localPromise externalRef\r)",
 "public wrapFor: targetActor = (\r	state == #resolved ifTrue: [^resolution wrapFor: targetActor].\r\r	checkCurrentActor.\r	targetActor == __owner ifTrue: [halt].\r\r	^(InternalRemotePromise target: self targetsActor: currentActor __owner: targetActor) externalRef\r)",
 "class InternalNearRef wrapping: t __owner: o = InternalRef __owner: o (|\rprotected target = t.\r|)",
 "__owner: o",
 "__owner: o",
 "public addReactor: reactor = (\r	reactor reactResolved: target.\r)",
 "public checkCycle ^<Boolean> = (\r	^false\r)",
 "public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (\r	| localPromise = InternalLocalPromise __owner: __owner. |\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: target\r			selector: selector\r			arguments: arguments\r			resolver: localPromise).\r	^localPromise externalRef\r)",
 "public immediateSend: message <Message> ^<Object> = (\r	^message sendTo: target\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'InternalNearRef: '.\r	target printOn: stream.\r)",
 "public refPrintOn: stream = (\r	stream nextPutAll: '<near ref: '.\r	target printOn: stream.\r	stream nextPutAll: '>'.\r)",
 "public shorten ^<InternalRef> = (\r	^self\r)",
 "public whenFulfilled: onValue whenBroken: onError ^<Ref> = (\r	| localPromise = InternalLocalPromise __owner: __owner. |\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: onValue\r			selector: #cull:\r			arguments: {target}\r			resolver: localPromise).\r	^localPromise externalRef\r)",
 "public wrapFor: targetActor = (\r	self checkCurrentActor.\r	(isValueObject: target) ifTrue: [^target].\r	^createFarReferenceTo: target in: currentActor for: targetActor\r)",
 "class InternalRef __owner: o = (|\rpublic __owner <InternalActor> = o.\r|)",
 " ",
 " ",
 "protected checkCurrentActor = (\r	currentActor == __owner ifFalse: [halt].\r)",
 "public checkCycle ^<Boolean> = (\r	subclassResponsibility\r)",
 "public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (\r	subclassResponsibility\r)",
 "public externalRef = (\r	^Ref wrapping: self\r)",
 "public immediateSend: message <Message> ^<Object> = (\r	subclassResponsibility\r)",
 "public isInternalRef ^<Boolean> = (\r	^true\r)",
 "public refPrintOn: stream = (\r	subclassResponsibility\r)",
 "public shorten ^<InternalRef> = (\r	subclassResponsibility\r)",
 "public whenFulfilled: onValue whenBroken: onError ^<Ref> = (\r	subclassResponsibility\r)",
 "public wrapFor: targetActor = (\r	subclassResponsibility\r)",
 "class InternalRemotePromise target: t targetsActor: ta __owner: o = InternalRef __owner: o (|\rtarget <InternalLocalPromise> = t.\rtargetsActor <InternalActor> = ta.\rstate ::= #unresolved.\rresolution <InternalRef>\r|)",
 "__owner: o",
 "__owner: o",
 "public addReactor: reactor = (\r	state == #resolved ifTrue: [^resolution addReactor: reactor].\r	state == #unresolved ifTrue: [^reactor reactMoreResolved: self].\r	stop5.\r)",
 "public checkCycle ^<Boolean> = (\r	state == #resolving ifTrue: [^true].\r	state == #unresolved ifTrue: [^false].\r	state == #resolved ifTrue: [^resolution checkCycle].\r	halt.\r)",
 "public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (\r	| resolverInTarget remotePromise redirector |\r	resolverInTarget:: InternalLocalPromise __owner: targetsActor.\r	targetsActor enqueueMessage:\r		(PendingDelivery\r			receiver: target\r			selector: #eventualSend:arguments:\r			arguments: {selector. (wrapArguments: arguments from: currentActor to: targetsActor)}\r			resolver: resolverInTarget).\r\r	remotePromise:: InternalRemotePromise\r		target: resolverInTarget\r		targetsActor: targetsActor\r		__owner: currentActor.\r\r	redirector:: RedirectReactor\r		from: targetsActor\r		to: currentActor\r		resolver: remotePromise.\r	targetsActor enqueueMessage:\r		(PendingDelivery\r			receiver: resolverInTarget\r			selector: #addReactor:\r			arguments: {redirector}\r			resolver: nil).\r\r	^remotePromise externalRef\r)",
 "public immediateSend: message <Message> ^<Object> = (\r	state == #resolved ifTrue: [^resolution immediateSend: message].\r	^Error signal: 'Cannot immediate-send to an eventual ref: ', message selector\r)",
 "public internalResolve: internalRef <InternalRef> = (\r	state == #unresolved ifFalse: [^Error signal: 'Already resolved'].\r	internalRef isInternalRef ifFalse: [halt].\r\r	state:: #resolving.\r	internalRef checkCycle\r		ifTrue: [resolution:: InternalBrokenRef problem: (Error new messageText: 'Cyclic resolution') __owner: __owner]\r		ifFalse: [resolution:: internalRef].\r	state:: #resolved.\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'InternalRemotePromise: '.\r	state printOn: stream.\r)",
 "public redirectFrom: sourceActor to: destinationActor resolving: resolver = (\r	| redirector |\r	destinationActor == targetsActor ifTrue:\r		[targetsActor enqueueMessage:\r			(PendingDelivery\r				receiver: resolver\r				selector: #internalResolve:\r				arguments: {target}\r				resolver: nil).\r		^self].\r\r	redirector:: RedirectReactor\r		from: targetsActor\r		to: destinationActor\r		resolver: resolver.\r	targetsActor enqueueMessage:\r		(PendingDelivery\r			receiver: target\r			selector: #addReactor:\r			arguments: {redirector}\r			resolver: nil).\r)",
 "public refPrintOn: stream = (\r	state == #resolved\r		ifTrue: [resolution refPrintOn: stream]\r		ifFalse: [stream nextPutAll: '<remote promise>'].\r)",
 "public shorten ^<InternalRef> = (\r	state == #unresolved ifTrue: [^self].\r	state == #resolved ifTrue: [^resolution].\r	halt.\r)",
 "public whenFulfilled: onValue whenBroken: onError ^<Ref> = (\r	| localPromise redirector |\r	self checkCurrentActor.\r	state == #resolved ifTrue: [^resolution whenFulfilled: onValue whenBroken: onError].\r\r	localPromise:: InternalLocalPromise __owner: __owner.\r	redirector:: RedirectReactor\r		from: targetsActor\r		to: currentActor\r		resolver: localPromise.\r	targetsActor enqueueMessage:\r		(PendingDelivery\r			receiver: target\r			selector: #addReactor:\r			arguments: {redirector}\r			resolver: nil).\r	^localPromise whenFulfilled: onValue whenBroken: onError.\r)",
 "public wrapFor: targetActor = (\r	state == #resolved ifTrue: [^resolution wrapFor: targetActor].\r\r	targetActor == targetsActor ifTrue: [^target externalRef].\r\r	^(InternalRemotePromise target: target targetsActor: targetsActor __owner: targetActor) externalRef\r)",
 "protected class PendingDelivery receiver: r selector: s arguments: a resolver: y = (\r(* A message in an actor's event queue. Every turn starts by sending #deliverIn:.\r\rNote that all slots contain objects that belong to the actor in which the message is queued, even the resolver. *)\r|\rprotected receiver <Object> = r.\rprotected selector <Symbol> = s.\rprotected arguments <Array> = a.\rprotected resolver <InternalResolver> = y.\r|)",
 " ",
 " ",
 "public deliverIn: fastCurrentActor = (\r	| resolution type msg |\r\r	(* Transcript print: fastCurrentActor; space; print: self; cr. *)\r	msg:: Message selector: selector arguments: arguments.\r\r	[resolution:: msg sendTo: receiver.\r	type:: #internalResolve:]\r		on: Error (* BOGUS: Exception? *)\r		do: [:error |\r			error out.\r			resolver == nil ifTrue: [error pass].\r			resolution:: error.\r			type:: #internalBreak:].\r\r	(* Transcript show: {resolver. type. resolution}; cr. *)\r\r	nil == resolver ifTrue: [\r		type == #internalBreak: ifTrue: [{'silent failure'. resolution} out].\r		^self].\r\r	resolver internalResolve: (type == #internalResolve:\r		ifTrue: [asInternalRef: resolution]\r		ifFalse: [InternalBrokenRef problem: resolution __owner: self]).\r)",
 "public postedTo: actor = (\r	(*check: receiver allowedIn: actor.\r	arguments do: [:arg | check: arg allowedIn: actor].*)\r\r	(* selector numArgs == arguments size ifFalse: [halt]. *)\r	resolver == nil ifFalse: [resolver __owner == actor ifFalse: [halt]].\r)",
 "public printOn: stream = (\r	receiver printOn: stream.\r	stream nextPutAll: ' <-: '.\r	stream nextPutAll: selector.\r	stream space.\r	arguments isEmpty ifFalse: [arguments printOn: stream].\r)",
 "class PromiseUtils = ()",
 " ",
 " ",
 "public all: refs <List[Promise[V, E]]> ^<Promise[List[V], E]> = (\r	(* Answers a promise that resolves with all the resolutions of refs, or the first problem. *)\r)",
 "public broken: problem <E> ^<Promise[nil, E]> = (\r	^Resolver new break: problem; promise\r)",
 "public fulfilled: resolution <V> ^<Promise[V, nil]> = (\r	^Resolver new fulfill: resolution; promise\r)",
 "public timeout: ref <Promise[V, E]> after: milliseconds <Integer> ^<Promise[V, E | TimeoutError]> = (\r	(* Answers a promise that resolves with the resolution of ref, or a TimeoutError if refs is not resolved within milliseconds. *)\r	#BOGUS. (* Should have proper duration type. *)\r)",
 "public when: ref <Promise[V, E]> fulfilled: onValue <[:V | V2 def]> ^<Promise[V2, E]> = (\r	(* Subscribe to notification of a reference being fulfilled. If ref is fulfilled, onValue will run in some turn after the turn that resolves ref, and the returned promise with be resolved with the result of onValue. If ref is broken, the returned promise with be broken with the same error. *)\r	^(asInternalRef: ref) whenFulfilled: onValue whenBroken: [:e | e signal] (* Should we make this the behavior of a nil catch-clause instead? *)\r)",
 "public when: ref <Promise[V, E]> fulfilled: onValue <[:V | V2 def]> broken: onError <[:E | E2 def]> ^<Promise[V2, E2]> = (\r	(* Subscribe to notification of a reference being fulfilled or broken. onValue or onError respectively will run in some turn after the turn that resolves ref., and the returned promise with be resolved with the result of the callback. *)\r	^(asInternalRef: ref) whenFulfilled: onValue whenBroken: onError\r)",
 "public when: ref <Promise> partitioned: onPartition <[:Promise | R def] | [R def]> ^<Promise[R, nil]> = (\r	(* Subscribe to notification of a reference breaking due to partition. *)\r)",
 "protected class RedirectReactor from: s to: d resolver: r = (\r(* A bridge between InternalResolvers in different actors. *)\r|\rprotected sourceActor <Actor> = s.\rprotected destinationActor <Actor> = d.\rprotected resolver <InternalResolver> = r.\r|)",
 " ",
 " ",
 "public reactBroken: r = (\r	| msg |\r	currentActor == sourceActor ifFalse: [halt].\r	msg:: PendingDelivery\r		receiver: resolver\r		selector: #internalResolve:\r		arguments: {InternalBrokenRef problem: r __owner: destinationActor}\r		resolver: nil.\r	destinationActor enqueueMessage: msg.\r)",
 "public reactMoreResolved: internalRef = (\r	internalRef redirectFrom: sourceActor to: destinationActor resolving: resolver.\r)",
 "public reactResolved: r = (\r	| msg |\r	currentActor == sourceActor ifFalse: [halt].\r	msg:: PendingDelivery\r		receiver: resolver\r		selector: #internalResolve:\r		arguments: {asInternalRef: (wrapArgument: r from: sourceActor to: destinationActor)}\r		resolver: nil.\r	destinationActor enqueueMessage: msg.\r)",
 "class Ref wrapping: ref = (|\rprotected internalRef = ref.\r|internalRefs at: self put: ref)",
 " ",
 " ",
 "protected doesNotUnderstand: message <Message> = (\r	(* For the debugger/inspector. Questionable. *)\r	(* Should probably override public method of Object as well. *)\r	0 = message arguments size ifTrue: [(message selector startsWith: 'is') ifTrue: [^false]].\r	^internalRef immediateSend: message\r)",
 "public identityHash = (\r	(* :bogus: Need a proper implementation of WeakMap that does not send messages to its keys. *)\r	^super hash\r)",
 "public isPromise = (\r	^true\r)",
 "public printOn: stream = (\r	(* BOGUS - debugging *)\r	internalRef refPrintOn: stream.\r)",
 "protected yourself = (\r	^super yourself\r)",
 "public class Resolver = (\r(*A Resolver represents the authority to resolve a Promise and is the control facet of the promise's eventual resolution.*)\r|\r	private (* N.B. We must not leak access to an InternalResolver via subobjects. *) internalResolver = InternalLocalPromise __owner: currentActor.\r	public promise <Promise[V, E]> = internalResolver externalRef.\r|)",
 " ",
 " ",
 "public break: error <E> = (\r	internalResolver internalResolve: (InternalBrokenRef problem: error __owner: currentActor).\r)",
 "public fulfill: value <V> = (\r	internalResolver internalResolve: (asInternalRef: value).\r)",
 "public isResolver ^<Boolean> = (\r	^true\r)",
 "class Scheduler = ()",
 " ",
 " ",
 "public eventualSendTo: r selector: s arguments: a = (\r)",
 "public class Timer __duration: milliseconds callback: callback repeating: repeating = (|\r	protected cancelled ::= false.\r|repeating\r		ifTrue: [self schedule: callback every: milliseconds]\r		ifFalse: [self schedule: callback after: milliseconds])",
 " ",
 " ",
 "public cancel = (\r	cancelled:: true.\r	nil == process ifFalse: [process terminate. process:: nil].\r)",
 "public isActive ^<Boolean> = (\r	cancelled ifTrue: [^false].\r	^nil ~= process\r)",
 "public isTimer ^<Boolean> = (\r	^true\r)",
 "protected schedule: callback after: ms = (\r	js call: (js propertyOf: (js ident: 'window') at: (js literal: 'setTimeout'))\r	with: {callback. ms}\r)",
 "protected schedule: callback every: ms = (\r	js call: (js propertyOf: (js ident: 'window') at: (js literal: 'setInterval'))\r	with: {callback. ms}\r)",
 "public after: duration do: callback <[]> ^<Timer> = (\r	^self __duration: duration callback: callback repeating: false\r)",
 "public every: duration do: callback <[:Timer]> ^<Timer> = (\r	^self __duration: duration callback: callback repeating: true\r)",
 "protected class WhenReactor onValue: v onError: e resolver: r = (\r(* A when-catch for a promise.\r\rNote that all slots contain objects that belong to the actor which sent #whenResolved:. *)\r|\r	protected onValue <[:V] | []> = v.\r	protected onError <[:E] | []> = e.\r	protected resolver <InternalResolver> = r.\r|)",
 " ",
 " ",
 "public reactBroken: value = (\r	resolver __owner == currentActor ifFalse: [halt].\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: onError\r			selector: #cull:\r			arguments: {value}\r			resolver: resolver).\r)",
 "public reactMoreResolved: internalRef = (\r	resolver internalResolve: (asInternalRef: (internalRef whenFulfilled: onValue whenBroken: onError)).\r)",
 "public reactResolved: value = (\r	resolver __owner == currentActor ifFalse: [halt].\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: onValue\r			selector: #cull:\r			arguments: {value}\r			resolver: resolver).\r)",
 "class AliensForV8 usingPlatform: p = (\r(* Aliens are a capability-based API for a foreign function interface (FFI). On NS2V8, they allow Newspeak code to invoke JavaScript code and vice versa.\r\rAn Alien is a Newspeak proxy for a JavaScript object. Upon receiving a message, an Alien expatriates the arguments, sends the message to the target JavaScript object, and alienates the result.\r\rAn Expat is a JavaScript proxy for a Newspeak object. Unpon receiving a message, an Expat alienates the arguments, sends the message to the target Newspeak object, and expatriates the result.\r\rA bilingual object is one whose representation is the same in both languages: unwrapped basic types such as numbers, booleans. Note that even though Newspeak and JavaScript closures have the same representation, they are not bilingual and wrapping should occur because Newspeak closures expect Newspeak/Alien arguments and JavaScript closures expect JavaScript/Expat arguments. What about strings and arrays? It would seem we have to wrap arrays because their elements should be alieniated/expatriated. It may be safe to treat strings as bilingual if they always respond to messages with other bilingual objects.\r\rAlien mappings:\ralien sort: a ignored: b ignored: c -> alien.sort(a, b, c)\ralien new: a ignored: b ignored: c  -> new alien(a, b, c)\ralien at: 'a' -> alien.a\ralien at: 'a' put: b -> alien.a = b\r\rExpat mappings:\r?\r\r*)\r|\rpublic global = Alien wrapping: (js ident: 'theGlobalObject').\r|)",
 " ",
 " ",
 "alienate: jsObj = (\r	#TODO.\r	(js operator: '===' with: (js ident: 'null') and: jsObj) ifTrue: [^nil].\r	(js prefixOperator: 'typeof ' on: jsObj) == 'string' ifTrue: [^jsObj].\r	(js prefixOperator: 'typeof ' on: jsObj) == 'number' ifTrue: [^jsObj].\r	(js prefixOperator: 'typeof ' on: jsObj) == 'boolean' ifTrue: [^jsObj].\r	(* This does not discrimate NS vs JS closures *)\r	(js prefixOperator: 'typeof ' on: jsObj) == 'function' ifTrue: [^Alien wrapping: jsObj].\r	(js operator: 'instanceof' with: jsObj and: (js propertyOf: (js propertyOf: Object at: (js literal: 'runtimeClass')) at: (js literal: 'basicNew')))\r		ifTrue:\r			[jsObj isAlien ifTrue: [Error signal: 'Shouldnt be asked to double alienate...'].\r			jsObj isExpat ifTrue: [^js propertyOf: jsObj at: (js literal: 'nsTarget')].\r			Error signal: 'Asked to alienate a raw Newspeak object...'].\r	(js operator: 'instanceof' with: jsObj and: (js ident: 'Array')) ifTrue:\r		[(* :todo: We should stamp NS arrays so we can verify everything commutes. *)\r		^jsObj collect: [:element | alienate: element]].\r	(js operator: 'instanceof' with: jsObj and: (js ident: 'Uint8Array')) ifTrue: [^jsObj].\r	^Alien wrapping: jsObj\r)",
 "copyUntilFirstColon: sel = (\r	#BOGUS. (* DNU does not yet pass unmangled selectors. *)\r	2 to: sel size do: [:i |\r		((sel at: i) = \"$\") ifTrue: [^sel copyFrom: 2 to: i - 1]].\r	^sel copyFrom: 2 to: sel size\r)",
 "expatriate: nsObj = (\r	#TODO.\r	(js operator: '===' with: nil and: nsObj) ifTrue: [^js ident: 'null'].\r	(js prefixOperator: 'typeof ' on: nsObj) == 'string' ifTrue: [^nsObj].\r	(js prefixOperator: 'typeof ' on: nsObj) == 'number' ifTrue: [^nsObj].\r	(js prefixOperator: 'typeof ' on: nsObj) == 'boolean' ifTrue: [^nsObj].\r	(* This does not discrimate NS vs JS closures *)\r	(js prefixOperator: 'typeof ' on: nsObj) == 'function' ifTrue: [^expatriateBlock: nsObj].\r	(js operator: 'instanceof' with: nsObj and: (js propertyOf: (js propertyOf: Object at: (js literal: 'runtimeClass')) at: (js literal: 'basicNew')))\r		ifTrue:\r			[nsObj isAlien ifTrue: [^js propertyOf: nsObj at: (js literal: 'jsTarget')].\r			nsObj isExpat ifTrue: [Error signal: 'Shouldnt be asked to double expatriate...'].\r			^Expat wrapping: nsObj.].\r	(js operator: 'instanceof' with: nsObj and: (js ident: 'Array')) ifTrue:\r		[(* :todo: We should stamp NS arrays so we can verify everything commutes. *)\r		^nsObj collect: [:element | expatriate: element]].\r	(js operator: 'instanceof' with: nsObj and: (js ident: 'Uint8Array')) ifTrue: [^nsObj].\r	Error signal: 'Asked to expatriate a raw JS object...'\r)",
 "expatriateBlock: b = (\r	^js functionOf: {} body: (\r		js return: (\r			expatriate: (\r				b valueWithArguments: (\r					(js verbatim: 'Array.prototype.slice.call(arguments, 0)') collect: [:ea | alienate: ea]))))\r)",
 "class Alien wrapping: o = (\r	js assign: (js propertyOf: self at: (js literal: 'jsTarget')) toBe: o.\r)",
 " ",
 " ",
 "applyConstructorUsingEval: jsArguments = (\r	(* On at least Safari, some objects used as constructors are not functions (*face palm*) and the trick with bind and apply doesn't work. Fall back to eval, sigh... *)\r	js verbatim:\r'function applyNewUsingEval(weirdConstructor, args) {\r	var a = [];\r	for (var i = 0; i < args.length; i++)\r		a[i] = \"args[\" + i + \"]\";\r	return eval(\"new weirdConstructor(\" + a.join() + \")\");\r}'.\r	^js call: (js ident: 'applyNewUsingEval') with: {(js propertyOf: self at: (js literal: 'jsTarget')). jsArguments}\r)",
 "public at: memberName = (\r	^alienate: (js propertyOf: (js propertyOf: self at: (js literal: 'jsTarget')) at: memberName)\r)",
 "public at: memberName put: value = (\r	js assign: (js propertyOf: (js propertyOf: self at: (js literal: 'jsTarget')) at: memberName) toBe: (expatriate: value).\r	^value\r)",
 "doesNotUnderstand: msg = (\r	| jsTarget jsArguments jsSelector |\r	jsTarget:: js propertyOf: self at: (js literal: 'jsTarget').\r	jsArguments:: msg arguments collect: [:arg | expatriate: arg].\r	jsSelector:: copyUntilFirstColon: msg mangledSelector.\r	jsSelector = 'new'\r		ifTrue:\r			[ (* var args = [null].concat(jsArguments);\r				var boundFunction = _jsTarget.bind.apply(_jsTarget, args);\r				return new boundFunction(); *)\r			| args boundFunction |\r			(js operator: '===' with: (js prefixOperator: 'typeof ' on: jsTarget) and: (js literal: 'function'))\r				ifFalse: [^alienate: (applyConstructorUsingEval: jsArguments)].\r			args:: js call: (js propertyOf: (js array: {js ident: 'null'}) at: (js literal: 'concat')) with: {jsArguments}.\r			boundFunction:: (js call: (js propertyOf: (js propertyOf: jsTarget at: (js literal: 'bind')) at: (js literal: 'apply')) with: {jsTarget. args}).\r			^alienate: (js new: boundFunction with: {}) ]\r\r		ifFalse:\r			[ | jsFunction jsResult |\r			jsFunction:: js propertyOf: jsTarget at: jsSelector.\r			(js operator: '===' with: jsFunction and: (js ident: 'undefined'))\r				ifTrue: [^super doesNotUnderstand: msg].\r			jsResult:: js call: (js propertyOf: jsFunction at: (js literal: 'apply')) with: {jsTarget. jsArguments}.\r			^alienate: jsResult].\r)",
 "public isAlien ^<Boolean> = (\r	^true\r)",
 "public isExpat ^<Boolean> = (\r	^false\r)",
 "public isUndefined = (\r	^js operator: '===' with: (js propertyOf: self at: (js literal: 'jsTarget')) and: (js ident: 'undefined')\r)",
 "public printString = (\r	self isUndefined ifTrue: [^'undefined']. (* undefined.toString() throws in JS *)\r	^(js call: (js propertyOf: (js propertyOf: self at: (js literal: 'jsTarget')) at: (js literal: 'toString')) with: {})\r)",
 "public value = (\r	| jsTarget = js propertyOf: self at: (js literal: 'jsTarget'). |\r	^alienate: (js\r		call: (js propertyOf: jsTarget at: (js literal: 'call'))\r		with: {jsTarget})\r)",
 "public value: a1 = (\r	| jsTarget = js propertyOf: self at: (js literal: 'jsTarget'). |\r	^alienate: (js\r		call: (js propertyOf: jsTarget at: (js literal: 'call'))\r		with: {jsTarget. expatriate: a1})\r)",
 "public value: a1 value: a2 = (\r	| jsTarget = js propertyOf: self at: (js literal: 'jsTarget'). |\r	^alienate: (js\r		call: (js propertyOf: jsTarget at: (js literal: 'call'))\r		with: {jsTarget. expatriate: a1. expatriate: a2})\r)",
 "public value: a1 value: a2 value: a3 = (\r	| jsTarget = js propertyOf: self at: (js literal: 'jsTarget'). |\r	^alienate: (js\r		call: (js propertyOf: jsTarget at: (js literal: 'call'))\r		with: {jsTarget. expatriate: a1. expatriate: a2. expatriate: a3})\r)",
 "public valueWithArguments: args = (\r	| jsTarget = js propertyOf: self at: (js literal: 'jsTarget'). |\r	^alienate: (js\r		call: (js propertyOf: jsTarget at: (js literal: 'apply'))\r		with: {jsTarget. args collect: [:nsArg | expatriate: nsArg]})\r)",
 "class Expat wrapping: o = (\r	(* :todo: Implement with ES6 Proxy instead. *)\r	js assign: (js propertyOf: self at: (js literal: 'nsTarget')) toBe: o.\r)",
 " ",
 " ",
 "public isAlien ^<Boolean> = (\r	^false\r)",
 "public isExpat ^<Boolean> = (\r	^true\r)",
 "class Collections usingPlatform: p = (\r(*\rNewspeak collections library.\rThis code was derived by converting the Strongtalk Collections classes to Newspeak, which is why the Sun Microsystems copyright and BSD license below applies.\r\rCopyright (c) 1995-2006 Sun Microsystems, Inc. ALL RIGHTS RESERVED.\rCopyright 2008-2009 Yardena Meymann, Gilad Bracha and other contributors.\r\rRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\r\r* Redistributions of source code must retain the above copyright notice,\r this  list of conditions and the following disclaimer.\r\r* Redistribution in binary form must reproduce the above copyright notice,\rthis list of conditions and the following disclaimer in the documentation and/o other materials provided with the distribution.\r\rNeither the name of Sun Microsystems or the names of contributors may\rbe used to endorse or promote products derived from this software without\rspecific prior written permission.\r\r>>\rTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\rTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\rBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\rGOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\rLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\rDAMAGE.>> *)\r|	private MutableAddableList = MutableList mixinApply: AddableList. (* -- streams -- *)	private ListReadStream = p streams SeqCltnReadStream. 	private ListReadWriteStream = p streams SeqCltnReadWriteStream.		(* magic collections *)	(* Not yet supported by NS2JS or NS2Dart *)	public WeakArray = Future computing: [p squeak WeakArray]. |)",
 " ",
 " ",
 "public IdentityMap = (\r	^IdentityMutableHashedMap\r)",
 "public List = (\r	^MutableArrayList\r)",
 "public Map = (\r	^MutableHashedMap\r)",
 "error: s = (\r	^Error signal: s\r)",
 "class AbstractList = Collection (\r(* This class implements the read-only protocol for indexed collections that order their elements using integer indices. *)\r)",
 "Collection",
 "Collection",
 "public , other <List[X]> ^<MutableList[E | X]> = (\r	^self copyReplaceFrom: size + 1 to: size with: other\r)",
 "public allButFirst ^ <MutableList[E]> = (\r	^copyFrom: 2 to: size\r)",
 "public allButLast ^ <MutableList[E]> = (\r	^copyFrom: 1 to: size - 1\r)",
 "public anyOne = (\r	^ first\r)",
 "public at: index <Integer> ^<E> = (\r	subclassResponsibility\r)",
 "public at: index <Integer> ifAbsent: fail <[X def]> ^<E|X> = (\r	^(index between: 1 and: size)\r		ifTrue: [ at: index ]\r		ifFalse: [ fail value ]\r)",
 "binarySearchFor: el <EL>\rbetween: start <Integer>\rand: end <Integer>\rtoCompare: compare <[:EL def:EL| Boolean]>\r^<Int>\r= (\r			(* {where CONSTRAINER <EL> is returnType of #anElement message of receiverType} *)\r	(* This does a binary search for the index such that if el was inserted before it\r	  the receiver would remain sorted.  The receiver must be sorted relative to the\r	  comparison block.  The comparison block should return true if the first block argument\r	  cannot appear after the second block argument *)\r\r	| low <Integer> high <Integer> |\r	low:: start.\r	high:: end.\r	[ low <= high ]\r		whileTrue:\r				[ | mid <Integer> |\r					mid:: (low + high)  // 2.\r	  				(* The guaranteed below is safe because of the inference clause *)\r					(compare value: (\r(* guaranteed <EL> *) (at: mid)) value: el)\r						ifTrue: [ low:: mid + 1 ]\r						ifFalse: [ high:: mid - 1 ].\r				].\r	^low\r)",
 "public binarySearchFor: el <EL>\rtoCompare: compare <[:EL def:EL| Boolean]>\r^ <Integer>\r= (\r	#BOGUS. (* Remove me. *)\r	(* {where CONSTRAINER <EL> is returnType of #anElement message of receiverType} *)\r\r	(* The guarantee is safe because of the inference clause *)\r	^(\r(* guaranteed <List[EL]> *) self)\r			binarySearchFor: el\r			between: 1\r			and: size\r			toCompare: compare\r)",
 "public collect: map <[:E | R def]> ^<List[R]> = (\r	^collectUsingAtPut: map\r)",
 "protected collectUsingAtPut: map <[:E | R def]> ^<List[R]> = (\r	| c <MutableList[R]> |\r	(* See #newForCollect: for explanation of why the guarantee is safe *)\r	c:: (* guaranteed <MutableList[R]> ( *)newForCollectUsingAtPut: size(* ) *).\r	1 to: self size do:\r		[:i <Integer> |\r			c at: i put: (map value: (at: i)) ].\r	^c\r)",
 "collection: cltn <List[Object]>\rmatchesElementsAt: index <Integer>\r^<Boolean> = (\r	(* Test whether we contain the given subcollection at index.  This method assumes\r	  that there are at least as many elements in this collection after index as cltn size *)\r\r	| offset <Integer> |\r	offset:: index - 1.\r	1 to: cltn size do:\r		[:i <Integer> |\r			(cltn at: i) = (at: i+offset)\r				ifFalse: [ ^false ]		].\r	^true\r)",
 "public copyFrom: start <Integer> to: stop <Integer> ^<MutableList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r\r	(* The guarantee is typesafe since the inference clause guarantees that E < EX at the call site *)\r	| cp <MutableList[EX]> safeme <List[EX]> |\r	safeme:: (* guaranteed <List[EX]> *) self.\r	cp:: (* guaranteed <MutableList[EX]> *)\r				newCopyOfSize: (stop - start) + 1 thatCanAlsoHoldElementsOf: safeme.\r	cp replaceFrom: 1 to: cp size with: safeme startingAt: start.\r	^cp\r)",
 "public copyReplaceAll: oldSub <List[Object]> with: newSub <List[X]> ^<MutableList[EX | X]> = (\r	(* {where EX is returnType of #anElement message of receiverType;\r			where X is returnType of #anElement message of arg 2} *)\r\r	|	spots <List[Integer]>\r		subDelta <Integer>\r		copy <MutableList[EX | X]>\r		current <Integer>\r		offset <Integer>\r		newSubSize <Integer>\r		oldSubSize <Integer>\r		safeself <List[EX]>\r		|\r	newSubSize:: newSub size.\r	oldSubSize:: oldSub size.\r	subDelta:: newSub size - oldSubSize.\r	spots:: indicesOfSubCollection: oldSub.\r\r	(* This guarantee is typesafe since the inference clause guarantees that E < EX at the call site *)\r	safeself:: (* guaranteed <List[EX]> *) self.\r\r	spots size = 0\r		ifTrue: [ copy:: safeself newCopyOfSize: size\r								thatCanAlsoHoldElementsOf: newSub.\r						copy replaceFrom: 1 to: size with: safeself.\r						^copy\r						].\r\r	copy:: safeself newCopyOfSize: size + (spots size * subDelta)\r				thatCanAlsoHoldElementsOf: newSub.\r	current:: 1.\r	offset:: 0.\r	spots do:\r		[:spot <Int> |	| offspot <Int> |\r			offspot:: spot + offset.\r\r			(* copy segment of self before the next occurrence *)\r			copy	replaceFrom: current + offset\r					to: offspot - 1\r					with: safeself\r					startingAt: current.\r			(* copy the new subcollection at the next occurrence *)\r			copy	replaceFrom: offspot\r					to: (offspot + newSubSize) - 1\r					with: newSub.\r			current:: spot + oldSubSize.\r			offset:: offset + subDelta.	].\r	(* copy the final segment from self after the last occurrence *)\r	copy	replaceFrom: current + offset\r			to: copy size\r			with: safeself\r			startingAt: current.\r	^copy\r)",
 "copyReplaceFrom: start <Integer> to: stop <Integer> with: other <List[X]> ^<MutableList[EX | X]> = (\r	(* {where EX is returnType of #anElement message of receiverType;\r			where X is returnType of #anElement message of arg 3} *)\r\r	|	copy <MutableList[EX | X]>\r		sizeChange <Integer>\r		sz <Integer>\r		afterNew <Integer>\r		safeself <List[EX]> |\r\r	(* The guarantee is typesafe since the inference clause guarantees that E < EX at the call site *)\r	safeself:: (* guaranteed <List[EX]> *) self.\r\r	sizeChange:: other size - ((stop - start) + 1).\r	sz:: size.\r	copy:: safeself newCopyOfSize: sz + sizeChange\r				thatCanAlsoHoldElementsOf: other.\r	afterNew:: start + other size.\r	copy replaceFrom: 1 to: start - 1 with: safeself startingAt: 1.\r	copy replaceFrom: start to: afterNew - 1 with: other.\r	copy replaceFrom: afterNew to: copy size with: (\r(* guaranteed <List[EX]> *) self) startingAt: stop + 1.\r	^copy\r)",
 "public copyWith: element <X> ^<MutableList[E | X]> = (\r	^self , {element}\r)",
 "public copyWithSize: s <Integer> ^<MutableList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r\r	(* return a mutable copy of the receiver of a different size, that is either truncated\r		or extended with nils as necessary.  Note this works even if the receiver itself\r		is not mutable *)\r\r	(* %note: the inference clause above is a tricky way of doing something very difficult:\r	  it allows us to effectively return a mutable copy of the receiver in a typesafe way,\r	  even though the\r	  receiver itself may not be mutable.  This would be impossible to type reasonably\r	  without the inference clause, because we would have to have a return type of\r	 <MutableList[E]>, which isn't typesafe since  E is a 'covariant' generic variable of this\r	  class, whereas E is an 'unrelated' generic variable in MutableList. - D.G. *)\r\r	(* %note: The inference clause above should really read ... EX <E> ..., but the type\r		system implementation for some reason can't deal with implementations\r		of such a method in subclasses that have bound E (i.e. are not generic on E).\r		For an example, see the implementation in ReadString, which would not have to\r		have a guarantee in the method body if this worked right - D.G. *)\r\r	subclassResponsibility\r)",
 "public copyWithout: el <Object> ^<MutableList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r\r	| safeself <List[EX]> |\r\r	(* The following guarantee is safe because the inference clause ensures that E < EX\r		at the call site *)\r	safeself:: (* guaranteed <List[EX]> *) self.\r\r	^safeself copyReplaceAll: (Array(* [Object] *) with: el) with: {}\r)",
 "public do: f <[:E]> = (\r	1 to: size do:\r		[:i <Integer> |\r			f value: (at: i)	]\r)",
 "public doWithIndex: f <[:E :Integer]> = (\r	1 to: size do:\r		[:i <Integer> |\r			f value: (at: i) value: i]\r)",
 "public findFirst: predicate <[:E| Boolean]> ^<Integer> = (\r	1 to: size do:\r		[:i <Integer> |\r			(predicate value: (at: i))\r				ifTrue: [ ^i ]	].\r	^0\r)",
 "public findLast: predicate <[:E| Boolean]> ^<Integer> = (\r	size to: 1 by: -1 do:\r		[:i <Integer> |\r			(predicate value: (at: i))\r				ifTrue: [ ^i ]	].\r	^0\r)",
 "public first ^<E> = (\r	^self at: 1\r)",
 "public hasSameElementsAndOrderAs: other <List[Object]> ^<Boolean> = (\r	#ACCESSBOGUS.\r	(* Like #hasSameElementsAs:, but also requires the elements to be in the same order *)\r\r	size = other size\r		ifFalse: [ ^false ].\r	1 to: size do:\r		[:i <Integer> |\r			(at: i) = (other at: i)\r				ifFalse: [ ^false ]	].\r	^true\r)",
 "public hash ^<Integer> = (\r	(* This function should not be changed, since it is designed to produce the\r		same results as the identityHash primitive, for strings and symbols *)\r	| sz <Integer> val <Integer> |\r	sz:: size.\r	sz < 2\r		ifTrue: [ ^sz = 1 ifTrue: [ self hashAt: 1 ] ifFalse: [ 1 ] ].\r	val:: hashAt: 1.\r	val:: (val bitShift: 3) bitXor: ((hashAt: 2) bitXor: val).\r	val:: (val bitShift: 3) bitXor: ((hashAt: sz) bitXor: val).\r	val:: (val bitShift: 3) bitXor: ((hashAt: sz - 1) bitXor: val).\r	val:: (val bitShift: 3) bitXor: ((hashAt: (sz bitShift: -1) + 1) bitXor: val).\r	val:: (val bitShift: 3) bitXor: (sz bitXor: val).\r\r	(* mask it to 20 bits to match VM *)\r	val:: val bitAnd: 16rFFFFF.\r	^val\r)",
 "protected hashAt: index <Integer> ^<Integer> = (\r	^(at: index) hash\r)",
 "protected includesIndex: index <Integer> ^<Boolean> = (\r	^index between: 1 and: size\r)",
 "public indexOf: element <Object> ^<Integer> = (\r	^self indexOf: element ifAbsent: [ 0 ]\r)",
 "public indexOf: element <Object> ifAbsent: f <[X def]> ^<Integer | X> = (\r	1 to: size do:\r [:index <Integer> |\r (at: index) =\relement ifTrue: [^index]].\r	^f value\r)",
 "indexOfSubCollection: sub <List[Object]>\rstartingAt: index <Integer>\r^<Integer> = (\r	^indexOfSubCollection: sub\r		startingAt: index\r		ifAbsent: [ error: 'subcollection not found' ]\r)",
 "indexOfSubCollection: sub <List[Object]>\rstartingAt: index <Integer>\rifAbsent: f <[X def]>\r^<Integer | X> = (\r	index to: (size - sub size) + 1 do:\r		[:i <Integer> |\r			(collection: sub matchesElementsAt: i)\r				ifTrue: [ ^i ]		].\r	^f value\r)",
 "indicesOfSubCollection: sub <List[Object]> ^<List[Int]> = (\r	^indicesOfSubCollection: sub startingAt: 1\r)",
 "indicesOfSubCollection: sub <List[Object]>\rstartingAt: index <Integer>\r^<List[Integer]> = (\r	| indices <MutableArrayList[Integer]> subSize <Integer> current <Integer> |\r	indices:: MutableArrayList(* [Int] *) new.\r	subSize:: sub size.\r	current:: index.\r	[ current:: self indexOfSubCollection: sub startingAt: current ifAbsent: [ 0 ].\r	  current = 0\r		] whileFalse:\r			[ indices addLast: current.\r				current:: current + subSize.		].\r	^indices\r)",
 "public isKindOfList ^ <Boolean> = (\r	^true\r)",
 "public isSequenceable = (\r	^true\r)",
 "isSortedBy: compare <[:E:E| Boolean]> ^<Boolean> = (\r	(* Returns true if the receiver is in sorted order, using the specified comparison *)\r\r	| last <E> |\r	size < 2\r		ifTrue: [ ^true ].\r	last:: at: 1.\r	2 to: size do:\r		[:i <Integer> |\r			(compare value: last value: (at: i))\r				ifFalse: [ ^false ]	].\r	^true\r)",
 "public keysAndValuesDo: action <[:Integer :E]> = (\r	1 to: size do:\r		[:index <Integer> |\r action value: index value: (at: index)]\r)",
 "public last ^<E> = (\r	^self at: self size\r)",
 "public newCopyOfSize: size <Integer>\rthatCanAlsoHoldElementsOf: other <List[X]>\r^<MutableList[EX | X]>\r= (\r		(* {where X is returnType of #anElement message of arg 2;\r		     where EX is returnType of #anElement message of receiverType} *)\r\r	(* Return a fresh collection of a closely related type\r	that can hold both elements of self and elements of the other collection *)\r\r	^Array(* [EX | X] *) new: size\r)",
 "newForCollectUsingAtPut: size <Integer> ^<MutableList[Object]> = (\r	(* Return a new extensible collection that is as closely related to the receiver's class as possible.  The\r	 returned collection must be unaliased and empty, so it is safe for the caller to guarantee that the type\r	 variable is of a more specific type *)\r\r	^Array(* [Object] *) new: size\r)",
 "public readStream ^<ReadStream[E]> = (\r	^ListReadStream on: self\r)",
 "public reverse ^<MutableList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r\r	(* The guarantees are typesafe since the inference clause guarantees that E < EX at the call site *)\r	| copy <MutableList[EX]> |\r\r	#BOGUS. (* #reverse implies an in-place operation, should be #reversed *)\r	copy:: (* guaranteed <MutableList[EX]> *)\r		(newCopyOfSize: size thatCanAlsoHoldElementsOf: self).\r	1 to: size do:\r		[:i <Integer> |\r			| el <EX> |\r			el:: (\r(* guaranteed <MutableList[EX]> *) self) at: i.\r			copy at: size + 1 - i put: el.	].\r	^copy\r)",
 "public reverseDo: action <[:E]> = (\r	size to: 1 by: -1 do:\r		[:index <Integer> |\r action value: (at: index)]\r)",
 "public size ^<Integer> = (\r	subclassResponsibility\r)",
 "public species ^<Collection[E] class> = (\r	^Array(* [E] *)\r)",
 "public with: other <List[X def]> do: action <[:E :X]> = (\r	assert: [ self size = other size ] message: 'Cannot jointly interate collections of different size'.\r	1 to: size do:\r		[:index <Integer> |\r action value: (at: index) value: (other at: index)].\r)",
 "class AddableList = AbstractList (\r(* AddableLists are Lists that support the Extensible protocol, and which support indexing in constant time. *)\r|\r	protected contents <Array[E]>\r	protected startGap <Integer> (* number of empty slots at the beginning of contents *)\r	protected lastIndex <Integer> (* (internal) index of last occupied table entry *)\r|initCapacity: self class defaultCapacity)",
 "AbstractList",
 "AbstractList",
 "public add: e <E> ^<E> = (\r	subclassResponsibility\r)",
 "public addAll: c <Collection[E]> ^<Collection[E]> = (\r	c do: [:el <E> |\r		add: el	].\r	^c\r)",
 "public at: i <Integer> ^<E> = (\r	| adjusted <Int> |\r	adjusted:: i + startGap.\r	((0 < i) and: [adjusted <= self lastIndex])\r		ifFalse: [ error: 'invalid index' ].\r	^contents at: adjusted\r)",
 "public at: i <Integer> ifAbsent: f <[X def]> ^<E | X> = (\r	| internal <Int> |\r	internal:: i + self startGap.\r	^(internalIndexIsValid: internal)\r		ifTrue: [ contents at: internal ]\r		ifFalse: [ f value ]\r)",
 "public copyWithSize: s <Integer> ^<MutableList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r\r	| safeself <List[EX]> |\r\r	(* This guarantee is safe because the inference clause guarantees\r		that E < EX at each call site *)\r	safeself:: (* guaranteed <List[EX]> *) self.\r\r	^(Array(* [EX] *) new: s)\r		replaceFrom: 1 to: (s min: size) with: safeself\r)",
 "public do: action <[:E]> = (\r	startGap + 1 to: lastIndex do:\r		[:index <Integer> | action value: (contents at: index) ]\r)",
 "endGap ^<Integer> = (\r	^contents size - lastIndex\r)",
 "firstIndex ^<Integer> = (\r	^1 + startGap\r)",
 "public include: e <E> ^<E> = (\r	^include: e ifNew: []\r)",
 "public include: e <E> ifNew: blk <[]> ^<E> = (\r	(includes: e)\r		ifFalse: [ add: e.\r						blk value. ].\r	^e\r)",
 "public includeAll: c <Collection[E]> ^<Collection[E]> = (\r	c do: [:el <E> |\r		include: el ].\r	^c\r)",
 "public indexOf: el <Object> ifAbsent: f <[X def]> ^<Integer | X> = (\r	1 to: size do: [:i <Integer> |\r		(at: i) = el\r			ifTrue: [ ^i ].	].\r	^f value\r)",
 "public initCapacity: c <Integer> = (\r	(* Need proper factories to pass initial capacity and make this non-public. *)\r\r	contents:: Array(* [E] *) new: c.\r	startGap:: 0.\r	lastIndex:: 0.\r)",
 "internalIndexIsValid: index <Integer> ^<Boolean> = (\r	^index > startGap and: [ index <= lastIndex ]\r)",
 "internalRangeCheck: index <Integer> = (\r	(internalIndexIsValid: index )\r		ifFalse: [ error: 'invalid index' ].\r)",
 "makeSpace: slots <Integer> beforeIndex: i <Integer> ^<Integer> = (\r	(* assume: i is a valid internal index.  The index is returned, adjusted\r	 for any resizing of the internal array that may have taken place\r	 (i.e. the index of the beginning of the created gap is returned) *)\r\r	(* # before i is (i - startGap) - 1, # after is (lastIndex - i) + 1 *)\r	^((i - startGap) - 1) > ((lastIndex - i) + 1)\r		ifTrue: [ 	(* fewer elements after, so move them *)\r			      	needSpaceAtEnd: slots.\r			      	contents\r					replaceFrom: i + slots\r					to: lastIndex + slots\r					with: contents\r					startingAt: i.\r			    	lastIndex:: lastIndex + slots.\r				i	]\r		ifFalse: [ (* fewer elements before, so move them *)\r				| newI <Integer> |\r				newI:: i + (needSpaceAtStart: slots) - slots.\r				contents\r					replaceFrom: (startGap + 1) - slots\r					to: newI - 1\r					with: contents\r					startingAt: startGap + 1.\r				startGap:: startGap - slots.\r				newI	].\r)",
 "makeSpaceAtStart: nslots <Integer> ^<Integer> = (\r	(* Make sure that there are at least nslots of unused capacity at the low\r	 end of contents.  The # of slots added at the beginning is returned. *)\r\r	|	newGap <Integer>\r		diff <Integer>\r		newContents <AbsoluteArray[E]>\r		sz <Integer>\r		newLastIndex <Integer> |\r	(isEmpty and: [nslots <= contents size])\r		ifTrue: [startGap: nslots.\r  				lastIndex: nslots.\r				^nslots].\r\r	sz:: size.\r	newGap:: nslots max: sz.\r	diff:: newGap - startGap.\r	newLastIndex:: newGap + sz.\r	newContents:: Array(* [E] *) new:\r		contents size + diff.\r	newContents\r		replaceFrom: newGap + 1\r		to: newLastIndex\r		with: contents\r		startingAt: firstIndex.\r	startGap: newGap.\r	contents: newContents.\r	lastIndex: newLastIndex.\r	^diff\r)",
 "needSpaceAtEnd: slots <Integer> = (\r	slots > endGap\r		ifTrue: [ contents:\r							(contents copyWithSize:\r								contents size + (slots max: size)	)]\r)",
 "needSpaceAtStart: nslots <Integer> ^<Integer> = (\r	(* Make sure that there are at least nslots of unused capacity at the low\r	 end of contents.  The # of slots added at the beginning is returned. *)\r\r	^nslots > startGap\r		ifTrue: [makeSpaceAtStart: nslots]\r		ifFalse: [ 0 ]\r)",
 "public postCopy = (\r	super postCopy.\r	(* We potentially may change the size of the contents array so that this can work for copyWithSize:\r	  as well *)\r	contents: (contents copyWithSize: (contents size max: lastIndex))\r)",
 "public remove: el <E> ^<E> = (\r	^remove: el\r		ifAbsent: [ error: 'element not found' ]\r)",
 "public remove: nElements <Integer> at: i <Integer> = (\r	| el <E> internal <Integer> |\r	el:: at: i.\r	internal:: startGap + i.\r	internalRangeCheck: internal.\r	internalRangeCheck: (internal + nElements) - 1.\r	internal  to: lastIndex - nElements\r		 do: [:index <Integer> |\r			  contents at: index put: (contents at: index + nElements).	].\r	contents at: lastIndex put: nil.\r	lastIndex: lastIndex - nElements.\r)",
 "public remove: el <E> ifAbsent: f <[X def]> ^<E|X> = (\r	removeAt: (indexOf: el ifAbsent: [^f value]).\r	^el\r)",
 "public removeAll = (\r	startGap + 1 to: lastIndex do:\r		[:i <Integer> |\r			contents at: i put: nil].\r	lastIndex: startGap\r)",
 "public removeAll: c <Collection[E]> ^<Collection[E]> = (\r	c do: [:el <E> |\r		remove: el ].\r	^c\r)",
 "public removeAllSuchThat: test <[:E | Boolean]> = (\r	| i <Integer> |\r	i:: 1.\r	[ i <= size ]\r		whileTrue:\r			[ (test value: (at: i))\r					ifTrue: [ removeAt: i ]\r					ifFalse: [ i:: i + 1 ]	]\r)",
 "public removeAt: index <Integer> ^<E> = (\r	| el <E> |\r	el:: at: index.\r	remove: 1 at: index.\r	^el\r)",
 "public removeEvery: val <E> ^<E> = (\r	^removeEvery: val startingAt: 1\r)",
 "public removeEvery: val <X def> startingAt: start <Integer> ^<X> = (\r	| index <Integer> |\r	index:: indexOf: val ifAbsent: [ ^val ].\r	removeAt: index.\r	^removeEvery: val startingAt: index\r)",
 "public removeFirst ^<E> = (\r	^removeAt: 1\r)",
 "public removeLast ^<E> = (\r	^removeAt: size\r)",
 "public size ^<Integer> = (\r	^lastIndex - startGap\r)",
 "public size: s <Integer> = (\r	(* Change the size of the ordered collection to s (not the capacity).  This will truncate elements at the end if the current size\r	  is larger.  If the current size is smaller, the added elements will be undefined, in which case it is erroneous to access them until they have been set.\r	  This method should be used very rarely and carefully as a result. *)\r\r	| delta <Integer> newLastIndex <Integer> |\r	delta:: s - size.\r	newLastIndex:: lastIndex + delta.\r	delta < 0\r		ifTrue: [ newLastIndex + 1 to: lastIndex do:\r					[:i <Integer> |\r						contents at: i put: nil]].\r	delta > 0\r		ifTrue: [ needSpaceAtEnd: delta ].\r	lastIndex: lastIndex + delta.\r)",
 "public sort: compare <[:E :E | Boolean]> = (\r	(* In-place sort. *)\r	lastIndex < firstIndex ifTrue: [^self].\r	contents\r		mergeSortFrom: firstIndex\r		to: lastIndex\r		by: compare\r)",
 "public defaultCapacity ^<Integer> = (\r	^5\r)",
 "public new: capacity <Integer> ^<Instance> = (\r	^new initCapacity: capacity\r)",
 "public with: val1 <E> ^<Instance> = (\r	^(new: 1) add: val1; yourself\r)",
 "public withAll: cltn <Collection[E]> ^<Instance> = (\r	^(new: cltn size) addAll: cltn; yourself\r)",
 "public class Association key: k value: v = (\r(* Associates an object of type K with an object of type V. *)\r|\r	public key <K> ::= k.\r	public value <V> ::= v.\r|)",
 " ",
 " ",
 "public = other <Object> ^<Boolean> = (\r	(* | othera <Assoc[Object,Object]> | *)\r	(* %todo: replace Association with Assoc when typecase is fully impl *)\r	(* othera:: Association[Object,Object] coerce: other else: [ ^false ]. *)\r	^key = other key and: [ value = other value ].\r)",
 "public copy = (\r	^class key: key value: value\r)",
 "public hash ^<Integer> = (\r	^key hash bitXor: value hash\r)",
 "public printOn: strm <CharOutputStream> = (\r	key printOn: strm.\r	strm nextPutAll: ' -> '.\r	value printOn: strm.\r)",
 "public new ^<Instance> = (\r	self warnObsolete.\r	^self key: nil value: nil\r)",
 "public class Collection = (\r(* A Collection is an object that represents a group of objects.\r\rThe only message that must be implemented by subclasses is the #do: message.\rAll other Collection messages are then defined in terms of #do:.\r\r%responsibility size\r	Subclasses usually reimplement the #size message if possible, since the\r	implementation provided in this class is very inefficient.\r%responsibility collect:\r	Subclasses may wish to consider overriding the #collect: (and #select: and #reject:)\r	messages to specialize their return\r	types to match the receiver type more closely. *)\r)",
 " ",
 " ",
 "public allSatisfy: predicate <[:E | Boolean]> ^<Boolean> = (\r	self do: [:each | (predicate value: each) ifFalse: [^false]].\r	^true\r)",
 "public anySatisfy: predicate <[:E | Boolean]> ^<Boolean> = (\r	self do: [:each | (predicate value: each) ifTrue: [^true]].\r	^false\r)",
 "public asArray ^<Array[E]> = (\r	|\r	array <Array[E]> = Array new: size.\r	index <Integer> ::= 1.\r	|\r	self do: [:element <E> |\r		array at: index put: element.\r		index:: index + 1].\r	^array\r)",
 "public asCollection = (\r	(* Squeak 5.0 *)\r	^self\r)",
 "public asMutableArrayList ^<MutableArrayList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r(* Return a new MutableArrayList holding the elements of this collection.  The element type of the ordered collection\r	is whatever the static type of the receiver is at the point of send. *)\r	^MutableArrayList(* [EX] *) withAll: (* (guaranteed <CollectionEX]> *)self(* ) *)\r)",
 "public asSet ^<Extensible[EX]> = (\r	 (* Return a new extensible collection holding the elements of this collection. *)\r\r	^Set(* [EX] *) withAll: (* (guaranteed <Collection[EX]> *)self(* ) *)\r)",
 "public asSortedList ^<List[Object]> = (\r	(* This message is NOT typesafe, and should only be used for compatibility reasons, since there is\r 	 no way of knowing whether the elements of this collection support #< or not.  You should use\r	 #asSortedList: instead, if possible *)\r\r	^SortedList(* [Object] *) withAll: self\r)",
 "public asSortedList: sortPredicate <[:E:EX | Boolean]> ^<SortedList[EX]> = (\r	(* { where EX is  arg 1 of #value:value: message of arg 1 } *)\r	(* Return a new sorted collection ordered by the given sortPredicate.  Note that Magnitude\r	 supports the defaultSort message for convenience, so that for example if you have a collection\r	 of strings strc, you can say:\r		strc asSortedList: String defaultSort\r	*)\r\r	(* This is typesafe despite the guarantee because the inference clause requires that E = EX at the\r	call site *)\r	^(SortedList(* [EX] *) new: size sortBlock: (* (guaranteed <[EX,EX,^Boolean]> *)sortPredicate(* ) *))\r		addAll: (* (guaranteed <Collection[EX]> *)self(* ) *); yourself\r)",
 "public collect: map <[:E | R def]> ^<Collection[R]> = (\r	^self collectUsingAdd: map\r)",
 "protected collectUsingAdd: map <[:E | R def]> ^<Collection[R]> = (\r	| c |\r	(* See #newForCollect: for explanation of why the guarantee is safe *)\r	c:: (newForCollectUsingAdd: size).\r	do: [:e | c add: (map value: e) ].\r	^c\r)",
 "public copy = (\r	#BOGUS. (* Questionable. Probably should be shallowCopy if we keep it. *)\r	^self class withAll: self\r)",
 "public detect: predicate <[:E | Boolean]> ^<E> = (\r	^self detect: predicate ifNone: [Error signal: 'No matching element detected']\r)",
 "public detect: aBlock ifFound: foundBlock ifNone: exceptionBlock = (\r	self\r		do: [ :each |\r			(aBlock value: each)\r				ifTrue: [ ^ foundBlock cull: each ] ].\r	^ exceptionBlock value\r)",
 "public detect: predicate <[:E | Boolean]> ifNone: fail <[X def]> ^<E | X> = (\r	self do: [:element | (predicate value: element) ifTrue: [^element]].\r	^fail value\r)",
 "public do: action <[:E]> = (\r	subclassResponsibility\r)",
 "public do: action <[:E]> separatedBy: betweenAction <[]> = (\r	(* Useful when you need to do something 'between' elements (i.e. not before the first one, and not after the last one). [action] is evaluated the same way as for #do:, but [betweenAction] is evaluated once between each pair of elements. *)\r	| firstTime <Boolean> ::= true. |\r	firstTime:: true.\r	self do:\r		[:element <E> |\r		firstTime\r			ifTrue: [firstTime:: false]\r			ifFalse: [betweenAction value].\r			action value: element].\r)",
 "public flatMap: map <[:E | R def]> ^<Collection[R]> = (\r	^(collect: map) flatten\r)",
 "public flatten ^ <Collection[E]> = (\r	| totalSize <Integer> ::= 0. c |\r	do: [:e <E> | totalSize:: totalSize + (e isKindOfCollection ifTrue: [e size] ifFalse: [1])].\r	c:: newForCollectUsingAdd: totalSize.\r	do: [:e <E> | e isKindOfCollection ifTrue: [e do: [:x | c add: x]] ifFalse: [c add: e]].\r	^c\r)",
 "public hash ^<Integer> = (\r	| count ::= 0. |\r	^self inject: 0 into:\r		[:previousHash <Integer> :element <E> |\r		| newHash |\r		newHash:: previousHash bitXor: element hash.\r		count:: count + 1.\r		count > 2 ifTrue: [^newHash].\r		newHash]\r)",
 "public includes: o <Object> ^<Boolean> = (\r	self do: [:element <E> | element = o ifTrue: [^true]].\r	^false\r)",
 "public inject: initialValue <X> into: foldBlock <[:X def :E | X]> ^<X> = (\r	| runningValue <X> |\r	runningValue:: initialValue.\r	self do: [:element <X> | runningValue:: foldBlock value: runningValue value: element].\r	^runningValue\r)",
 "public intersection: other <Collection[Object]> ^<List[E]> = (\r	^self select: [:each | other includes: each]\r)",
 "public isCollection ^<Boolean> = (\r	^true\r)",
 "public isEmpty ^<Boolean> = (\r	^0 == self size\r)",
 "public isKindOfCollection = (\r	(* Should be auto-generated *)\r	^true\r)",
 "public max = (\r	^ self inject: self anyOne into: [:m :each | m max: each]\r)",
 "protected maxPrintElements ^<Int> = (\r	^100\r)",
 "protected newForCollectUsingAdd: size <Int> ^<MutableArrayList[Object]> = (\r	(* Return a new extensible collection that is as closely related to the receiver's class as possible.  The\r	 returned collection must be unaliased and empty, so it is safe for the caller to guarantee that the type\r	 variable is of a more specific type *)\r\r	^MutableArrayList new: size\r)",
 "public noneSatisfy: predicate <[:E | Boolean]> ^<Boolean> = (\r	self do: [:each | (predicate value: each) ifTrue: [^false]].\r	^true\r)",
 "protected occurrencesOf: o <Object> ^<Int> = (\r	| c <Int> |\r	#BOGUS. (* Questionable *)\r	c:: 0.\r	do: [:e <E> | e = o ifTrue: [ c:: c + 1 ]].\r	^c\r)",
 "public postCopy = (\r	#BOGUS. (* Squeakism *)\r)",
 "protected printElementsDo: f <[:Object]> = (\r	(* Evaluate the block with all the elements that should be shown as the contents in the printstring.  This provides a hook for things like MutableHashedMaps, which want to show their associations, not their values *)\r	self do: f\r)",
 "public printOn: stream <CharOutputStream> = (\r	| count <Integer> first <Boolean> |\r	stream	nextPutAll: class mixin simpleName;\r			nextPut: \"(\".\r	count:: 0.\r	first:: true.\r	self printElementsDo:\r		[:element <Object> |\r		first\r			ifTrue: [ first:: false ]\r			ifFalse: [ stream space ].\r		element printOn: stream.\r		count:: count + 1.\r		count >= maxPrintElements\r			ifTrue: [ stream nextPut: \"<\"; print: size - count; nextPutAll: ' more elements>)'.\r						^self]].\r	stream nextPut: \")\".\r)",
 "public reduce: reduceFn <[:RE def :RE | RE]> ^<RE> = (\r	(* {where CONSTRAINER <RE> is returnType of #anElement message of receiverType} *)\r	(* Like reduce:ifEmpty: except that it is a dynamic error to send this to an empty collection *)\r\r	^self reduce: reduceFn ifEmpty: [Error signal: 'Cannot reduce an empty collection' ]\r)",
 "public reduce: reduceFn <[:RE def:RE| RE]> ifEmpty: onEmpty <[X def]> ^<RE | X> = (\r	(* {where CONSTRAINER <RE> is returnType of #anElement message of receiverType} *)\r	(* Reduce is similar to inject except that the first element is used as the injected\r	  element for the rest of the collection.  It is often handier than inject.  For example:\r		(#(1 2 3 4) reduce: [:a <Int> :b <Int> | a + b ]) sums a collection of numbers. *)\r\r	(* esoteric typing %note: We need to ensure that E is a subtype of RE (the argument type for the reduction\r		function), but since that would require a\r		supertype constraint (which neither we nor anyone else support, we accomplish the same\r	    thing indirectly by introducing an unreferenced type\r		variable CONSTRAINER that is inferred to be E at the call site, and then constraining it with a bound\r		of RE.  This will prevent any call where E > RE from typechecking.  However, since the\r		typesystem doesn't 'know' that, we have to tell it that with a guarantee in the method body.\r		Because of the CONSTRAINER, we know that the guarantee is true for all calls that typecheck.\r		Of course, this is tricky, but at least we can express it, and in a way that hides the guarantee from\r		callers! *)\r\r	| current <RE> |\r	self do:\r		[:element <E> |\r		| rel <RE> |\r		rel:: element.\r		current isNil\r			ifTrue: [ current:: rel ]\r			ifFalse: [ current:: reduceFn value: current value: rel ]	].\r	^current isNil\r		ifFalse: [ current ]\r		ifTrue: [ onEmpty value ]\r)",
 "public reject: predicate <[:E | Boolean]> ^<List[E]> = (\r	^self select: [:e | (predicate value: e) not ]\r)",
 "public select: predicate <[:E | Boolean]> ^<List[E]> = (\r	| result <MutableArrayList[E]> |\r	result:: self newForCollectUsingAdd: size.\r	self do: [:element | (predicate value: element) ifTrue: [result add: element]].\r	^result\r)",
 "public size ^<Integer> = (\r	| count ::= 0. |\r	self do: [:element <E> | count:: count + 1 ].\r	^count\r)",
 "public species ^<Collection[E] class> = (\r	^Set\r)",
 "public union: other <Collection[Object]> ^ <Set[Object]> = (\r	^self asSet addAll: other; yourself\r)",
 "public value = (\r	#BOGUS. (* Questionable *)\r	^self\r)",
 "class HashedCollection new: cap = Collection (|\r	protected table_0 <Array[A|Object]>\r			(* The table holds either included entries, or an object indicating a deleted entry,\r			which is currently the table itself.  This of course means that the table is not allowed\r			as a valid element of the collection, but this is only an issue when writing reflective\r			system code that violates encapsulation. *)\r	protected size_0 <Integer>\r			(* the number of collection elements (not the size of the table) *)\r	protected deleted <Integer>\r			(* the number of slots marked with the deletion placeholder *)\r|initCapacity: cap)",
 "Collection",
 "Collection",
 "public add: val <A> ^<A> = (\r	^include: val\r)",
 "public addAll: c <Collection[A]> ^<Collection[A]> = (\r	c do: [:e <A> |\r		add: e. ].\r	^c\r)",
 "advanceAmount ^<Int> = (\r	(* a large prime - 1 *)\r		^99990\r)",
 "public at: key <K> ^<E> = (\r	^at: key ifAbsent: [ Error signal: 'key not found' ]\r)",
 "public at: key <Object> ifAbsent: f <[X def]> ^<E|X> = (\r	^elementFor:\r			(valAt: key ifAbsent: [ ^f value ])\r)",
 "atIndex: i <Int>\rinTable: tbl <Array[Object|A]>\roccupiedSlotDo: occupied <[:A| X def]>\remptySlotDo: empty <[Y def]>\rdeletedSlotDo: deleted <[Z def]>\r^<X|Y|Z> = (\r	(* This is the core method that does the case analysis for a slot to\r		determine whether it is occupied, deleted, or empty *)\r\r	| el <A|Object> |\r	el:: tbl at: i.\r	el == nil\r		ifTrue: [ ^empty value ].\r	el == tbl\r		ifTrue: [ ^deleted value ].\r\r	(* The following guarantee is because the table uses a non-typesafe trick in\r	  which the table pointer itself is used to indicate a deleted slot; thus the table\r	  doesn't hold only values of type A.  The guarantee is safe because we know that\r	  we only put either values or the table into the table, and the previous\r	  statement already handled the case when el is the table pointer-\r	  thus at this point by elimination el has to be a value of type A *)\r	^occupied value: (* (guaranteed <A> *)el(* ) *)\r)",
 "buildValForKey: k <K> element: el <E> ^<A> = (\r	(* construct an A from a K and an E *)\r	subclassResponsibility\r)",
 "checkValidity = (\r	(* This method performs various validity checks on the receiver *)\r\r	| c <Int> |\r	c:: 0.\r	contentsDo:\r		[:val <A> |\r			assert: [ (at: (keyFor: val)) = (elementFor: val) ] message: ''.\r			c:: c + 1.		].\r\r	assert: [ c = size ] message: ''.\r)",
 "public contentsDo: f <[:A]> = (\r	| tbl <Array[A|Object]> |\r	#ACCESSBOGUS.\r	tbl:: table.\r	tbl == nil\r		ifTrue: [ ^self ].\r\r	1 to: tbl size do:\r		[:index <Int> |\r				atIndex: index\r					inTable: tbl\r					occupiedSlotDo:\r						[:val <A> |\r							f value: val	]\r					emptySlotDo: [ ]\r					deletedSlotDo: [ ]\r		]\r)",
 "createFirstTable = (\r	table:: newTableWithSize: firstTableSize.\r)",
 "public do: f <[:E]> = (\r	contentsDo:\r		[:val <A> |\r			f value: (elementFor: val)		]\r)",
 "elementFor: val <A> ^<E> = (\r	(* extract an E from an A *)\r	subclassResponsibility\r)",
 "elementForCopy: el <A> ^<A> = (\r	(* When a copy of the collection is made, this method implements what happens\r	  to each element.  For example, MutableHashedMaps copy their elements, since the\r	  associations are really part of the MutableHashedMap, whereas KeyedSets don't since the\r	  associations are really elements of the collection. *)\r\r	subclassResponsibility\r)",
 "firstTableSize ^<Integer> = (\r	(* The size used for the table when the capacity is 0 and the first element is added *)\r\r	^8\r)",
 "growIfNeeded = (\r	(minTableSizeForCapacity: occupied) > table size\r		ifTrue: [ growTable ]\r)",
 "growTable = (\r	| new <Array[A|Object]> |\r	new:: newTableWithSize: table size + table size.\r	contentsDo:\r		[:a_value <A> |\r				lookup: (keyFor: a_value)\r					inTable: new\r					matchingSlotDo:\r						[:index <Int> :val <A> |\r							shouldNotHappen	]\r					emptySlotDo:\r						[:index <Int> |\r							new at: index put: a_value	]\r					deletedSlotsDo:\r						[:index <Int> |\r							shouldNotHappen ]\r					mismatchingSlotsDo:\r						[:index <Int> | (* ignore *) ]\r		].\r	deleted: 0.\r	table: new.\r)",
 "hashFor: key <Object> ^<Int> = (\r	(* return the appropriate hash value for a key *)\r	subclassResponsibility\r)",
 "public include: val <A> ^<A> = (\r	^include: val ifNew: []\r)",
 "public include: val <A> ifNew: ifNew <[]> ^<A> = (\r	^tableAt: (keyFor: val) put: (elementFor: val) ifNew: ifNew\r)",
 "public includeAll: c <Collection[A]> ^<Collection[A]> = (\r	c do: [:el <A> |\r		include: el ].\r	^c\r)",
 "public includesIndex: k <Object> ^<Boolean> = (\r	valAt: k ifAbsent: [ ^false ].\r	^true\r)",
 "public includesKey: k <Object> ^<Boolean> = (\r	^includesIndex: k\r)",
 "public indexOf: el <Object> ^<K> = (\r	^indexOf: el\r			ifAbsent: [ error: 'Element not found' ]\r)",
 "public indexOf: el <Object> ifAbsent: blk <[X def]> ^<K | X> = (\r	contentsDo:\r		[:v <A> |\r			(elementFor: v) = el\r				ifTrue: [ ^keyFor: v ] ].\r	^blk value\r)",
 "indexOf: key <Object> tableMask: mask <Int> ^<Int> = (\r	^((hashFor: key) bitAnd: mask) + 1\r)",
 "initCapacity: cap <Int> = (\r	size: 0.\r	deleted: 0.\r	cap > 0\r		ifTrue: [ table:: newTableWithSize: (tableSizeForCapacity: cap). ].\r)",
 "key: key1 <Object> matches: key2 <Object> ^<Boolean> = (\r	(* Test whether two keys match *)\r	self subclassResponsibility\r)",
 "public keyAtValue: v <Object> ^<K> = (\r	^indexOf: v\r)",
 "public keyAtValue: v <Object> ifAbsent: blk <[X def]> ^<K | X> = (\r	^indexOf: v ifAbsent: blk\r)",
 "keyFor: val <A> ^<K> = (\r	(* extract an K from an A *)\r	subclassResponsibility\r)",
 "public keysDo: f <[:K]> = (\r	contentsDo:\r		[:val <A> |\r			f value: (keyFor: val)		]\r)",
 "lookup: key <Object>\rinTable: tbl <Array[Object|A]>\rmatchingSlotDo: matching <[:Int:A| X def]>\remptySlotDo: empty <[:Int | Y def]>\rdeletedSlotsDo: marked <[:Int]>\rmismatchingSlotsDo: mismatch <[:Int]>\r^<X|Y> = (\r	(* This is the core method that looks for a slot suitable for the key,\r		and evaluates the appropriate blocks.\r	   The lookup process is iterative, terminating when a slot that is empty\r	   or has a matching key is found *)\r\r	| i <Int> mask <Int> |\r	mask:: tbl size - 1.\r	i:: indexOf: key tableMask: mask.\r	[ 			atIndex: i\r				inTable: tbl\r				occupiedSlotDo:\r					[:val <A> |\r						(key: key matches: (keyFor: val))\r							ifTrue: [ ^matching value: i value: val	 ]\r							ifFalse: [ mismatch value: i	 ]\r					]\r				emptySlotDo:\r					[ ^empty value: i ]\r				deletedSlotDo:\r					[ marked value: i	 ].\r		i:: ((i + advanceAmount) bitAnd: mask) + 1.\r	] repeat\r)",
 "lookup: key <Object>\rmatchingSlotDo: matching <[:Integer:A| X def]>\remptySlotDo: empty <[:Integer | Y def]>\rdeletedSlotsDo: marked <[:Integer]>\r^<X|Y> = (\r	^self		lookup: key\r				inTable: self table\r				matchingSlotDo: matching\r				emptySlotDo: empty\r				deletedSlotsDo: marked\r				mismatchingSlotsDo: [:index <Integer> | (* ignore *) ]\r)",
 "markDeleted: index <Int> = (\r	| tbl <Array[A|Object]> |\r	tbl:: table.\r	tbl at: index put: tbl.\r	deleted: deleted + 1\r)",
 "minTableSize ^<Int> = (\r	^4\r)",
 "minTableSizeForCapacity: cap <Integer> ^<Integer> = (\r	(* max density is 50% full *)\r	^cap + cap\r)",
 "newTableWithSize: tableSize <Int> ^<Array[A|Object]> = (\r	^Array new: tableSize\r)",
 "objToIncludeFor: new <A> withExisting: other <A> ^<A> = (\r	(* In the situation where a new value  is being 'include'ed in the collection, and there is already an existing\r	 value with a matching key, this method determines what value is actually placed in the collection *)\r\r	subclassResponsibility\r)",
 "occupied ^<Integer> = (\r	^size + deleted\r)",
 "postCopy = (\r	| tbl <Array[A|Object]> newtbl <Array[A|Object]> |\r\r	super postCopy.\r	tbl:: table.\r	tbl == nil\r		ifTrue: [ ^self ].\r\r	newtbl:: newTableWithSize: tbl size.\r	1 to: tbl size do:\r		[:index <Int> |\r			atIndex: index\r					inTable: tbl\r					occupiedSlotDo:\r						[:val <A> |\r							newtbl at: index put: (elementForCopy: val)	]\r					emptySlotDo: [ ]\r					deletedSlotDo:\r						[ newtbl at: index put: newtbl		]\r		].\r	setTable: newtbl\r)",
 "printElementsDo: f <[:Object]> = (\r	contentsDo: f\r)",
 "public remove: val <A> ^<A> = (\r	^remove: val ifAbsent: [ error: 'value not in collection' ]\r)",
 "public remove: val <A> ifAbsent: f <[X def]> ^<A|X> = (\r	removeKey: (keyFor: val) ifAbsent: f.\r	^val\r)",
 "public removeAll: c <Collection[A]> ^<Collection[A]> = (\r	c do: [:el <A> |\r		remove: el ].\r	^c\r)",
 "public removeAllSuchThat: test <[:A | Boolean]> = (\r	copy contentsDo:\r		[:el <A> |\r			(test value: el)\r				ifTrue: [ remove: el ]		]\r)",
 "public removeAt: k <K> ^<E> = (\r	(* A synonym for #removeKey: for consistency with AddableList *)\r\r	^removeKey: k\r)",
 "public removeAt: k <K> ifAbsent: f <[X def]> ^<E|X> = (\r	(* A synonym for #removeKey:ifAbsent: for consistency with AddableList *)\r\r	^removeKey: k ifAbsent: f\r)",
 "public removeEvery: val <A> ^<A> = (\r	remove: val ifAbsent: [].\r	^val\r)",
 "public removeKey: key <K> ^<E> = (\r	^removeKey: key ifAbsent: [ error: 'key not found' ]\r)",
 "public removeKey: key <K> ifAbsent: f <[X def]> ^<E|X> = (\r	table == nil\r		ifTrue: [ ^f value	 ].\r	^			lookup: key\r				matchingSlotDo:\r						[:index <Int> :val <A> |\r							markDeleted: index.\r							size: size - 1.\r							elementFor: val		]\r				emptySlotDo:\r						[:index <Int> |\r							f value	]\r				deletedSlotsDo:\r						[:index <Int> |\r							(* ignore *)\r						]\r)",
 "setTable: t <Array[A|Object]> = (\r	table_0:: t.\r)",
 "public size ^<Int> = (\r	^size_0\r)",
 "size: s <Int> = (\r	size_0:: s\r)",
 "table = (\r	^table_0\r)",
 "table: t <Array[A|Object]> = (\r	setTable: t.\r	assert: [deleted = 0] message: ''.\r)",
 "tableAt: key <K> put: el <E> ifNew: onNew <[]> ^<A> = (\r	(* put a value for el in the right spot in the table, and return the val *)\r\r	| reusableSlot <Integer> |\r	table == nil\r		ifTrue: [ self createFirstTable.	 ].\r	^			lookup: key\r				matchingSlotDo:\r						[:index <Integer> :val <A> |\r							self tableAt: key put: el inMatchingSlot: index value: val		]\r				emptySlotDo:\r						[:index <Integer> |\r							| newVal <A> |\r							reusableSlot == nil\r								ifTrue: [ newVal:: self tableAt: key put: el inEmptySlot: index ]\r								ifFalse: [ newVal:: self tableAt: key put: el inDeletedSlot: reusableSlot ].\r							onNew value.\r							newVal	]\r				deletedSlotsDo:\r						[:index <Integer> |\r							reusableSlot == nil\r								ifTrue: [ reusableSlot:: index ].\r						]\r)",
 "tableAt: key <K>\rput: el <E>\rinDeletedSlot: index <Integer>\r^<A> = (\r	| val <A> |\r	val:: tableAt: key put: el inUnusedSlot: index.\r	deleted: deleted - 1.\r	(* we don't have to check for growth when reusing a previously used slot *)\r	^val\r)",
 "tableAt: key <K>\rput: el <E>\rinEmptySlot: index <Integer>\r^<A> = (\r	| val <A> |\r	val:: tableAt: key put: el inUnusedSlot: index.\r	growIfNeeded.\r	^val\r)",
 "tableAt: key <K>\rput: el <E>\rinMatchingSlot: index <Integer>\rvalue: val <A>\r^<A> = (\r	| newVal <A> |\r	newVal:: objToIncludeFor: (buildValForKey: key element: el)\r								withExisting: val.\r	table at: index put: newVal.\r	^newVal\r)",
 "tableAt: key <K>\rput: el <E>\rinUnusedSlot: index <Integer>\r^<A> = (\r	(* This does the core work for #tableAt:put: [inDeletedSlot:|inEmptySlot:] *)\r\r	| newVal <A> |\r	newVal:: buildValForKey: key element: el.\r	table at: index put: newVal.\r	size: size + 1.\r	^newVal\r)",
 "tableSizeForCapacity: cap <Integer> ^<Integer> = (\r	| min <Integer> tsize <Integer> |\r	min:: minTableSizeForCapacity: cap.\r	(* search for the smallest power of two that is >= min *)\r	tsize:: minTableSize.\r	[ tsize < min ]\r	      whileTrue: [ tsize:: tsize + tsize ].\r	^tsize\r)",
 "valAt: key <Object> ifAbsent: f <[X def]> ^<A|X> = (\r	table == nil\r		ifTrue: [ ^f value ].\r\r	^			lookup: key\r				matchingSlotDo:\r					[:index <Integer> :val <A> |\r						val	]\r				emptySlotDo:\r					[:index <Integer> |\r						f value	]\r				deletedSlotsDo:\r					[:index <Integer> |\r						(* ignore deleted slots *) ]\r)",
 "public defaultCapacity ^<Integer> = (\r	^0\r)",
 "class IdentityMutableHashedMap new: cap = MutableHashedMap new: cap (\r(* IdentityMutableHashedMaps are efficient HashedCollections that let you dynamically associate key->value\rpairs,  where the keys are matched using the #== message. *)\r)",
 "new: cap",
 "new: cap",
 "hashFor: key <Object> ^<Int> = (\r	^key identityHash\r)",
 "key: k <Object> matches: another <Object> ^<Boolean> = (\r	^k == another\r)",
 "public defaultCapacity ^<Int> = (\r	^0\r)",
 "public new = (\r	^new: defaultCapacity\r)",
 "public class IdentitySet new: cap <Integer> = Set new: cap ()",
 "new: cap",
 "new: cap",
 "hashFor: key <Object> ^<Int> = (\r		^key identityHash\r)",
 "key: k <Object> matches: another <Object> ^<Boolean> = (\r	^k == another\r)",
 "public defaultCapacity = (\r	^0\r)",
 "public new ^ <Instance> = (\r	^self new: defaultCapacity\r)",
 "public withAll: cltn <Collection[A]> ^<Instance> = (\r	^(new: cltn size) includeAll: cltn; yourself\r)",
 "public class Interval from: p_start <Number> to: p_stop <Number> by: p_step <Number> = AbstractList (\r(* Intervals are Lists that generate their contents on the fly as a progression\rof numbers from a start number to a stop number, separated by a step number.  Usually, the\rto: [by:]do: messages defined in the Number subclasses are used instead of Intervals\rwhen just a control structure is needed, since they are much faster.\r\rNote on strong typing issues:\r\rThe to: [by:]do: messages in the Number hierarchy are typed restrictively, in such a way that they\rcan only be used in non-coercive situations (i.e. where the start, stop, and step are all integers,\ror all floats, etc.).  This is done to preserve the type of the iteration value passed to the iteration block\rin the pure integer form, so that bit operations etc. can be performed etc.  This would not be possible\rif Number was the type for the step.  Although this may seem restrictive, the following points should\rbe noted about this design:\r\r	1) explicit coercions handle the vast majority of these cases;\r		for example, use (j asFloat to: k asFloat by: 0.1) rather than\r		 (j to: k by: 0.1) when j and k are typed as Numbers or Integers.\r	2) this scheme is perfectly compatible with untyped code, since the typed versions will work correctly\r	    even if called with arguments of mismatched numeric types, so that things like (1 to: 10 by: 0.1) will\r	    work, even though they don't typecheck.\r	3) If full coercive generality is needed in typesafe code, the Interval class can be used, which has been\r	    designed using values of type Number, so that things like (1 to: 10 by: 0.1) are ok.  They cannot, however,\r		preserve more detailed information about the kinds of numbers in the Interval. *)\r|\r	public start <Number> = p_start.\r	public stop <Number> = p_stop.\r	public increment <Number> = p_step.\r|)",
 "AbstractList",
 "AbstractList",
 "public at: index <Integer> ^<Number> = (\r	(start - stop) sign = increment sign\r		ifFalse: [ | value <Number> |\r						value: start + (increment * (index - 1)).\r						increment >= 0\r							ifTrue: [ ( value between: start and: stop)\r												ifTrue: [ ^value ]	]\r							ifFalse: [ (value between: stop and: start)\r												ifTrue: [ ^value ]	]	].\r	Error signal: 'Index out-of-range'.\r)",
 "copyWithSize: s <Int> ^<MutableList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r	self unimplemented\r)",
 "public do: action <[:Number]> = (\r	|\r	value <Number> ::= self start.\r	incr <Number> = self increment.\r	stp <Number> = self stop.\r	|\r	incr >= 0\r		ifTrue: [ [ value <= stp ]\r							whileTrue: [ action value: value.\r										value:: value + incr.	]	]\r		ifFalse: [ [ value >= stp ]\r							whileTrue: [ action value: value.\r										value:: value + incr.	]	]\r)",
 "public size ^<Integer> = (\r	^((stop - start) // increment) + 1 max: 0\r)",
 "public from: start <Number> to: stop <Number> ^<Instance> = (\r	^self from: start to: stop by: 1\r)",
 "class MutableArrayList = MutableAddableList (\r(* MutableArrayLists are AddableLists that also support setting\relements in place (the MutableList protocol). *)\r)",
 "MutableAddableList",
 "MutableAddableList",
 "public add: e <E> ^<E> = (\r	^addLast: e\r)",
 "public add: el <E> after: existing <E> ^<E> = (\r	| index <Int> |\r	index:: indexOf: existing.\r	index = size\r		ifFalse: [ index:: makeSpace: 1\r							beforeIndex: index + startGap + 1 ]\r		ifTrue: [ needSpaceAtEnd: 1.\r						index:: index + startGap + 1.	].\r	^contents at: index put: el.\r)",
 "public add: el <E> afterIndex: i <Int> ^<E> = (\r	^add: el beforeIndex: i + 1\r)",
 "public add: el <E> before: existing <E> ^<E> = (\r	| index <Int> |\r	index:: indexOf: existing.\r	index:: makeSpace: 1 beforeIndex: index + startGap.\r	^contents at: index put: el.\r)",
 "public add: el <E> beforeIndex: i <Int> ^<E> = (\r	| index <Int> |\r	i > size\r		ifFalse: [ index:: makeSpace: 1 beforeIndex: i + startGap]\r		ifTrue: [ needSpaceAtEnd: 1.\r					index:: i + startGap. ].\r	^contents at: index put: el.\r)",
 "public addAllFirst: c <Collection[E]> ^<Collection[E]> = (\r	c do: [:el <E> | 	addFirst: el ].\r	^c\r)",
 "public addAllLast: c <Collection[E]> ^<Collection[E]> = (\r	c do: [:el <E> | 	addLast: el ].\r	^c\r)",
 "public addFirst: e <E> ^<E> = (\r	needSpaceAtStart: 1.\r	contents at: startGap put: e.\r	startGap: startGap - 1.\r	^e\r)",
 "public addLast: e <E> ^<E> = (\r	needSpaceAtEnd: 1.\r	lastIndex: lastIndex + 1.\r	contents at: lastIndex put: e.\r	^e\r)",
 "public asMutableArrayList ^<MutableArrayList[EX]> = (\r		(* {where EX is returnType of #anElement message of receiverType} *)\r\r	(* the guarantee is safe because of the inference clause *)\r	^(* guaranteed <MutableArrayList[EX]> *) self\r)",
 "public at: i <Int> put: el <E> ^<E> = (\r	| adjusted <Int> |\r	adjusted:: i + startGap.\r	((0 < i) and: [adjusted <= lastIndex])\r		ifFalse: [ error: 'invalid index' ].\r	^contents at: adjusted put: el\r)",
 "public collect: map <[:E | R def]> ^<MutableArrayList[R]> = (\r	^(collectUsingAdd: map) asMutableArrayList\r)",
 "public copyWithSize: s <Int> ^<MutableArrayList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r\r	(* Note: this method temporarily mutates the receiver, so it should not be sent to an object that\r		another process might be accessing. *)\r\r	(* We use a trick here: we temporarily fudge the lastIndex to be the value we want to use in the copy,\r	  which will cause postCopy to copy the contents with a different size, and then we restore the old\r	  lastIndex value for this instance.  This lets the normal copy mechanism handle subclass instance\r	  variable copying. *)\r	| oldLastIndex <Int> safeself <MutableArrayList[EX]> copy <MutableArrayList[EX]> |\r\r	(* This guarantee is safe because the inference clause guarantees\r		that E < EX at each call site *)\r	safeself:: (* guaranteed <MutableArrayList[EX]> *) self.\r\r	oldLastIndex:: lastIndex.\r	lastIndex: s + startGap.\r	copy:: safeself copy.\r	lastIndex: oldLastIndex.\r\r	^copy\r)",
 "public newCopyOfSize: size <Int>\rthatCanAlsoHoldElementsOf: other <List[X]>\r^<MutableArrayList[EX | X]> = (\r		(* {where X is returnType of #anElement message of arg 2;\r		     where EX is returnType of #anElement message of receiverType} *)\r\r	^(MutableArrayList(* [EX | X] *) new: size) size: size\r)",
 "public replaceFrom: start <Int>\rto: stop <Int>\rwith: other <List[E]>\rstartingAt: repStart <Int> = (\r	(* replace the elements of the receiver from start to stop with elements from other,\r	  starting with the element of other with index repStart. *)\r\r	| otheri <Int> |\r	(start >= 1 and: [ stop <= size ])\r		ifFalse: [ error: 'range out of bounds' ].\r\r	contents replaceFrom: start + startGap to: stop + startGap with: other startingAt: repStart\r)",
 "public defaultCapacity ^<Int> = (\r	^5\r)",
 "public new: capacity <Int> ^<Instance> = (\r	^new initCapacity: capacity\r)",
 "public with: val1 <E> ^<Instance> = (\r	^(new: 1) add: val1; yourself\r)",
 "public withAll: cltn <Collection[E]> ^<Instance> = (\r	^(new: cltn size) addAll: cltn; yourself\r)",
 "class MutableHashedMap new: cap = HashedCollection new: cap (\r(* MutableHashMaps are efficient HashedCollections that let you dynamically associate key->value\rpairs,  where the keys are matched using the #= message.  Equal keys must have equal #hash\rvalues. *)\r)",
 "new: cap",
 "new: cap",
 "public = other <Object> ^<Boolean> = (\r	^super = other and: [\r		self == other or: [\r			(* We already know that the other object must be a MutableHashedMap *)\r			self keys = other keys	]]\r)",
 "associationAt: key <K> ^<Assoc[K,E]> = (\r	^associationAt: key ifAbsent: [ error: 'key not found' ]\r)",
 "associationAt: key <K> ifAbsent: failBlock <[X def]> ^<Assoc[K,E] | X> = (\r	^valAt: key ifAbsent: failBlock\r)",
 "associations ^<MutableArrayList[Assoc[K,E]]> = (\r	| oc <MutableArrayList[Assoc[K,E]]> |\r\r	oc:: MutableArrayList new: size.\r	associationsDo:\r		[:assoc <Assoc[K,E]> |\r			oc add: assoc	].\r	^oc\r)",
 "associationsDo: f <[:Assoc[K,E]]> = (\r	contentsDo:\r		[:assoc <Assoc[K,E]> |\r			f value: assoc ]\r)",
 "public at: key <K> ifAbsentPut: ablk <[V]> ^<V> = (\r	^self at: key ifPresent: [:e | e] ifAbsentPut: ablk\r)",
 "public at: key <K> ifPresent: pblk <[:E]> ifAbsentPut: ablk <[E]> ^<E> = (\r	(* This is a method that is useful in the common case when you want\r		to find out if a key is present, and if it isn't, put an entry in for it.\r		It is much faster than a construct like (hc at: k ifAbsent: [ hc at: k put: e ])\r		for the case when a new entry must be added.\r		If the key is present, pblk is evaluated with the associated element.\r		If it is absent, then ablk is evaluated, and the value that it returns\r		is associated with k in the receiver.  In either case, the associated element\r		is returned. *)\r\r	| reusableSlot <Int> |\r	#BOGUS. (* Remove this method. *)\r	table == nil\r		ifTrue: [ createFirstTable.	 ].\r	^lookup: key\r				matchingSlotDo:\r						[:index <Int> :assoc <VarAssoc[K,E]> |\r							| el <E> |\r							el:: assoc value.\r							pblk value: el.\r							el		]\r				emptySlotDo:\r						[:index <Int> |\r							| newEl <E> |\r							newEl:: ablk value.\r							reusableSlot == nil\r								ifTrue: [ tableAt: key put: newEl inEmptySlot: index ]\r								ifFalse: [ tableAt: key put: newEl inDeletedSlot: reusableSlot ].\r							newEl	]\r				deletedSlotsDo:\r						[:index <Int> |\r							reusableSlot == nil\r								ifTrue: [ reusableSlot:: index ].\r						]\r)",
 "public at: key <K> put: el <E> ^<E> = (\r	^at: key put: el ifNew: []\r)",
 "protected at: key <K> put: el <E> ifNew: blk <[]> ^<E> = (\r	#BOGUS. (* Remove this method. *)\r	tableAt: key put: el ifNew: blk.\r	^el\r)",
 "protected buildValForKey: k <K> element: el <E> ^<VarAssoc[K,E]> = (\r	^Association key: k value: el\r)",
 "protected elementFor: assoc <Assoc[K,E]> ^<E> = (\r	^assoc value\r)",
 "protected elementForCopy: el <VarAssoc[K,E]> ^<VarAssoc[K,E]> = (\r	^el copy\r)",
 "protected hashFor: key <Object> ^<Int> = (\r	^key hash\r)",
 "public includesAssociation: assoc <Assoc[K,Object]> ^<Boolean> = (\r	^(at: assoc key ifAbsent: [ ^false ]) = assoc value\r)",
 "public isDictionary ^<Boolean> = (\r	^true\r)",
 "public isKindOfMap ^<Boolean> = (\r	^true\r)",
 "protected key: k <Object> matches: another <Object> ^<Boolean> = (\r	^k = another\r)",
 "protected keyFor: assoc <Association[K, V]> ^<K> = (\r	^assoc key\r)",
 "public keys ^<Set[K]> = (\r	| s <Set[K]> |\r	s:: Set new: size.\r	self keysDo: [:key <K> | s include: key ].\r	^s\r)",
 "public keysAndValuesDo: action <[:K :V]> = (\r	self contentsDo:\r		[:assoc <Association[K, V]> | action value: assoc key value: assoc value ]\r)",
 "protected objToIncludeFor: newAssoc <VarAssoc[K,E]> withExisting: assoc <VarAssoc[K,E]> ^<VarAssoc[K,E]> = (\r	(* MutableHashMaps reuse the previous association *)\r	assoc value: newAssoc value.\r	^assoc\r)",
 "protected tableAt: key <K>\rput: el <E>\rinMatchingSlot: index <Int>\rvalue: val <VarAssoc[K,E]>\r^<VarAssoc[K,E]> = (\r	val value: el.\r	^val\r)",
 "public values ^<MutableArrayList[V]> = (\r	^self inject: (MutableArrayList new: size) into:\r		[:oc <MutableArrayList[V]> :el <V> |\r			oc add: el; yourself ]\r)",
 "public defaultCapacity ^<Integer> = (\r	^0\r)",
 "public new = (\r	^self new: defaultCapacity\r)",
 "public with: val1 <A> ^<Instance> = (\r	^(self new: 1) include: val1; yourself\r)",
 "public withAll: cltn <Collection[A]> ^<Instance> = (\r	^(self new: cltn size) includeAll: cltn; yourself\r)",
 "class MutableList = AbstractList (\r(* This class extends List[E] with mutation operations defined in terms of #at:put:.\rThe List[E] protocol is defined from this class' interface. *)\r)",
 "AbstractList",
 "AbstractList",
 "public at: index <Int> put: el <E> ^<E> = (\r	self subclassResponsibility\r)",
 "defaultMedianOf: a <Int> and: b <Int> and: c <Int> ^<Int> = (\r	(* This is an untypesafe method that only works for MutableLists of elements that\r		have Magnitude relationships with each other.  It is used by the default sorting\r		method. *)\r\r	| atA <E> atB <E> atC <E> |\r	atA:: at: a.\r	atB:: at: b.\r	atC:: at: c.\r	^atB <= atA\r		ifFalse: [ atC <= atB\r							ifFalse: [ b ]\r							ifTrue: [ atC <= atA\r												ifFalse: [ c ]\r												ifTrue: [ a ] 	] ]\r		ifTrue: [ atB <= atC\r							ifFalse: [ b ]\r							ifTrue: [ atA <= atC\r												ifFalse: [ c ]\r												ifTrue: [ a ] 	] ]\r)",
 "defaultSort: l <Int> to: r <Int> = (\r	(* This is an untypesafe method that only works for MutableLists of elements that\r		have Magnitude relationships with each other *)\r\r	| i <Int> j <Int> x <E> m <Int> n <Int> |\r	i:: l.\r	j:: r.\r	n:: ((r - l) + 1).\r	n == 0\r		ifTrue: [ ^self ].\r\r	(* Pick the partition value.  For <=7 elements, use the middle element.\r		For more than 7 but <= 40, use a median of three elements.  For > 40,\r		use a median of three medians of three *)\r	m:: (l + r) // 2.\r	n > 7\r		ifTrue: [ | pl <Int> pn <Int> s <Int> |\r						pl:: l.\r						pn:: r.\r						n > 40\r							ifTrue: [ s:: n // 8.\r											pl:: defaultMedianOf: pl and: pl+s and: pl+s+s.\r											m:: defaultMedianOf: m-s and: m and: m+s.\r											pn:: defaultMedianOf: (pn-s)-s and: pn-s and: pn.	].\r						m:: defaultMedianOf: pl and: m and: pn.		].\r	x:: at: m.\r\r	[i <= j]\r		whileTrue:\r			[ | ati <E> atj <E> |\r			 	[ x <= (ati:: at: i)]\r					whileFalse: [i:: i + 1].\r				[(atj:: at: j) <= x]\r					whileFalse: [j:: j - 1].\r				i <= j\r					ifTrue: [ at: i put: atj.\r									at: j put: ati.\r									i:: i + 1.\r									j:: j - 1]\r			].\r	l < j ifTrue: [defaultSort: l to: j ].\r	i < r ifTrue: [defaultSort: i to: r ].\r)",
 "medianOf: a <Int> and: b <Int> and: c <Int> using: compare <[:E:E| Boolean]> ^<Int> = (\r	| atA <E> atB <E> atC <E> |\r	atA:: at: a.\r	atB:: at: b.\r	atC:: at: c.\r	^(compare value: atB value: atA)\r		ifFalse: [ (compare value: atC value: atB)\r							ifFalse: [ b ]\r							ifTrue: [ (compare value: atC value: atA)\r												ifFalse: [ c ]\r												ifTrue: [ a ] 	] ]\r		ifTrue: [ (compare value: atB value: atC)\r							ifFalse: [ b ]\r							ifTrue: [ (compare value: atA value: atC)\r												ifFalse: [ c ]\r												ifTrue: [ a ] 	] ]\r)",
 "readWriteStream ^<ReadWriteStream[E]> = (\r	^ListReadWriteStream on: self\r)",
 "public replaceFrom: start <Int>\rto: stop <Int>\rwith: other <List[E]> = (\r	(* replace the elements of the receiver from start to stop with elements from other,\r	  starting with the first element of other. *)\r\r	^replaceFrom: start to: stop with: other startingAt: 1\r)",
 "public replaceFrom: start <Int>\rto: stop <Int>\rwith: other <List[E]>\rstartingAt: repStart <Int> = (\r	(* replace the elements of the receiver from start to stop with elements from other,\r	  starting with the element of other with index repStart. *)\r\r	| otheri <Int> |\r\r	repStart < start\r		ifFalse: [ otheri:: repStart.\r				  start to: stop do:\r					[:i <Int> |\r						at: i put: (other at: otheri).\r						otheri:: otheri + 1.	]]\r		ifTrue: [ otheri:: repStart + (stop - start).\r				stop to: start by: -1 do:\r					[:i <Int> |\r						at: i put: (other at: otheri).\r						otheri:: otheri - 1.	]]\r)",
 "swap: i <Int> with: j <Int> = (\r	| t <E> |\r	t:: at: i.\r	at: i put: (at: j).\r	at: j put: t.\r)",
 "writeStream ^<WriteStream[E]> = (\r	^readWriteStream\r)",
 "public class Set new: cap = HashedCollection new: cap ()",
 "new: cap",
 "new: cap",
 "public asSet ^<Extensible[EX]> = (\r		(* {where EX is returnType of #anElement message of receiverType} *)\r\r	(* The guarantee is safe because of the inference clause *)\r	^(* guaranteed <Set[EX]> *) self\r)",
 "buildValForKey: key <Object> element: el <E> ^<E> = (\r	^el\r)",
 "elementFor: el <E> ^<E> = (\r	^el\r)",
 "elementForCopy: el <E> ^<E> = (\r	^el\r)",
 "public hasSameElementsAs: other <Collection[Object]> ^<Boolean> = (\r	(* A faster reimplementation of the inherited version, to speed up set comparisons *)\r\r	| otherSet <Extensible[Object]> |\r	size = other size\r		ifFalse: [ ^false ].\r	otherSet:: other asSet.\r	size = otherSet size\r		ifFalse: [ ^false ].\r	do:\r		[:el <Object> |\r			(otherSet includes: el)\r				ifFalse: [ ^false ] ].\r	^true\r)",
 "hashFor: key <Object> ^<Int> = (\r	^key hash\r)",
 "public includes: o <Object> ^<Boolean> = (\r	^includesKey: o\r)",
 "public isKindOfSet ^ <Boolean> = (\r	^true\r)",
 "key: k <Object> matches: another <Object> ^<Boolean> = (\r	^k = another\r)",
 "keyFor: e <E> ^<Object> = (\r	^e\r)",
 "objToIncludeFor: new <E> withExisting: other <E> ^<E> = (\r	^new\r)",
 "public defaultCapacity = (\r	^0\r)",
 "public new = (\r	^new: defaultCapacity\r)",
 "public with: val1 <A> ^<Instance> = (\r	^(new: 1) include: val1; yourself\r)",
 "public withAll: cltn <Collection[A]> ^<Instance> = (\r	^(new: cltn size) includeAll: cltn; yourself\r)",
 "public class SortedList = AddableList (\r	(* Sorted collections are addable collections that always keep their elements in sorted order.  The\r	sort order is determined by the sortPredicate, which is a function that compares 2 elements and\r	returns true if the first argument should be before the second argument in the collection.\r	The sortPredicate should be provided when the collection is created.\r\r	Unfortunately, Smalltalk defines SortedList as having a default sortPredicate that uses #<= to compare\r	elements.  This is NOT typesafe, since there are many kinds of objects that you might want to sort that don't support\r	the #<= operator; however, this feature is retained in Strongtalk for compatibility.   If you wish to write typesafe programs,\r	then SortedLists should always be given a sort block when they are created.  This involves using the creation\r	messages #new:sortBlock:, #sortBlock: and the Collection utility message #asSortedList: instead of #new:, #new,\r	and #asSortedList, respectively. *)\r|\r	private usesDefaultSortBlock_private <Boolean>\r	private sortBlock_private <[:E:E| Boolean]>\r|initCapacity: self class defaultCapacity.\r	sortBlock_private:: SortedList defaultSortBlock.\r	usesDefaultSortBlock_private:: true)",
 "AddableList",
 "AddableList",
 "public add: el <E> ^<E> = (\r	| index <Integer> |\r	index:: indexFor: el.\r	index > contents size\r		ifFalse: [ index:: makeSpace: 1 beforeIndex: index]\r		ifTrue: [ needSpaceAtEnd: 1.\r						lastIndex: lastIndex + 1. ].\r	^contents at: index put: el.\r)",
 "public addAll: els <Collection[E]> ^<Collection[E]> = (\r	els size > (size // 8) 		 (* %todo: do measurements to see if 8 is reasonable *)\r		ifTrue: [ 	needSpaceAtEnd: els size.\r				els do: [:el <E> |\r					lastIndex: lastIndex + 1.\r					contents at: lastIndex put: el.	].\r				sort.		]\r		ifFalse: [ els do: [:el <E> |\r					add: el	]].\r	^els\r)",
 "public asSortedList ^<List[Object]> = (\r	^self\r)",
 "indexFor: el <E> ^<Integer> = (\r	(* This returns an internal index such that if el was inserted before it\r	  the collection would remain sorted *)\r\r	^contents\r		binarySearchFor: el\r		between: startGap + 1\r		and: lastIndex\r		toCompare: sortBlock\r)",
 "public initCapacity: cap <Int> = (\r	super initCapacity: cap.\r)",
 "public isSorted ^<Boolean> = (\r	(* testing function used for sort routine validation *)\r\r	^isSortedBy: sortBlock\r)",
 "public sort = (\r	usesDefaultSortBlock\r		ifTrue: [ contents defaultSort: startGap + 1 to: lastIndex ]\r		ifFalse: [ 	contents sort: startGap + 1 to: lastIndex using: sortBlock ]\r)",
 "public sortBlock ^<[:E:E| Boolean]> = (\r	^sortBlock_private\r)",
 "public sortBlock: sortBy <[:E:E| Boolean]> = (\r	sortBlock_private:: sortBy.\r	usesDefaultSortBlock_private:: false.\r	isEmpty ifFalse: [ sort. ].\r)",
 "public usesDefaultSortBlock ^<Boolean> = (\r	^usesDefaultSortBlock_private\r)",
 "public defaultCapacity ^<Int> = (\r	^5\r)",
 "public defaultSortBlock ^<[:E:E| Boolean]> = (\r	^[:el1 <E> :el2 <E> |\r		(* The default sort block for SortedLists is is not typesafe, but is included for\r		 Smalltalk compatibility (that's the way Smalltalk is!). *)\r		(\r(* guaranteed <Magnitude[E]> *) el1) <= el2	].\r)",
 "public new: capacity <Integer> ^<Instance> = (\r	^new initCapacity: capacity\r)",
 "public new: capacity <Integer> sortBlock: sort <[:E :E | Boolean]> ^<Instance> = (\r	^(new: capacity) sortBlock: sort\r)",
 "public sortBlock: sort <[:E :E | Boolean]> ^<Instance> = (\r	^new: defaultCapacity sortBlock: sort\r)",
 "public with: val1 <E> ^<Instance> = (\r	^(new: 1) add: val1; yourself\r)",
 "public withAll: cltn <Collection[E]> ^<Instance> = (\r	^(new: cltn size) addAll: cltn; yourself\r)",
 "class MirrorsForV8 usingPlatform: p runtime: r vmMirror: vmm = (\r(* The reflection library for the Javascript-based implementation of Newspeak.\r\rCopyright Google Inc. 2014 - 2017\r*)\r|\rprivate List = p collections List.\rprivate Map = p collections Map.\rprivate Mixin = p kernel Mixin.\rprivate StringBuilder = p kernel StringBuilder.\rprivate ImmutableMirrorGroup = (r MirrorGroups usingLib: p) ImmutableMirrorGroup.\rprivate vmmirror = vmm.\r\rprivate parserLib = Future computing: [r CombinatorialParsing usingPlatform: p].\rprivate grammar = Future computing: [r NewspeakGrammar usingPlatform: p parsers: parserLib].\rprivate asts = Future computing: [r NewspeakASTs usingLib: p].\rprivate parsing = Future computing: [r NewspeakParsing usingPlatform: p grammar: grammar asts: asts].\rprivate generation = Future computing: [r JavascriptGeneration usingPlatform: p].\rprivate compilation = Future computing: [r Compilation usingPlatform: p asts: asts parsing: parsing generation: generation].\rprivate compiler = Future computing: [compilation Compiler new].\r|)",
 " ",
 " ",
 "classDeclIRFor: mixin within: enclosing = (\r	| source = 'Newspeak3 ''Uncategorized'' ', (ClassDeclarationMirror reflecting: mixin) source. |\r	(*('compiling class:', source) out.*)\r	^compiler compileClassSource: source within: enclosing\r)",
 "classMixinOf: m <InstanceMixin> ^ <ClassMixin> = (\r (* Sometimes we need to get the class side of a mixin. Since reflectee is not exposed by MixinMirror, we must rely\r	on knowledge of the runtime structure.\r *)\r	^Mixin fromRuntimeMixin: (js propertyOf: (js propertyOf: m at: (js literal: 'runtimeMixin')) at: (js literal: 'meta'))\r)",
 "private identityHashOf: object ^<Integer> = (\r	[(js propertyOf: object at: (js literal: 'hashCode')) = 0] whileTrue:\r		[js assign: (js propertyOf: object at: (js literal: 'hashCode')) toBe: (js verbatim: 'Math.random() * 0x3FFFFFF | 0')].\r	^(js propertyOf: object at: (js literal: 'hashCode'))\r)",
 "sourceForMethod: methodName <String> ofMixin: m <Mixin> ^ <String> = (\r	| js = generation factory. sourceIndex <Integer> |\r	sourceIndex:: sourceIndexForMethod: methodName ofMixin: m.\r	^js propertyOf: (js ident: 'sources') at: sourceIndex.\r)",
 "sourceIndexForMethod: methodName <String> ofMixin: m <Mixin> ^ <Integer> = (\r	| js = generation factory. methodMetadata |\r	methodMetadata:: (js propertyOf: m at: (js literal: 'methods')) select: [:e | (js propertyOf: e at: 'name') = methodName].\r	^js propertyOf: methodMetadata at: 'source'. (* compute the source index from the metadata *)\r)",
 "class AbstractClassHeaderMirror = (\r)",
 " ",
 " ",
 "public accessModifier = (\r(* Ths won't work for slots. So should we set this up explicitly and store the access? If we had the mangled name we could use that to decided; might be easier to keep mangled name and unmangle it on demand *)\r	(source startsWith: 'public ') ifTrue: [^#public].\r	(source startsWith: 'private ') ifTrue: [^#private].\r	^#protected\r)",
 "public classComment ^ <String> = (\r	^(compilation parser classHeader parseString: source) classComment\r)",
 "public source ^ <String> = (\r	subclassResponsibility\r)",
 "public class ClassDeclarationBuilder forExistingMixin: m <Mixin> within: enclosing <ClassDeclarationBuilder> = (\r(*\rA mutable description of a class, ready for installation. This class is the abstract superclass of two alternate\rimplementations: IRBasedClassDeclarationBuilder and MixinBasedClassDeclarationBuilder.\r\rThe former is created based upon the compiler's intermediate representation, and is useful when producing a\rcomplete class from source code.  The latter is created based upon an existing class declaration, specifically\rits mixin. This is much faster, as it does not require compilation to produce the builder. This is important\rsince some IDE presenters work off a builder, and requiring a complete compile may introduce a noticeable\rdelay (at least until the compiler gets a lot faster).\r\rSubclasses must implement a number of methods: computeInstanceSide, computeClassSide, name and declarationData.\rThe first two specify how the MixinBuilders that represent the two sides of the class are computed. The name\rcomputation also depends on the underlying structure.\r\rThe last subclass responsibility method, declarationData,\rspecifies how to compute other data representing the class under construction. These will differ depending\ron whether the initial input for the new class is an IR (obtained by compiling source code) or a mixin (obtained\rfrom an existing class in the runtime). The builders for the sides are stored in the instanceSide and classSide slots.\r\rIn all cases, the builder retains a copy of the existing mixin, if it exists. This the first formal parameter, m,\rwhich is saved in the slot prvtExistingMixin.\rIf the class is new, m is nil.\rIn addition, the builder expect another builder representing the enclosing class declaration. For top level classes\rthis is nil.\r\rThe remaining slots are reserved for future use to support deletion of members.\r\rInstallation is always based on recompiling the current (likely modified) version of the class from source.\rThis is because the compiled representation statically resolves the lexical level of a here send, and adding\ror removing members may impact that resolution within the class (including its nested classes).\r\rThe recompiled IR is installed, either by updating the existing mixin in the runtime, or by creating a new one,\rwhich is stored in prvtExistingMixin so that it becomes the \"existing mixin \" from that point on.\r\rStill lacking are facilities for correctly adding slots (and hence nested classes) and for delteions.\r*)\r|\rprvtExistingMixin <Mixin> ::= m.\rpublic enclosingClass <ClassDeclarationBuilder> = enclosing.\rprivate instanceSideSlot <MixinBuilder>\rprivate classSideSlot <MixinBuilder>\rdeletedInstanceMethods <List[Symbol]>\rdeletedClassMethods <List[Symbol]>\r|)",
 " ",
 " ",
 "public accessModifier = (\r	^declarationData accessModifier\r)",
 "public classSide ^ <MixinBuilder> = (\r	nil = classSideSlot ifTrue: [classSideSlot:: computeClassSide].\r	^classSideSlot\r)",
 "public computeClassDeclIR ^ <IntermediateClassDeclaration> = (\r(*  Compile latest source into an IR.  But this won't work for nested classes\r	| src = 'Newspeak3 ''Uncategorized'' ',  source. |\r	('compiling class:', src) out.*)\r\r	^nil = enclosingClass\r	  ifTrue: [\r		compiler compileClassSource: 'Newspeak3 ''Uncategorized'' ', source within: nil.\r		]\r	  ifFalse: [(* compiler compileClassSource: source within: enclosingClass.\r		Is enclosingClass the right kind of argument?\r		Can we make the compiler API more uniform so we can always just make this call?\r		This assumes we can dispense with compiling the entire module.\r		 *)\r		enclosingClass computeClassDeclIR instanceSide nestedClasses detect:\r		 [:ncd <IntermediateClassDeclaration> | ncd qualifiedName = qualifiedName]\r		]\r)",
 "computeClassSide ^ <MixinBuilder> = (\r	subclassResponsibility\r)",
 "computeInstanceSide ^ <MixinBuilder> = (\r	subclassResponsibility\r)",
 "declarationData = (\r	subclassResponsibility\r)",
 "public install ^<ClassDeclarationMirror> = (\r	| writer sb <StringBuilder> src <String> runtimeMixin <JRM> cdir <IntermediateClassDeclaration> |\r\r	writer:: generation Writer new.\r	sb:: StringBuilder new.\r	cdir:: computeClassDeclIR.\r	writer generateSourceFor: cdir runtimeMixin on: sb. (* compute up to date JS translation *)\r	src:: sb asString.\r	src out.\r	runtimeMixin:: js call: (js ident: 'eval') with: {src}. (* compute up to date runtime mixin *)\r	prvtExistingMixin isNil (* Update based on latest mixin *)\r		ifTrue: [\r			prvtExistingMixin:: Mixin fromRuntimeMixin: runtimeMixin.\r			updateSourceIndicesOfNewRuntimeMixin: runtimeMixin from: cdir.\r			(* this is where we should recompile the enclosing class*)\r			]\r		ifFalse: [updateMixinFrom: runtimeMixin with: cdir].\r	^ClassDeclarationMirror reflecting: prvtExistingMixin.\r)",
 "public instanceSide ^ <MixinBuilder> = (\r	nil = instanceSideSlot ifTrue: [instanceSideSlot:: computeInstanceSide].\r	^instanceSideSlot\r)",
 "public name ^<Symbol> = (\r	^subclassResponsibility\r)",
 "public qualifiedName = (\r	^declarationData qualifiedName\r)",
 "public simpleName ^<Symbol> = (\r	^name\r)",
 "public source ^<String> = (\r	| sb = StringBuilder new. |\r	sb add: header source.\r	sb writeln: ' ( '.\r	instanceSide nestedClasses do: [:ea <ClassDeclarationMirror | ClassDeclarationBuilder> | sb writeln: ea source].\r	instanceSide methods do: [:ea <MethodMirror | MethodBuilder> | sb writeln: ea source].\r	sb writeln: ' ) : ( '.\r	classSide methods do: [:ea <MethodMirror | MethodBuilder> | sb writeln: ea source].\r	sb writeln: ' )'.\r	^sb asString\r)",
 "updateApplicationsOf: oldRuntimeMixin <JRM> from: newRuntimeMixin <JRM> by: classDeclIR <IntermediateClassDeclaration> = (\r	|\r	newRuntimeMetamixin <MJRM> = js propertyOf: newRuntimeMixin at: (js literal: 'meta').\r	applications <Array[JRC]> = js propertyOf: oldRuntimeMixin at: (js literal: 'applications').\r	|\r	(* TODO: handle deletes *)\r	(* TODO: copy nested classes also? *)\r	(* TODO: copy new metadata *)\r	applications do: [:runtimeClass <JRC> |\r		|\r		runtimeMetaclass <MJRC> = js propertyOf: runtimeClass at: (js literal: 'meta').\r		|\r		(*runtimeClass out.*)\r		(* Cf. IntermediateClassDeclaration copyMethods: *)\r		classDeclIR instanceSide methods do: [:ea <IntermediateMethod> |\r			| jsProName <String> jsPubName <String> |\r			jsPubName:: compilation names manglePublic: ea name.\r			jsProName:: compilation names mangleProtected: ea name.\r			ea isProtected ifTrue: [\r				js assign: (js propertyOf: runtimeClass at: jsProName) toBe: (js propertyOf: newRuntimeMixin at: jsPubName).\r				js assign: (js propertyOf: runtimeClass at: jsPubName) toBe: (js call: (js ident: 'dnuCatcher') with: {jsPubName}).\r			].\r			ea isPublic ifTrue: [\r				js assign: (js propertyOf: runtimeClass at: jsProName) toBe: (js propertyOf: newRuntimeMixin at: jsPubName).\r				js assign: (js propertyOf: runtimeClass at: jsPubName) toBe: (js propertyOf: newRuntimeMixin at: jsPubName).\r			].\r		].\r		classDeclIR classSide methods do: [:ea <IntermediateMethod> |\r			| jsProName <String> jsPubName <String> |\r			jsPubName:: compilation names manglePublic: ea name.\r			jsProName:: compilation names mangleProtected: ea name.\r			ea isProtected ifTrue: [\r				js assign: (js propertyOf: runtimeMetaclass at: jsProName) toBe: (js propertyOf: newRuntimeMetamixin at: jsPubName).\r				js assign: (js propertyOf: runtimeMetaclass at: jsPubName) toBe: (js call: (js ident: 'dnuCatcher') with: {jsPubName}).\r			].\r			ea isPublic ifTrue: [\r				js assign: (js propertyOf: runtimeMetaclass at: jsProName) toBe: (js propertyOf: newRuntimeMetamixin at: jsPubName).\r				js assign: (js propertyOf: runtimeMetaclass at: jsPubName) toBe: (js propertyOf: newRuntimeMetamixin at: jsPubName).\r			].\r		].\r	].\r)",
 "updateHeaderSourceForNewRuntimeMixin: runtimeMixin <JRM> from: cdir <IntermediateClassDeclaration> = (\r |\r  headerSourceIndex <Integer> ::= js propertyOf: (js ident: 'sources') at: (js literal: 'length').\r  headerSource = cdir headerSource.\r |\r\r  js assign: (js propertyOf: runtimeMixin at: (js literal: 'header')) toBe: headerSourceIndex.\r  js assign: (js propertyOf: (js ident: 'sources') at: headerSourceIndex) toBe: headerSource.\r)",
 "updateInstanceMixin: oldRuntimeMixin <JRM> from: newRuntimeMixin <JRM> by: classDeclIR <IntermediateClassDeclaration> ^ <List[Symbol]> = (\r	(* TODO: handle deletes\r	go thru old methods and see if they exist in new methods, if not add them to deleted list? and remove from old.\r	*)\r	| newMethods <List[IntermediateMethod]> = classDeclIR instanceSide methods. |\r\r	deletedInstanceMethods:: List new.\r\r	(* (js propertyOf: oldRuntimeMixin at: #methods) forEach: [:m <MM> |\r		(newMethods anySatisfy: [:im <IntermediateMethod> |\r			im name = (compilation names manglePublic: (js propertyOf: m at: #name))\r			])\r		   ifFalse: [\r			deletedInstanceMethods add: im name.\r			(* remove from old; need to add delete support to JavascriptGeneration; not critical *)\r			].\r		].*)\r	(* TODO: copy nested classes also? *)\r	(* TODO: copy new metadata *)\r	newMethods do: [:ea <IntermediateMethod> | (* insert modified or new instance methods into mixin *)\r		| jsName <String> |\r		jsName:: compilation names manglePublic: ea name.\r		js assign: (js propertyOf: oldRuntimeMixin at: jsName) toBe: (js propertyOf: newRuntimeMixin at: jsName).\r	].\r	{#name. #header. #slots. #methods. #nestedClasses} do: [:jsName |\r		js assign: (js propertyOf: oldRuntimeMixin at: jsName) toBe: (js propertyOf: newRuntimeMixin at: jsName).\r	].\r)",
 "updateMetaMixin: oldRuntimeMetamixin <MJRM> from: newRuntimeMetamixin <MJRM> by: classDeclIR <IntermediateClassDeclaration> ^ <List[Symbol]> = (\r	| newMethods <List[IntermediateMethod]> = classDeclIR classSide methods. |\r\r	(* TODO: handle deletes *)\r	deletedClassMethods:: List new.\r	(* TODO: copy nested classes also? *)\r	(* TODO: copy new metadata *)\r	newMethods do: [:ea <IntermediateMethod> | (* insert modified or new class methods into mixin *)\r		| jsName <String> |\r		jsName:: compilation names manglePublic: ea name.\r		js assign: (js propertyOf: oldRuntimeMetamixin at: jsName) toBe: (js propertyOf: newRuntimeMetamixin at: jsName).\r	].\r	{#slots. #methods. #nestedClasses} do: [:jsName <Symbol> |\r		js assign: (js propertyOf: oldRuntimeMetamixin at: jsName) toBe: (js propertyOf: newRuntimeMetamixin at: jsName).\r	].\r)",
 "updateMixin: oldMixin <Mixin> from: newRuntimeMixin <JRM> by: classDeclIR <IntermediateClassDeclaration> = (\r	|\r	deletedInstanceMethods <List[Symbol]>\r	deletedClassMethods <List[Symbol]>\r	oldRuntimeMixin <JRM> = js propertyOf: oldMixin at: (js literal: 'runtimeMixin').\r	oldRuntimeMetamixin <MJRM> = js propertyOf: oldRuntimeMixin at: (js literal: 'meta').\r	newRuntimeMetamixin <MJRM> = js propertyOf: newRuntimeMixin at: (js literal: 'meta').\r	|\r	(* TODO: handle deletes *)\r	(* TODO: copy nested classes also? *)\r	(* TODO: copy new metadata *)\r	deletedInstanceMethods:: updateInstanceMixin: oldRuntimeMixin from: newRuntimeMixin  by: classDeclIR.\r	deletedClassMethods:: updateMetaMixin: oldRuntimeMetamixin from: newRuntimeMetamixin by: classDeclIR.\r	updateApplicationsOf: oldRuntimeMixin from: newRuntimeMixin by: classDeclIR.\r)",
 "updateMixinFrom: runtimeMixin <JRM> with: cdir <IntermediateClassDeclaration> = (\r |\r  instanceMethodSourceIndices <Map[String, Integer]> = Map new.\r  classMethodSourceIndices <Map[String, Integer]> = Map new.\r  runtimeMetamixin <MJRM> = js propertyOf: runtimeMixin at: (js literal: 'meta').\r  existingMixin <JRM> = js propertyOf: prvtExistingMixin at: (js literal: 'runtimeMixin').\r  existingMetamixin <MJRM> = js propertyOf: existingMixin at: (js literal: 'meta').\r  newSourceIndex <Integer> ::= js propertyOf: (js ident: 'sources') at: (js literal: 'length').\r |\r(* TODO: Also update source indices for header. *)\r(* TODO: update access modifiers if they have changed? *)\r	(* collect existing mixin's source indices into a map keyed by name *)\r	(js propertyOf: existingMixin at: (js literal: 'methods'))  do: [:ea <MM> |\r	   instanceMethodSourceIndices at: (js propertyOf: ea at: (js literal: 'name')) put: (js propertyOf: ea at: (js literal: 'source'))\r	].\r	(js propertyOf: existingMetamixin at: (js literal: 'methods')) do: [:ea <MM> |\r	  classMethodSourceIndices at: (js propertyOf: ea at: (js literal: 'name')) put: (js propertyOf: ea at: (js literal: 'source'))\r	].\r	(* Augment maps of source indices with entries for any new methods *)\r	(js propertyOf: runtimeMixin at: (js literal: 'methods')) do:\r		[:e <MM> | | selector |\r		   selector:: (js propertyOf: e at: (js literal: 'name')).\r		   instanceMethodSourceIndices at: selector ifAbsent: [instanceMethodSourceIndices at: selector put: newSourceIndex].\r		   newSourceIndex:: newSourceIndex + 1.\r		 ].\r	(js propertyOf: runtimeMetamixin at: (js literal: 'methods')) do:\r		[:e <MM> | | selector |\r		   selector:: (js propertyOf: e at: (js literal: 'name')).\r		   classMethodSourceIndices at: selector ifAbsent: [classMethodSourceIndices at: selector put: newSourceIndex].\r	         newSourceIndex:: newSourceIndex + 1.\r		 ].\r\r	  (* Update global sources array with any changed or new source code *)\r	instanceSide methods do: [:m <MethodBuilder> | | sourceIndex <Integer> |\r		  sourceIndex:: instanceMethodSourceIndices at: m name.\r		  m source ~= nil ifTrue: [js assign: (js propertyOf: (js ident: 'sources') at: sourceIndex) toBe: m source].\r		].\r	classSide methods do: [:m <MethodBuilder> | | sourceIndex <Integer> |\r		  sourceIndex:: classMethodSourceIndices at: m name.\r		  m source ~= nil ifTrue: [js assign: (js propertyOf: (js ident: 'sources') at: sourceIndex) toBe: m source].\r		].\r	  (* Ensure new runtime structure has correct source indices in its metadata*)\r	  (* what about the name itself? And the access modifier *)\r	(js propertyOf: runtimeMixin at: (js literal: 'methods')) do: [:mm <MM> |\r			js assign: (js propertyOf: mm at: (js literal: 'source'))\r			    toBe: (instanceMethodSourceIndices at: (js propertyOf: mm at: (js literal: 'name'))).\r	].\r	(js propertyOf: runtimeMetamixin at: (js literal: 'methods')) do: [:mm <MM> |\r		    js assign: (js propertyOf: mm at: (js literal: 'source'))\r		       toBe: (classMethodSourceIndices at: (js propertyOf: mm at: (js literal: 'name'))).\r		].\r		  (* Update class header source index *)\r	js assign: (js propertyOf: runtimeMixin at: (js literal: 'header')) toBe: (js propertyOf: existingMixin at: (js literal: 'header')).\r\r	(* Update the  existing runtime based on the new one *)\r	updateMixin: prvtExistingMixin from: runtimeMixin by: cdir\r)",
 "updateSourceIndicesOfNewRuntimeMixin: runtimeMixin <JRM> from: cdir <IntermediateClassDeclaration> = (\r |\r  instanceMethodSourceIndices <Map[String, Integer]> = Map new.\r  classMethodSourceIndices <Map[String, Integer]> = Map new.\r  runtimeMetamixin <MJRM> = js propertyOf: runtimeMixin at: (js literal: 'meta').\r  newSourceIndex <Integer> ::= js propertyOf: (js ident: 'sources') at: (js literal: 'length').\r |\r(* TODO: update access modifiers if they have changed? *)\r	(* Augment maps of source indices with entries for any new methods *)\r	(js propertyOf: runtimeMixin at: (js literal: 'methods')) do:\r		[:e <MM> | | selector |\r		   selector:: (js propertyOf: e at: (js literal: 'name')).\r		   instanceMethodSourceIndices at: selector ifAbsent: [instanceMethodSourceIndices at: selector put: newSourceIndex].\r		   newSourceIndex:: newSourceIndex + 1.\r		 ].\r	(js propertyOf: runtimeMetamixin at: (js literal: 'methods')) do:\r		[:e <MM> | | selector |\r		   selector:: (js propertyOf: e at: (js literal: 'name')).\r		   classMethodSourceIndices at: selector ifAbsent: [classMethodSourceIndices at: selector put: newSourceIndex].\r	         newSourceIndex:: newSourceIndex + 1.\r		 ].\r\r	  (* Update global sources array with any changed or new source code *)\r	instanceSide methods do: [:m <MethodBuilder> | | sourceIndex <Integer> |\r		  sourceIndex:: instanceMethodSourceIndices at: m name.\r		  m source ~= nil ifTrue: [js assign: (js propertyOf: (js ident: 'sources') at: sourceIndex) toBe: m source].\r		].\r	classSide methods do: [:m <MethodBuilder> | | sourceIndex <Integer> |\r		  sourceIndex:: classMethodSourceIndices at: m name.\r		  m source ~= nil ifTrue: [js assign: (js propertyOf: (js ident: 'sources') at: sourceIndex) toBe: m source].\r		].\r	  (* Ensure new runtime structure has correct source indices in its metadata*)\r	  (* what about the name itself? And the access modifier *)\r	(js propertyOf: runtimeMixin at: (js literal: 'methods')) do: [:mm <MM> |\r			js assign: (js propertyOf: mm at: (js literal: 'source'))\r			    toBe: (instanceMethodSourceIndices at: (js propertyOf: mm at: (js literal: 'name'))).\r	].\r	(js propertyOf: runtimeMetamixin at: (js literal: 'methods')) do: [:mm <MM> |\r		    js assign: (js propertyOf: mm at: (js literal: 'source'))\r		       toBe: (classMethodSourceIndices at: (js propertyOf: mm at: (js literal: 'name'))).\r		].\r		  (* Update class header source index *)\r	updateHeaderSourceForNewRuntimeMixin: runtimeMixin from: cdir.\r)",
 "public fromSource: src <String> ^<ClassDeclarationBuilder> = (\r	^self fromUnitSource: 'Newspeak3 ''Uncategorized'' ', src\r)",
 "public fromUnitSource: src <String> ^<ClassDeclarationBuilder> = (\r	| ir <IntermediateMixin> = (compiler compileClassSource: src within: nil). |\r(* source indices will be BOGUS here *)\r	^IRBasedClassDeclarationBuilder fromIR: ir existingMixin: nil within: nil\r)",
 "public reflecting: mixin <InstanceMixin> ^<ClassDeclarationBuilder> = (\r	| m = ClassDeclarationMirror reflecting: mixin. |\r	nil = m enclosingClass ifFalse:\r		[^m enclosingClass asBuilder instanceSide nestedClasses findMirrorNamed: m simpleName].\r\r	^MixinBasedClassDeclarationBuilder\r		forExistingMixin: mixin\r		within: nil\r)",
 "class ClassDeclarationMirror reflecting: mixin = (|\r	private reflectee = mixin.\r	public instanceSide <MixinMirror> = MixinMirror reflecting: mixin.\r	public classSide <MixinMirror> = MixinMirror reflecting: (classMixinOf: mixin).\r|)",
 " ",
 " ",
 "public accessModifier ^ <Symbol> = (\r	^header accessModifier\r)",
 "public applyToObject ^<ClassMirror> = (\r	nil = enclosingClass ifFalse: [^notTopLevel].\r	^ClassMirror reflecting: (reflectee applyTo: Object withName: simpleName)\r)",
 "public asBuilder ^<ClassDeclarationBuilder> = (\r	^ClassDeclarationBuilder reflecting: reflectee\r)",
 "public definingMixin ^<MixinMirror> = (\r	| ec = enclosingClass. |\r	nil = ec ifTrue: [^nil].\r	^ec instanceSide\r)",
 "public enclosingClass ^ <ClassDeclarationMirror> = (\r	| enclosing <Class> |\r	enclosing:: (js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'enclosingMixin')).\r	(js operator: '===' with: enclosing and: (js ident: 'undefined')) ifTrue: [^nil].\r	^ClassDeclarationMirror reflecting: (Mixin fromRuntimeMixin: enclosing)\r)",
 "public header ^<ClassHeaderMirror> = (\r	^ClassHeaderMirror reflecting: reflectee\r)",
 "public isKindOfClassDeclarationMirror ^<Boolean> = (\r	^true\r)",
 "public name = (\r	^(reflectee name splitBy: '`') last\r)",
 "public qualifiedName = (\r	#BOGUS. (* Remove when currentMixinUID uses a proper token. *)\r	^reflectee name\r)",
 "public simpleName = (\r	^name\r)",
 "public source ^<String> = (\r	| sb = StringBuilder new. |\r	sb add: header source.\r	sb writeln: ' ( '.\r	instanceSide nestedClasses do: [:ea | sb writeln: ea source].\r	instanceSide methods do: [:ea | sb writeln: ea source].\r	sb writeln: ' ) : ( '.\r	classSide methods do: [:ea | sb writeln: ea source].\r	sb writeln: ' )'.\r	^sb asString\r)",
 "class ClassHeaderMirror reflecting: mixin = AbstractClassHeaderMirror (|\r	private reflectee <Mixin> = mixin.\r|)",
 "AbstractClassHeaderMirror",
 "AbstractClassHeaderMirror",
 "public isKindOfClassHeaderMirror ^<Boolean> = (\r	^true\r)",
 "public name = (\r	^(reflectee name splitBy: '`') last\r)",
 "public preamble ^ <String> = (\r	(* Foo factory = SuperFoo superFactory *)\r	| headerAst |\r	headerAst:: compilation parser classHeader parseString: source.\r	^source copyFrom: headerAst start to: headerAst superConstructorCall end\r)",
 "public source ^<String> = (\r	| sourceIndex = js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'header'). |\r	^js propertyOf: (js ident: 'sources') at: sourceIndex.\r)",
 "public class ClassMirror reflecting: r <Class> = (|\rpublic reflectee <Class> = r.\r|)",
 " ",
 " ",
 "public = other <Object> ^<Boolean> = (\r	other isKindOfClassMirror ifFalse: [^false].\r	^js operator: '===' with: reflectee and: other reflectee\r)",
 "public allSuperclasses ^ <List[ClassMirror]> = (\r	| klass <Class> superclasses <List[Class]> |\r	superclasses:: List new.\r	klass:: superclass.\r	[klass isNil] whileFalse: [\r		superclasses add: klass.\r		klass:: klass superclass.\r	].\r	^superclasses\r)",
 "private computeMirrorGroup: mgAccessor <[:MixinMirror | MirrorGroup]> ^ <List[Mirror]> = (\r(* Return a mirror group based on the mixins group and those of all superclasses. The argument mgAccessor extracts a mirror group from any mirror provided to it. *)\r	| mg <MirrorGroup> |\r	mg:: List new.\r	(allSuperclasses reverse add: self; yourself)\r		do: [:klass <ClassMirror> | mg addAll: (mgAccessor value: klass mixin)].\r	^mg\r)",
 "public declaration ^ <ClassDeclarationMirror> = (\r(* Convenience method to make the API more usable *)\r	^mixin declaration\r)",
 "public enclosingObject ^<ObjectMirror> = (\r	^ObjectMirror reflecting: reflectee enclosingObject\r)",
 "public hash ^<Integer> = (\r	^(identityHashOf: reflectee) bitXor: class hash\r)",
 "public isKindOfClassMirror ^<Boolean> = (\r	^true\r)",
 "public isMeta ^<Boolean> = (\r	^reflectee isMeta\r)",
 "public methods ^ <MirrorGroup[MethodMirror]> = (\r	^computeMirrorGroup: [:r | r methods]\r)",
 "public mixin ^ <MixinMirror> = (\r	^MixinMirror reflecting: reflectee mixin\r)",
 "public name = (\r	^reflectee name\r)",
 "public nestedClasses ^ <MirrorGroup[ClassDeclarationMirror]> = (\r	^computeMirrorGroup: [:r | r nestedClasses]\r)",
 "public simpleName = (\r	^(reflectee name splitBy: '`') last\r)",
 "public slots ^ <MirrorGroup[SlotMirror]> = (\r	^computeMirrorGroup: [:r | r slots].\r)",
 "public superclass ^ <ClassMirror> = (\r	reflectee superclass isNil ifTrue: [^nil].\r	^ClassMirror reflecting: reflectee superclass\r)",
 "class IRBasedClassDeclarationBuilder fromIR: ir <IntermediateClassDeclaration> existingMixin: m <Mixin> within: enclosing <ClassDeclarationBuilder> = ClassDeclarationBuilder forExistingMixin: m  within: enclosing (\r|\rprvtIR <IntermediateClassDeclaration> = ir.\r|)",
 "forExistingMixin: m  within: enclosing",
 "forExistingMixin: m  within: enclosing",
 "computeClassSide ^ <MixinBuilder> = (\r	| existingClassMixin = nil = prvtExistingMixin ifFalse: [classMixinOf: prvtExistingMixin]. |\r	^MixinBuilder for: prvtIR classSide classDeclaration: self existingMixin: existingClassMixin.\r)",
 "computeInstanceSide ^ <MixinBuilder> = (\r	^MixinBuilder for: prvtIR instanceSide classDeclaration: self existingMixin: prvtIR instanceSide.\r)",
 "declarationData = (\r	^prvtIR\r)",
 "public header ^ <ClassHeaderMirror> = (\r	^SourceBasedClassHeaderMirror from: prvtIR headerSource\r)",
 "public name ^<Symbol> = (\r	^compilation names fullyQualifiedNameToSimple: qualifiedName\r)",
 "class MethodBuilder reflecting: mir in: mb source: s = (|\rreflecteeX <IntermediateMethod> = mir.\rdefiningMixinX <MixinBuilder> = mb.\rpublic source <String> = s.\r|)",
 " ",
 " ",
 "public accessModifier = (\r	^reflecteeX accessModifier\r)",
 "public definingMixin ^ <MixinBuilder> = (\r	^definingMixinX\r)",
 "public name ^<Symbol> = (\r	^reflecteeX name\r)",
 "public simpleName ^<Symbol> = (\r	^reflecteeX name\r)",
 "class MethodMirror name: n accessModifier: a mixin: m source: s = (|\r	public name <Symbol> = n.\r	public accessModifier <Symbol> = a.\r	public definingMixin <MixinMirror> = m.\r	private sourceIndex <Integer> = s.\r|)",
 " ",
 " ",
 "public isKindOfMethodMirror ^<Boolean> = (\r	^true\r)",
 "public simpleName ^<Symbol> = (\r	^name\r)",
 "public source ^<String> = (\r	^js propertyOf: (js ident: 'sources') at: sourceIndex.\r)",
 "public class MixinBasedClassDeclarationBuilder forExistingMixin: m <InstanceMixin> within: enclosing <ClassDeclarationBuilder> =\rClassDeclarationBuilder forExistingMixin: m  within: enclosing (\r| mixinMirror = MixinMirror reflecting: m. |\r)",
 "forExistingMixin: m  within: enclosing",
 "forExistingMixin: m  within: enclosing",
 "computeClassSide ^ <MixinBuilder> = (\r	| existingClassMixin = classMixinOf: prvtExistingMixin. |\r	^MixinBuilder for: mixinMirror declaration classSide classDeclaration: self existingMixin: existingClassMixin.\r)",
 "computeInstanceSide ^ <MixinBuilder> = (\r	^MixinBuilder for: mixinMirror classDeclaration: self existingMixin: prvtExistingMixin.\r)",
 "declarationData ^ <ClassDeclarationMirror> = (\r	^mixinMirror declaration\r)",
 "public header ^ <ClassHeaderMirror> = (\r	^declarationData header\r)",
 "public name ^<Symbol> = (\r	^declarationData name\r)",
 "class MixinBuilder for: dataSource <IntermediateMixin | MixinMirror> classDeclaration: cdb <ClassDeclarationBuilder> existingMixin: em <Mixin> = (\r(*\rA mutable description of a mixin. Used by ClassDeclarationBuilder, which is the actual unit of installation.\rInstances of this class are created from dataSource, which  may be either the compiler's intermediate representation for mixins,\ror a mixin mirror. In all cases, a builder, cdb,  for the entire class must be supplied as a reference to the overall\rdeclaration. If the mixin, em, that is being described already exists, it too is required - otherwise em should be nil.\r\rThe working representation for the builder consists of slots representing the methods, nested classes and slots of the mixin.\rThese are computed upon instantiation. Changing the mixin elsewhere will have no effect on this builder once it has\rbeen instantiated!\r\rArguably, it might be cleaner to separate out MixinBuilders into different implementations just like ClassDeclarationBuilders.\rIn practice, the only point where a difference arises is in computing nestedClasses, the set of nested class builders.\rThus, it seems simpler to factor out that decision to the method #nestedClassBuildrFor:within:, which does a test\ron the data to decide what action to take.\r*)\r|\rdata <IntermediateMixin | MixinMirror> = dataSource.\rpublic declaration <ClassDeclarationBuilder> = cdb.\rpublic slots <MutableMirrorGroup> = MutableMirrorGroup group: ((dataSource slots reject: [:ea | ea isSynthetic])) within: self.\rpublic methods <MutableMethodGroup> = MutableMethodGroup group: ((dataSource methods reject: [:ea | ea isSynthetic]) collect: [:ea | MethodBuilder reflecting: ea in: self source: ea source]) within: self.\rpublic nestedClasses <MutableNestedClassGroup> =\r   MutableNestedClassGroup group: (dataSource nestedClasses collect: [:ea <IntermediateClassDeclaration | ClassDeclarationMirror> |\r	nestedClassBuilderFor: ea within: em]) within: self.\r|)",
 " ",
 " ",
 "public canUnderstand: selector <Symbol> ^ <Boolean> = (\r	^methods includesMirrorNamed: selector\r)",
 "find: name <String> in: aMixin <Mixin>^ <Mixin> = (\r	^Mixin fromRuntimeMixin:\r		(js propertyOf:\r			(js propertyOf: aMixin at: (js literal: 'runtimeMixin')) at: (compilation names manglePublic: name)).\r)",
 "public isKindOfMixinMirror ^<Boolean> = (\r	^true\r)",
 "public isMeta ^ <Boolean> = (\r	^data isMeta\r)",
 "nestedClassBuilderFor: nc <IntermediateClassDeclaration | ClassDeclarationMirror> within: em <Mixin> ^ <ClassDeclartionBuilder> = (\r	data isKindOfIntermediateMixin ifTrue: [\r		^IRBasedClassDeclarationBuilder fromIR: nc existingMixin: (find: nc qualifiedName in: em) within: declaration\r		].\r	^MixinBasedClassDeclarationBuilder forExistingMixin: (find: nc qualifiedName in: em) within: declaration\r)",
 "public reflecting: mxn <Mixin | ClassMixin> ^<MixinBuilder> = (\r	^mxn isMeta\r		ifTrue: [(ClassDeclarationBuilder reflecting: (MixinMirror reflecting: mxn) declaration instanceSide reflectee) classSide]\r		ifFalse: [(ClassDeclarationBuilder reflecting: mxn) instanceSide]\r)",
 "class MixinMirror reflecting: mixin <Mixin> = (|\r	private reflectee <Mixin> = mixin.\r|)",
 " ",
 " ",
 "public apply: newSuperclass <Class> withName: n <Symbol> ^ <ClassMirror> = (\r	^ClassMirror reflecting: (reflectee applyTo: newSuperclass withName: n)\r)",
 "public asBuilder ^<MixinBuilder> = (\r	^isMeta\r		ifTrue: [declaration asBuilder classSide]\r		ifFalse: [declaration asBuilder instanceSide]\r)",
 "public canUnderstand: selector <Symbol> ^ <Boolean> = (\r	^methods includesMirrorNamed: selector\r)",
 "public declaration ^<ClassDeclarationMirror> = (\r	^ClassDeclarationMirror\r		reflecting: (isMeta\r			ifFalse: [reflectee]\r			ifTrue: [(Mixin fromRuntimeMixin: (js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'nonMeta')))])\r)",
 "public isKindOfMixinMirror ^<Boolean> = (\r	^true\r)",
 "public isMeta ^<Boolean> = (\r	^reflectee isMeta\r)",
 "public methods ^<MirrorGroup[MethodMirror]> = (\r	| raw <Array[MethodMirror]> |\r	raw:: ((js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'methods'))\r		select: [:each | (js propertyOf: each at: (js literal: 'isSynthetic')) not])\r		collect: [:each | MethodMirror\r			name: (js propertyOf: each at: (js literal: 'name'))\r			accessModifier: (js propertyOf: each at: (js literal: 'accessModifier'))\r			mixin: self\r			source: (js propertyOf: each at: (js literal: 'source'))].\r	^ImmutableMirrorGroup group: raw\r)",
 "public name = (\r	^(reflectee name splitBy: '`') last\r)",
 "public nestedClasses ^<MirrorGroup[ClassDeclarationMirror]> = (\r	| raw <Array[ClassDeclarationMirror]> |\r	raw:: (js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'nestedClasses'))\r		collect: [:each | ClassDeclarationMirror reflecting:\r			(Mixin fromRuntimeMixin:\r				(js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (vmmirror mangleSelector: each)))].\r	^ImmutableMirrorGroup group: raw\r)",
 "public slots ^<MirrorGroup[SlotDeclarationMirror]> = (\r	| raw <Array[SlotDeclarationMirror]> |\r	isMeta ifTrue: [^ImmutableMirrorGroup group: {}].\r	raw:: ((js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'slots'))\r		select: [:each | (js propertyOf: each at: (js literal: 'isSynthetic')) not])\r		collect: [:each | SlotDeclarationMirror\r			name: (js propertyOf: each at: (js literal: 'name'))\r			accessModifier: (js propertyOf: each at: (js literal: 'accessModifier'))\r			isMutable: (js propertyOf: each at: (js literal: 'isMutable'))\r			mixin: self].\r	^ImmutableMirrorGroup group: raw\r)",
 "class MutableMethodGroup group: ms <List[Mirror]>\r  within: mb <MixinBuilder>\r = MutableMirrorGroup group: ms within: mb  ()",
 "group: ms within: mb",
 "group: ms within: mb",
 "public addFromSource: s <String> ^ <MethodBuilder> = (\r	|\r	result <IntermediateMethod>\r	newM <MethodBuilder>\r	sourceIndex <Integer>\r	|\r	result:: compiler\r		compileMethodSource: s\r		within: definingMixin.\r\r	(* TODO: check for name conflicts *)\r\r	newM:: MethodBuilder reflecting: result in: definingMixin source: s.\r	removeMirrorNamed: result name.\r	(*mixinIR methods add: result.*)\r	addMirror: newM.\r	^newM\r)",
 "public removeMirrorNamed: m <Symbol | String>^ <Mirror> = (\r	| 	oldMirror <MethodMirror> |\r	oldMirror:: super removeMirrorNamed: m.\r	oldMirror isNil\r	  ifFalse: [ (* we are removing an existing method *)\r		(*mixinIR methods removeAllSuchThat: [:ea <IntermediateMethod> | ea name = m].*)\r	 ].\r	^oldMirror\r)",
 "class MutableMirrorGroup group: mirrors <List[Mirror]> within: mb <MixinBuilder> = ImmutableMirrorGroup group: mirrors (\r	|\r	protected definingMixin <MixinBuilder> = mb.\r	|\r)",
 "group: mirrors",
 "group: mirrors",
 "addMirror: m <Mirror> ^ <Mirror> = (\r	mirrors keysAndValuesDo: [:index <Integer> :mirror <Mirror> |\r		mirror simpleName = m simpleName ifTrue: [^mirrors at: index put: m]].\r	^mirrors addLast: m\r)",
 "public removeMirrorNamed: m <Symbol | String>^ <Mirror> = (\r	mirrors keysAndValuesDo: [:index :mirror |\r		mirror simpleName = m  ifTrue: [^mirrors remove: mirror]].\r	^nil\r)",
 "class MutableNestedClassGroup group: ms within: mb = MutableMirrorGroup group: ms within: mb  (\r)",
 "group: ms within: mb",
 "group: ms within: mb",
 "public class ObjectMirror reflecting: r = (|\r	public reflectee = r.\r|)",
 " ",
 " ",
 "public = other <Object> ^<Boolean> = (\r	other isKindOfObjectMirror ifFalse: [^false].\r	^js operator: '===' with: reflectee and: other reflectee\r)",
 "private compileExpression: expression <String> with: rawScope <Map[Symbol, Object]> ^<JS[Function]> = (\r	|\r	compiler\r	ir\r	dnuHandlers\r	writer\r	sb\r	src\r	func\r	|\r\r	compiler:: compilation Compiler new.\r	ir:: compiler\r			compileExpressionSource: expression\r			inMixin: getClass mixin\r			withScope: rawScope.\r	dnuHandlers:: compiler dnuHandlers.\r\r	writer:: generation Writer new.\r	sb:: StringBuilder new.\r	writer generateSourceFor: dnuHandlers on: sb.\r	src:: sb asString.\r	func:: js call: (js ident: 'eval') with: {'(',src, ')'}.\r	js call: func with: {js verbatim: 'Object.prototype'}.\r\r	writer:: generation Writer new.\r	sb:: StringBuilder new.\r	writer generateSourceFor: ir function on: sb.\r	src:: sb asString.\r	src out.\r	^js call: (js ident: 'eval') with: {'(',src, ')'}\r)",
 "public evaluate: expression <String> ^<ThreadMirror> = (\r	^self evaluate: expression with: Map new\r)",
 "public evaluate: expression <String> with: scope <Map[Symbol, ObjectMirror]> ^<ThreadMirror> = (\r	| rawScope func state result |\r	rawScope:: Map new.\r	scope keysAndValuesDo: [:key :value | rawScope at: key put: value reflectee].\r\r	func:: compileExpression: expression with: scope.\r	\r	[result:: js call: (js propertyOf: func at: (js literal: 'call')) with: {reflectee. rawScope}.\r	 state:: #fulfilled]\r		on: Error do: [:e | result:: e. state:: #broken].\r\r	^ThreadMirror\r		state: state\r		result: (ObjectMirror reflecting: result)\r)",
 "public getClass = (\r	#BOGUS. (* Wrong for bilingual objects. *)\r	^ClassMirror reflecting:\r		(js propertyOf: reflectee at: (js literal: 'newspeakClass')).\r)",
 "public getSlot: selector = (\r	|\r	mangledName = vmmirror mangleSelector: selector, '`slot'.\r	raw = js propertyOf: reflectee at: mangledName.\r	|\r	(js operator: '===' with: (js ident: 'undefined') and: raw) ifTrue: [halt].\r	^ObjectMirror reflecting: raw\r)",
 "public hash ^<Integer> = (\r	^(identityHashOf: reflectee) bitXor: class hash\r)",
 "public isKindOfObjectMirror ^<Boolean> = (\r	^true\r)",
 "public setSlot: selector to: value = (\r	|\r	mangledName = vmmirror mangleSelector: selector, '`slot'.\r	raw = js propertyOf: reflectee at: mangledName.\r	|\r	(js operator: '===' with: (js ident: 'undefined') and: raw) ifTrue: [^halt].\r	js assign: (js propertyOf: reflectee at: mangledName) toBe: value.\r)",
 "class SlotDeclarationMirror name: n accessModifier: a isMutable: m mixin: mxn = (|\r	public name <Symbol> = n.\r	public accessModifier <Symbol> = a.\r	public isMutable <Boolean> = m.\r	public definingMixin <MixinMirror> = mxn.\r|)",
 " ",
 " ",
 "public isKindOfSlotDeclarationMirror ^<Boolean> = (\r	^true\r)",
 "class SourceBasedClassHeaderMirror from: src <String> = AbstractClassHeaderMirror (\r|\r	public source = src.\r|\r)",
 "AbstractClassHeaderMirror",
 "AbstractClassHeaderMirror",
 "class ThreadMirror state: s result: r = (\r	|\r	protected state = s.\r	public result <ObjectMirror | nil> = r.\r	|\r)",
 " ",
 " ",
 "public isBroken ^<Boolean> = (\r	^state = #broken\r)",
 "public isFulfilled ^<Boolean> = (\r	^state = #fulfilled\r)",
 "public isSuspended ^<Boolean> = (\r	^state = #suspended\r)",
 "class MirrorGroups usingLib: platform = (\r(* Mirror groups are designed to aggregate mirrors of any kind.\rThey make the mirror API compositional and not too\rheavyweight.  Consider the API of an immutable mixin mirror:\r\r\rname\rmethods\rslots\rclasses\r\rthe latter three all return mirror groups, which all share a common protocol:\r\rfindMirrorNamed: #foo\rincludesMirrorNamed: #foo\rdo: blk\r\rIn a more traditional API, we would need to support methods like:\r\rfindMethodNamed: #foo\rfindSlotNamed: #foo\rfindClassNamed: #foo\r\rincludesMethodNamed: #foo\rincludesSlotNamed: #foo\rincludesClassNamed: #foo\r\rmethodsDo: blk\rslotsDo: blk\rclassesDo: blk\r\rThis means 3 times as many methods, which need to be kept consistent.\rWhen the mirror is mutable, the actual mixin API does not change much. The\rimplementation returns mutable mirror groups, which support:\r\raddMirror: aMirror\raddFromSource: aSourceString\r\rinstead of having the mutable mixin support:\r\raddMethodMirror:\raddMethodFromSource:\raddSlotMirror:\raddSlotFromSource:\raddClassStencilMirror:\raddClassFromSource:\r\r   Copyright 2008 Cadence Design Systems, Inc.\r   Copyright 2011 Ryan Macnak\r\r   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)\r|\rprivate Collection = platform collections Collection.\rprivate List = platform collections List.\r|)",
 " ",
 " ",
 "public class ImmutableMirrorGroup group: ms <List[Mirror]> = Collection (\r(* Immutable mirror groups do not support adding or removing mirrors. They are created from an initial set of mirrors passed to the factory method.\r\rHowever, the API does include mutators, which all fail if called.  This allows them to provide good error messages when used in a context that might attempt to mutate them. An example would be a mutable mixin mirror that does not allow changes to its representation; it includes immutable mirror groups for its slots and classes, and a mutable mirror group for its methods. *)\r|\r	protected mirrors <List[Mirror]> = List withAll: ms. (* Preserve order.  Keep source code order if applicable.  Shape is important for many classes known to the VM. *)\r|)",
 "Collection",
 "Collection",
 "public addFromSource: s <String> = (\r	^Error signal: 'Adding mirrors not allowed on an immutable mirror group!'\r)",
 "public addMirror: m <Mirror> = (\r	^Error signal: 'Adding mirrors not allowed on an immutable mirror group!'\r)",
 "public do: blk <[:Mirror]> = (\r	mirrors do: blk\r)",
 "public findMirrorNamed: n <Symbol> ^ <Mirror> = (\r	mirrors do: [:mirror <Mirror> | mirror name = n ifTrue: [^mirror]].\r	^nil\r)",
 "public includesMirrorNamed: n <Symbol> = (\r	mirrors do: [:mirror <Mirror> | mirror name = n ifTrue: [^true]].\r	^false\r)",
 "public removeMirror: m <Mirror> = (\r	^Error signal: 'Removng mirrors not allowed on an immutable mirror group!'\r)",
 "public removeMirrorNamed: m <Symbol | String> = (\r	^Error signal: 'Removng mirrors not allowed on an immutable mirror group!'\r)",
 "public size ^ <Integer> = (\r	^mirrors size\r)",
 "class MirrorGroup group: ms <Collection[Mirror]> = ImmutableMirrorGroup group: ms (\r(* A mutable mirror group; mirrors can be added or removed after its creation. *)\r)",
 "group: ms",
 "group: ms",
 "public addFromSource: s <String> = (\r	self subclassResponsibility\r)",
 "addMirror: m <Mirror> = (\r	mirrors keysAndValuesDo: [:index :mirror |\r		mirror simpleName = m simpleName ifTrue: [^mirrors at: index put: m]].\r	^mirrors addLast: m\r)",
 "removeAll = (\r	mirrors: List new.\r)",
 "removeAllSuchThat: blk = (\r	mirrors select: blk thenDo: [:m <Mirror> | removeMirrorNamed: m name].\r)",
 "removeMirror: m <Mirror> = (\r	^mirrors remove: m\r)",
 "removeMirrorNamed: n <Symbol | String> = (\r	| m |\r	m:: findMirrorNamed: n.\r	^m ifNotNil: [removeMirror: m].\r)",
 "class Streams usingPlatform: platform = (\r(*\rInterim Newspeak Streams library.\rThis code was derived by converting the Strongtalk Stream classes to Newspeak, which is why the Sun Microsystems copyright and BSD license below applies.\r\rConverting Strongtalk code gives Newspeak a quick route to its own library, that is small, quite clean and  has a typed interface, with desirable license, and also quite close to the Smalltalk libraries we've been using. However, it may not be the final or ideal design.\r\rIt is not yet clear to me what the dividing lines between this module and the modules for files or even strings are. For example, the various character streams might really belong with strings, and the external streams may belong with files.\r\rThe naming conventions are probably too verbose as well. Finally, the fine grain breakdown into many mixins may not be ideal.\r\rCopyright (c) 1995-2006 Sun Microsystems, Inc. ALL RIGHTS RESERVED.\rCopyright 2008-2009 Gilad Bracha and other contributors.\r\rRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\r\r* Redistributions of source code must retain the above copyright notice,\r this  list of conditions and the following disclaimer.\r\r* Redistribution in binary form must reproduce the above copyright notice,\rthis list of conditions and the following disclaimer in the documentation and/o other materials provided with the distribution.\r\rNeither the name of Sun Microsystems or the names of contributors may\rbe used to endorse or promote products derived from this software without\rspecific prior written permission.\r\r>>\rTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\rTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\rBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\rGOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\rLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\rDAMAGE.>> *)\r|\rprivate BasicOutputReadStream = BasicOutputStream mixinApply: BasicReadStream.\r\rprivate CharacterIStream = CharacterInput mixinApply: BasicInputStream.\rprivate CharacterOStream = CharacterOutput mixinApply: BasicOutputStream.\r\rprivate CharacterConverterWithOutput = BasicOutputStream mixinApply: CharacterInputConverter.\rprivate OutputInputConverter = CharacterOutput mixinApply: CharacterConverterWithOutput.\rprivate BasicIExStream = BasicInputStream mixinApply: ExternalStream.\rprivate EIStream = BasicReadStream mixinApply: ExternalInputStream.\rprivate ReadExternalOutputStream = BasicOutputStream mixinApply: ExternalReadStream.\rprivate EOStream = BasicOutputStream mixinApply: ExternalStream.\rprivate EIOStream = ExternalOutputStream mixinApply: ReadExternalOutputStream.\r|)",
 " ",
 " ",
 "usingCrLfConvention = (\r	(* The current code only distinguishes systems that use CR and systems use CRLF for line endings. In order to generate files that are printed correctly on systems that use LF (Linux, OS X), we default to CRLF for now. *)\r	^true\r)",
 "public class BasicInputStream = (\r(* This class provides the standard implementation of the InputStream[E] protocol, where E is the type of the elements of the stream.  It implements all functionality\rin terms of the two messages #actualNext and #actualAtEnd, which subclasses must provide.\r\rNote that streams support all collection operations.  However, when using collection messages with\rstreams, the caller must be aware that iteration on a stream changes the state of the stream, so that\riterations are not repeatable.  Also, care must be taken with infinite streams, since most collection\rmessages will not terminate on their own for infinite streams.\r\r%responsibility #newCollectionOfSize:\r	Optionally override\r%responsibility #close\r	Close must be reimplemented if any work must be done when the stream is closed. *)\r|\rhavePeeked_0 <Boolean> ::= false.\r(* If true, then peekVal is the next element *)\rpeekVal <E>\r|)",
 " ",
 " ",
 "accumulateUntil: predicate <[Boolean]> ^ <List[E]> = (\r	| build <ReadWriteStream[E]> |\r\r	build:: self newBuildStream.\r	[ predicate value ]\r		whileFalse: [ build nextPut: self next ].\r	^build contentsWritten\r)",
 "actualAtEnd ^ <Boolean> = (\r	(* Test whether there are elements remaining in the stream, disregarding peekVal *)\r\r	self subclassResponsibility\r)",
 "actualNext ^ <E> = (\r	(* Return the next element of the stream, disregarding peekVal *)\r\r	self subclassResponsibility\r)",
 "atEnd ^ <Boolean> = (\r	^self havePeeked\r		ifTrue: [ false ]\r		ifFalse: [ self actualAtEnd ]\r)",
 "atEndOrPeekIs: delimiter <Object> ^ <Boolean> = (\r	^(self peekIfAbsent: [ ^true ]) = delimiter\r)",
 "close = (\r	(* by default, do nothing *)\r)",
 "contentsRemaining ^ <List[E]> = (\r	^self accumulateUntil: [ self atEnd ]\r)",
 "defaultExpected ^ <Integer> = (\r	^10\r)",
 "do: f <[:E]> = (\r	[ self atEnd ]\r		whileFalse: [ f value: self next ]\r)",
 "havePeeked ^ <Boolean> = (\r	^havePeeked_0\r)",
 "havePeeked: f <Boolean> = (\r	f ifFalse: [ peekVal:: nil ].\r	havePeeked_0:: f.\r)",
 "newBuildStream ^ <ReadWriteStream[E]> = (\r	(* Returns a readwrite stream to be used for accumulating elements\r	 for the various contents messages, etc. *)\r\r	^BasicReadWriteStream(* [E] *) on: (self newCollectionOfSize: self defaultExpected)\r)",
 "newCollectionOfSize: n <Integer> ^ <MutableList[E]> = (\r	(* Create and return a new collection of a class appropriate for\r	 holding elements of this stream.  By overriding this, subclasses\r	can customize the kind of collection returned by the various\r	contents messages, as well as #upTo:, etc. *)\r\r	^Array(* [E] *) new: n\r)",
 "next ^ <E> = (\r	^self havePeeked\r		ifTrue: [ self nextFromPeek ]\r		ifFalse: [ self actualNext ]\r)",
 "next: nElements <Integer> ^ <List[E]> = (\r	| cltn <VarSeqCltn[E]> |\r\r	cltn:: self newCollectionOfSize: nElements.\r	1 to: nElements do: [:i <Integer> |\r		self atEnd\r			ifTrue: [ self error: 'Not enough elements' ].\r		cltn at: i put: self next.	].\r	^cltn\r)",
 "nextFromPeek ^ <E> = (\r	| v <E> |\r	v:: self peekVal.\r	self	noPeekVal.\r	^v\r)",
 "public nextIfAbsent: f <[X def]> ^ <E | X> = (\r	^self havePeeked\r		ifTrue: [ self nextFromPeek ]\r		ifFalse: [ self actualAtEnd\r							ifFalse: [ self actualNext ]\r							ifTrue: [ f value ]	 ]\r)",
 "nextMatchFor: o <Object> ^ <Boolean> = (\r	^self next = o\r)",
 "noPeekVal = (\r	havePeeked:: false.\r	peekVal:: nil\r)",
 "peek ^ <E> = (\r	self havePeeked\r		ifFalse: [ self peekVal: self actualNext.\r				self havePeeked: true.	 ].\r	^self peekVal\r)",
 "peekFor: o <Object> ^ <Boolean> = (\r	^self peek = o\r		ifTrue: [ self next.\r				true	]\r		ifFalse: [ false ]\r)",
 "peekIfAbsent: f <[X def]> ^ <E | X> = (\r	self havePeeked\r		ifFalse: [ self actualAtEnd\r							ifTrue: [ ^f value ].\r						self peekVal: self actualNext.\r						self havePeeked: true.	 ].\r	^self peekVal\r)",
 "public printOn: strm <CharOutputStream> = (\r	strm	nextPutAll: self class name\r)",
 "skip: nElements <Integer> = (\r	nElements timesRepeat: [ self next ]\r)",
 "skipTo: o <Object> ^ <Boolean> = (\r	[ self atEnd ] whileFalse: [\r			self next = o\r				ifTrue: [ ^true ]	].\r	^false\r)",
 "upTo: delimiter <Object> ^ <List[E]> = (\r	| s <SeqCltn[E]> |\r	s:: self accumulateUntil: [ self atEndOrPeekIs: delimiter ].\r	self nextIfAbsent: [ ].\r	^s\r)",
 "public class BasicOutputStream = (\r(* This class provides the standard implementation of the OutputStream protocol.  It implements all functionality in terms of the message #nextPut:, which subclasses must provide.\r\r%responsibility #flush\r	Subclasses may have to reimplement this to flush any internal buffers.\r\r%todo: if this class doesn't end up with more methods than next:put: and nextPutAll:, then we\rshould remove it and copy those two methods into its subclasses and invocations.\r*)\r)",
 " ",
 " ",
 "externalFlush = (\r	(* Flush both internal Smalltalk buffers and any buffers external to Smalltalk *)\r\r	(* By default do regular flush.  Subclasses should extend to deal with any external buffers *)\r	self flush\r)",
 "public flush = (\r	(* Flush any information buffered in Smalltalk.  This does NOT\r	 flush the external medium; use #externalFlush for that. *)\r\r	(* By default do nothing *)\r)",
 "next: nElements <Integer> put: el <E> ^ <E> = (\r	nElements timesRepeat: [\r		self nextPut: el		].\r	^el\r)",
 "public nextPut: el <E> ^ <E> = (\r	self subclassResponsibility\r)",
 "public nextPutAll: els <Collection[E]> ^ <Collection[Object]> = (\r	els do: [:el <E> |\r		self nextPut: el		].\r	^els\r)",
 "put: el <E> ^ <E> = (\r	(* A better name for nextPut: *)\r\r	^self nextPut: el\r)",
 "putAll: els <Collection[E]> ^ <Collection[Object]> = (\r	(* Better name for nextPutAll: *)\r\r	^self nextPutAll: els\r)",
 "show: els <Collection[E]> ^ <Collection[Object]> = (\r	(* basically like for #nextPutAll, except that it should flush immediately. *)\r\r	self nextPutAll: els; flush.\r	^els\r)",
 "class BasicReadStream = BasicInputStream (\r(* This class provides the standard implementation of the ReadStream protocol.\r\rSubclass responsibilities:\r	%responsibility actualPosition:\r	Should be extended in subclasses to change any external position cursor, if necessary.\r	%responsibility actualNext\r	Subclasses must ensure that their implementation of next and nextFromPeek increments the position. *)\r| actualPosition_slot <Integer> ::= 0. |)",
 "BasicInputStream",
 "BasicInputStream",
 "actualAtEnd ^ <Boolean> = (\r	^self actualPosition >= self size\r)",
 "actualPosition ^ <Integer> = (\r	^actualPosition_slot\r)",
 "actualPosition: p <Integer> = (\r	actualPosition_slot: p\r)",
 "at: index <Integer> ^ <E> = (\r	| pos <Integer> result <E> |\r	pos:: self position.\r	self position: index - 1.\r	result:: self next.\r	self position: pos.\r	^result\r)",
 "collection ^ <List[E]> = (\r	| cltn <MutableList[E]> origPos <Integer> |\r\r	cltn:: self newCollectionOfSize: self size.\r	origPos:: self position.\r	self position: 0.\r	1 to: self size do: [:i <Integer> |\r		cltn at: i put: self next.	].\r	self position: origPos.\r	^cltn\r)",
 "public contents ^ <List[E]> = (\r	(* Obsolete: this method is included purely for BlueBook compatibility.  If possible, use\r	 #contentsRemaining and #contentsWritten, which will work when a ReadWriteStream\r	 is substituted for a ReadStream or a WriteStream, unlike this method *)\r\r	(* This originally referred to contentsRemaining. The result of 'contents' should not depend on how much of a stream has already been read, see Blue Book - Protocol for Streams *)\r\r	^self collection\r)",
 "contentsRemaining ^ <List[E]> = (\r	| cltn <MutableList[E]> n <Integer> |\r\r	n:: self size - self position.\r	cltn:: self newCollectionOfSize: n.\r	1 to: n do: [:i <Integer> |\r		cltn at: i put: self next.	].\r	^cltn\r)",
 "copyFrom: start <Integer> to: stop <Integer> ^ <MutableList[EX]>\r	(* {where EX is returnType of #anElement message of receiverType} *)\r= (\r	| pos <Integer> n <Integer> result <Array[EX]> offset <Integer> |\r	pos:: self position.\r	n:: (stop - start) + 1.\r	result:: Array(* [EX] *) new: n.\r	offset:: start - 1.\r	1 to: n do:\r		[:i <Integer> |\r			(* guarantee is safe because of inference clause *)\r			result at: i put: (\r(* guaranteed <EX> *) (self repositioningAt: offset + i)). ].\r	self position: pos.\r	^result\r)",
 "isEmpty ^ <Boolean> = (\r	^self size = 0\r)",
 "public position ^ <Integer> = (\r	^self havePeeked\r		ifFalse: [ self actualPosition ]\r		ifTrue: [ self actualPosition - 1 ]\r)",
 "public position: p <Integer> = (\r	self actualPosition: p.\r	self noPeekVal.\r)",
 "repositioningAt: index <Integer> ^ <E> = (\r	(* Like at:, but may leave the position changed *)\r\r	^self at: index\r)",
 "reset = (\r	self position: 0.\r)",
 "setToEnd = (\r	self position: self size.\r)",
 "size ^ <Integer> = (\r	self subclassResponsibility\r)",
 "skip: nElements <Integer> = (\r	self position: (self position + nElements max: self size)\r)",
 "skipTo: o <Object> ^ <Boolean> = (\r	| pos <Integer> n <Integer> sz <Integer> |\r	sz:: self size.\r	pos:: self position.\r	pos + 1 to: sz do:\r		[:i <Integer> |\r			(self repositioningAt: i) = o\r				ifTrue: [ self position: i.\r								^true ]\r		].\r	self position: sz.\r	^false\r)",
 "upTo: delimiter <Object> ^ <SeqCltn[E]> = (\r	| pos <Integer> n <Integer> result <List[E]> |\r	pos:: self position.\r	^(self skipTo: delimiter)\r		ifTrue: [ self copyFrom: pos + 1 to: self position - 1 ]\r		ifFalse: [ self copyFrom: pos + 1 to: self position ]\r\r(*	| pos <Integer> n <Integer> result <Array[E]> |\r	pos:: self position.\r	self skipTo: delimiter.\r	n:: (self position - pos) - 1.\r	self position: pos.\r	result:: Array[E] new: n.\r	1 to: n do:\r		[:i <Integer> |\r			result at: i put: self next ].\r	self nextIfAbsent: [].\r	^result *)\r)",
 "on: sc <List[E]> ^ <ReadStream[E]> = (\r	(* Create a new read stream on sc, assuming that all of its elements are readable.\r		This message is here for BlueBook compatibility.  For good style, use (sc readStream)\r		instead. *)\r\r	^SeqCltnReadStream(* [E] *) on: sc\r)",
 "on: sc <List[E]> from: firstIndex <Integer> to: lastIndex <Integer> ^ <ReadStream[E]> = (\r	(* Create a new read stream on a copy of the elements in sc from firstIndex to lastIndex, inclusive *)\r\r	^self on: (sc copyFrom: firstIndex to: lastIndex)\r)",
 "class BasicReadWriteStream = BasicOutputReadStream (\r(* This class provides the standard implementation of the WriteStream and ReadWriteStream protocols.\r\rThere is no BasicWriteStream class; this is because virtually all WriteStreams are on data structures with implicit readability (try thinking of a positionable collection that can be written and not read), so ReadStreams and ReadWriteStreams are used instead.\r\rBlue Book compatibility note: you can use ReadWriteStreams as you would in the Blue Book, with\rone exception: the #contents message acts like it would for a WriteStream (i.e. it returns the elements\rwritten) rather than returning the entire collection.  The messages #collection, #contentsRemaining, and #contentsWritten fulfill these kind of roles without ambiguity in our system, to make ReadWriteStreams\rfully substitutable for both ReadStreams and WriteStreams.\r\r%responsibility nextPut:\r	Subclasses must extend the nextPut: method to do the actual work of writing the element.\r%responsibility size:\r	Optional - Any subclass that wishes to start off with readable elements in the stream must send\r	the message size: to indicate how many there are.\r*)\r| size <Integer> ::= 0. |)",
 "BasicOutputReadStream",
 "BasicOutputReadStream",
 "public contents ^ <List[E]> = (\r	(* Obsolete: this method is included purely for BlueBook compatibility.  If possible, use\r	 #contentsRemaining and #contentsWritten, which will work when a ReadWriteStream\r	 is substituted for a ReadStream or a WriteStream, unlike this method *)\r\r	^self collection\r)",
 "public contentsWritten ^ <List[E]> = (\r	| cltn <MutableList[E]> origPos <Integer> |\r\r	cltn:: self newCollectionOfSize: self position.\r	origPos:: self position.\r	self position: 0.\r	1 to: origPos do: [:i <Integer> |\r		cltn at: i put: self next.	].\r	self position: origPos.\r	^cltn\r)",
 "public nextPut: el <E> ^ <E> = (\r	(* Subclasses must extend this to do the actual writing of the element.  This impl just keeps track of bookkeeping. *)\r\r	| pos <Integer> |\r	self position: (pos:: self position + 1).\r	pos > self size\r		ifTrue: [ self size: pos ].\r	^el\r)",
 "on: sc <MutableList[E]> ^ <ReadWriteStream[E]> = (\r	(* Create a new read write stream on a sequenceable collection, assuming that it contains no readable elements yet *)\r\r	^self on: sc numElements: 0\r)",
 "on: sc <MutableList[E]> numElements: n <Integer> ^ <ReadWriteStream[E]> = (\r	(* Create a new read write stream on a sequenceable collection, assuming that it contains n readable elements to start *)\r\r	^SeqCltnReadWriteStream on: sc numElements: n\r)",
 "class CharacterInput = (\r(* This mixin adds character specific messages to an InputStream class. *)\r)",
 " ",
 " ",
 "contentsRemaining ^ <String> = (\r	| con <List[Character]> |\r	con:: super contentsRemaining.\r\r	(* %todo use Str below when have first class protocols *)\r	^con isString\r		ifTrue: [ (* guaranteed <Str> *) con ]\r		ifFalse: [ String withAll: con ]\r)",
 "newCollectionOfSize: n <Integer> ^ <String> = (\r	^String(* [E] *) new: n\r)",
 "next: nElements <Integer> ^ <String> = (\r	| con <List[Character]> |\r	con:: super next: nElements.\r	^con isString\r		ifTrue: [ (* guaranteed <Str> *) con ]\r		ifFalse: [ String withAll: con ]\r)",
 "upTo: o <Object> ^ <String> = (\r	| con <List[Character]> |\r	con:: super upTo: o.\r	^con isString\r		ifTrue: [ (* guaranteed <String> *) con ]\r		ifFalse: [ String withAll: con ]\r)",
 "class CharacterInputConverter = CharacterIStream (\r(* Instances are used to create a CharInputStream that wraps a byte input stream\r*)\r| binaryStream <STRM> (* = binaryStrm. *) |)",
 "CharacterIStream",
 "CharacterIStream",
 "actualAtEnd ^ <Boolean> = (\r	^self binaryStream atEnd\r)",
 "actualNext ^ <Character> = (\r	| c <Character> |\r	c:: Character value: self binaryStream next.\r	(usingCrLfConvention and: [ c = Character cr ])\r	ifTrue: [ self binaryStream atEnd\r						ifFalse: [ self binaryStream peek = Character lf asciiValue\r											ifTrue: [ self binaryStream next ]	]].\r	^c\r)",
 "close = (\r	self binaryStream close.\r)",
 "initBinaryStream: binaryStrm <STRM> = (\r	self binaryStream: binaryStrm\r)",
 "upTo: del <Object> ^ <Str> = (\r	| bytes <List[Integer]> s <String> lfs <Integer> j <Integer> delimiter <Character> |\r\r	(self havePeeked and: [ self peek == del ])\r		ifTrue: [ ^super upTo: del ].\r\r	delimiter:: Character coerce: del.\r	bytes:: self binaryStream upTo: delimiter asciiValue.\r\r	usingCrLfConvention\r		ifTrue: [ delimiter == Character cr\r							ifTrue: [ (* If cr was the delim, got to check for reading the lf, since\r											it was at the lower level *)\r											(self binaryStream atEnd not and: [ self binaryStream peek == 10 ])\r												ifTrue: [ self binaryStream next ].\r										].\r					]\r		ifFalse: [ (* self havePeeked\r							ifFalse: [ s:: String new: bytes size.\r											1 to: bytes size do:\r												[:ind <Integer> |\r													s at: ind putUnicode: (bytes at: ind)	].\r										 ]\r							ifTrue:	[ s:: String new: bytes size + 1.\r											1 to: bytes size do:\r												[:ind <Integer> |\r													s at: ind + 1 putUnicode: (bytes at: ind)	].\r											s at: 1 put: self next.\r										 ]\r						^s *)\r					].\r\r	(* Count the line feeds *)\r	lfs:: 0.\r	1 to: bytes size do:\r		[:ind <Integer> |\r			(bytes at: ind) == 10\r				ifTrue: [ lfs:: lfs + 1 ]\r		].\r	self havePeeked\r		ifFalse: [ s:: String new: bytes size - lfs.\r						j:: 1.	 ]\r		ifTrue: [ s:: String new: (bytes size - lfs) + 1.\r						j:: 2.	 ].\r	bytes do:\r		[:b <Integer> |\r			b == 10\r				ifFalse: [ s at: j putUnicode: b.\r								j:: j + 1.	 ]\r		].\r	self havePeeked\r		ifTrue: [ s at: 1 put: self next ].\r	^s\r)",
 "on: binaryStrm <STRM> ^ <Instance> = (\r	^self new initBinaryStream: binaryStrm\r)",
 "public class CharacterInputOutputConverter = OutputInputConverter ()",
 "OutputInputConverter",
 "OutputInputConverter",
 "externalFlush = (\r	self binaryStream externalFlush.\r)",
 "public flush = (\r	self binaryStream flush.\r)",
 "public nextPut: c <Character> ^ <Character> = (\r	self binaryStream nextPut: c asciiValue.\r	 (usingCrLfConvention and: [ c = Character cr ])\r		ifTrue: [ self binaryStream nextPut: Character lf asciiValue ].\r	^c\r)",
 "public position ^ <Integer> = (\r	^self binaryStream position\r)",
 "public position: i <Integer> = (\r	self binaryStream position: i.\r	self noPeekVal.\r)",
 "setToEnd = (\r	self binaryStream setToEnd\r)",
 "public on: binaryStrm <STRM> ^ <Instance> = (\r	^self new initBinaryStream: binaryStrm\r)",
 "class CharacterOutput = (\r(* This mixin adds character specific messages to an OutputStream class. *)\r)",
 " ",
 " ",
 "public cr = (\r	self nextPut: Character cr\r)",
 "public crTab = (\r	self crTab: 1\r)",
 "public crTab: count <Integer> = (\r	count timesRepeat:\r		[ self nextPut: Character cr; nextPut: Character tab	]\r)",
 "public print: o <Object> = (\r	o printOn: self\r)",
 "public space = (\r	self nextPut: Character space\r)",
 "public tab = (\r	self nextPut: Character tab\r)",
 "class CharacterOutputConverter = CharacterOStream (\r| binaryStream <OutputStream[Integer]> (* = bstream. *) |)",
 "CharacterOStream",
 "CharacterOStream",
 "public close = (\r	self binaryStream close.\r)",
 "externalFlush = (\r	self binaryStream externalFlush.\r)",
 "public flush = (\r	self binaryStream flush.\r)",
 "initBinaryStream: binaryStrm <InputStream[Integer]> = (\r(* delete *)\r\r	self binaryStream: binaryStrm\r)",
 "public nextPut: c <Character> ^ <Character> = (\r	self binaryStream nextPut: c asciiValue.\r	 (usingCrLfConvention and: [ c = Character cr ])\r		ifTrue: [ self binaryStream nextPut: Character lf asciiValue ].\r	^c\r)",
 "public on: binaryStrm <OutputStream[Integer]> ^ <Instance> = (\r	^self new initBinaryStream: binaryStrm\r)",
 "public class CharacterReadConverter = CharacterInputConverter (\r(* Like CharacterInputConverter, but takes a ReadStream[Integer] rather than an InputStream[Integer], so that it can do some operations like\rupTo: faster.\r*)\r)",
 "CharacterInputConverter",
 "CharacterInputConverter",
 "numCharsUpToAscii: del <Integer> ^ <Integer> = (\r	(* Num chars from current pos to del, not counting lfs if they shouldn't be.  May leave the position changed. *)\r\r	| n <Integer> sz <Integer> |\r	n:: 0.\r	sz:: self binaryStream size.\r	self binaryStream position + 1 to: sz do:\r		[:i <Integer> |\r			| asc <Integer> |\r			asc:: self binaryStream repositioningAt: i.\r			(usingCrLfConvention and: [ asc == 10 ]) (* lf *)\r				ifFalse: [ asc == del\r									ifTrue: [ ^n ]\r									ifFalse: [ n:: n + 1 ]\r							 ]\r		].\r	^n\r)",
 "upTo: del <Object> ^ <String> = (\r	| sz <Integer> s <String> lfs <Integer> offset <Integer> delimiter <Integer> pos <Integer> bsize <Integer> i <Integer> |\r\r	(self havePeeked and: [ self peek == del ])\r		ifTrue: [ ^super upTo: del ].\r\r	delimiter:: (Character coerce: del) asciiValue.\r	pos:: self binaryStream position.\r\r	(* Scan for the delimiter in the binary stream *)\r	sz:: self numCharsUpToAscii: delimiter.\r\r	self havePeeked\r		ifFalse: [ s:: String new: sz.\r						offset:: 0]\r		ifTrue: [ s:: String new: sz + 1.\r						s at: 1 put: self next.\r						offset:: 1. ].\r\r	pos:: pos + 1.\r	i:: 1.\r	[ i <= sz ]\r		whileTrue: [ | code <Integer> |\r							code:: self binaryStream repositioningAt: pos.\r							s at: i + offset putUnicode: code.\r							i:: i + 1.\r							(code == 13 and: [usingCrLfConvention])\r								ifTrue: [ pos:: pos + 1. ].\r							pos:: pos + 1.	].\r	(* The following fiddly code is to set the binary stream position to pos without\r		going past the end of the stream *)\r	self binaryStream position: pos - 1.\r	self binaryStream atEnd\r		ifFalse: [ self binaryStream next ].\r	^s\r)",
 "public on: binaryStrm <STRM> ^ <Instance> = (\r	^self new initBinaryStream: binaryStrm\r)",
 "class ExternalInputStream = BasicIExStream (\r)",
 "BasicIExStream",
 "BasicIExStream",
 "actualAtEnd ^ <Boolean> = (\r	^self nextBufferPosition >= self bufferNumElements\r)",
 "actualNext ^ <Integer> = (\r	| pos <Integer> byte <Integer> |\r	self actualAtEnd\r		ifTrue: [ self error: 'attempt to read past the end of an external stream' ].\r	pos:: self nextBufferPosition.\r	byte:: self buffer (* byteAt: pos. *) unsignedByteAt: pos+1.\r	pos:: pos + 1.\r	pos >= self bufferSize\r	ifFalse: [ self nextBufferPosition: pos ]\r	ifTrue: [ self advanceBuffer ].\r	^byte\r)",
 "arrangeForFinalization = (\r	(* %todo: arrange for the finalize message to be sent to the stream before gc.\r	Is this right? *)\r	(* self descriptor register. *)\r)",
 "atEnd ^ <Boolean> = (\r	(* Reimplemented for speed since we have ensured that atEnd and actualAtEnd mean\r	  the same thing *)\r\r	^self actualAtEnd\r)",
 "public close = (\r	(* We have to reimplement this because BasicInputStream mixin in an inappropriate version *)\r	self doClose.\r)",
 "fillBuffer = (\r	self bufferNumElements:\r	(self descriptor readAt: self bufferOrigin\r	  ifFail: [:err <ExternalError> | self error: err ]).\r)",
 "public initDescriptor: d <DESCRIPTOR> = (\r	#ACCESSBOGUS.\r\r	super initDescriptor: d.\r	self fillBuffer.\r)",
 "newCollectionOfSize: n <Integer> ^ <ByteArray> = (\r	^ByteArray new: n\r)",
 "public next ^ <Integer> = (\r	(* Reimplemented for speed since we have ensured that next and actualNext mean\r	  the same thing *)\r\r	^self actualNext\r)",
 "peek ^ <Integer> = (\r	(* Reimplement so that we can ensure that next and actualNext are the same, for\r	 speed, since by design we always know we have another buffer byte to look at. *)\r\r	self assert: [ self atEnd not ] message: 'Can''t peak past the end of the stream'.\r	^self buffer unsignedByteAt: self nextBufferPosition + 1 (* byteAt: self nextBufferPosition *)\r)",
 "peekIfAbsent: f <[X def]> ^ <E | X> = (\r	(* Reimplement so that we can ensure that next and actualNext are the same, for\r	 speed, since by design we always know we have another buffer byte to look at. *)\r\r	^self atEnd\r		ifTrue: [ f value ]\r		ifFalse: [ self buffer byteAt: self nextBufferPosition ]\r)",
 "public class ExternalOutputStream = EOStream (\r(* %responsibility #updateBufferLocationAfterFlush\r	This method may have to be reimplemented (for example in read/write streams) depending\r	on whether the buffer contains only written elements, or a mix of read/written elements.\r\r%todo: we must make sure when %finalization is implemented that instances of this class are finalized before their descriptors, so that the buffer can be flushed.  See #finalize. *)\r|\rdirty <Boolean> ::= false. (* indicates whether the buffer contains unflushed modified data *)\r|)",
 "EOStream",
 "EOStream",
 "advanceBufferLocation = (\r	self bufferOrigin: self bufferOrigin + self bufferNumElements;\r		nextBufferPosition: 0;\r		bufferNumElements: 0.\r)",
 "arrangeForFinalization = (\r	(* %todo: arrange for the finalize message to be sent to the stream before gc. *)\r)",
 "public close = (\r	self flush.\r	super close.\r)",
 "externalFlush = (\r	self flush.\r	self descriptor flushIfFail: [:err <ExternalError> | self error: err ]\r)",
 "finalize = (\r	self close\r)",
 "public flush = (\r	self dirty\r		ifTrue: [ self bufferNumElements > 0\r					ifTrue: [ self writeBuffer; updateBufferLocationAfterFlush. 	].\r				self dirty: false.	].\r)",
 "logicalFlush = (\r	self dirty\r	ifTrue: [ self bufferNumElements > 0\r	          ifTrue: [ self writeBuffer; updateBufferLocationAfterFlush. ].\r	      self dirty: false. ].\r)",
 "public nextPut: byte <Integer> ^ <Integer> = (\r	| pos <Integer> |\r	pos:: self nextBufferPosition.\r	(* self buffer byteAt: pos put: byte. *)\r	self buffer unsignedByteAt: pos+1 put: byte.\r\r	pos:: pos + 1.\r	self nextBufferPosition: pos;\r	bufferNumElements: (pos max: self bufferNumElements).\r	pos >= self bufferSize\r	ifTrue: [ self writeBuffer; advanceBuffer; dirty: false]\r	ifFalse: [ self dirty: true ].\r	^byte\r)",
 "updateBufferLocationAfterFlush = (\r	self advanceBufferLocation\r)",
 "public writeBuffer = (\r	(* Caller is responsible for updating dirty *)\r	self descriptor\r	write: self bufferNumElements\r	at: self bufferOrigin\r	ifFail: [:err | self error: err ]\r)",
 "public onDescriptor: d <DESCRIPTOR> ^ <Instance> = (\r	^self new initDescriptor: d\r)",
 "public class ExternalReadStream = EIStream (\r(* %note: the actualPosition slot inherited from BasicReadStream is\rnot used; its access methods are reimplemented to use the\rbuffer origin and buffer position. *)\r)",
 "EIStream",
 "EIStream",
 "actualAtEnd ^ <Boolean> = (\r	(* copied-down implementation from ExternalInputStream for efficiency *)\r	^self nextBufferPosition >= self bufferNumElements\r)",
 "actualPosition ^ <Integer> = (\r	^self bufferOrigin + self nextBufferPosition\r)",
 "actualPosition: p <Integer> = (\r	| bufPos <Integer> |\r	bufPos:: p - self bufferOrigin.\r	(bufPos >= 0 and: [ bufPos < self bufferNumElements ])\r	ifTrue: [ self nextBufferPosition: bufPos ]\r	ifFalse: [ (* We need to reload the buffer *)\r					self assert: [ p between: 0 and: self size ] message: ''.\r	          self writeIfNeededBeforePositionChange.\r	          self bufferOrigin: (self goodBufferOriginForPosition: p).\r	          self descriptor position: self bufferOrigin.\r	          self fillBuffer.\r	          self nextBufferPosition: p - self bufferOrigin. ].\r)",
 "at: index <Integer> ^ <Integer> = (\r	| i <Integer> |\r	i:: index - self bufferOrigin.\r	^(i < 1 or: [ i > self bufferNumElements ])\r		ifFalse: [ self buffer byteAt: i - 1 ]\r		ifTrue: [ | pos <Integer> result <Integer> |\r						pos:: self position.\r						self position: index - 1.\r						(* Use a recursive call, which should now be in range *)\r						result:: self at: index.\r						self position: pos.\r						result	]\r)",
 "goodBufferOriginForPosition: nextPos <Integer> ^ <Integer> = (\r	(* Try to keep the origin on a buffer-aligned boundary *)\r	^nextPos - (nextPos \\\\ self bufferSize)\r)",
 "initializeActualPosition = (\r	(* disable initialization, since we don't use the inherited actualPosition instance variable *)\r)",
 "repositioningAt: index <Integer> ^ <Integer> = (\r	| i <Integer> |\r	i:: index - self bufferOrigin.\r	^(i < 1 or: [ i > self bufferNumElements ])\r		ifFalse: [ self buffer byteAt: i - 1 ]\r		ifTrue: [ self position: index - 1.\r						self at: index ]\r)",
 "public size ^ <Integer> = (\r	^self descriptor size\r)",
 "writeIfNeededBeforePositionChange = (\r	(* This is a hook for mutable subclasses to do any buffer flushing necessary before\r	 the buffer is repositioned.  By default, do nothing *)\r)",
 "public onDescriptor: d <DESCRIPTOR> ^ <Instance> = (\r	^self new initDescriptor: d\r)",
 "public class ExternalReadWriteStream = EIOStream (\r(* Implements positionable streams of bytes from an external source.  Currently, this class is used both\rfor read-only streams and read-write streams, with different creation messages. *)\r)",
 "EIOStream",
 "EIOStream",
 "public contents ^ <List[Integer]> = (\r	(* Obsolete: this method is included purely for BlueBook compatibility.  If possible, use\r	 #contentsRemaining and #contentsWritten, which will work when a ReadWriteStream\r	 is substituted for a ReadStream or a WriteStream, unlike this method *)\r\r	^self collection\r)",
 "contentsWritten ^ <List[Integer]> = (\r	(* %copied (substituting for E) from BasicReadWriteStream *)\r	| cltn <VarSeqCltn[Integer]> origPos <Integer> |\r	cltn:: self newCollectionOfSize: self position.\r	origPos:: self position.\r	self position: 0.\r	1 to: origPos do: [:i <Integer> |\r	cltn at: i put: self next. ].\r	self position: origPos.\r	^cltn\r)",
 "public size ^ <Integer> = (\r	(* Make sure we flush our buffer if needed to ensure that\r	 the buffer contents are taken into account *)\r\r	self flush.\r	^super size\r)",
 "public updateBufferLocationAfterFlush = (\r	#ACCESSBOGUS.\r	(* We don't advance the buffer here because we need to preserve the read semantics *)\r)",
 "writeIfNeededBeforePositionChange = (\r	self dirty\r	ifTrue: [ self writeBuffer; dirty: false. ].\r)",
 "public onDescriptor: d <DESCRIPTOR> ^ <Instance> = (\r	^self new initDescriptor: d\r)",
 "class ExternalStream = Object (\r(* This is the abstract superclass for all external stream classes.  It\rprovides buffer management for subclasses.   Library users don't normally directly instantiate ExternalStreams,\rsince that exposes you to genericity and raw ExternalDescriptors; instead, more appropriate entry points\rsuch as readStream/writeStream/readWriteStream are implemented for the various kinds of external objects\rthat can be streamed over, such as File.\r\rInvariant: the buffer position is always less than the index of the last buffer element.   This is accomplished by proactively filling/flushing the buffer when the end is reached.\r\r%responsibility #arrangeForFinalization\r	Subclasses should reimplement this appropriately to do any finalization registration\r	to ensure that the stream is closed when it is garbage collected. *)\r|\rdescriptor <DESCRIPTOR> (* = d. *)\rbuffer <ExternalProxy> (* I/O buffer, cached from descriptor for speed (0 indexed) *)\rbufferSize <Integer> (* I/O buffer size, cached from descriptor for speed *)\rbufferOrigin <Integer> (* the offset between position and buffer coordinates *)\rpublic nextBufferPosition <Integer> (* The actual position, in buffer coordinates, of the next element (i.e. position + 1 in buffer coords) *)\rpublic bufferNumElements <Integer> (* The number of valid data bytes in the buffer *)\r|)",
 "Object",
 "Object",
 "advanceBuffer = (\r	(* advance the buffer, and fill it if the receiver is readable.  Assumption: the last advanceBuffer completely\r	filled the buffer *)\r	self bufferOrigin: self bufferOrigin + self bufferSize.\r	self fillBuffer.\r	self nextBufferPosition: 0.\r)",
 "arrangeForFinalization = (\r	(* Subclasses should reimplement this appropriately to do any finalization registration\r	  to ensure that the stream is closed when it is garbage collected. *)\r\r	self subclassResponsibility\r)",
 "public close = (\r	self doClose\r)",
 "doClose = (\r	(* This is factored out from close so that subclasses that mixin BasicInputStream can reimplement close to call this *)\r	self descriptor close.\r	buffer:: nil.\r)",
 "fillBuffer = (\r	(* fill the buffer if needed (this default implementation works for noninput streams) *)\r\r	self bufferNumElements: 0\r)",
 "initBuffer = (\r	buffer:: descriptor buffer.\r	bufferSize:: descriptor bufferSize.\r	self arrangeForFinalization.\r)",
 "initDescriptor: d <DESCRIPTOR> = (\r	self descriptor: d.\r	self initBuffer.\r\r	self bufferOrigin: 0.\r	self bufferNumElements: 0.\r	self nextBufferPosition: 0.\r)",
 "postCopy = (\r	super postCopy.\r	self descriptor: self descriptor copy.\r	self initBuffer.\r)",
 "onDescriptor: d <DESCRIPTOR> ^ <Instance> = (\r	^self new initDescriptor: d\r)",
 "public class SeqCltnReadStream = BasicReadStream (\r(* This is the standard concrete class used for creating ReadStreams on lists. *)\r| collection <List[E]> (* = sc. *) |)",
 "BasicReadStream",
 "BasicReadStream",
 "accumulateUntil: predicate <[Boolean]> ^ <List[E]> = (\r	| start <Integer> |\r\r	start:: self position.\r	[ predicate value ]\r		whileFalse: [ self position: self position + 1 ].\r	^self collection copyFrom: start + 1 to: self position\r)",
 "public actualNext ^<E> = (\r	| pos <Integer> |\r	pos:: self actualPosition.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ self error: 'Attempt to read past the end of a stream' ].\r	self actualPosition: pos.\r	^self collection at: pos\r)",
 "at: index <Integer> ^ <E> = (\r	^self collection at: index\r)",
 "public atEnd ^<Boolean> = (\r	(* %optimization: we can ensure that atEnd and actualAtEnd are identical, since we reimplement peek to avoid the superclass\r	  peek buffer, because we can look ahead quickly in a seqcltn *)\r	^self actualAtEnd\r)",
 "public initCollection: sc <List[E]> = (\r	collection:: sc.\r)",
 "public next ^<E> = (\r	(* %optimization: we can ensure that next and actualNext are identical, since we reimplement peek to avoid the superclass\r	  peek buffer, since we can look ahead quickly in a seqcltn *)\r	^self actualNext\r)",
 "nextFromPeek ^ <E> = (\r	(* If this happens, you should have overridden the calling method *)\r	self shouldNotHappen\r)",
 "public nextIfAbsent: f <[X def]> ^ <E | X> = (\r	| pos <Integer> |\r	pos:: self actualPosition.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ ^f value ].\r	self actualPosition: pos.\r	^self collection at: pos\r)",
 "public peek ^<E> = (\r	| pos <Integer> |\r	pos:: self position.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ self error: 'Attempt to read past the end of a stream' ].\r	^self collection at: pos\r)",
 "peekIfAbsent: f <[X def]> ^ <E | X> = (\r	| pos <Integer> |\r	pos:: self position.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ ^f value ].\r	^self collection at: pos\r)",
 "peekVal ^ <E> = (\r	self shouldNotHappen\r)",
 "public position: p <Integer> = (\r	self actualPosition: p.\r	(* Don't have to unset the peekVal *)\r)",
 "public printOn: strm <CharOutputStream> = (\r	strm nextPutAll: self class name;\r			nextPutAll: '(position='; 	print: self position;\r			nextPutAll: ' collection=';  print: self collection;\r			nextPut: \")\"\r)",
 "public size ^<Integer> = (\r	^self collection size\r)",
 "public on: sc <List[E]> ^<ReadStream[E]> = (\r	^self over: sc\r)",
 "over: sc <List[E]> ^ <Instance> = (\r	(* This is like on: except it returns type Instance.   on: for streams may return a non-instance type. *)\r\r	^self new initCollection: sc\r)",
 "public class SeqCltnReadWriteStream = BasicReadWriteStream (\r(* This is the standard concrete class used for creating WriteStreams or ReadWriteStreams on lists. *)\r| buffer <MutableList[E]> (* = sc *) |)",
 "BasicReadWriteStream",
 "BasicReadWriteStream",
 "accumulateUntil: predicate <[Boolean]> ^ <List[E]> = (\r	| start <Integer> |\r\r	start:: self position.\r	[ predicate value ]\r		whileFalse: [ self position: self position + 1 ].\r	^self buffer copyFrom: start + 1 to: self position\r)",
 "actualNext ^ <E> = (\r	| pos <Integer> |\r	pos:: self actualPosition.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ self error: 'Attempt to read past the end of a stream' ].\r	self actualPosition: pos.\r	^self buffer at: pos\r)",
 "at: index <Integer> ^ <E> = (\r	self assert: [ index <= self size ].\r	^self buffer at: index\r)",
 "public atEnd ^ <Boolean> = (\r	(* %optimization: we can ensure that atEnd and actualAtEnd are identical, since we reimplement peek to avoid the superclass\r	  peek buffer, because we can look ahead quickly in a seqcltn *)\r	^self actualAtEnd\r)",
 "collection ^ <MutableList[E]> = (\r	^self buffer copyFrom: 1 to: self size\r)",
 "public contents ^ <List[E]> = (\r	(* Obsolete: this method is included purely for BlueBook compatibility.  If possible, use\r	 #contentsRemaining and #contentsWritten, which will work when a ReadWriteStream\r	 is substituted for a ReadStream or a WriteStream, unlike this method *)\r\r	(* This originally referred to contentsWritten. The result of 'contents' should not depend on how much of a stream has already been read, see Blue Book - Protocol for Streams *)\r\r	^self collection\r)",
 "public initBuffer: sc <MutableList[E]> = (\r	buffer:: sc.\r)",
 "next ^ <E> = (\r	(* %optimization: we can ensure that next and actualNext are identical, since we reimplement peek to avoid the superclass\r	  peek buffer, since we can look ahead quickly in a seqcltn *)\r	^self actualNext\r)",
 "nextFromPeek ^ <E> = (\r	(* If this happens, you should have overridden the calling method *)\r	self shouldNotHappen\r)",
 "public nextIfAbsent: f <[X def]> ^ <E | X> = (\r	| pos <Integer> |\r	pos:: self actualPosition.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ ^f value ].\r	self actualPosition: pos.\r	^self buffer at: pos\r)",
 "nextPut: el <E> ^ <E> = (\r	| pos <Integer> |\r	super nextPut: el.\r	(pos:: self position) > self buffer size\r		ifTrue: [ self initBuffer: (self buffer copyWithSize: (self buffer size * 2 max: 8)) ].\r	self buffer at: pos put: el.\r	^el\r)",
 "peek ^ <E> = (\r	| pos <Integer> |\r	pos:: self position.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ self error: 'Attempt to read past the end of a stream' ].\r	^self buffer at: pos\r)",
 "peekIfAbsent: f <[X def]> ^ <E | X> = (\r	| pos <Integer> |\r	pos:: self position.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ ^f value ].\r	^self buffer at: pos\r)",
 "peekVal ^ <E> = (\r	self shouldNotHappen\r)",
 "position: p <Integer> = (\r	self actualPosition: p.\r	(* Don't have to unset the peekVal *)\r)",
 "public printOn: strm <CharOutputStream> = (\r	strm nextPutAll: self class name;\r			nextPutAll: '(position='; 	print: self position;\r			nextPutAll: ' buffer=';  print: self buffer;\r			nextPut: \")\"\r)",
 "on: sc <MutableList[E]> ^ <ReadWriteStream[E]> = (\r	^self over: sc\r)",
 "on: sc <MutableList[E]> numElements: n <Integer> ^ <ReadWriteStream[E]> = (\r	^(self over: sc) size: n\r)",
 "over: sc <MutableList[E]> ^ <Instance> = (\r	(* This is like on: except it returns type Instance.   on: for streams may return a non-instance type. *)\r\r	^self new initBuffer: sc\r)",
 "public class TempTranscript = CharacterOStream (\r(* This probably doesn't belong here.  *)\r)",
 "CharacterOStream",
 "CharacterOStream",
 "public cr = (\r	(* self nextPut: Character cr. *)\r	self nextPut: Character lf.\r)",
 "public nextPut: c <Character> ^ <Character> = (\r	c unicodeValue printCharacter.\r	c == Character cr\r		ifTrue: [ Character lf unicodeValue printCharacter. ].\r)",
 "public show: s <Collection[Character]> ^ <Collection[Object]> = (\r	self nextPutAll: s.\r	^s\r)",
 "class Particles packageUsing: manifest = (\r	|\r	private hopscotchRuntime = manifest HopscotchForHTML5Runtime packageUsing: manifest.\r	|\r)",
 " ",
 " ",
 "public main: platform args: args = (\r	| hopscotchPlatform world |\r	hopscotchPlatform:: hopscotchRuntime using: platform.\r	world:: World usingPlatform: hopscotchPlatform.\r	hopscotchPlatform hopscotch core HopscotchWindow openSubject:\r		(world WorldSubject onModel:\r			(world World withExtent: (hopscotchPlatform graphics Point x: 800 y: 600))).\r)",
 "class World usingPlatform: p = (|\rTimer = p actors Timer.\rPoint = p graphics Point.\rColor = p graphics Color.\rList = p collections List.\rSubject = p hopscotch core Subject.\rPresenter = p hopscotch core Presenter.\rMath = p js global at: 'Math'.\rtau = 6.28318530718 asFloat.\r|)",
 " ",
 " ",
 "class Atom = (|\rpublic x ::= Math random * 800.\rpublic y ::= Math random * 600.\rpublic vx ::= (Math random - 0.5) * 6.\rpublic vy ::= (Math random - 0.5) * 6.\rpublic m = Math random * 150 + 5.\rpublic r = m sqrt + 1.\rpublic color = Color r: Math random g: Math random b: Math random.\r|)",
 " ",
 " ",
 "public collideWith: b = (\r	| a = self. dx dy R distance overlap ox oy e dvx dvy top bottom j |\r\r	dx:: a x - b x.\r	dy:: a y - b y.\r	R:: a r + b r.\r	(dx*dx) + (dy*dy) > (R*R) ifTrue: [^self].\r\r	distance:: ((dx*dx) + (dy*dy)) sqrt.\r	overlap:: R - distance.\r	ox:: overlap * dx / distance.\r	oy:: overlap * dy / distance.\r\r	a x: (a x + (ox / 2)).\r	a y: (a y + (oy / 2)).\r	b x: (b x - (ox / 2)).\r	b y: (b y - (oy / 2)).\r\r	dvx:: a vx - b vx.\r	dvy:: a vy - b vy.\r	e:: 1.\r\r	top:: (-1*(1+e)) * ((dvx*dx) + (dvy*dy)).\r	bottom:: ((1 / a m) + (1 / b m)) * ((dx*dx) + (dy*dy)).\r	j:: top/bottom.\r\r	a vx: (a vx + ((j / a m)*dx)).\r	a vy: (a vy + ((j / a m)*dy)).\r	b vx: (b vx - ((j / b m)*dx)).\r	b vy: (b vy - ((j / b m)*dy)).\r)",
 "public drawOn: gc = (\r	gc fillStyle: color.\r	gc beginPath.\r	gc arcAt: (Point x: x y: y) radius: r from: 0 to: tau.\r	gc fill.\r)",
 "public tick = (\r	x:: x + vx.\r	y:: y + vy.\r\r	x < r ifTrue: [vx:: vx abs].\r	x > (800 - r) ifTrue: [vx:: vx abs * -1].\r	y < r ifTrue: [vy:: vy abs].\r	y > (600 - r) ifTrue: [vy:: vy abs * -1].\r\r	vx abs > 16 ifTrue: [vx: vx * 0.9].\r	vy abs > 16 ifTrue: [vy: vy * 0.9].\r)",
 "public class World withExtent: e = (\r|\r	extent = e.\r	public atoms = List new.\r	timer\r|\r	10 timesRepeat: [atoms add: Atom new].\r)",
 " ",
 " ",
 "public drawOn: gc = (\r	gc fillStyle: (Color r: 0 g: 0 b: 0 a: 0.12 asFloat).\r	gc beginPath.\r	gc rectangle: ((Point x: 0 y: 0) corner: extent).\r	gc fill.\r	atoms do: [:atom | atom drawOn: gc].\r)",
 "public tick = (\r	1 to: atoms size -1 do: [:i |\r		i + 1 to: atoms size do: [:j |\r			(atoms at: i) collideWith: (atoms at: j).\r		].\r	].\r\r	atoms do: [:atom | atom tick].\r)",
 "class WorldPresenter onSubject: s = Presenter onSubject: s ()",
 "onSubject: s",
 "onSubject: s",
 "definition = (\r	| c |\r	c:: canvas: (Point x: 800 y: 600).\r	Timer every: 30 do: [:timer | subject model tick. subject model drawOn: c context].\r	^column: {\r		c.\r		link: 'Add Atom' action: [subject model atoms add: Atom new].\r		link: 'Remove Atom' action: [subject model atoms removeFirst].\r	}\r)",
 "public class WorldSubject onModel: m = Subject onModel: m ()",
 "onModel: m",
 "onModel: m",
 "createPresenter = (\r	^WorldPresenter onSubject: self\r)",
 "public model = (\r	^super model\r)",
 "class HopscotchForHTML5Runtime packageUsing: manifest = (\r	|\r	private Graphics = manifest GraphicsForHTML5.\r	private TextModule = manifest TextModule.\r	private Hopscotch = manifest HopscotchForHTML5.\r	private images = Images packageUsing: manifest.\r	|\r)",
 " ",
 " ",
 "public using: platform = (\r	^PlatformWithHopscotch usingPlatform: platform\r)",
 "class Images packageUsing: manifest = (\r|\r	public accept16px = manifest accept16px.\r	public cancel16px = manifest cancel16px.\r	public disclosureClosedImage = manifest disclosureClosedImage.\r	public disclosureTransitionImage = manifest disclosureTransitionImage.\r	public disclosureOpenImage = manifest disclosureOpenImage.\r	public dropDownImage = manifest hsDropdownImage.\r	public dropDownOutImage = manifest hsDropdownOutImage.\r	public dropDownOverImage = manifest hsDropdownOverImage.\r|\r)",
 " ",
 " ",
 "class PlatformWithHopscotch usingPlatform: platform = (\r	|\r	private platform = platform.\r	public graphics = Graphics usingPlatform: self.\r	public text = TextModule usingPlatform: self.\r	public hopscotch = Hopscotch usingPlatform: self images: images.\r	|\r)",
 " ",
 " ",
 "public actors = ( ^platform actors )",
 "public collections = ( ^platform collections )",
 "public js = ( ^platform js )",
 "public kernel = ( ^platform kernel )",
 "public mirrors = ( ^platform mirrors )",
 "public operatingSystem = ( ^platform operatingSystem )",
 "class GraphicsForHTML5 usingPlatform: p = (\r(*\rCore graphics support for Newspeak.\r\rCopyright Google Inc. 2015 - 2017\r*)\r|\rdocument = p js global at: 'document'.\r|)",
 " ",
 " ",
 "public class Canvas width: w height: h = (\r|\r	private alien ::= document createElement: 'canvas'.\r|\r	alien at: 'width' put: w.\r	alien at: 'height' put: h.\r	(alien at: 'style') at: 'position' put: 'relative'.\r)",
 " ",
 " ",
 "public context = (\r	^Context on: (alien getContext: '2d')\r)",
 "public mouseDownAction: onMouseDown <[:Point]> = (\r	alien addEventListener: 'mousedown' action:\r		[:event | onMouseDown value: (Point x: (event at: 'offsetX') y: (event at: 'offsetY')). nil].\r)",
 "public mouseMovedAction: onMouseMoved <[:Point]> = (\r	alien addEventListener: 'mousemove' action:\r		[:event | onMouseMoved value: (Point x: (event at: 'offsetX') y: (event at: 'offsetY')). nil].\r)",
 "public class Color scaledR: r g: g b: b a: a = (|\rpublic red <Integer> = r.\rpublic green <Integer> = g.\rpublic blue <Integer> = b.\rpublic alpha <Integer> = a.\r|)",
 " ",
 " ",
 "public applyToStyle: style = (\r	style setProperty: 'background-color' to: self asCSSString\r)",
 "public asCSSString = (\r	^'rgba(', red printString, ',', green printString, ',', blue printString, ',', alpha printString, ')'\r)",
 "public black = (\r	^self scaledR: 0 g: 0 b: 0 a: 255\r)",
 "public blue = (\r	^self scaledR: 0 g: 0 b: 255 a: 255\r)",
 "public blue: brightness = (\r	^self scaledR: 0 g: 0 b: brightness a: 255\r)",
 "public gray = (\r	^self r: 0.5 g: 0.5 b: 0.5\r)",
 "public gray: brightness = (\r	^self r: brightness g: brightness b: brightness\r)",
 "public h: hue s: saturation v: brightness = (\r	| s v hf i f p q t |\r	s:: (saturation asFloat max: 0.0) min: 1.0.\r	v:: (brightness asFloat max: 0.0) min: 1.0.\r\r	(* zero saturation yields gray with the given brightness *)\r	s = 0.0 ifTrue: [ ^self r: v g: v b: v ].\r\r	hf:: hue asFloat.\r	(hf < 0.0 or: [hf >= 360.0])\r		ifTrue: [hf:: hf \\\\ 360].\r	hf:: hf / 60.0.\r	i:: hf asInteger. (* integer part of hue *)\r	f:: hf - i. (* hf fractionPart. *)  (* fractional part of hue *)\r	p:: (1.0 - s) * v.\r	q:: (1.0 - (s * f)) * v.\r	t:: (1.0 - (s * (1.0 - f))) * v.\r\r	0 = i ifTrue: [ ^self r: v g: t b: p ].\r	1 = i ifTrue: [ ^self r: q g: v b: p ].\r	2 = i ifTrue: [ ^self r: p g: v b: t ].\r	3 = i ifTrue: [ ^self r: p g: q b: v ].\r	4 = i ifTrue: [ ^self r: t g: p b: v ].\r	5 = i ifTrue: [ ^self r: v g: p b: q ].\r\r	Error signal: 'implementation error'.\r)",
 "public magenta = (\r	^self r: 139 g: 0 b: 139 a: 255\r)",
 "public orange = (\r	^self scaledR: 255 g: 165 b: 0 a: 255\r)",
 "public r: r g: g b: b = (\r	^self scaledR: (r * 255) floor g: (g * 255) floor b: (b * 255) floor a: 255\r)",
 "public r: r g: g b: b a: a = (\r	^self scaledR: (r * 255) floor g: (g * 255) floor b: (b * 255) floor a: a\r)",
 "public red = (\r	^self scaledR: 255 g: 0 b: 0 a: 255\r)",
 "public red: brightness = (\r	^self scaledR: brightness g: 0 b: 0 a: 255\r)",
 "public white = (\r	^self scaledR: 255 g: 255 b: 255 a: 255\r)",
 "public class Context on: a = (|\ralien = a.\r|)",
 " ",
 " ",
 "public arcAt: center radius: radius from: startAngle to: stopAngle = (\r	alien arc: center x with: center y with: radius with: startAngle with: stopAngle\r)",
 "public beginPath = (\r	alien beginPath.\r)",
 "public fill = (\r	alien fill.\r)",
 "public fillStyle: c <Color> = (\r	alien at: 'fillStyle' put: c asCSSString.\r)",
 "public fillText: string at: p = (\r	alien fillText: string with: p x with: p y\r)",
 "public lineTo: p = (\r	alien lineTo: p x with: p y\r)",
 "public moveTo: p = (\r	alien moveTo: p x with: p y\r)",
 "public rectangle: r = (\r	alien rect: r origin x with: r origin y with: r extent x with: r extent y\r)",
 "public stroke = (\r	alien stroke.\r)",
 "public strokeStyle: c <Color> = (\r	alien at: 'strokeStyle' put: c asCSSString\r)",
 "public class Point x: xCoord y: yCoord = (|\rpublic x <Number> = xCoord.\rpublic y <Number> = yCoord.\r|)",
 " ",
 " ",
 "public = other <Object> ^<Boolean> = (\r	^other isPoint and: [x = other x and: [y = other y]]\r)",
 "public corner: corner <Point> ^<Rectangle> = (\r	^Rectangle origin: self corner: corner\r)",
 "public extent: extent <Point> ^<Rectangle> = (\r	^Rectangle origin: self extent: extent\r)",
 "public hash ^<Integer> = (\r	^x hash bitXor: y hash\r)",
 "public isPoint ^<Boolean> = (\r	^true\r)",
 "public printString ^<String> = (\r	^x printString, ' @ ', y printString\r)",
 "public r ^<Number> = (\r	^((x*x) + (y*y)) sqrt\r)",
 "public theta ^<Number> = (\r	Error signal: 'Unimplemented'\r)",
 "public r: r <Number> theta: theta <Number> ^<Point> = (\r	^self x: r * theta cos y: r * theta sin\r)",
 "public zero ^<Point> = (\r	^self x: 0 y: 0\r)",
 "public class Rectangle origin: o corner: c = (|\rpublic origin <Point> = o.\rpublic corner <Point> = c.\r|)",
 " ",
 " ",
 "public = other ^<Boolean> = (\r	^other isRectangle and: [origin = other origin and: [corner = other corner]]\r)",
 "public center = (\r	^Point x: origin x + ((corner x - origin x) / 2) y: origin y + ((corner y - origin y) / 2)\r)",
 "public containsPoint: p = (\r	^((origin x <= p x\r		and: [origin y <= p y])\r		and: [corner x >= p x])\r		and: [corner y >= p y]\r)",
 "public extent = (\r	^Point x: corner x - origin x y: corner y - origin y\r)",
 "public hash ^<Integer> = (\r	^origin hash bitXor: corner hash\r)",
 "public insetBy: delta = (\r	^Rectangle\r		origin: (Point x: origin x + delta x y: origin y + delta y)\r		corner: (Point x: corner x - delta x y: corner y - delta y)\r)",
 "public isRectangle ^<Boolean> = (\r	^true\r)",
 "public printString ^<String> = (\r	^'Rectangle origin: ', origin printString, ' corner: ', corner printString\r)",
 "public origin: o <Point> extent: e <Point> ^<Rectangle> = (\r	^self origin: o corner: (Point x: o x + e x y: o y + e y)\r)",
 "class TextModule usingPlatform: p <Platform> = (\r(*\rTop level module for text, HTML version. Experimental.\rCopyright 2016-2017 Google Inc.\r*)\r)",
 " ",
 " ",
 "public class Text properties: tps = (\r(*Abstract supertype of all texts.*)\r|\r	public textProperties <TextProperties> = tps.\r|)",
 " ",
 " ",
 "public isKindOfText ^ <Boolean> = (\r	^true\r)",
 "public textUnits ^ <List[Fragment]> = (\r	^self subclassResponsibility\r)",
 "public class TextBlock units: tus <List[Text]> properties: tps <TextProperties> = Text properties: tps (\r|\r	 public textUnits <List[Text]> = tus.\r|)",
 "properties: tps",
 "properties: tps",
 "public cloneWithDefaultProperties: tps <TextProperties> ^ <Self> = (\r	^self class units: immediateTextUnits properties: (tps supplyDefaultsFor: textProperties)\r)",
 "public elementaryTextUnits ^ <List[Text]> = (\r	^textUnits flatMap: [:u <Text> |\r		u isKindOfText ifTrue: [(u cloneWithDefaultProperties: textProperties) elementaryTextUnits] ifFalse: [u]\r		].\r)",
 "public isKindOfTextBlock ^ <Boolean> = (\r	^true\r)",
 "public string ^ <String> = (\r	^textUnits inject: '' into: [:s1 :s2 | s1, s2 string].\r)",
 "public forString: s <String> ^ <Instance> = (\r	^units: {TextString forString: s}\r)",
 "public units: tus <List[Text]> ^ <Instance> = (\r	^self units: tus properties: TextProperties new\r)",
 "public class TextProperties = (\r(*The properties of text: font, weight, color, size etc.*)\r|\r	public font\r	public weight <Symbol>\r	public style <Symbol>\r	public pointSize <Integer>\r	public color <Color>\r	public strikeThrough <Boolean>\r	public underline <Boolean>\r|)",
 " ",
 " ",
 "public applyTo: element <HTMLElement> = (\r	| styleElement = element at: 'style'. |\r	styleElement setProperty: 'white-space' to: 'pre-wrap'.\r	font isNil ifFalse: [styleElement setProperty: 'font-family' to: font].\r	pointSize isNil ifFalse: [styleElement setProperty: 'font-size' to: pointSize printString, 'pt'].\r	weight isNil ifFalse: [styleElement setProperty: 'font-weight' to: weight].\r	style isNil ifFalse: [styleElement setProperty: 'font-style' to: style].\r	color isNil ifFalse: [\r		styleElement setProperty: 'color' to: 'rgb(', color red printString, ', ', color green printString, ', ', color blue printString, ')'\r		].\r	 strikeThrough isNil ifFalse: [\r		 strikeThrough ifTrue: [styleElement setProperty: 'text-decoration' to: 'line-through']\r		].\r	underline isNil ifFalse: [\r		underline ifTrue: [styleElement setProperty: 'text-decoration' to: 'underline']\r		].\r)",
 "public applyToText: t <Text> = (\r	| tProperties <TextProperties> = t textProperties. |\r	tProperties font isNil ifTrue: [tProperties font: font].\r	tProperties weight isNil ifTrue: [tProperties weight: weight].\r	tProperties pointSize isNil ifTrue: [tProperties pointSize: pointSize].\r	tProperties color isNil ifTrue: [tProperties color: color].\r	tProperties strikeThrough isNil ifTrue: [tProperties strikeThrough: strikeThrough].\r	tProperties underline isNil ifTrue: [tProperties underline: underline].\r)",
 "public clone ^ <Self> = (\r	^self class new\r		font: font;\r	 	weight: weight;\r		pointSize: pointSize;\r		color: color;\r		strikeThrough: strikeThrough;\r		underline: underline;\r		yourself\r)",
 "public supplyDefaultsFor: tps <TextProperties> = (\r	| tProperties <TextProperties> = tps clone. |\r\r	tProperties font isNil ifTrue: [tProperties font: font].\r	tProperties weight isNil ifTrue: [tProperties weight: weight].\r	tProperties pointSize isNil ifTrue: [tProperties pointSize: pointSize].\r	tProperties color isNil ifTrue: [tProperties color: color].\r	tProperties strikeThrough isNil ifTrue: [tProperties strikeThrough: strikeThrough].\r	tProperties underline isNil ifTrue: [tProperties underline: underline].\r)",
 "public class TextString forString: s <String> properties: tps = Text properties: tps (\r|\r	public string <String> = s.\r|)",
 "properties: tps",
 "properties: tps",
 "public cloneWithDefaultProperties: tps <TextProperties> ^ <Self> = (\r	^self class forString: string properties: (tps supplyDefaultsFor: textProperties)\r)",
 "public elementaryTextUnits ^ <List[Fragment]> = (\r	^{self}\r)",
 "public isKindOfTextString ^ <Boolean> = (\r	^true\r)",
 "public forString: s <String> ^ <Instance> = (\r	^forString: s properties: TextProperties new\r)",
 "class HopscotchForHTML5 usingPlatform: p images: images = (\r(* Hopscotch is Newspeak's UI framework. This version is implemented on top of HTML and CSS.\r\rCopyright Google Inc. 2012 -2017\r*)\r|\r	private Color = p graphics Color.\r	private Context = p graphics Context.\r	private Timer = p actors Timer.\r	private List = p collections List.\r	private Map = p collections Map.\r	private Set = p collections Set.\r	private TextBlock = p text TextBlock.\r	private TextProperties = p text TextProperties.\r	private TextString = p text TextString.\r	private window = p js global.\r	private document = window at: 'document'.\r	JSObject = p js global at: 'Object'.\r	private CodeMirror = window at: 'CodeMirror'.\r	private body = document at: 'body'.\r	private history = window at: 'history'.\r	sharedNavigationHistory\r	embeddedWindowMap = Map new.\r	sharedBackButtonListener\r	currentHopscotchWindow\r\r	private accept16px = images accept16px.\r	private cancel16px = images cancel16px.\r	private disclosureClosedImage = images disclosureClosedImage.\r	private disclosureTransitionImage = images disclosureTransitionImage.\r	private disclosureOpenImage = images disclosureOpenImage.\r	public dropDownImage = images dropDownImage.\r	public dropDownOutImage = images dropDownOutImage.\r	public dropDownOverImage = images dropDownOverImage.\r\r	private deferredContentQueue = List new.\r	public core = self. (* Polymorphic with HopscotchForBrazil *)\r	public fragments = self. (* Polymorphic with HopscotchForBrazil *)\r	|)",
 " ",
 " ",
 "computeContentForMenu: menuSupplier <[Menu]> ^ <Alien[Div]> = (\r	| dropDownContent = document createElement: 'div'. |\r	(dropDownContent at: 'style')\r		at: 'color' put: 'black';\r		at: 'backgroundColor' put: 'lightgray';\r		at: 'position' put: 'absolute';\r		at: 'z-index' put: 1;\r		at: 'padding-left' put: '6px';\r		at: 'padding-right' put: '10px';\r		at: 'border-radius' put: '5px';\r		at: 'box-shadow' put: '5px 5px 5px darkgrey';\r		at: 'display' put: 'none'.\r	menuSupplier value do: \r		[:menuItem <MenuItem | Symbol> |\r		 | itemContent <Alien[Element]> |\r		 itemContent:: contentFor: menuItem within: dropDownContent.\r		 dropDownContent appendChild: itemContent].\r	^dropDownContent\r)",
 "contentFor: menuItem < MenuItem | Symbol> within: dropDownContent ^ <Alien[Element]> = (\r	| entry |\r	menuItem = #separator ifTrue:\r		[^document createElement: 'hr'].\r	entry:: document createElement: 'div'.\r	entry at: 'textContent' put: menuItem first.\r	entry\r		addEventListener: 'mouseover' action:\r			[:event | (entry at: 'style') at: 'background-color' put: 'darkgrey'. nil];\r	      addEventListener: 'mouseout' action:\r			[:event | (entry at: 'style') at: 'background-color' put: 'lightgrey'. nil];\r		addEventListener: 'click' action:\r			[:event | menuItem last value. nil].\r	^entry\r)",
 "deferAction: action = (\r	deferredContentQueue add: action.\r	deferredContentQueue size = 1 ifTrue:\r		[nextFrameDo: [nextDeferredAction]].\r)",
 "nextDeferredAction = (\r	| action = deferredContentQueue removeFirst. |\r	deferredContentQueue size > 0 ifTrue:\r		[nextFrameDo: [nextDeferredAction]].\r	action value.\r)",
 "nextFrameDo: action <[]> = (\r	(* Our goal is to run the argument after images have been loaded and rendered. window.requestAnimationFrame runs the callback *before* the next frame. We register another callback in the callback so the first deferred action runs *after* the next frame. We register *that* callback in another RAF callback to let new images added from a deferred block load and render before the next deferred block runs. RAF is also a relative new feature, so simply schedule a timer if it is not available. *)\r	(window at: 'requestAnimationFrame') isUndefined ifTrue:\r		[Timer after: 200 do: action. ^self].\r\r	window requestAnimationFrame:\r		[:time1 <Float> | window requestAnimationFrame:\r			[:time2 <Float> | window requestAnimationFrame:\r				[:time3 <Float> | action value. nil]]].\r)",
 "sharedNavigator ^ <NavigationHistory> = (\r	nil = sharedNavigationHistory ifTrue:\r		[sharedNavigationHistory:: NavigationHistory new].\r	^sharedNavigationHistory\r)",
 "class BlankFragment = LeafFragment (\r)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	^document createElement: 'div'\r)",
 "class ButtonFragment label: l action: a = LeafFragment (|\r	label = l.\r	action = a.\r	public enabled ::= true.\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	^(document createElement: 'button')\r		appendChild: (document createTextNode: label);\r		at: 'onclick' put: [:event | action value. false];\r		at: 'disabled' put: enabled not;\r		yourself\r)",
 "class CanvasFragment withExtent: e = LeafFragment (\r	|\r	private alien = document createElement: 'canvas'.\r	|\r	alien at: 'width' put: e x.\r	alien at: 'height' put: e y.\r	(alien at: 'style') at: 'position' put: 'relative'.\r)",
 "LeafFragment",
 "LeafFragment",
 "public context = (\r	^Context on: (alien getContext: '2d')\r)",
 "createVisual = (\r	^alien\r)",
 "public keyDownAction: onKeyPressed <[:String]> = (\r	(* The canvas element itself doesn't seem to get key events. *)\r	body addEventListener: 'keydown' action: \r		[:event | onKeyPressed value: (String fromCharCode: (event at: 'keyCode')). nil].\r)",
 "public mouseDownAction: onMouseDown <[:Point]> = (\r	alien addEventListener: 'mousedown' action: \r		[:event | onMouseDown value: (event at: 'offsetX') @ (event at: 'offsetY'). nil].\r)",
 "public mouseMovedAction: onMouseMoved <[:Point]> = (\r	alien addEventListener: 'mousemove' action:\r		[:event | onMouseMoved value: (event at: 'offsetX') @ (event at: 'offsetY'). nil].\r)",
 "public class CodeMirrorFragment onText: t <String>  = LeafFragment (\r(* An experiment to see how to integrate CodeMirror as editor. *)\r|\r      public editor <Alien[CodeMIrror]>\r	textSlot <TextFragment | String> ::= t.\r	counterfactualBar <Alien[Span]>\r	isInEditState ::= false.\r	public changeResponse <[:TextEditorFragment]>\r	public acceptResponse <[:TextEditorFragment]>\r	public cancelResponse <[:TextEditorFragment]>\r	styles ::= List new.\r|\r)",
 "LeafFragment",
 "LeafFragment",
 "applyStyle: style <{Integer. Integer. Alien[JSObject]}> = (\r	| s <Alien[CodeMirrorPosition]> e <Alien[CodeMirrorPosition]> |\r	(* Newspeak intervals are 1-origin and [start, stop]. JS intervals are 0-origin and [start, stop). *)\r	s:: editor posFromIndex: (style at: 1) - 1.\r	e:: editor posFromIndex: (style at: 2).\r	editor markText: s to: e style: (style at: 3).\r)",
 "applyStyles = (\r    nil = editor ifFalse: [\r	styles do: [: s <{Integer. Integer. Alien[JSObject]}> |\r	applyStyle: s\r	].\r     styles:: List new.\r     editor refresh.\r   ]\r)",
 "controlBarColor = (\r	^Color r: 0.95 g: 0.792 b: 0.475\r)",
 "createVisual = (\r	| frame  <Alien[Div]> accept  <Alien[Img]> cancel <Alien[Img]> textArea <Alien[Span]> options <Alien[JSObject]> |\r	\r	frame:: document createElement: 'div'.\r	(frame at: 'style')\r		at: 'display' put: 'flex';\r		at: 'opacity' put: 1.\r	counterfactualBar:: document createElement: 'span'.\r	(counterfactualBar at: 'style')\r		at: 'backgroundColor' put: controlBarColor asCSSString;\r		at: 'flex' put: 'none'.\r	accept:: document createElement: 'img'.\r	accept at: 'src' put: (accept16px yourself at: 'src').\r	(accept at: 'style') at: 'margin' put: '3px'.\r	accept at: 'onclick' put:\r		[:event | respondToAccept: event. nil].\r	cancel:: document createElement: 'img'.\r	cancel at: 'src' put: (cancel16px yourself at: 'src').\r	(cancel at: 'style') at: 'margin' put: '3px'.\r	cancel at: 'onclick' put:\r		[:event | respondToCancel. nil].\r	counterfactualBar appendChild: accept.\r	counterfactualBar appendChild: cancel.\r	textArea:: document createElement: 'textarea'.\r	textArea\r		at: 'value' put:  textSlot;\r		at: 'resize' put: true.\r	frame appendChild: textArea.\r	options:: JSObject new.\r	options at: 'lineWrapping' put: true.\r	editor:: CodeMirror fromTextArea: textArea with: options.\r      editor on: 'change' respondToChange:\r		[:codeMirror :change | respondToChange: codeMirror. nil].\r	((textArea at: 'nextSibling') at: 'style') \r		at: 'height' put: 'unset';\r		at: 'width' put: '100%';\r		at: 'fontFamily' put: 'TimesNewRoman';\r		at: 'borderStyle' put: 'solid';\r		at: 'borderWidth' put: '1px';\r		at: 'borderColor' put: 'gray'.\r	^frame\r)",
 "public defaultAcceptResponse = (\r      textSlot:: editor getValue.\r	leaveEditState\r)",
 "defaultCancelResponse = (\r	editor setValue: textSlot.\r	leaveEditState\r)",
 "defaultChangeResponse = (\r	enterEditState\r)",
 "public enterEditState = (\r	isInEditState ifFalse:\r		[visual appendChild: counterfactualBar.\r		isInEditState:: true].\r	visual scrollIntoView: true (* alignWithTop *).\r)",
 "public leaveEditState = (\r	isInEditState ifTrue:\r		[visualX removeChild: counterfactualBar.\r		isInEditState:: false.\r		(*removeMessages*)]\r)",
 "public noticeExposure = (\r  refresh\r)",
 "public refresh = (\r  applyStyles\r)",
 "respondToAccept: event <Alien[Event]> = (\r	nil = acceptResponse\r		ifTrue: [defaultAcceptResponse]\r		ifFalse: [acceptResponse cull: self cull: event]\r)",
 "respondToCancel = (\r	(*confirm: 'Confirm Cancel' ifConfirmed:\r		[*)nil = cancelResponse\r			ifTrue: [defaultCancelResponse]\r			ifFalse: [cancelResponse cull: self](*]*)\r)",
 "respondToChange: event <Alien[Event]> = (\r	nil = changeResponse\r		ifTrue: [defaultChangeResponse]\r		ifFalse: [changeResponse cull: self cull: event]\r)",
 "public showMessage: message <String> = (\r	message out.\r)",
 "public style: style <Alien[JSObject]> from: start <Integer> to: end <Integer>  = (\r	styles add: {start. end. style}.\r	applyStyles\r)",
 "public text: t = (\r      textSlot:: t.\r	hasVisual ifTrue: [editor setValue: t].\r)",
 "public textBeingAccepted ^ <String> = (\r  ^editor getValue\r)",
 "class ColorDecorator color: c <Color> = Decorator (\r| color <Color> = c. |)",
 "Decorator",
 "Decorator",
 "public decorate: aVisual = (\r	color applyToStyle: (aVisual at: 'style').\r	^aVisual\r)",
 "class ColumnComposer definitions: fs <List[Fragment]> = SequenceComposer definitions: fs (\r	crossAxisStretch\r)",
 "definitions: fs",
 "definitions: fs",
 "flexDirection ^ <String> = (\r	^'column'\r)",
 "class Composer = Fragment ()",
 "Fragment",
 "Fragment",
 "public class Decorator = (\r(* A Decorator is attached to a fragment and is called by the fragment to change the various attributes of the Brazil visual created by the fragment itself. *)\r)",
 " ",
 " ",
 "public decorate: aVisual = (\r	(* Change properties of aVisual or wrap it into a new visual that applies whatever decorating we represent to aVisual. Answer aVisual or the new visual. *)\r	subclassResponsibility\r)",
 "class DeferredContentComposer initialContent: ic contentSource: cs = Composer (|\r	initialContent <Fragment> = ic.\r	contentSource <[Fragment]> = cs.\r	contentFragment <Fragment>\r|)",
 "Composer",
 "Composer",
 "public childrenDo: aBlock = (\r	nil = contentFragment \r	  ifFalse: [aBlock value: contentFragment]\r	  ifTrue: [aBlock value: initialContent]\r)",
 "createVisual = (\r	| div initialVisual |\r	div:: document createElement: 'div'.\r	(div at: 'style') at: 'align-self' put: 'center'.\r	initialVisual:: initialContent visual.\r	div appendChild: initialVisual.\r	deferAction: [\r		| deferredFragment = contentSource value. |\r		deferredFragment parent: self.\r		contentFragment:: deferredFragment.\r		(* replace: new with: old due to stupid DOM argument ordering *)\r		div replaceChild: deferredFragment visual with: initialVisual].\r	^div\r)",
 "class DropDownMenuFragment menu: ms images: ims <Array[Image]> alignment: side <Symbol> = ImageButtonFragment images: ims (\r(*\rCreate a drop down menu based on dynamic content. This means that the menu contents may vary every time the menu button\ris clicked.  The contents are computed by a closure provided by the ms argument to the factory, and stored in the\rmenuSupplier slot.  The images to use for the menu button are provided by the ims argument.  Menus may be aligned to the right\ror the left; ideally, the system would figure the best alignment dynamically, but for now it must be specified via the side argument. Usually the presenter has a good idea what side the menu should be aligned to, so this is not a high priority item to address.\r\rClass methods that provide convenient defaults for the button images and the alignment are provided as well.\r*)\r	|\r	menuSupplier <[Tuple[Symbol | Tuple[String, []]]]> = ms. (* Skip formal menu structure for now*)\r	menuActive <Boolean> ::= false.\r	alignment <String>  = side asString.\r	|\r	action:: [].\r)",
 "images: ims",
 "images: ims",
 "createVisual ^ <Alien[Element]> = (\r	| column = super createVisual. |\r	column addEventListener: 'click' action: [:event | toggleContent. nil].\r	(column at: 'style')\r		at: 'cursor' put: 'pointer'.\r	^column\r)",
 "removeContent ^ <Alien[Element]> = (\r	^visual removeChild: (visual at: 'lastChild')\r)",
 "toggleContent = (\r	menuActive ifTrue: [removeContent] ifFalse: [updateContent].\r	menuActive:: menuActive not.\r)",
 "updateContent ^ <Alien[Element]> = (\r	| menuContent <Alien[Div]> |\r	menuContent:: computeContentForMenu: menuSupplier.\r	(menuContent at: 'style') \r	   at: alignment put: 0;\r	   at: 'display' put: 'block'.\r	visual appendChild: menuContent.\r	^menuContent\r)",
 "public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> ^ <Instance> = (\r   ^menu: ms images: {dropDownImage. dropDownOverImage. dropDownOutImage} alignment: #right\r)",
 "public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> alignment: side <Symbol> ^ <Instance> = (\r   ^menu: ms images: {dropDownImage. dropDownOverImage. dropDownOutImage} alignment: side\r)",
 "public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> images: ims <Array[Image]> ^ <Instance> = (\r   ^menu: ms images: ims alignment: #right\r)",
 "public class EmbeddedHopscotchWindow into: container openSubject: s = HopscotchShell (\r	|\r	localNavigator = LocalNavigationHistory new.\r	|\r	container appendChild: contentHolder.\r	enterSubject: s.\r)",
 "HopscotchShell",
 "HopscotchShell",
 "public displayPresenter: p <Presenter> = (\r	super displayPresenter: p.\r	(* Not a full-page app: don't update document title. *)\r)",
 "public enterPresenter: p <Presenter> = (\r	currentHopscotchWindow:: self.\r	embeddedWindowMap at: p ifAbsentPut: [self].\r	localNavigator visit: p.\r	super enterPresenter: p\r)",
 "public enterSubject: s <Subject> fromSnippet: snippet <SnippetSubject> = (\r	embeddedWindowMap at: snippet presenter ifAbsentPut: [self].\r	enterSubject: s.\r)",
 "public goBack = (\r	localNavigator goBack.\r	displayPresenter: localNavigator current.\r)",
 "listenForBackButton = (\r	nil = sharedBackButtonListener ifFalse: [^self. (* Already listening. *)].\r	sharedBackButtonListener::\r		[:event <Alien[Event]> |\r		| p <Presenter> = navigator presenterFor: (event at: 'state').\r		priorWindow = embeddedWindowMap at: p. |\r		currentHopscotchWindow goBack. (* might be better to enterPresenter:? *)\r		currentHopscotchWindow:: priorWindow].\r	window at: 'onpopstate' put: sharedBackButtonListener.\r)",
 "navigationHistory = (\r	^sharedNavigator\r)",
 "public openSubject: s = (\r	^into: body openSubject: s\r)",
 "class Fragment = (|\r	visualX\r	public parent\r	public size ::= nil.\r	public expansibility ::= 0.\r	public compressibility ::= 0.\r	decorators\r	|)",
 " ",
 " ",
 "public addDecorator: newDecorator <Decorator> = (\r	(* The argument is added last to the collection of our decorators, meaning it will be applied after all the other decorators we might have. *)\r	nil = decorators ifTrue: [decorators:: List new].\r	decorators addLast: newDecorator.\r)",
 "createVisual = (\r	subclassResponsibility\r)",
 "public decorate: aVisual = (\r	(* The argument is a visual freshly created by the #createVisual or #createViewportWithVisual method. If we have any decorators attached, apply them now to arrive at the final decorated visual. *)\r	| decorated |\r	decorated:: aVisual.\r	nil = decorators ifFalse:\r		[decorators do: [:each | decorated:: each decorate: decorated]].\r	^decorated\r)",
 "public elasticity: x = (\r	expansibility: x.\r	compressibility: x.\r)",
 "public hasVisual = (\r	^visualX isNil not\r)",
 "public noticeExposure = (\r	(* Propagated down the fragment hierarchy just after the hierarchy has been made visible. A fragment may receive this message multiple times over its life. *)\r\r	childrenDo: [:each | each noticeExposure]\r)",
 "public refresh = (\r	(* Fragments that dynamically retrieve their information should reimplement this to update their visuals accordingly. *)\r\r	childrenDo: [:each | each refresh]\r)",
 "public shell = (\r	^parent isNil\r		ifTrue: [Error signal: 'hierarchy not installed in a shell :',  printString]\r		ifFalse: [parent shell]\r)",
 "public value = (\r	^self\r)",
 "public visual = (\r	visualX isNil ifTrue: [visualX:: decorate: createVisual].\r	^visualX\r)",
 "public width: w elasticity: e = (\r	size: w.\r	expansibility: e.\r	compressibility: e.\r)",
 "public class Gradient from: a to: b = (|\r	topColor = a.\r	bottomColor = b.\r|)",
 " ",
 " ",
 "public applyToStyle: style = (\r	| value |\r	value:: '(top,', topColor asCSSString, ',', bottomColor asCSSString, ')'.\r	style setProperty: 'background-image' to: '-webkit-linear-gradient', value.\r	style setProperty: 'background-image' to: '-moz-linear-gradient', value.\r)",
 "class HolderComposer withContent: definition <Fragment | [Fragment]> = Composer (|\r	contentSource <Fragment | [Fragment]> ::= definition.\r	actualContent <Fragment>\r|)",
 "Composer",
 "Composer",
 "public childrenDo: aBlock <[:Fragment]> = (\r	nil = actualContent ifFalse: [aBlock value: actualContent].\r)",
 "public content ^<Fragment> = (\r	nil = actualContent ifTrue:\r		[actualContent:: contentSource value.\r		actualContent parent: self].\r	^actualContent\r)",
 "public content: fragment = (\r	fragment parent: self.\r	hasVisual ifTrue:\r		[ | oldContent newContent |\r		oldContent:: actualContent.\r		newContent:: actualContent:: fragment.\r		(* replace: new with: old due to stupid DOM argument ordering *)\r		visual replaceChild: newContent visual with: oldContent visual]\r	ifFalse: [actualContent:: fragment]\r)",
 "createVisual = (\r	| div |\r	div:: document createElement: 'div'.\r	div appendChild: content visual.\r	^div\r)",
 "public noticeExposure = (\r  refresh\r)",
 "public refresh = (\r	(contentSource isKindOfClosure and: [hasVisual])\r		ifTrue:\r			[ | oldContent newContent |\r			oldContent:: actualContent.\r			actualContent:: nil.\r			newContent:: content.\r			(* replace: new with: old due to stupid DOM argument ordering *)\r			visual replaceChild: newContent visual with: oldContent visual]\r		ifFalse:\r			[actualContent refresh].\r)",
 "class HopscotchShell = (\r	|\r	navigator = navigationHistory.\r	currentPresenterX\r	contentHolder = document createElement: 'div'.\r	|\r	listenForBackButton.\r)",
 " ",
 " ",
 "public childrenDo: aBlock = (\r	aBlock value: currentPresenter\r)",
 "public currentPresenter = (\r	^currentPresenterX\r)",
 "public displayPresenter: p = (\r	(* TODO: noticeX events *)\r	currentPresenterX:: p.\r	p parent: self.\r	contentHolder hasChildNodes\r		ifTrue: [contentHolder replaceChild: p visual from: (contentHolder at: 'firstChild')]\r		ifFalse: [contentHolder appendChild: p visual].\r	p noticeExposure.\r)",
 "public enterPresenter: presenter = (\r	presenter isTransient ifFalse:\r		[nil = currentPresenterX\r			ifTrue: [navigator recordFirst: presenter]\r			ifFalse: [history pushState: (navigator idFor: presenter) title: presenter title]].\r	displayPresenter: presenter.\r)",
 "public enterSubject: s <Subject> = (\r	self enterPresenter: s presenter\r)",
 "listenForBackButton = (\r	window at: 'onpopstate' put: [:event | userBack: event. nil]\r)",
 "navigationHistory = (\r	^NavigationHistory new\r)",
 "public refresh = (\r	(* Since refreshing forces a new copy of the current presenter into the browser, we need to massage it into the history as well. *)\r\r	| newSubject |\r	newSubject:: currentPresenter subject refreshmentSubject.\r	displayPresenter: newSubject presenter.\r	(* navigator replaceCurrentWith: newSubject presenter. *)\r)",
 "public shell = (\r	^self\r)",
 "userBack: event = (\r	displayPresenter: (navigator presenterFor: (event at: 'state'))\r)",
 "public class HopscotchWindow into: container openSubject: s = HopscotchShell (\r	container appendChild: contentHolder.\r	enterSubject: s.\r)",
 "HopscotchShell",
 "HopscotchShell",
 "public displayPresenter: p = (\r	super displayPresenter: p.\r	document at: 'title' put: p title.\r)",
 "public openSubject: s = (\r	^into: body openSubject: s\r)",
 "class HyperlinkFragment label: l action: a = LeafFragment (|\r	label = l.\r	action = a.\r	public color ::= Color r: 0 g: 0 b: 1.\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	| anchor |\r	anchor:: document createElement: 'a'.\r	anchor at: 'href' put: '#'.\r	anchor appendChild: (document createTextNode: label).\r	anchor at: 'onclick' put: [:event | action value. false].\r	(anchor at: 'style')\r		at: 'textDecoration' put: 'none'; (* No underline *)\r		at: 'overflow' put: 'hidden';\r		setProperty: 'white-space' to: 'nowrap'.\r	color isNil ifFalse:\r		[(anchor at: 'style') setProperty: 'color' to: color asCSSString].\r	^anchor\r)",
 "public smallFont = (\r	(visual at: 'style') at: 'font-size' put: 'smaller'\r)",
 "class HyperlinkImageFragment image: i action: a = LeafFragment (|\r	image = i.\r	action = a.\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	| img |\r	img:: image cloneNode: false (* Not deep *).\r	img at: 'onclick' put: [:event | action value. false].\r	^img\r)",
 "class ImageButtonFragment images: imageArray <Array[Image]> = LeafFragment (\r(* A button displayed as an image; or an image that acts as a button. *)\r|\r	public action <[]>\r	stateImages <Array[Image]> = imageArray, (Array new: 3).\r	(* Appending three nils so that we can always send #at: with an index between 1 and 4 and expect it not to fail. *)\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual ^ <Visual> = (\r	| div img |\r	div:: document createElement: 'div'.\r	(div at: 'style')\r		at: 'display' put: 'flex';\r		at: 'flex-direction' put: 'flex-column';\r		at: 'align-items' put: 'center'.\r	img:: (stateImages at: 1) cloneNode: false (* Not deep *).\r	img at: 'onclick' put: [:event | action value. false].\r	div appendChild: img.\r	^div\r)",
 "class LeafFragment = Fragment ()",
 "Fragment",
 "Fragment",
 "public childrenDo: aBlock = (\r	(* No children. *)\r)",
 "class LocalNavigationHistory = (\r(* LocalNavigationHistory is a richly structured collection that maintains a web browser-like history of ''visits''. Visits are arbitrary objects. NavigationHistory makes no assumptions about visits other than that they can be compared using #=.\r\rThe important attributes of a history are: the ''current'' visit, the ''past'', the ''future'' and ''allVisits''. A history starts off empty. To visit an object, send the #visit: message to the history with the object as the argument. This makes the object the ''current'' object of the history.\r\rThe ''past'' is a queue of visits that used to be the current (most recently current object last). Sending the #goBack message makes the most recently current object from the past the current again, while the current object becomes the first member of the ''future'' queue. Sending the #goForward message reverses the process. Visiting an object other than the first element of the ''future'' queue erases the future queue.\r\rAll visits visited by a history are remembered in the ''allVisits'' set. This set is never emptied, other than on an explicit request.\r\rA history can optionally be configured with a transientTestBlock. The test block is applied to visits to determine whether they are transient or not. Transient visits are not recorded in the ''past'' and ''future'' queues and in the ''allVisits'' set. By default all visits are considered to be non-transient.\r*)\r	|\r	currentVisitSlot\r	public allVisits <List>\r	public past <List>\r	public future <List>\r	public transientTestBlock <[:Object | Boolean]> ::= [:element | false].\r	|\r	erase.\r)",
 " ",
 " ",
 "public current ^ <Object> = (\r	^currentVisitSlot\r)",
 "public do: aBlock = (\r	(* Do the current visit separately if transient because it's not among allVisits. *)\r	(isTransient: currentVisitSlot) ifTrue:\r		[aBlock value: currentVisitSlot].\r	allVisits do: aBlock\r)",
 "public equalVisitOr: anObject ^ <Object> = (\r	(* Return a visit from the history equal to the argument, or the argument itself if there is no equal visit in the history. *)\r	^allVisits detect: [:some | some = anObject] ifNone: [anObject]\r)",
 "public erase = (\r	currentVisitSlot:: nil.\r	allVisits:: List new.\r	erasePast.\r	eraseFuture.\r)",
 "public eraseEntry: anObject = (\r	allVisits remove: anObject.\r	past remove: anObject ifAbsent: [].\r	future remove: anObject ifAbsent: []. (* can it ever be in the future list? *)\r)",
 "eraseFuture = (\r	future:: List new.\r)",
 "erasePast = (\r	past:: List new.\r)",
 "public goBack = (\r	isPastEmpty ifFalse:\r		[(isTransient: currentVisitSlot) ifFalse:\r			[future addFirst: currentVisitSlot].\r		currentVisitSlot:: past removeLast]\r)",
 "public goForward = (\r	isFutureEmpty ifFalse:\r		[(isTransient: currentVisitSlot) ifFalse:\r			[past addLast: currentVisitSlot].\r		currentVisitSlot:: future removeFirst]\r)",
 "public goToFutureItem: anObject = (\r	[currentVisitSlot = anObject or: [isFutureEmpty]]\r		whileFalse: [goForward]\r)",
 "public goToPastItem: anObject = (\r	[currentVisitSlot = anObject or: [isPastEmpty]]\r		whileFalse: [goBack]\r)",
 "includesVisit: anObject ^ <Boolean> = (\r	^allVisits includes: anObject\r)",
 "isEmpty ^ <Boolean> = (\r	^allVisits isEmpty\r)",
 "public isFutureEmpty ^ <Boolean> = (\r	^future isEmpty\r)",
 "public isPastEmpty ^ <Boolean> = (\r	^past isEmpty\r)",
 "isTransient: anObject ^ <Boolean> = (\r	^transientTestBlock value: anObject\r)",
 "next ^ <Object> = (\r	(* Answer the closest visit from the future. Fail if the future is empty. *)\r	^future first\r)",
 "previous ^ <Object> = (\r	(* Answer the most recent visit from the past. Fail if the past is empty. *)\r	^past last\r)",
 "replace: anObject with: replacement = (\r	(* Replace all references to anObject that we have with references to 'replacement'. *)\r	allVisits remove: anObject ifAbsent: [].\r	(isTransient: replacement) ifFalse: [allVisits add: replacement].\r	currentVisitSlot = anObject ifTrue: [currentVisitSlot:: replacement].\r	past keysAndValuesDo:\r		[:index :each | each = anObject ifTrue: [past at: index put: replacement]].\r	future keysAndValuesDo:\r		[:index :each | each = anObject ifTrue: [future at: index put: replacement]]\r)",
 "public replaceCurrentWith: anObject = (\r	self replace: currentVisitSlot with: anObject\r)",
 "public visit: anObject = (\r	(* Make the argument the current object of the history. The prior current object becomes the last object of the 'past' queue. The 'future' queue is erased, unless the visit is equal to the first element of the future. *)\r	currentVisitSlot = anObject ifTrue: [^self].\r	((nil = currentVisitSlot) not and: [(isTransient: currentVisitSlot) not]) ifTrue:\r		[past addLast: currentVisitSlot].\r	currentVisitSlot:: anObject.\r	(isTransient: anObject) ifFalse:\r		[allVisits\r			remove: anObject ifAbsent: [];\r			add: anObject].\r	future isEmpty not ifTrue:\r		[future first = currentVisitSlot\r			ifTrue: [future removeFirst]\r			ifFalse: [eraseFuture]].\r)",
 "class NavigationHistory = (| nextId ::= 1. ids <Map[Presenter, Integer]> = Map new. |)",
 " ",
 " ",
 "public idFor: presenter <Presenter> ^ <Integer> = (\r	^ids at: presenter ifAbsentPut: [nextId:: nextId + 1]\r)",
 "public presenterFor: id <Integer> ^ <Presenter> = (\r	ids keysAndValuesDo:\r		[:key :value | value = id ifTrue: [^key]].\r	^nil\r)",
 "public recordFirst: presenter = (\r	(* The popstate event has a null id when navigating all the way back. *)\r	ids at: presenter put: nil.\r)",
 "class PaddedFrameComposer content: c offsets: o = Composer (|\r	content = c.\r	offsets = o.\r	public color\r|)",
 "Composer",
 "Composer",
 "public childrenDo: aBlock = (\r	nil = content ifFalse: [aBlock value: content]\r)",
 "createVisual = (\r	| div = document createElement: 'div'. |\r	(div at: 'style')\r		at: 'paddingLeft' put: (offsets at: 1) printString, 'px';\r		at: 'paddingTop' put: (offsets at: 2) printString, 'px';\r		at: 'paddingRight' put: (offsets at: 3) printString, 'px';\r		at: 'paddingBottom' put: (offsets at: 4) printString, 'px'.\r	color isNil ifFalse: [color applyToStyle: (div at: 'style')].\r	content parent: self.\r	div appendChild: content visual.\r	^div\r)",
 "public class Presenter onSubject: aSubject <Subject> = Fragment (|\rpublic subject <Subject> ::= aSubject.\rsubstanceSlot <Fragment>\r|)",
 "Fragment",
 "Fragment",
 "alert: text = (\r	window alert: text\r)",
 "blank: size = (\r	^BlankFragment new size: size\r)",
 "button: label <String> action: block <[]> = (\r	^ButtonFragment label: label action: block\r)",
 "canvas: extent <Point> = (\r	^CanvasFragment withExtent: extent\r)",
 "public childrenDo: aBlock = (\r	nil = substanceSlot ifFalse: [aBlock value: substanceSlot]\r)",
 "codeMirror: t <Text | String> = (\r	^CodeMirrorFragment onText: t\r)",
 "collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> ^<Fragment> = (\r	^collapsed: collapsed expanded: expanded initiallyExpanded: false\r)",
 "collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> initiallyExpanded: flag <Boolean>\r^<Fragment> = (\r	^ToggleComposer\r		collapsedDefinition: collapsed\r		expandedDefinition: expanded\r		initiallyExpanded: flag\r)",
 "column: definitions <List[Fragment]> ^ <ColumnComposer> = (\r	^ColumnComposer definitions: definitions\r)",
 "createVisual ^ <Alien[HTMLElement]> = (\r(*	| substance = definition. |\r	substance parent: self.\r	^substance visual *)\r	ensureSubstance.\r	^substanceSlot visual\r)",
 "deferred: contentSource <[Fragment]> ^<Fragment> = (\r	^DeferredContentComposer initialContent: nothing contentSource: contentSource\r)",
 "public definition ^<Fragment> = (\r	subclassResponsibility\r)",
 "dropDownMenu: menu <[Menu]> ^ <DropDownMenuFragment> = (\r	^DropDownMenuFragment menu: menu\r)",
 "dropDownMenu: menu <[Menu]> alignment: side <Symbol> ^ <DropDownMenuFragment> = (\r	^DropDownMenuFragment menu: menu alignment: side\r)",
 "dropDownMenu: menu <[Menu]> images: ims <Array[Image]>  ^ <DropDownMenuFragment> = (\r	^DropDownMenuFragment menu: menu images: ims\r)",
 "dropDownMenu: menu <[Menu]> images: ims <Array[Image]> alignment: side <Symbol> ^ <DropDownMenuFragment> = (\r	^DropDownMenuFragment menu: menu images: ims alignment: side\r)",
 "elastic: aFragment = (\r	aFragment elasticity: 1.\r	^aFragment\r)",
 "ensureSubstance = (\r	nil = substanceSlot ifTrue:\r		[substanceSlot:: self definition.\r		substanceSlot parent: self.\r		noticeSubstanceCreation]\r)",
 "enterSubject: s = (\r	(* TODO: use sendUp and open a new window if undelivered *)\r	^shell enterSubject: s\r)",
 "enterSubject: s <Subject> fromSnippet: snippet <SnippetSubject> = (\r	(* TODO: use sendUp and open a new window if undelivered *)\r	^shell enterSubject: s fromSnippet: snippet\r)",
 "expanded: expanded <[Fragment]> collapsed: collapsed <[Fragment]> ^<Fragment> = (\r	^collapsed: collapsed expanded: expanded initiallyExpanded: true\r)",
 "filler = (\r	^BlankFragment new expansibility: 1; compressibility: 1\r)",
 "holder: def <Fragment | [Fragment]> = (\r	^HolderComposer withContent: def\r)",
 "image: image = (\r	^StaticImageFragment image: image\r)",
 "imageButton: images <Array[Image]> action: block <[]> = (\r	^(ImageButtonFragment images: images)\r		action: block\r)",
 "initially: initialContent <Fragment> deferred: contentSource <[Fragment]> ^<Fragment> = (\r	^DeferredContentComposer initialContent: initialContent contentSource: contentSource\r)",
 "public isTransient = (\r	(* Should visits of this presenter be omitted from the navigation history? *)\r	^false\r)",
 "label: label <String> = (\r	^StaticLabelFragment text: label\r)",
 "link: label <String> action: block <[]> = (\r	^HyperlinkFragment label: label action: block\r)",
 "linkImage: image action: block = (\r	^HyperlinkImageFragment image: image action: block\r)",
 "list ^ <PresenterList> = (\r	^PresenterList new\r)",
 "list: presenterSource <Sequence[Presenter] | [Sequence[Presenter]]> ^ <PresenterList> = (\r	^PresenterList new presenterSource: presenterSource\r)",
 "mediumBlank = (\r	^blank: 10\r)",
 "menuWithLabelsAndActions: labelsAndActions <Tuple[Symbol | Tuple[String, []]]> ^ <Menu> = (\r	| menu |\r	^labelsAndActions\r\r(*	menu:: Menu forVisual: visual.\r	labelsAndActions do:\r		[:each |\r		menu add: (#separator = each\r			ifTrue: [SeparatorItem new]\r			ifFalse: [MenuItem key: nil label: each key action: each value])].\r	^menun*)\r)",
 "nothing = (\r	^BlankFragment new\r)",
 "noticeSubstanceCreation = (\r	(* Received after the #definition method of the receiver has been invoked and the result remembered as its substance. The substance hasn't been asked to create a visual yet. *)\r)",
 "openMenu: aMenu <Menu> ^ <Alien[Div]> = (\r	| menuContent <Alien[Div]> |\r	menuContent:: computeContentForMenu: [aMenu].\r	(menuContent at: 'style') at: 'display' put: 'block'.\r	visual appendChild: menuContent.\r	menuContent addEventListener: 'click' action:\r		[:event | visual removeChild: menuContent. nil].\r	^menuContent\r(* so the issue here is to actually open a menu that was not in the tree before? And how to close it*)\r)",
 "openMenuWithLabelsAndActions: labelsAndActions = (\r	openMenu: (menuWithLabelsAndActions: labelsAndActions)\r)",
 "padded: def with: offsets = (\r	^PaddedFrameComposer content: def offsets: offsets\r)",
 "row: definitions = (\r	^RowComposer definitions: definitions\r)",
 "schedule: action <[]> = (\r	window setTimeout: [action value. nil] with: 0.\r)",
 "substance ^ <Fragment> = (\r	ensureSubstance.\r	^substanceSlot\r)",
 "text: t <Text> = (\r	| subfragments <Collection[Fragment]> |\r	t isKindOfTextString ifTrue: [^TextStringFragment onText: t].\r	subfragments:: t textUnits collect: [:u <Text> | text: u].\r	^TextBlockFragment onText: t subfragments: subfragments\r)",
 "textDisplay: string = (\r	^TextDisplayFragment text: string\r)",
 "textField: initialText onAccept: blk = (\r(* experimental *)\r	 ^fragments TextEditorFragment new\r	  text: initialText;\r	  acceptResponse: blk (*[:editor | blk valueWithPossibleArgument: editor. editor defaultAcceptResponse] *)\r)",
 "textString: string <String> = (\r	^TextStringFragment forString: string\r)",
 "textString: string <String> properties: tps <TextProperties> = (\r	^TextStringFragment forString: string properties: tps\r)",
 "public title ^<String> = (\r	^subject title\r)",
 "zebra: sequence <Sequence[Fragment]> ^ <Sequence[Fragment]> = (\r	sequence addDecorator: ZebraDecorator lighterColorFirst.\r	^sequence\r)",
 "class PresenterList = Fragment (\r(* PresenterList is a fragment that manages a sequence of Presenters, displaying them as a column. The interesting functionality it provides beyond that is updating itself intelligently when receiving a new sequence of presenters to display. New presenters equal (as determined by #=) to those currently displayed remain displayed as before, with any state they had unaffected even if their order in the list has changed.\r\rThe presenters can be given to the list either as a collection or as a niladic block that evaluates to a collection. In the latter case, a PresenterList will re-evaluate the block and update itself from the result each time it receives the #refresh message.\r\rSlots:\r\rpresenterSourceX. The presenters to display or the block providing them, as given to this instance when it was created.\r\rpresentersX. If presenterSourceX is a collection, this slot holds the same object as presenterSourceX. It it is the block, it holds the last result produced by the block.\r*)\r|\r	presenterSourceX <Sequence[Presenter] | [Sequence[Presenter]]> ::= List new.\r	presentersX <Sequence[Presenter]>\r|)",
 "Fragment",
 "Fragment",
 "public add: aPresenter <Presenter> = (\r	(* Append the argument to the end of the list of displayed presenters. If there is an equal presenter already displayed, remove it. *)\r	\r	| newPresenters |\r	newPresenters:: List withAll: presenters.\r	(newPresenters includes: aPresenter) ifTrue:\r		[newPresenters remove: aPresenter].\r	newPresenters add: aPresenter.\r	setPresenters: newPresenters.\r)",
 "public add: aPresenter <Presenter> afterIndex: index <Integer> = (\r	| newList |\r	newList:: presenters copy.\r	newList add: aPresenter afterIndex: index.\r	presenters: newList.\r)",
 "public addAll: additionalPresenters <{Presenter}> = (\r	| newPresenters |\r	newPresenters:: List withAll: presenters.\r	newPresenters addAll: additionalPresenters.\r	setPresenters: newPresenters.\r)",
 "public addFirst: aPresenter <Presenter> = (\r	(* Add the argument at the beginning of the end of the list of displayed presenters. If there is an equal presenter already displayed, remove it. *)\r	| newPresenters |\r	newPresenters:: List withAll: presenters.\r	(newPresenters includes: aPresenter) ifTrue:\r		[newPresenters remove: aPresenter].\r	newPresenters addFirst: aPresenter.\r	setPresenters: newPresenters.\r)",
 "public childrenDo: aBlock = (\r	nil = presentersX ifFalse: [presentersX do: aBlock].\r)",
 "public color: aColor = (\r	addDecorator::\r		ColorDecorator new color: aColor\r)",
 "createVisual = (\r	| column = ColumnComposer definitions: presenters. |\r	column parent: self.\r	^column visual\r)",
 "public detectPresenter: aBlock = (\r	^presentersX detect: aBlock\r)",
 "public detectPresenter: aBlock ifNone: noneBlock = (\r	^presentersX detect: aBlock ifNone: noneBlock\r)",
 "findFirst: aBlock = (\r	(* Answer the index of my first element for which aBlock evaluates as true. *)\r	^presentersX findFirst: aBlock\r)",
 "findLast: aBlock = (\r	(* Answer the index of my last element for which aBlock evaluates as true. *)\r	^presentersX findLast: aBlock\r)",
 "public presenterSource: niladicValuable <Sequence[Presenter] | [Sequence[Presenter]]> = (\r	presenterSourceX:: niladicValuable.\r	nil = presentersX ifFalse: [refreshPresenterList].\r)",
 "public presenters ^ <Sequence[Presenter]> = (\r	(* Return the presenters we are currently showing, pulling them from the source if needed. *)\r\r	nil = presentersX ifTrue:\r		[setPresenters: (presenterSourceX isKindOfClosure\r			ifTrue: [presenterSourceX value]\r			ifFalse: [presenterSourceX])].\r	^presentersX\r)",
 "public presenters: newPresenterList <Sequence[Presenter]> = (\r	self presenterSource: newPresenterList\r)",
 "public refresh = (\r	| newPresenters |\r	newPresenters:: Set withAll: refreshPresenterList.\r	presenters do:\r		[:each | (newPresenters includes: each) ifFalse: [each refresh]]\r)",
 "refreshPresenterList = (\r	(* Make it so that the displayed presenters match those provided by the source. For a list initialized with a presenter collection, this only does anything non-trivial when the instance is brand new. For a list initialized with a block, this re-evaluates the block and updates the list. *)\r	| newPresenters |\r	newPresenters:: presenterSourceX isKindOfClosure\r		ifTrue: [presenterSourceX value]\r		ifFalse: [presenterSourceX].\r	^setPresenters: newPresenters\r)",
 "refreshPresenters = (\r	presenters do: [:each | each refresh]\r)",
 "public remove: aPresenter = (\r	| newPresenters |\r	newPresenters:: List withAll: presenters.\r	newPresenters remove: aPresenter.\r	setPresenters:: newPresenters.\r)",
 "public removeAt: index <Integer> = (\r	| copy |\r	copy:: presenters copy.\r	copy removeAt: index.\r	presenters:: copy.\r)",
 "replaceChild: aFragment with: anotherFragment = (\r	| index newPresenters |\r	(presentersX includes: aFragment) ifTrue:\r		[index:: presenters indexOf: aFragment.\r		newPresenters:: presenters copy.\r		newPresenters at: index put: anotherFragment.\r		^presenters: newPresenters].\r	error: 'the fragment is not a child'\r)",
 "public setPresenters: newPresenterList <Sequence[Presenter]> = (\r	(* This is the workhorse of intelligent updates: massage the argument presenters into the currently displayed list, making sure that if there is an element of newPresenterList equal to a currently displayed presenter, we continue using the current presenter. *)\r\r	| currentPresenters oldPresentersAndIndices removedPresenters removedIndices addedPresenters newFinalList |\r	currentPresenters:: nil = presentersX ifTrue: [List new] ifFalse: [presentersX].\r	oldPresentersAndIndices:: Map new: currentPresenters size.\r	currentPresenters keysAndValuesDo:\r		[:index :each | oldPresentersAndIndices at: each put: index].\r	addedPresenters:: List new: newPresenterList size.\r	newFinalList:: List new: newPresenterList size.\r\r	newPresenterList do:\r		[:each | | oldIndex |\r		oldIndex:: oldPresentersAndIndices at: each ifAbsent: [nil].\r		nil = oldIndex\r			ifFalse: (* reusing a presenter we already have for this subject *)\r				[newFinalList add: (presenters at: oldIndex).\r				oldPresentersAndIndices removeKey: each]\r			ifTrue:\r				[newFinalList add: each.\r				addedPresenters add: each]].\r\r	removedPresenters:: oldPresentersAndIndices keys.\r	(* removedIndices:: (1 to: currentPresenters size) select:\r		[:index | removedPresenters includes: (currentPresenters at: index)]. *)\r\r	presentersX:: newFinalList.\r	presenterSourceX:: newFinalList.\r	addedPresenters do: [:each <Presenter> | each parent: self].\r	hasVisual ifTrue: [updateColumn].\r	(*	[updateColumn: visualX\r		 removingIndices: removedIndices\r		 addingPresenters: addedPresenters].*)\r	^addedPresenters\r)",
 "updateColumn = (\r	| newVisual = createVisual. |\r  (visual at: 'parentElement') replaceChild: newVisual with: visual.\r(* Note: this really means replace visual with newVisual; JS takes the args in wrong order *)\r  visualX: newVisual\r)",
 "updateColumn: column removingIndices: indices addingPresenters: newPresenters = (\r	indices asSortedList reverseDo:\r		[:each | column removeAt: each].\r	newPresenters do:\r		[:each | column add: each visual].\r	column reorder:\r		(presenters collect: [:each | each visual])\r)",
 "class RowComposer definitions: fs <List[Fragment]> = SequenceComposer definitions: fs (\r)",
 "definitions: fs",
 "definitions: fs",
 "flexDirection = (\r	^'row'\r)",
 "class SequenceComposer definitions: fs <List[Fragment]> = Composer (|\r	definitions <List[Fragment]> = fs.\r	public color <Color>\r	protected alignItems ::= 'center'.\r	protected childAlignSelf ::= 'center'.\r	protected justifyContent ::= 'flex-start'.\r|)",
 "Composer",
 "Composer",
 "public childrenDo: aBlock = (\r	definitions do: aBlock\r)",
 "createVisual ^ <Alien[HTMLElement]> = (\r	| container <Alien[HTMLElement]> |\r	container:: document createElement: 'div'.\r	(container at: 'style')\r		at: 'overflow' put: 'hidden';\r		at: 'display' put: 'flex';\r		at: 'flex-direction' put: flexDirection;\r		at: 'align-content' put: alignItems;\r		at: 'justify-content' put: justifyContent.\r	nil = color ifFalse:\r		[color applyToStyle: (container at: 'style')].\r	definitions do: [:fragment <Fragment> |\r		| cell <Alien[HTMLElement]> |\r		fragment parent: self.\r		cell:: fragment visual.\r		(cell at: 'style')\r			at: 'overflow' put: 'hidden';\r			at: 'align-self' put: childAlignSelf;\r			at: 'flex-grow' put: fragment expansibility;\r			at: 'flex-shrink' put: fragment compressibility.\r		nil = fragment size ifFalse:\r			[(cell at: 'style')\r				at: 'flex-basis' put: fragment size printString, 'px'].\r		container appendChild: cell].\r	^container\r)",
 "public crossAxisAlignToCenter = (\r	alignItems:: 'center'.\r	childAlignSelf:: 'center'.\r)",
 "public crossAxisAlignToEnd = (\r	alignItems:: 'flex-end'.\r	childAlignSelf:: nil.\r)",
 "public crossAxisAlignToStart = (\r	alignItems:: 'flex-start'.\r	childAlignSelf:: nil.\r)",
 "public crossAxisStretch = (\r	alignItems:: 'stretch'.\r	childAlignSelf:: nil.\r)",
 "public mainAxisAlignToCenter = (\r	justifyContent:: 'center'.\r)",
 "public mainAxisAlignToEnd = (\r	justifyContent:: 'flex-end'.\r)",
 "public mainAxisAlignToStart = (\r	justifyContent:: 'flex-start'.\r)",
 "class StaticImageFragment image: i = LeafFragment (|\r	image = i.\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	| div img |\r	div:: document createElement: 'div'.\r	(div at: 'style')\r		at: 'display' put: 'flex';\r		at: 'flex-direction' put: 'flex-column';\r		at: 'align-items' put: 'center'.\r	img:: image cloneNode: false. (* Not deep *)\r	div appendChild: img.\r	^div\r)",
 "class StaticLabelFragment text: t = LeafFragment (|\r	textX ::= t.\r	public color\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	| div = document createElement: 'div'. |\r	(div at: 'style')\r		at: 'overflow' put: 'hidden';\r		at: 'white-space' put: 'pre'.\r	div at: 'textContent' put: text.\r	nil = color ifFalse:\r		[(div at: 'style') setProperty: 'color' to: color asCSSString].\r	^div\r)",
 "public smallFont = (\r	(visual at: 'style') at: 'font-size' put: 'smaller'\r)",
 "public text = (\r	^textX\r)",
 "public text: newText = (\r	textX: newText.\r	hasVisual ifTrue: [visual at: 'textContent' put: textX]\r)",
 "public class Subject onModel: aModel = (|\r	protected model ::= aModel.\r	protected presenterX <Presenter>\r|)",
 " ",
 " ",
 "public createPresenter ^<Presenter> = (\r	subclassResponsibility\r)",
 "public presenter ^<Presenter> = (\r	presenterX isNil ifTrue: [presenterX:: createPresenter].\r	^presenterX\r)",
 "public refreshmentSubject ^<Subject> = (\r	(* Answer a new subject representing the same thing as the receiver. *)\r	^self class onModel: model\r)",
 "public title ^<String> = (\r	^self printString\r)",
 "class TextBlockFragment onText: t <Text> subfragments: sfs <List[Fragment]> = TextFragment onText: t (\r(* A fragment representing a compound text . *)\r| subfragments <List[Fragment]> = sfs. |)",
 "onText: t",
 "onText: t",
 "createVisual = (\r	| span = document createElement: 'span'. |\r	text textProperties applyTo: span.\r	subfragments do: [:u |\r		span insertAdjacentElement: 'beforeEnd' into: u visual\r		].\r	^span\r)",
 "public cursorPosition ^ <Integer> = (\r |\r  ca\r  sel = window getSelection.\r  focusNode\r  sum <Integer> ::= 0.\r |\r  sel isNil ifFalse: [ (*BOGUS: assumes the block is a flat collection of TextStringFragments*)\r	focusNode:: sel at: 'focusNode'.\r	ca:: (sel getRangeAt: 0) at: 'commonAncestorContainer'.\r	subfragments do: [:sf <Fragment> |\r		(sf visual at: 'firstChild') = focusNode ifTrue: [^sum + sf cursorPosition].\r	  sum:: sum + (sf visual at: 'textContent') size.\r		].\r	].\r	^nil\r)",
 "public cursorPosition: position <Integer> = (\r	| sum <Integer> ::= 0. |\r(*BOGUS: assumes the block is a flat collection of TextStringFragments*)\r	subfragments do: [:subfragment <Fragment> | | index <Integer> |\r		index:: position  - sum.\r		sum:: sum + (subfragment visual at: 'textContent') size.\r		position <= sum ifTrue: [subfragment cursorPosition: index. ^self].\r		].\r)",
 "public isKindOfTextBlockFragment ^ <Boolean> = (\r	^true\r)",
 "class TextDisplayFragment text: t = LeafFragment (|\r	textX ::= t.\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	| div = document createElement: 'div'. |\r	(div at: 'style') setProperty: 'white-space' to: 'pre-wrap'.\r	div at: 'textContent' put: textX.\r	^div\r)",
 "public smallFont = (\r  (visual at: 'style') at: 'font-size' put: 'smaller'\r)",
 "public text = (\r	^textX\r)",
 "public text: newText = (\r	textX: newText.\r	hasVisual ifTrue: [visual at: 'textContent' put: textX]\r)",
 "public class TextEditorFragment = LeafFragment (|\r	textX <TextFragment | String> ::= ''.\r	counterfactualBarX\r	editorX <Div>\r	public textBeingAccepted <String>\r	isInEditState ::= false.\r	public changeResponse <[TextEditorFragment]>\r	public acceptResponse <[TextEditorFragment]>\r	public cancelResponse <[TextEditorFragment]>\r	public oldText <TextFragment | String>\r|)",
 "LeafFragment",
 "LeafFragment",
 "controlBarColor = (\r	^Color r: 0.95 g: 0.792 b: 0.475\r)",
 "createVisual = (\r	| frame editorWrapper accept cancel |\r	frame:: document createElement: 'div'.\r	(frame at: 'style')\r		at: 'display' put: 'flex'.\r	editorX:: document createElement: 'div'.\r	editorX at: 'contentEditable' put: 'true'.\r	(editorX at: 'style')\r		at: 'borderStyle' put: 'solid';\r		at: 'borderWidth' put: '1px';\r		at: 'borderColor' put: 'gray';\r		setProperty: 'background-color' to: 'white';\r		at: 'flex' put: 1;\r		setProperty: 'white-space' to: 'pre-wrap';\r		at: 'display' put: 'block'.\r		setText: textX.\r	(* editorX at: 'textContent' put: textX.*)\r	editorX addEventListener: 'input' action: [:event | respondToChange: event. nil].\r	counterfactualBarX:: document createElement: 'span'.\r	(counterfactualBarX at: 'style')\r		at: 'backgroundColor' put: controlBarColor asCSSString;\r		at: 'flex' put: 'none'.\r	accept:: document createElement: 'img'.\r	accept at: 'src' put: (accept16px yourself at: 'src').\r	(accept at: 'style') at: 'margin' put: '3px'.\r	accept at: 'onclick' put: [:event | respondToAccept: event. nil].\r	cancel:: document createElement: 'img'.\r	cancel at: 'src' put: (cancel16px yourself at: 'src').\r	(cancel at: 'style') at: 'margin' put: '3px'.\r	cancel at: 'onclick' put: [:event | respondToCancel. nil].\r	counterfactualBarX appendChild: accept.\r	counterfactualBarX appendChild: cancel.\r	frame appendChild: editorX.\r	(* frame appendChild: counterfactualBarX. *)\r	^frame\r)",
 "public cursorPosition ^ <Integer> = (\r(* BOGUS. This leads to quirks when cutting and pasting. We really need to get the selection from the browser and identify\rthe cursor position based on that. But so far that hasn't worked. And we have issues with inserting newlines.\r*)\r	|\r	oldString <String>\r	newString <String>\r	bound <Integer>\r	offset <Integer> ::= 0.\r	|\r	oldString:: textX text string.\r	newString:: textBeingAccepted.\r	bound:: newString size min: oldString size.\r	offset:: -1 max: (newString size - oldString size - 1).\r	('old: ', oldString) out.\r	('new: ', newString) out.\r	1 to: bound do: [:i <Integer> |\r		(oldString at: i) = (newString at: i) ifFalse: [^i + offset]\r		].\r	^newString size\r)",
 "public defaultAcceptResponse = (\r	setVisualText: textBeingAccepted.\r	leaveEditState\r)",
 "defaultCancelResponse = (\r	setVisualText: textX.\r	leaveEditState\r)",
 "defaultChangeResponse = (\r	enterEditState\r)",
 "public enterEditState = (\r	isInEditState ifFalse:\r		[visual appendChild: counterfactualBarX.\r		isInEditState:: true].\r	visual scrollIntoView: true (* alignWithTop *).\r)",
 "public leaveEditState = (\r	isInEditState ifTrue:\r		[visualX removeChild: counterfactualBarX.\r		isInEditState:: false.\r		(*removeMessages*)]\r)",
 "reconstructText ^ <String> = (\r  (* compute the text string from the DOM. This is necessary since the textContent attribute does not accurately reflect\r	newlines, as these are sometimes implied by div and br nodes. *)\r |\r  children <Alien[HTMLCollection]> = editorX at: 'children'.\r  numberOfChildren = children at: 'length'.\r  result <String>\r |\r	numberOfChildren = 0 ifTrue: [^textBeingAccepted:: editorX at: 'textContent'].\r	result:: ''.\r	0 to: numberOfChildren - 1 do: [:i <Integer> | result:: result, (reconstructTextForNode: (children item: i))].\r	^result\r)",
 "reconstructTextForNode: n <Alien[Node]> ^ <String> = (\r  (* compute the text string from the DOM. This is necessary since the textContent attribute does not accurately reflect\r	newlines, as these are sometimes implied by div and br nodes. *)\r |\r  children <Alien[HTMLCollection]> = n at: 'children'.\r  numberOfChildren = children at: 'length'.\r  result <String>\r |\r	result:: ''.\r	numberOfChildren = 0  ifTrue: [result:: n at: 'textContent'].\r	0 to: numberOfChildren - 1 do: [:i <Integer> | result:: result, (reconstructTextForNode: (children item: i))].\r	({'P'. 'BR'. 'DIV'} includes: (n at: 'tagName') ) ifTrue: [(n at: 'tagName') out. result:: result, String cr].\r	^result.\r)",
 "respondToAccept: event <Alien[Event]> = (\r	textBeingAccepted:: reconstructText (*editorX at: 'textContent'.*)(*withSqueakLineEndings*).\r	nil = acceptResponse\r		ifTrue: [defaultAcceptResponse]\r		ifFalse: [acceptResponse cull: self cull: event]\r)",
 "respondToCancel = (\r	(*confirm: 'Confirm Cancel' ifConfirmed:\r		[*)nil = cancelResponse\r			ifTrue: [defaultCancelResponse]\r			ifFalse: [cancelResponse cull: self](*]*)\r)",
 "respondToChange: event <Alien[Event]> = (\r	textBeingAccepted:: reconstructText (*editorX at: 'textContent'.*).\r	nil = changeResponse\r		ifTrue: [defaultChangeResponse]\r		ifFalse: [changeResponse cull: self cull: event]\r)",
 "public setCursor = (\r	| sum <Integer> ::= 0. cp <Integer> = cursorPosition. |\r	cp out.\r	textX cursorPosition: 5.\r	(* textX elementaryTextUnits do: [:u <TextString> | (*textX is a fragment or a string, has no elementary text units*)\r		sum:: sum + u string size.\r		cp < sum ifTrue: [^setCursor: u to: cp]\r		]*)\r)",
 "public setCursor: position <Integer> = (\r	| sum <Integer> ::= 0. |\r	position out.\r	textX cursorPosition: position.\r)",
 "setText: t <TextFragment | String> = (\r   t isKindOfString\r	ifTrue: [editorX at: 'textContent' put: t]\r	ifFalse: [ | children = List new. |\r		oldText isKindOfString ifFalse: [\r			(editorX at: 'childNodes') forEach: [:n | children add: n].\r			children do: [:n | editorX removeChild: n].\r			].\r		editorX appendChild: t visual\r		]\r)",
 "setVisualText: aText = (\r	hasVisual ifTrue: [setText: aText]\r)",
 "public showMessage: m = (\r#BOGUS.\r	m out\r)",
 "public text = (\r	^textX\r)",
 "public text: t = (\r	oldText:: textX.\r	textX: t.\r	setVisualText: textX.\r)",
 "public updateCursor = (\r	| sum <Integer> ::= 0. cp <Integer> = textX cursorPosition. |\r	textX cursorPosition: cp.\r)",
 "class TextFragment onText: t <Text> = Fragment (\r(*Abstract supertype of all texts.*)\r|\r	public text <Text> = t.\r|)",
 "Fragment",
 "Fragment",
 "public cursorPosition: position <Integer> = (\r	subclassResponsibility\r)",
 "public isKindOfTextFragment ^ <Boolean> = (\r	^true\r)",
 "class TextStringFragment onText: t <Text> = TextFragment onText: t (\r(*A formatted string.*)\r)",
 "onText: t",
 "onText: t",
 "public createVisual = (\r	| span = document createElement: 'span'. |\r	text textProperties applyTo: span.\r	span at: 'textContent' put: text string.\r	^span\r)",
 "public cursorPosition ^ <Integer> = (\r | sel = window getSelection. |\r  sel isNil ifFalse: [\r	(*(visual at: 'firstChild') = (sel at: 'focusNode') ifTrue: [*)\r		^(sel getRangeAt: 0) at: 'endOffset'\r		(*]*)\r	].\r  'textStringFragment cursorPosition is nil!' out.\r	^nil\r)",
 "public cursorPosition: position <Integer> = (\r | textNode = visual at: 'firstChild'. range = document createRange. |\r\r  range setStart: textNode to: position;\r	  setEnd: textNode to: position.\r  window getSelection removeAllRanges; addRange: range\r)",
 "public isKindOfTextStringFragment ^ <Boolean> = (\r	^true\r)",
 "public forString: s <String> ^ <Instance> = (\r	^onText: (TextString forString: s properties: TextProperties new)\r)",
 "public forString: s <String> properties: tps <TextProperties> ^<Instance> = (\r	^onText: (TextString forString: s properties: tps)\r)",
 "class ToggleComposer collapsedDefinition: collapsed <[Fragment]>\r expandedDefinition: expanded <[Fragment]>\r initiallyExpanded: flag <Boolean> = Composer (|\rexpandedDefinition <[Fragment]> = expanded.\rcollapsedDefinition <[Fragment]> = collapsed.\risExpanded <Boolean> ::= flag.\rexpandedPresenter <Fragment>\rcollapsedPresenter <Fragment>\rcontentHolder\rtoggleWidget\r|)",
 "Composer",
 "Composer",
 "public childrenDo: aBlock = (\r	nil = collapsedPresenter ifFalse:\r		[aBlock value: collapsedPresenter].\r	nil = expandedPresenter ifFalse:\r		[aBlock value: expandedPresenter].\r)",
 "public collapse = (\r	isExpanded:: false.\r	installCollapsedPresenter\r)",
 "createVisual = (\r	| toggleDiv div |\r	contentHolder:: document createElement: 'div'.\r\r	toggleDiv:: document createElement: 'div'.\r	toggleWidget:: document createElement: 'img'.\r	toggleWidget at: 'onclick' put: [:event | toggle. nil].\r	toggleDiv appendChild: toggleWidget.\r\r	(contentHolder at: 'style')\r		setProperty: 'flex-grow' to: 1;\r		setProperty: 'flex-shrink' to: 1.\r	(toggleDiv at: 'style')\r		setProperty: 'flex-grow' to: 0;\r		setProperty: 'flex-shrink' to: 0;\r		at: 'paddingTop' put: '2px';\r		at: 'paddingRight' put: '3px'.\r	toggleWidget at: 'align' put: 'top'.\r\r	isExpanded\r		ifTrue: [installExpandedPresenter]\r		ifFalse: [installCollapsedPresenter].\r\r	div:: document createElement: 'div'.\r	(div at: 'style')\r		at: 'display' put: 'flex';\r		setProperty: 'flex-direction' to: 'row'.\r	div appendChild: toggleDiv.\r	div appendChild: contentHolder.\r	^div\r)",
 "public expand = (\r	isExpanded:: true.\r	installExpandedPresenter\r)",
 "installCollapsedPresenter = (\r	nil = collapsedPresenter ifTrue:\r		[collapsedPresenter:: collapsedDefinition value.\r		collapsedPresenter parent: self].\r	installContentVisual: collapsedPresenter visual.\r	toggleWidget at: 'src' put: (disclosureClosedImage at: 'src').\r)",
 "installContentVisual: newVisual = (\r	contentHolder hasChildNodes\r		ifTrue:\r			[ | oldVisual = contentHolder at: 'firstChild'. |\r			contentHolder replaceChild: newVisual with: oldVisual]\r		ifFalse: [contentHolder appendChild: newVisual].\r)",
 "installExpandedPresenter = (\r	expandedPresenter isNil ifTrue:\r		[expandedPresenter:: expandedDefinition value.\r		expandedPresenter parent: self].\r	installContentVisual: expandedPresenter visual.\r	expandedPresenter noticeExposure.\r	toggleWidget at: 'src' put: (disclosureOpenImage at: 'src').\r)",
 "public toggle = (\r	isExpanded:: isExpanded not.\r	isExpanded\r		ifTrue: [installExpandedPresenter]\r		ifFalse: [installCollapsedPresenter].\r)",
 "public class ZebraDecorator firstColor: color1 secondColor: color2 = Decorator (|\r	firstColor ::= color1.\r	secondColor ::= color2.\r	sequenceDefinition\r|)",
 "Decorator",
 "Decorator",
 "public decorate: aVisual = (\r| odd <Boolean> ::= false.  children = (aVisual at: 'children'). |\r	0 to: (children at: 'length') - 1 do:\r		[:index | | each = children item: index. c <Color> |\r		c:: odd ifTrue: [firstColor] ifFalse: [secondColor].\r		assert: [c isNil not] message: ['nil color!'].\r		c applyToStyle: (each at: 'style').\r		odd:: odd not.\r		].\r	^aVisual\r)",
 "public darkerColorFirst = (\r	^self firstColor: (Color gray: 0.97) secondColor: Color white\r)",
 "public lighterColorFirst = (\r	^self firstColor: Color white secondColor: (Color gray: 0.97)\r)"
]