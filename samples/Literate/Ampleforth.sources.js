var sources = [
 null,
 "class RuntimeForV8WithMirrorBuilders packageUsing: manifest = (\r(* Provides the platform object for Newspeak on Javascript.\r\rCopyright 2012 Google Inc.\rCopyright 2013 Ryan Macnak\r\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)\r|\r	Kernel = manifest KernelForV8.\r	Actors = manifest ActorsForV8.\r	Aliens = manifest AliensForV8.\r	Collections = manifest Collections.\r	Mirrors = manifest MirrorsForV8.\r	public MirrorGroups = manifest MirrorGroups.\r	Streams = manifest Streams.\r\r	public CombinatorialParsing = manifest CombinatorialParsing.\r	public NewspeakGrammar = manifest NewspeakGrammar.\r	public NewspeakASTs = manifest NewspeakASTs.\r	public NewspeakParsing = manifest NewspeakParsing.\r\r	public JavascriptGeneration = manifest JavascriptGeneration.\r	public Compilation = manifest Newspeak2V8Compilation mixinApply: manifest NewspeakCompilation.\r|)",
 " ",
 " ",
 "public using: vmmirror = (\r	Object enclosingObject augmentPrototypes.\r	^Platform usingVmMirror: vmmirror\r)",
 "class Platform usingVmMirror: vmmirror = (\r	|\r	public kernel = Object enclosingObject. (* Instantiated specially to avoid bootstrapping issues. *)\r	public actors = Future computing: [Actors usingPlatform: self].\r	public js = Future computing: [Aliens usingPlatform: self].\r	public collections = Future computing: [Collections usingPlatform: self].\r	public mirrors = Future computing: [Mirrors usingPlatform: self runtime: outer RuntimeForV8WithMirrorBuilders vmMirror: vmmirror].\r	public streams = Future computing: [Streams usingPlatform: self].\r	|\r	kernel platform: self.\r	actors yourself.\r)",
 " ",
 " ",
 "public Exception = (\r	^Error\r)",
 "public Message = (\r	^kernel Message\r)",
 "public MessageNotUnderstood = (\r	^kernel MessageNotUnderstood\r)",
 "public UnhandledError = (\r	^Error\r)",
 "class KernelForV8 usingVmMirror: vmm = (\r(*\rKernel classes for the Javscript-based implementation of Newspeak.\rCopyright 2008 Cadence Design Systems, Inc.\rCopyright 2009-2010 Gilad Bracha.\rCopyright 2012 SAP AG.\rCopyright 2012 Google Inc.\rCopyright 2013 Ryan Macnak\r\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)\r|\rvmmirror = vmm.\rpublic platform\r|)",
 " ",
 " ",
 "public Error = (\r	(* Squeak compatibility *)\r	^Exception\r)",
 "public UnhandledError = (\r	(* Squeak compatibility *)\r	^Exception\r)",
 "augment: prototype withPropertiesOf: runtimeClass = (\r	| keys = js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'keys')) with: {runtimeClass}. |\r	js call: (js propertyOf: keys at: (js literal: 'forEach')) with: {js functionOf: {'key'} body: (js block: {\r		(*js if: (js operator: '||' with: (js call: (js propertyOf: (js ident: 'key') at: (js literal: 'startsWith')) with: {js literal: '$'}) and:\r			(js call: (js propertyOf: (js ident: 'key') at: (js literal: 'startsWith')) with: {js literal: '_$'})) then: (js block: {*)\r			js assign: (js propertyOf: prototype at: (js ident: 'key'))\r				toBe: (js propertyOf: runtimeClass at: (js ident: 'key')).\r			(*(js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'defineProperty')) with: {\r				prototype.\r				(js ident: 'key').\r				js objectLiteralSlotNames: {js literal: 'enumerable'} values: {js literal: false}.\r			})\r		}).*)\r	})}.\r)",
 "public augmentPrototypes = (\r	js call: (js ident: 'installDnuHandlersOn') with: {js verbatim: 'Object.prototype'}.\r	augment: (js verbatim: 'Array.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Array.prototype') withPropertiesOf: (js propertyOf: Array at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Boolean.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Boolean.prototype') withPropertiesOf: (js propertyOf: Boolean at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Function.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Function.prototype') withPropertiesOf: (js propertyOf: Closure at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Number.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'Number.prototype') withPropertiesOf: (js propertyOf: Number at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'String.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).\r	augment: (js verbatim: 'String.prototype') withPropertiesOf: (js propertyOf: String at: (js literal: 'runtimeClass')).\r)",
 "private classOf: object = (\r	(js prefixOperator: 'typeof ' on: object) == 'string' ifTrue: [^String].\r	(js prefixOperator: 'typeof ' on: object) == 'number' ifTrue: [^Number].\r	(js prefixOperator: 'typeof ' on: object) == 'boolean' ifTrue: [^Boolean].\r	(js prefixOperator: 'typeof ' on: object) == 'function' ifTrue: [^Closure].\r	(js operator: 'instanceof' with: object and: (js ident: 'Array')) ifTrue: [^Array].\r	^js propertyOf: object at: (js literal: 'newspeakClass')\r)",
 "private print: string = (\r	js\r		ternaryIf: ((js prefixOperator: 'typeof ' on: (js ident: 'console')) == 'undefined')\r		then: (js call: (js ident: 'print') with: {string})\r		else: (js call: (js propertyOf: (js ident: 'console') at: (js literal: 'log')) with: {string})\r)",
 "public class Array uninstantiable = ()",
 " ",
 " ",
 "public , otherSequence = (\r	^js call: (js propertyOf: self at: (js literal: 'concat')) with: {otherSequence asArray}\r)",
 "public asArray = (\r	^self\r)",
 "public asOrderedCollection = (\r	^platform collections List withAll: self\r)",
 "public at: index <Integer> ^<E> = (\r	| jsIndex |\r	(js prefixOperator: 'typeof ' on: index) == 'number' ifFalse: [^Error signal: 'ArgumentError'].\r	jsIndex:: js operator: '-' with: index and: (js literal: 1).\r	(js operator: '<' with: jsIndex and: (js literal: 0)) ifTrue: [^Error signal: 'ArgumentError'].\r	(js operator: '>=' with: jsIndex and: (js verbatim: 'this.length')) ifTrue: [^Error signal: 'ArgumentError'].\r	^js propertyOf: (js ident: 'this') at: jsIndex\r)",
 "public at: index <Integer> put: value <E> ^<E> = (\r	| jsIndex |\r	(js prefixOperator: 'typeof ' on: index) == 'number' ifFalse: [^Error signal: 'ArgumentError'].\r	jsIndex:: js operator: '-' with: index and: (js literal: 1).\r	(js operator: '<' with: jsIndex and: (js literal: 0)) ifTrue: [^Error signal: 'ArgumentError'].\r	(js operator: '>=' with: jsIndex and: (js verbatim: 'this.length')) ifTrue: [^Error signal: 'ArgumentError'].\r	^js assign: (js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1)))\r	 toBe: value\r)",
 "public binarySearchFor: el between: start and: end toCompare: compare = (\r	(* This does a binary search for the index such that if el was inserted before it\r	  the receiver would remain sorted.  The receiver must be sorted relative to the\r	  comparison block.  The comparison block should return true if the first block argument\r	  cannot appear after the second block argument *)\r\r	| low high |\r	low:: start.\r	high:: end.\r	[ low <= high ]\r		whileTrue:\r				[ | mid |\r					mid:: (low + high) // 2.\r	  				(compare value: (self at: mid) value: el)\r						ifTrue: [ low:: mid + 1 ]\r						ifFalse: [ high:: mid - 1 ].\r				].\r	^low\r)",
 "protected class = (\r	^Array\r)",
 "public collect: block = (\r	^js call: (js propertyOf: self at: (js literal: 'map')) with: {block}.\r)",
 "public copyFrom: start to: end = (\r	^js call: (js propertyOf: self at: (js literal: 'slice')) with: {start - 1. end}\r)",
 "public copyWith: extraElement = (\r	| newSize ::= self size + 1. a |\r	a:: (Array new: newSize) replaceFrom: 1 to: self size with: self.\r	a at: newSize put: extraElement.\r	^a\r)",
 "public copyWithSize: s = (\r	^(Array new: s) replaceFrom: 1 to: (s min: self size) with: self\r)",
 "defaultMedianOf: a <Int> and: b <Int> and: c <Int> ^<Int> = (\r	(* This is an untypesafe method that only works for MutableLists of elements that\r		have Magnitude relationships with each other.  It is used by the default sorting\r		method. *)\r\r	| atA <E> atB <E> atC <E> |\r	atA:: at: a.\r	atB:: at: b.\r	atC:: at: c.\r	^atB <= atA\r		ifFalse: [ atC <= atB\r							ifFalse: [ b ]\r							ifTrue: [ atC <= atA\r												ifFalse: [ c ]\r												ifTrue: [ a ] 	] ]\r		ifTrue: [ atB <= atC\r							ifFalse: [ b ]\r							ifTrue: [ atA <= atC\r												ifFalse: [ c ]\r												ifTrue: [ a ] 	] ]\r)",
 "public defaultSort: l <Int> to: r <Int> = (\r	(* This is an untypesafe method that only works for MutableLists of elements that\r		have Magnitude relationships with each other *)\r\r	| i <Int> j <Int> x <E> m <Int> n <Int> |\r	i:: l.\r	j:: r.\r	n:: ((r - l) + 1).\r	n == 0\r		ifTrue: [ ^self ].\r\r	(* Pick the partition value.  For <=7 elements, use the middle element.\r		For more than 7 but <= 40, use a median of three elements.  For > 40,\r		use a median of three medians of three *)\r	m:: (l + r) // 2.\r	n > 7\r		ifTrue: [ | pl <Int> pn <Int> s <Int> |\r						pl:: l.\r						pn:: r.\r						n > 40\r							ifTrue: [ s:: n // 8.\r											pl:: defaultMedianOf: pl and: pl+s and: pl+s+s.\r											m:: defaultMedianOf: m-s and: m and: m+s.\r											pn:: defaultMedianOf: (pn-s)-s and: pn-s and: pn.	].\r						m:: defaultMedianOf: pl and: m and: pn.		].\r	x:: at: m.\r\r	[i <= j]\r		whileTrue:\r			[ | ati <E> atj <E> |\r			 	[ x <= (ati:: at: i)]\r					whileFalse: [i:: i + 1].\r				[(atj:: at: j) <= x]\r					whileFalse: [j:: j - 1].\r				i <= j\r					ifTrue: [ at: i put: atj.\r									at: j put: ati.\r									i:: i + 1.\r									j:: j - 1]\r			].\r	l < j ifTrue: [defaultSort: l to: j ].\r	i < r ifTrue: [defaultSort: i to: r ].\r)",
 "public do: block = (\r	js call: (js propertyOf: self at: (js literal: 'forEach')) with: {block}.\r)",
 "public do: block separatedBy: betweenBlock = (\r	| firstTime ::= true. |\r\r	self do: [:element |\r		firstTime ifTrue: [ firstTime:: false ] ifFalse: [betweenBlock value].\r		block value: element].\r)",
 "public first = (\r	^self at: 1\r)",
 "public flatMap: map <[:E | R def]> ^<Collection[R]> = (\r	^self flatten collect: map\r)",
 "public flatten ^ <Array> = (\r	| totalSize <Integer> ::= 0. c <Array> index <Integer> ::= 1. |\r	self do: [:e <E> | totalSize:: totalSize + (e isKindOfCollection ifTrue: [e size] ifFalse: [1])].\r	c:: Array new: totalSize.\r	do: [:e <E> | e isKindOfCollection\r					ifTrue: [e do: [:x | c at: index put: x. index:: index + 1]]\r					ifFalse: [c at: index put: e. index:: index + 1]\r		].\r	^c\r)",
 "public includes: element = (\r	self do: [:each | each = element ifTrue: [^true]].\r	^false\r)",
 "public indexOf: element <E> ^<Integer> = (\r	1 to: self size do: [:index | (self at: index) = element ifTrue: [^index]].\r	^0\r)",
 "public inject: initialValue into: accumulator = (\r	^js call: (js propertyOf: self at: (js literal: 'reduce')) with: {accumulator. initialValue}.\r)",
 "public isArray = (\r	^true\r)",
 "public isCollection ^<Boolean> = (\r	^true\r)",
 "public isEmpty = (\r	^0 == size\r)",
 "public isKindOfArray ^<Boolean> = (\r	^true\r)",
 "public isKindOfCollection ^<Boolean> = (\r	^true\r)",
 "public keysAndValuesDo: binaryBlock <[:Integer :E]> = (\r	1 to: self size do: [:index | binaryBlock value: index value: (self at: index)]\r)",
 "public last = (\r	^self at: self size\r)",
 "public mergeSortFrom: startIndex to: stopIndex by: aBlock = (\r	(*Sort the given range of indices using the mergesort algorithm.\r	Mergesort is a worst-case O(N log N) sorting algorithm that usually\r	does only half as many comparisons as heapsort or quicksort.\r\r	Details: recursively split the range to be sorted into two halves,\r	mergesort each half, then merge the two halves together. An extra\r	copy of the data is used as temporary storage and successive merge\r	phases copy data back and forth between the receiver and this copy.\r	The recursion is set up so that the final merge is performed into the\r	receiver, resulting in the receiver being completely sorted.*)\r\r	self size <= 1 ifTrue: [^self]. (* nothing to do *)\r	startIndex = stopIndex ifTrue: [^self].\r	self assert: [startIndex >= 1 and: [startIndex < stopIndex]]. (* bad start index *)\r	self assert: [stopIndex <= self size]. (* bad stop index *)\r	self (* BOGUS: probably replace with splice, sort and replace *)\r		mergeSortFrom: startIndex\r		to: stopIndex\r		src: self clone\r		dst: self\r		by: aBlock\r)",
 "public printString = (\r	| x ::= '{'. |\r	#FLAG. (* This is not safe for arrays that contain themselves. *)\r	self do: [:ea | x:: x , ea printString] separatedBy: [x:: x, '. '].\r	^x , '}'\r)",
 "public replaceFrom: start to: stop with: replacement = (\r	(* This destructively replaces elements from start to stop in the receiver.\r	Answer the receiver itself. Use copyReplaceFrom:to:with: for\r	insertion/deletion which may alter the size of the result. *)\r\r	replacement size = (stop - start + 1)\r		ifFalse: [self error: 'Size of replacement doesnt match'].\r	^self replaceFrom: start to: stop with: replacement startingAt: 1\r)",
 "public replaceFrom: start to: stop with: replacement startingAt: repStart = (\r	(* This destructively replaces elements from start to stop in the receiver\r	starting at index, repStart, in the sequenceable collection,\r	replacementCollection. Answer the receiver. No range checks are\r	performed. *)\r\r	| index repOff |\r	repOff:: repStart - start.\r	index:: start - 1.\r	[(index:: index + 1) <= stop]\r		whileTrue: [self at: index put: (replacement at: repOff + index)]\r)",
 "public select: block = (\r	^js call: (js propertyOf: self at: (js literal: 'filter')) with: {block}.\r)",
 "public size ^<Integer> = (\r	^js verbatim: 'this.length'\r)",
 "public sort: binaryBlock = (\r	js\r		call: (js propertyOf: self at: (js literal: 'sort'))\r		with: {js functionOf: {'a'. 'b'} body: (js block: {\r			js return: ((binaryBlock value: (js ident: 'a') value: (js ident: 'b'))\r				ifTrue: [-1] ifFalse: [1])\r		})}.\r)",
 "public new: size <Integer> = (\r(* should be private but does not work that way! Possible compiler bug. *)\r	^self new: size withAll: nil\r)",
 "new: size <Integer> withAll: initialElement <E> ^<Array[E]> = (\r	| array index |\r	(js prefixOperator: 'typeof ' on: size) == 'number' ifFalse: [^Error signal: 'ArgumentError'].\r	(js operator: '<' with: size and: (js literal: 0)) ifTrue: [^Error signal: 'ArgumentError'].\r\r	array:: js new: (js ident: 'Array') with: {size}.\r	js\r		for: (index:: 0)\r		while: (js operator: '<' with: index and: size)\r		step: (js postfixOperator: '++' on: index)\r		do: (js block: {\r			js assign: (js propertyOf: array at: index) toBe: initialElement}).\r	^array\r)",
 "public with: element = (\r	^{element}\r)",
 "public class Boolean uninstantiable = ()",
 " ",
 " ",
 "public & other = (\r	(* Evaluating conjunction. *)\r	^js operator: '&&' with: self and: other\r)",
 "public asString = (\r	^self ifTrue: ['true'] ifFalse: ['false']\r)",
 "public ifFalse: else = (\r	^js ternaryIf: self then: nil else: (js call: else with: {})\r)",
 "public ifFalse: else ifTrue: then = (\r	^js ternaryIf: self then: (js call: then with: {}) else: (js call: else with: {})\r)",
 "public ifTrue: onTrue = (\r	^js ternaryIf: self then: (js call: onTrue with: {}) else: nil\r)",
 "public ifTrue: then ifFalse: else = (\r	^js ternaryIf: self then: (js call: then with: {}) else: (js call: else with: {})\r)",
 "public isKindOfBoolean = (\r	^true\r)",
 "public not = (\r	^js prefixOperator: '!' on: self.\r)",
 "public printString = (\r	^self ifTrue: ['true'] ifFalse: ['false']\r)",
 "public value = (\r	^self\r)",
 "public | other = (\r	(* Evaluating disjunction. *)\r	^js operator: '||' with: self and: other\r)",
 "public class Class = (|\rpublic superclass\rpublic mixin\rpublic enclosingObject (* Remove me *)\rpublic enclosingObjects\rpublic name\r|)",
 " ",
 " ",
 "public isKindOfBehavior = (\r	^true\r)",
 "public isKindOfClass = (\r	^true\r)",
 "public isMeta = (\r	^true\r)",
 "public mixinApply: newSuperclass = (\r	^vmmirror\r		applyMixin: (js propertyOf: self mixin at: (js literal: 'runtimeMixin'))\r		toSuperclass: newSuperclass\r		withEnclosingObjects: self enclosingObjects\r)",
 "public simpleName = (\r	^mixin name\r)",
 "public class Closure uninstantiable = ()",
 " ",
 " ",
 "public cull: a1 = (\r	^js call: (js ident: 'this') with: {a1}\r)",
 "public cull: a1 cull: a2 = (\r	^js call: (js ident: 'this') with: {a1. a2}\r)",
 "public cull: a1 cull: a2 cull: a3 = (\r	^js call: (js ident: 'this') with: {a1. a2. a3}\r)",
 "public ensure: onUnwind = (\r	| result |\r	js try: (js block: {\r		result:: self value.\r	})\r	catch: (js ident: 'e')\r	with: (js block: {\r		onUnwind value.\r		js throw: (js ident: 'e').\r	}).\r	onUnwind value.\r	^result\r)",
 "public isKindOfClosure ^<Boolean> = (\r	^true\r)",
 "public numArgs ^<Integer> = (\r	^js propertyOf: self at: (js literal: 'length')\r)",
 "public on: errorClass do: handler = (\r	(* Perhaps we should match on mixin instead of class... *)\r	| c |\r	js try: (js block: {js return: self value})\r	catch: (js ident: 'e')\r	with: (js block: {\r		js if: (js operator: '===' with: (js propertyOf: (js ident: 'e') at: (js literal: 'newspeakClass')) and: (js ident: 'undefined'))\r		then: (js block: {js throw: (js ident: 'e')}).\r		js for: (c:: classOf: (js ident: 'e')) while: (js operator: '!==' with: c and: nil) step: (js verbatim: '') do: (js block: {\r			js if: (js operator: '===' with: c and: errorClass)\r			then: (js block: {js return: (handler value: (js ident: 'e'))}).\r			c:: c superclass.\r		}).\r		js throw: (js ident: 'e').\r	})\r)",
 "public value = (\r	^js call: (js ident: 'this') with: {}\r)",
 "public value: a1 = (\r	^js call: (js ident: 'this') with: {a1}\r)",
 "public value: a1 value: a2 = (\r	^js call: (js ident: 'this') with: {a1. a2}\r)",
 "public value: a1 value: a2 value: a3 = (\r	^js call: (js ident: 'this') with: {a1. a2. a3}\r)",
 "public valueWithArguments: args = (\r	^js call: (js propertyOf: (js ident: 'this') at: (js literal: 'apply')) with: {js ident: 'this'. args}\r)",
 "public whileFalse: aBlock = (\r	[self value] whileFalse: [aBlock value].\r	^nil\r)",
 "public class Exception = (|\r	public messageText (* squeak compatibility for Minitest *)\r|)",
 " ",
 " ",
 "public isError = (\r	^true\r)",
 "public printString = (\r	nil = messageText ifTrue: [^super printString].\r	^super printString, messageText\r)",
 "public signal = (\r	js verbatim: 'this.trace = new Error().stack'.\r	js throw: self.\r)",
 "public signal: message = (\r	(* squeak compatibility for Minitest *)\r	messageText:: message.\r	^self signal\r)",
 "public signal: message = (\r	^(self new messageText: message) signal\r)",
 "public class Future computing: block <[E]> = (\r(* The simplest possible future. It evalutes its closure in response to nearly every message. *)\r|\r	private blockOrValue000 <[E] | E> ::= block.\r	private state000 <Symbol> ::= #unresolved.\r|)",
 " ",
 " ",
 "protected doesNotUnderstand: message = (\r	^message sendTo: self resolve\r)",
 "public isFuture ^<Boolean> = (\r	^true\r)",
 "public isKindOfFuture ^<Boolean> = (\r	^true\r)",
 "resolve = (\r	state000 = #resolving ifTrue: [\r		Error signal: 'Divergent evaluation of ', blockOrValue000 printString].\r	state000 = #unresolved ifTrue: [\r		state000: #resolving.\r		blockOrValue000: blockOrValue000 value.\r		[blockOrValue000 isFuture] whileTrue:\r			[blockOrValue000: blockOrValue000 resolve].\r		state000: #resolved.\r	].\r	^blockOrValue000\r)",
 "public yourself = (\r	(* See InstanceMixin>>apply:withName: *)\r	^self resolve\r)",
 "public class Message mangledSelector: s arguments: a = (\r(* FIXME: This factory should not be public. *)\r|\r	public mangledSelector = s.\r	public arguments = a.\r|)",
 " ",
 " ",
 "public printString = (\r	^'#',selector\r)",
 "public selector = (\r	^vmmirror unmangleSelector: mangledSelector\r)",
 "public sendTo: receiver = (\r	^js call: (js propertyOf: (js propertyOf: receiver at: mangledSelector) at: (js literal: 'apply')) with: {receiver. arguments}\r)",
 "mangle: selector = (\r	^((('$', selector)\r		replaceAll: \":\" with: \"$\") (* Keyword *)\r		replaceAll: \"`\" with: \"$\") (* Qualified *)\r		replaceAll: \".\" with: \"$\" (* limit temp *)\r)",
 "public selector: selector = (\r	^self mangledSelector: (mangle: selector) arguments: {}\r)",
 "public selector: selector arguments: arguments = (\r	^self mangledSelector: (mangle: selector) arguments: arguments\r)",
 "public class MessageNotUnderstood receiver: r message: m = Exception (|\r	public receiver = r.\r	public message = m.\r|)",
 "Exception",
 "Exception",
 "public messageText = (\r	(* squeak compatibility for Minitest *)\r	^self printString\r)",
 "public printString ^<String> = (\r	^'MessageNotUnderstood: ', (classOf: receiver) name, ' ', message selector\r)",
 "public class Metaclass = (\r|\rpublic superclass\rpublic mixin\rpublic enclosingObject\rpublic name\rpublic thisClass\r|)",
 " ",
 " ",
 "public isKindOfBehavior = (\r	^true\r)",
 "public isMeta = (\r	^true\r)",
 "public class Mixin fromRuntimeMixin: rm = (js assign: (js propertyOf: self at: (js literal: 'runtimeMixin')) toBe: rm)",
 " ",
 " ",
 "public applyTo: superclass <Class> ^<Class> = (\r	(* assert: [isTopLevel] message: 'Only top-level mixins may be applied directly' *)\r	assert: [isMeta not] message: 'Only instance-side mixins may be applied directly'.\r	^self applyTo: superclass withName: (superclass name, ' <: ', name)\r)",
 "public applyTo: superclass <Class> withName: name <String> ^<Class> = (\r	^vmmirror\r		applyMixin: (js propertyOf: self at: (js literal: 'runtimeMixin'))\r		toSuperclass: superclass\r		withEnclosingObjects: {nil}\r)",
 "public isMeta ^<Boolean> = (\r	^js operator: '===' with: (js propertyOf: (js propertyOf: self at: (js literal: 'runtimeMixin')) at: (js literal: 'meta')) and: (js ident: 'undefined')\r)",
 "public name ^<Symbol> = (\r	^isMeta\r		ifTrue: [(js propertyOf: (js propertyOf: (js propertyOf: self at: (js literal: 'runtimeMixin')) at: (js literal: 'nonMeta')) at: (js literal: 'name')), ' class']\r		ifFalse: [js propertyOf: (js propertyOf: self at: (js literal: 'runtimeMixin')) at: (js literal: 'name')].\r)",
 "public printString ^<String> = (\r	^name, ' mixin'\r)",
 "public class Number uninstantiable = ()",
 " ",
 " ",
 "public * other = (\r	^js operator: '*' with: self and: other\r)",
 "public ** exponent = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'pow')) with: {self. exponent}\r)",
 "public + other = (\r	^js operator: '+' with: self and: other\r)",
 "public - other = (\r	^js operator: '-' with: self and: other\r)",
 "public / other = (\r	^js operator: '/' with: self and: other\r)",
 "public // other = (\r	^(self / other) floor\r)",
 "public < other = (\r	^js operator: '<' with: self and: other\r)",
 "public << other = (\r	^js operator: '<<' with: self and: other\r)",
 "public <= other = (\r	^js operator: '<=' with: self and: other\r)",
 "public = other = (\r	^js operator: '===' with: self and: other\r)",
 "public > other = (\r	^js operator: '>' with: self and: other\r)",
 "public >= other = (\r	^js operator: '>=' with: self and: other\r)",
 "public >> other = (\r	^js operator: '>>' with: self and: other\r)",
 "public \\\\ other = (\r	^self - (self // other * other)\r)",
 "public abs = (\r	self >= 0 ifTrue: [^self] ifFalse: [^-1.0 * self]\r)",
 "public asFloat = (\r	^self * 1.0\r)",
 "public asInteger = (\r	^self truncated\r)",
 "public asString ^<String> = (\r	^js call: (js propertyOf: self at: (js literal: 'toString')) with: {}\r)",
 "public asStringExponential: fractionDigits <Integer> ^<String> = (\r	^js call: (js propertyOf: self at: (js literal: 'toExponential')) with: {fractionDigits}\r)",
 "public asStringFixed: fractionDigits <Integer> ^<String> = (\r	^js call: (js propertyOf: self at: (js literal: 'toFixed')) with: {fractionDigits}\r)",
 "public asStringPrecision: precision <Integer> ^<String> = (\r	^js call: (js propertyOf: self at: (js literal: 'toPrecision')) with: {precision}\r)",
 "public between: min and: max = (\r	^self <= max and: [ self >= min ]\r)",
 "public bitAnd: other = (\r	^js operator: '&' with: self and: other\r)",
 "public bitInvert = (\r	^-1 - self\r)",
 "public bitOr: other = (\r	^js operator: '|' with: self and: other\r)",
 "public bitXor: other = (\r	^js operator: '^' with: self and: other\r)",
 "public ceiling = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'ceil')) with: {self}\r)",
 "public cos = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'cos')) with: {self}\r)",
 "public exp = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'exp')) with: {self}\r)",
 "public floor = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'floor')) with: {self}\r)",
 "public hash = (\r	(* Truncate to signed 32-bit integer. *)\r	^js operator: '|' with: self and: (js literal: 0)\r)",
 "public isKindOfFloat = (\r	^true\r)",
 "public isKindOfInteger = (\r	^self = self asInteger\r)",
 "public isKindOfNumber = (\r	^true\r)",
 "public isNumber = (\r	^true\r)",
 "public ln = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'log')) with: {self}\r)",
 "public max: other = (\r	^self > other ifTrue: [ self ] ifFalse: [ other ]\r)",
 "public min: other = (\r	^self < other ifTrue: [ self ] ifFalse: [ other ]\r)",
 "public printString = (\r	^js call: (js propertyOf: self at: (js literal: 'toString')) with: {}\r)",
 "public quo: other = (\r	^(self / other) truncated\r)",
 "public rem: other = (\r	^self - ((self quo: other) * other)\r)",
 "public rounded = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'round')) with: {self}\r)",
 "public sign = (\r	self > 0 ifTrue: [^1].\r	self < 0 ifTrue: [^-1].\r	^0\r)",
 "public sin = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'sin')) with: {self}\r)",
 "public sqrt = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'sqrt')) with: {self}\r)",
 "public tan = (\r	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'tan')) with: {self}\r)",
 "public timesRepeat: block = (\r	| i ::= 0. |\r	js\r		for: (js verbatim: '')\r		while: (js operator: '<' with: i and: (js ident: 'this'))\r		step: (js postfixOperator: '++' on: i)\r		do: (js block: {js call: block with: {}})\r)",
 "public to: stop = (\r	^platform collections Interval from: self to: stop\r)",
 "public to: limit do: block = (\r	| i ::= self. |\r	js\r		for: (js verbatim: '')\r		while: (js operator: '<=' with: i and: limit)\r		step: (js postfixOperator: '++' on: i)\r		do: (js block: {js call: block with: {i}})\r)",
 "public truncated = (\r	^self > 0 ifTrue: [self floor] ifFalse: [self ceiling]\r)",
 "public parse: str <String> ^<Float> = (\r	^js call: (js ident: 'parseFloat') with: {str}\r)",
 "public class Object = ImplementationBase ()",
 "ImplementationBase",
 "ImplementationBase",
 "public = other = (\r	^js operator: '===' with: self and: other\r)",
 "public == other = (\r	^js operator: '===' with: self and: other\r)",
 "Array ^ <KernelForV8 Array class>= (\r	^outer KernelForV8 Array\r)",
 "Character ^ <KernelForV8 Character class>= (\r	^outer KernelForV8 String\r)",
 "Error ^ <KernelForV8 Error class>= (\r	^outer KernelForV8 Error\r)",
 "Float ^ <KernelForV8 Float class>= (\r	^outer KernelForV8 Number\r)",
 "Future ^ <KernelForV8 Future class> = (\r	^outer KernelForV8 Future\r)",
 "Object ^ <KernelForV8 Object class>= (\r	^outer KernelForV8 Object\r)",
 "String ^ <KernelForV8 String class>= (\r	^outer KernelForV8 String\r)",
 "assert: condition <[Boolean]> message: message = (\r	(* Raises an error with the given message if and only if condition evaluates to false. *)\r	condition isKindOfClosure ifFalse: [Error signal: 'Block required'].\r	condition value ifFalse: [Error signal: 'Assertion failed: ', message]\r)",
 "private cannotReturn: value = (\r	(* compiler entry *)\r	Exception signal: 'CannotReturn: ', value printString.\r)",
 "protected class = (\r	^js propertyOf: (js ident: 'this') at: (js literal: 'newspeakClass')\r)",
 "protected doesNotUnderstand: message = (\r	((message selector startsWith: 'is') and: [message arguments size = 0])\r		ifTrue: [^false].\r	^(MessageNotUnderstood receiver: self message: message) signal\r)",
 "public hash ^<Integer> = (\r	(* It might be worth giving every object the hashCode field at instantiation to avoid map transitions. *)\r	js verbatim: 'while(this.hashCode === 0) this.hashCode = Math.random() * 0x3FFFFFF | 0'.\r	^js verbatim: 'this.hashCode'\r)",
 "public ifNil: nilBlock = (\r	^self\r)",
 "public ifNil: nilBlock ifNotNil: notNilBlock = (\r	^notNilBlock value: self\r)",
 "public ifNotNil: nonNilBlock = (\r	^nonNilBlock value: self\r)",
 "public isAlien = (\r	^false\r)",
 "public isExpat = (\r	^false\r)",
 "public isFuture = (\r	^false\r)",
 "public isKindOfFuture = (\r	^false\r)",
 "public isNil = (\r	^false\r)",
 "public notNil = (\r	^true\r)",
 "public out = (\r	print: self printString\r)",
 "public printString = (\r	^'instance of ', self class name\r)",
 "public yourself = (\r	^self\r)",
 "public ~= other = (\r	^(self = other) not\r)",
 "public class Stopwatch = (|\rprivate cumulativeMillis ::= 0.\rprivate startMillis\r|)",
 " ",
 " ",
 "private currentMonotonicMillis = (\r	^js verbatim: 'performance.now()'\r)",
 "public elapsedMicroseconds ^<Integer> = (\r	^elapsedMilliseconds * 1000\r)",
 "public elapsedMilliseconds ^<Integer> = (\r	nil = startMillis ifTrue: [^cumulativeMillis].\r	^cumulativeMillis + (currentMonotonicMillis - startMillis)\r)",
 "public start = (\r	nil = startMillis ifFalse: [^self (* Already running. *)].\r	startMillis:: currentMonotonicMillis\r)",
 "public stop = (\r	nil = startMillis ifTrue: [^self (* Already stopped. *)].\r	cumulativeMillis:: cumulativeMillis + (currentMonotonicMillis - startMillis).\r	startMillis:: nil.\r)",
 "public class String uninstantiable = ()",
 " ",
 " ",
 "public , other = (\r	^js call: (js propertyOf: self at: (js literal: 'concat')) with: {other}\r)",
 "public = other = (\r	^js operator: '===' with: self and: other\r)",
 "public asString = (\r	^self\r)",
 "public asSymbol = (\r	^self\r)",
 "public at: index = (\r	^js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1))\r)",
 "protected class = (\r	^String\r)",
 "public copyFrom: start to: end = (\r	^js call: (js propertyOf: self at: (js literal: 'substring')) with: {start - 1. end}\r)",
 "public do: action = (\r	|\r	i ::= 0.\r	len ::= js verbatim: 'this.length'.\r	|\r	js\r		for: (js verbatim: '')\r		while: (js operator: '<' with: i and: len)\r		step: (js postfixOperator: '++' on: i)\r		do: (js block: {\r			js call: action with: {js propertyOf: self at: i}}).\r)",
 "public endsWith: substring = (\r	^js call: (js propertyOf: self at: (js literal: 'endsWith')) with: {substring}\r)",
 "public first = (\r	^self at: 1\r)",
 "public hash = (\r	js var: 'l' value: (js propertyOf: (js ident: 'this') at: (js literal: 'length')).\r	^js ternaryIf: (js operator: '==' with: (js ident: 'l') and: (js literal: 0))\r		then: (js literal: 0)\r		else: (js verbatim: '(l * 32 ^ this.charCodeAt(0)) * 32 ^ this.charCodeAt(l - 1)')\r)",
 "public includes: object = (\r	self do: [:element | object = element ifTrue: [^true]].\r	^false\r)",
 "public indexOf: substring <String> ^ <Integer> = (\r	^1 + (js call: (js propertyOf: self at: (js literal: 'indexOf')) with: {substring})\r)",
 "public indexOf: substring <String> startingAt: index <Integer> ^<Integer> = (\r	^1 + (js call: (js propertyOf: self at: (js literal: 'indexOf')) with: {substring. index - 1})\r)",
 "public isEmpty ^ <Boolean> = (\r  ^0 = size\r)",
 "public isKindOfString ^ <Boolean> = (\r	^true\r)",
 "public isString ^ <Boolean> = (\r	^true\r)",
 "public last = (\r	^self at: self size\r)",
 "public lastIndexOf: substring <String> ^<Integer> = (\r	^1 + (js call: (js propertyOf: self at: (js literal: 'lastIndexOf')) with: {substring})\r)",
 "public out = (\r	print: self.\r)",
 "public printString = (\r	^js verbatim: '\"''\"+this.toString()+\"''\"'\r)",
 "public replaceAll: substring with: newSubstring = (\r	#BOGUS. (* Ought to be able to say this.replace(target, replacement, 'g'). *)\r	js var: 'target' value: substring.\r	js var: 'replacement' value: newSubstring.\r	^js verbatim: 'this.replace(new RegExp(target.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"), \"g\"), replacement)'\r)",
 "public runeAt: index = (\r	(* This is wrong for surrogate pairs. *)\r	^js call: (js propertyOf: self at: (js literal: 'charCodeAt')) with: {index - 1}\r)",
 "public size = (\r	^js verbatim: 'this.length'\r)",
 "public splitBy: str = (\r	^js call: (js propertyOf: self at: (js literal: 'split')) with: {str}\r)",
 "public startsWith: substring = (\r	^js call: (js propertyOf: self at: (js literal: 'startsWith')) with: {substring}\r)",
 "public cr = (\r	^js verbatim: '\"\\r\"'\r)",
 "public fromRune: rune = (\r	^js call: (js propertyOf: (js ident: 'String') at: (js literal: 'fromCharCode')) with: {rune}\r)",
 "public fromRunes: runes = (\r	^js call: (js propertyOf: (js propertyOf: (js ident: 'String') at: (js literal: 'fromCharCode')) at: (js literal: 'apply')) with: {js ident: 'null'. runes asArray}.\r)",
 "public lf = (\r	^js verbatim: '\"\\n\"'\r)",
 "public space = (\r	^\" \"\r)",
 "public tab = (\r	^js verbatim: '\"\\t\"'\r)",
 "public withAll: characters = (\r	^js call: (js propertyOf: characters asArray at: (js literal: 'join')) with: {js literal: ''}\r)",
 "public class StringBuilder = (|\rprotected parts = platform collections List new.\rprotected sizeX ::= 0.\r|)",
 " ",
 " ",
 "public add: string = (\r	sizeX:: sizeX + string size.\r	^parts add: string\r)",
 "public asString = (\r	^js call: (js propertyOf: parts asArray at: (js literal: 'join')) with: {js literal: ''}\r)",
 "public size = (\r	^sizeX\r)",
 "public writeln: line = (\r	self add: line.\r	self add: String lf.\r)",
 "public class UndefinedObject uninstantiable = ()",
 " ",
 " ",
 "public ifNil: nilBlock = (\r	^nilBlock value\r)",
 "public ifNil: nilBlock ifNotNil: notNilBlock = (\r	^nilBlock value\r)",
 "public ifNotNil: notNilBlock = (\r	^self\r)",
 "public isNil = (\r	^true\r)",
 "public notNil = (\r	^false\r)",
 "public printString = (\r	^'nil'\r)",
 "class ActorsForV8 usingPlatform: p = (|\rprivate WeakMap = p collections IdentityMap.\rprivate List = p collections List.\r\rprivate internalRefs <WeakMap[FarReference, InternalFarReference]> = WeakMap new.\r\rpublic Promise = PromiseUtils new.\r\rdefaultActor = DOMActor named: 'Default actor'.\r|js assign: (js ident: 'currentActor') toBe: defaultActor)",
 " ",
 " ",
 "private asInternalRef: externalRefOrUnboxedNearRef = (\r	^(isRef: externalRefOrUnboxedNearRef)\r		ifTrue: [internalRefs at: externalRefOrUnboxedNearRef ifAbsent: [halt]]\r		ifFalse: [InternalNearRef wrapping: externalRefOrUnboxedNearRef __owner: currentActor]\r)",
 "private check: object allowedIn: actor = (\r	assert: [nil ~= actor] message: 'Invalid actor'.\r\r	(isRef: object) ifTrue: [object __owner == actor ifFalse: [halt]].\r	(* Otherwise near reference *)\r)",
 "private createFarReferenceTo: target in: targetActor for: sourceActor = (\r	^(InternalFarReference target: target targetsActor: targetActor __owner: sourceActor) externalRef.\r)",
 "private createRemotePromiseOf: resolverInTarget in: targetActor for: sourceActor = (\r	| sourceResolver redirector message remotePromise |\r	sourceActor == targetActor ifTrue: [halt].\r\r	sourceResolver:: InternalLocalPromise __owner: sourceActor.\r	sourceResolver state: #remote.\r	sourceResolver _targetPromise: resolverInTarget.\r	sourceResolver _targetActor: targetActor.\r\r	redirector:: RedirectReactor\r		from: targetActor\r		to: sourceActor\r		resolver: sourceResolver.\r\r	message:: PendingDelivery\r		receiver: resolverInTarget\r		selector: #addReactor:\r		arguments: {redirector}\r		resolver: nil.\r	targetActor enqueueMessage: message.\r\r	^Ref wrapping: sourceResolver __owner: sourceActor.\r)",
 "private currentActor = (\r	^js ident: 'currentActor'\r)",
 "private isRef: object <Object> ^<Boolean> = (\r	^Ref == (js propertyOf: object at: (js literal: 'newspeakClass'))\r)",
 "private isValueObject: object <Object> ^<Boolean> = (\r	nil == object ifTrue: [^true].\r	true == object ifTrue: [^true].\r	false == object ifTrue: [^true].\r	object isString ifTrue: [^true].\r	object isNumber ifTrue: [^true].\r	object isCharacter ifTrue: [^true].\r	object isBehavior ifTrue: [^isValueObject: object enclosingClass].\r	Promise == object ifTrue: [^true].\r	^false\r)",
 "private wrapArgument: argument from: sourceActor to: targetActor = (\r	(* [argument] lives in [sourceActor], answer the corresponding proxy that lives in [targetActor] *)\r\r	sourceActor == targetActor ifTrue: [halt. (* We can't tell which side a near reference belongs to here, so we must have decided this earlier. *) ].\r\r	^(asInternalRef: argument) wrapFor: targetActor\r)",
 "private wrapArguments: arguments from: sourceActor to: targetActor = (\r	^arguments collect: [:argument | wrapArgument: argument from: sourceActor to: targetActor].\r)",
 "public class Actor named: debugName <String> = (|\rprivate (* N.B. Do not leak to subinstances. *) internalActor = DOMActor named: debugName.\r|)",
 " ",
 " ",
 "public interrupt = (\r	unimplemented\r)",
 "public onError: onError <[:E]> = (\r	unimplemented.\r)",
 "public seed: value <Value> ^<FarReference[Value]> = (\r	(* Creating a far reference to a PassByCopy is questionable. It may be that this should be seed: receiver perform: selector with: argument. *)\r	(isValueObject: value) ifFalse: [Error signal: 'Cannot seed an actor with a non-Value.'].\r	^createFarReferenceTo: value in: internalActor for: currentActor.\r)",
 "public terminate = (\r	unimplemented\r)",
 "class DOMActor named: n = InternalActor (\r(* An actor whose turns run in the DOM Context. *)\r|\r	protected name <String> = n.\r|)",
 "InternalActor",
 "InternalActor",
 "public enqueueMessage: actorMessage = (\r	actorMessage postedTo: self.\r\r	(* bogus - should drain an explicit queue to allow for a randomizing scheduler *)\r	js\r		call: (js propertyOf: (js ident: 'theGlobalObject') at: (js literal: 'setTimeout'))\r		with: {[js assign: (js ident: 'currentActor') toBe: self.\r				actorMessage deliverIn: self]. js literal: 0}.\r)",
 "protected class EventualSendReactor selector: s arguments: a resolver: r = (\r(* An eventual-send to a promise.\r\rNote that all slots contain objects that belong to the actor which performed the eventual send. *)\r|\rprotected selector <Symbol> = s.\rprotected arguments <Array> = a.\rprotected resolver <InternalResolver> = r.\r|)",
 " ",
 " ",
 "public reactBroken: error = (\r	(* Broken promise contagion. *)\r	resolver __owner == currentActor ifFalse: [halt].\r	(* Should this be immediate? *)\r	(* resolver internalBreak: error. ? *)\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: resolver\r			selector: #internalResolve:\r			arguments: {InternalBrokenRef problem: error __owner: resolver __owner}\r			resolver: nil)\r)",
 "public reactMoreResolved: internalRef = (\r	resolver internalResolve: (asInternalRef: (internalRef eventualSend: selector arguments: arguments)).\r)",
 "public reactResolved: value = (\r	resolver __owner == currentActor ifFalse: [halt].\r	resolver internalResolve:\r		(asInternalRef: (currentActor\r			eventualSendTo: value\r			selector: selector\r			arguments: arguments))\r)",
 "class InternalActor = ()",
 " ",
 " ",
 "public currentActor = (\r	(* BOGUS. Polymorphic with other actor system. *)\r	^self\r)",
 "public eventualSendTo: receiver selector: selector arguments: arguments ^<Ref> = (\r	(* Sent from the compilation of an eventual send, via the same method in ProcessScheduler. *)\r	^(asInternalRef: receiver) eventualSend: selector arguments: arguments\r)",
 "class InternalBrokenRef problem: p __owner: o = InternalRef __owner: o (|\rprotected problem = p.\r|)",
 "__owner: o",
 "__owner: o",
 "public addReactor: reactor = (\r	reactor reactBroken: problem.\r)",
 "public checkCycle ^<Boolean> = (\r	^false\r)",
 "public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (\r	^self externalRef (* I.e., broken with same problem. Should this wait for the next turn? *)\r)",
 "public immediateSend: message <Message> ^<Object> = (\r	^Error signal: 'Cannot immediate-send to a broken ref: ', message selector\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'InternalBrokenRef: '.\r	problem printOn: stream.\r)",
 "public refPrintOn: stream = (\r	stream nextPutAll: '<broken ref: '.\r	problem printOn: stream.\r	stream nextPutAll: '>'.\r)",
 "public shorten ^<InternalRef> = (\r	^self\r)",
 "public whenFulfilled: onValue whenBroken: onError ^<Ref> = (\r	| localPromise = InternalLocalPromise __owner: __owner. |\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: onError\r			selector: #cull:\r			arguments: {problem}\r			resolver: localPromise).\r	^localPromise externalRef\r)",
 "public wrapFor: targetActor = (\r	self checkCurrentActor.\r	#BOGUS.\r	^(InternalBrokenRef problem: problem __owner: targetActor) externalRef\r)",
 "class InternalFarReference target: t targetsActor: ta __owner: o = InternalRef __owner: o (|\rprotected target = t.\rprotected targetsActor = ta.\r|)",
 "__owner: o",
 "__owner: o",
 "public addReactor: reactor = (\r	reactor reactResolved: externalRef\r)",
 "public checkCycle ^<Boolean> = (\r	^false\r)",
 "public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (\r	| resolverInTarget remotePromise redirector |\r	resolverInTarget:: InternalLocalPromise __owner: targetsActor.\r	targetsActor enqueueMessage:\r		(PendingDelivery\r			receiver: target\r			selector: selector\r			arguments: (wrapArguments: arguments from: currentActor to: targetsActor)\r			resolver: resolverInTarget).\r\r	remotePromise:: InternalRemotePromise\r		target: resolverInTarget\r		targetsActor: targetsActor\r		__owner: currentActor.\r\r	redirector:: RedirectReactor\r		from: targetsActor\r		to: currentActor\r		resolver: remotePromise.\r	targetsActor enqueueMessage:\r		(PendingDelivery\r			receiver: resolverInTarget\r			selector: #addReactor:\r			arguments: {redirector}\r			resolver: nil).\r\r	^remotePromise externalRef\r)",
 "public immediateSend: message <Message> ^<Object> = (\r	^Error signal: 'Cannot immediate-send to an eventual ref: ', message selector\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'InternalFarRef: '.\r	target printOn: stream.\r)",
 "public refPrintOn: stream = (\r	stream nextPutAll: '<far ref: '.\r	target printOn: stream.\r	stream nextPutAll: '>'.\r)",
 "public shorten ^<InternalRef> = (\r	^self\r)",
 "public whenFulfilled: onValue whenBroken: onError ^<Ref> = (\r	| localPromise = InternalLocalPromise __owner: __owner. |\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: onValue\r			selector: #cull:\r			arguments: {externalRef}\r			resolver: localPromise).\r	^localPromise externalRef\r)",
 "public wrapFor: targetActor = (\r	targetsActor == targetActor ifTrue: [^target].\r	^(InternalFarReference target: target targetsActor: targetsActor __owner: targetActor) externalRef.\r)",
 "class InternalLocalPromise __owner: o = InternalRef __owner: o (|\rprotected state ::= #unresolved. (* resolving. resolved *)\rprotected resolution <InternalRef>\rprotected reactors\r|)",
 "__owner: o",
 "__owner: o",
 "public addReactor: reactor = (\r	state == #unresolved ifTrue:\r		[reactors == nil ifTrue: [reactors:: List new].\r		reactors add: reactor.\r		^self].\r	state == #resolved ifTrue:\r		[^resolution addReactor: reactor].\r	halt.\r)",
 "public checkCycle ^<Boolean> = (\r	state == #resolving ifTrue: [^true].\r	state == #unresolved ifTrue: [^false].\r	state == #resolved ifTrue: [^resolution checkCycle].\r	halt.\r)",
 "public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (\r	| localPromise |\r	self checkCurrentActor.\r	state == #resolved ifTrue: [^resolution eventualSend: selector arguments: arguments].\r	localPromise:: InternalLocalPromise __owner: __owner.\r	self addReactor: (EventualSendReactor selector: selector arguments: arguments resolver: localPromise).\r	^localPromise externalRef\r)",
 "public immediateSend: message <Message> ^<Object> = (\r	state == #resolved ifTrue: [^resolution immediateSend: message].\r	^Error signal: 'Cannot immediate-send to an eventual ref: ', message selector\r)",
 "public internalResolve: internalRef <InternalRef> = (\r	state == #unresolved ifFalse: [^Error signal: 'Already resolved'].\r	internalRef isInternalRef ifFalse: [halt].\r\r	state:: #resolving.\r	internalRef checkCycle\r		ifTrue: [resolution:: InternalBrokenRef problem: (Error new messageText: 'Cyclic resolution') __owner: __owner]\r		ifFalse: [resolution:: internalRef].\r	state:: #resolved.\r\r	nil == reactors ifFalse:\r		[reactors do: [:reactor | resolution addReactor: reactor].\r		reactors:: nil].\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'InternalLocalPromise: '.\r	state printOn: stream.\r)",
 "public refPrintOn: stream = (\r	state == #resolved\r		ifTrue: [resolution refPrintOn: stream]\r		ifFalse: [stream nextPutAll: '<local promise>'].\r)",
 "public shorten ^<InternalRef> = (\r	state == #unresolved ifTrue: [^self].\r	state == #resolved ifTrue: [^resolution].\r	halt.\r)",
 "public whenFulfilled: onValue whenBroken: onError ^<Ref> = (\r	| localPromise |\r	self checkCurrentActor.\r	state == #resolved ifTrue: [^resolution whenFulfilled: onValue whenBroken: onError].\r	localPromise:: InternalLocalPromise __owner: __owner.\r	self addReactor: (WhenReactor onValue: onValue onError: onError resolver: localPromise).\r	^localPromise externalRef\r)",
 "public wrapFor: targetActor = (\r	state == #resolved ifTrue: [^resolution wrapFor: targetActor].\r\r	checkCurrentActor.\r	targetActor == __owner ifTrue: [halt].\r\r	^(InternalRemotePromise target: self targetsActor: currentActor __owner: targetActor) externalRef\r)",
 "class InternalNearRef wrapping: t __owner: o = InternalRef __owner: o (|\rprotected target = t.\r|)",
 "__owner: o",
 "__owner: o",
 "public addReactor: reactor = (\r	reactor reactResolved: target.\r)",
 "public checkCycle ^<Boolean> = (\r	^false\r)",
 "public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (\r	| localPromise = InternalLocalPromise __owner: __owner. |\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: target\r			selector: selector\r			arguments: arguments\r			resolver: localPromise).\r	^localPromise externalRef\r)",
 "public immediateSend: message <Message> ^<Object> = (\r	^message sendTo: target\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'InternalNearRef: '.\r	target printOn: stream.\r)",
 "public refPrintOn: stream = (\r	stream nextPutAll: '<near ref: '.\r	target printOn: stream.\r	stream nextPutAll: '>'.\r)",
 "public shorten ^<InternalRef> = (\r	^self\r)",
 "public whenFulfilled: onValue whenBroken: onError ^<Ref> = (\r	| localPromise = InternalLocalPromise __owner: __owner. |\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: onValue\r			selector: #cull:\r			arguments: {target}\r			resolver: localPromise).\r	^localPromise externalRef\r)",
 "public wrapFor: targetActor = (\r	self checkCurrentActor.\r	(isValueObject: target) ifTrue: [^target].\r	^createFarReferenceTo: target in: currentActor for: targetActor\r)",
 "class InternalRef __owner: o = (|\rpublic __owner <InternalActor> = o.\r|)",
 " ",
 " ",
 "protected checkCurrentActor = (\r	currentActor == __owner ifFalse: [halt].\r)",
 "public checkCycle ^<Boolean> = (\r	subclassResponsibility\r)",
 "public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (\r	subclassResponsibility\r)",
 "public externalRef = (\r	^Ref wrapping: self\r)",
 "public immediateSend: message <Message> ^<Object> = (\r	subclassResponsibility\r)",
 "public isInternalRef ^<Boolean> = (\r	^true\r)",
 "public refPrintOn: stream = (\r	subclassResponsibility\r)",
 "public shorten ^<InternalRef> = (\r	subclassResponsibility\r)",
 "public whenFulfilled: onValue whenBroken: onError ^<Ref> = (\r	subclassResponsibility\r)",
 "public wrapFor: targetActor = (\r	subclassResponsibility\r)",
 "class InternalRemotePromise target: t targetsActor: ta __owner: o = InternalRef __owner: o (|\rtarget <InternalLocalPromise> = t.\rtargetsActor <InternalActor> = ta.\rstate ::= #unresolved.\rresolution <InternalRef>\r|)",
 "__owner: o",
 "__owner: o",
 "public addReactor: reactor = (\r	state == #resolved ifTrue: [^resolution addReactor: reactor].\r	state == #unresolved ifTrue: [^reactor reactMoreResolved: self].\r	stop5.\r)",
 "public checkCycle ^<Boolean> = (\r	state == #resolving ifTrue: [^true].\r	state == #unresolved ifTrue: [^false].\r	state == #resolved ifTrue: [^resolution checkCycle].\r	halt.\r)",
 "public eventualSend: selector <Symbol> arguments: arguments <Array> ^<Ref> = (\r	| resolverInTarget remotePromise redirector |\r	resolverInTarget:: InternalLocalPromise __owner: targetsActor.\r	targetsActor enqueueMessage:\r		(PendingDelivery\r			receiver: target\r			selector: #eventualSend:arguments:\r			arguments: {selector. (wrapArguments: arguments from: currentActor to: targetsActor)}\r			resolver: resolverInTarget).\r\r	remotePromise:: InternalRemotePromise\r		target: resolverInTarget\r		targetsActor: targetsActor\r		__owner: currentActor.\r\r	redirector:: RedirectReactor\r		from: targetsActor\r		to: currentActor\r		resolver: remotePromise.\r	targetsActor enqueueMessage:\r		(PendingDelivery\r			receiver: resolverInTarget\r			selector: #addReactor:\r			arguments: {redirector}\r			resolver: nil).\r\r	^remotePromise externalRef\r)",
 "public immediateSend: message <Message> ^<Object> = (\r	state == #resolved ifTrue: [^resolution immediateSend: message].\r	^Error signal: 'Cannot immediate-send to an eventual ref: ', message selector\r)",
 "public internalResolve: internalRef <InternalRef> = (\r	state == #unresolved ifFalse: [^Error signal: 'Already resolved'].\r	internalRef isInternalRef ifFalse: [halt].\r\r	state:: #resolving.\r	internalRef checkCycle\r		ifTrue: [resolution:: InternalBrokenRef problem: (Error new messageText: 'Cyclic resolution') __owner: __owner]\r		ifFalse: [resolution:: internalRef].\r	state:: #resolved.\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'InternalRemotePromise: '.\r	state printOn: stream.\r)",
 "public redirectFrom: sourceActor to: destinationActor resolving: resolver = (\r	| redirector |\r	destinationActor == targetsActor ifTrue:\r		[targetsActor enqueueMessage:\r			(PendingDelivery\r				receiver: resolver\r				selector: #internalResolve:\r				arguments: {target}\r				resolver: nil).\r		^self].\r\r	redirector:: RedirectReactor\r		from: targetsActor\r		to: destinationActor\r		resolver: resolver.\r	targetsActor enqueueMessage:\r		(PendingDelivery\r			receiver: target\r			selector: #addReactor:\r			arguments: {redirector}\r			resolver: nil).\r)",
 "public refPrintOn: stream = (\r	state == #resolved\r		ifTrue: [resolution refPrintOn: stream]\r		ifFalse: [stream nextPutAll: '<remote promise>'].\r)",
 "public shorten ^<InternalRef> = (\r	state == #unresolved ifTrue: [^self].\r	state == #resolved ifTrue: [^resolution].\r	halt.\r)",
 "public whenFulfilled: onValue whenBroken: onError ^<Ref> = (\r	| localPromise redirector |\r	self checkCurrentActor.\r	state == #resolved ifTrue: [^resolution whenFulfilled: onValue whenBroken: onError].\r\r	localPromise:: InternalLocalPromise __owner: __owner.\r	redirector:: RedirectReactor\r		from: targetsActor\r		to: currentActor\r		resolver: localPromise.\r	targetsActor enqueueMessage:\r		(PendingDelivery\r			receiver: target\r			selector: #addReactor:\r			arguments: {redirector}\r			resolver: nil).\r	^localPromise whenFulfilled: onValue whenBroken: onError.\r)",
 "public wrapFor: targetActor = (\r	state == #resolved ifTrue: [^resolution wrapFor: targetActor].\r\r	targetActor == targetsActor ifTrue: [^target externalRef].\r\r	^(InternalRemotePromise target: target targetsActor: targetsActor __owner: targetActor) externalRef\r)",
 "protected class PendingDelivery receiver: r selector: s arguments: a resolver: y = (\r(* A message in an actor's event queue. Every turn starts by sending #deliverIn:.\r\rNote that all slots contain objects that belong to the actor in which the message is queued, even the resolver. *)\r|\rprotected receiver <Object> = r.\rprotected selector <Symbol> = s.\rprotected arguments <Array> = a.\rprotected resolver <InternalResolver> = y.\r|)",
 " ",
 " ",
 "public deliverIn: fastCurrentActor = (\r	| resolution type msg |\r\r	(* Transcript print: fastCurrentActor; space; print: self; cr. *)\r\r	[(* BOGUS: Don't rely on perform not being overridden. *)\r	resolution:: receiver perform: selector withArguments: arguments.\r	type:: #internalResolve:]\r		on: Error (* BOGUS: Exception? *)\r		do: [:error |\r			error out.\r			resolver == nil ifTrue: [error pass].\r			resolution:: error.\r			type:: #internalBreak:].\r\r	(* Transcript show: {resolver. type. resolution}; cr. *)\r\r	nil == resolver ifTrue: [\r		type == #internalBreak: ifTrue: [{'silent failure'. resolution} out].\r		^self].\r\r	resolver internalResolve: (type == #internalResolve:\r		ifTrue: [asInternalRef: resolution]\r		ifFalse: [InternalBrokenRef problem: resolution __owner: self]).\r)",
 "public postedTo: actor = (\r	(*check: receiver allowedIn: actor.\r	arguments do: [:arg | check: arg allowedIn: actor].*)\r\r	(* selector numArgs == arguments size ifFalse: [halt]. *)\r	resolver == nil ifFalse: [resolver __owner == actor ifFalse: [halt]].\r)",
 "public printOn: stream = (\r	receiver printOn: stream.\r	stream nextPutAll: ' <-: '.\r	stream nextPutAll: selector.\r	stream space.\r	arguments isEmpty ifFalse: [arguments printOn: stream].\r)",
 "class PromiseUtils = ()",
 " ",
 " ",
 "public all: refs <List[Promise[V, E]]> ^<Promise[List[V], E]> = (\r	(* Answers a promise that resolves with all the resolutions of refs, or the first problem. *)\r)",
 "public broken: problem <E> ^<Promise[nil, E]> = (\r	^Resolver new break: problem; promise\r)",
 "public fulfilled: resolution <V> ^<Promise[V, nil]> = (\r	^Resolver new fulfill: resolution; promise\r)",
 "public timeout: ref <Promise[V, E]> after: milliseconds <Integer> ^<Promise[V, E | TimeoutError]> = (\r	(* Answers a promise that resolves with the resolution of ref, or a TimeoutError if refs is not resolved within milliseconds. *)\r	#BOGUS. (* Should have proper duration type. *)\r)",
 "public when: ref <Promise[V, E]> fulfilled: onValue <[:V | V2 def]> ^<Promise[V2, E]> = (\r	(* Subscribe to notification of a reference being fulfilled. If ref is fulfilled, onValue will run in some turn after the turn that resolves ref, and the returned promise with be resolved with the result of onValue. If ref is broken, the returned promise with be broken with the same error. *)\r	^(asInternalRef: ref) whenFulfilled: onValue whenBroken: [:e | e signal] (* Should we make this the behavior of a nil catch-clause instead? *)\r)",
 "public when: ref <Promise[V, E]> fulfilled: onValue <[:V | V2 def]> broken: onError <[:E | E2 def]> ^<Promise[V2, E2]> = (\r	(* Subscribe to notification of a reference being fulfilled or broken. onValue or onError respectively will run in some turn after the turn that resolves ref., and the returned promise with be resolved with the result of the callback. *)\r	^(asInternalRef: ref) whenFulfilled: onValue whenBroken: onError\r)",
 "public when: ref <Promise> partitioned: onPartition <[:Promise | R def] | [R def]> ^<Promise[R, nil]> = (\r	(* Subscribe to notification of a reference breaking due to partition. *)\r)",
 "protected class RedirectReactor from: s to: d resolver: r = (\r(* A bridge between InternalResolvers in different actors. *)\r|\rprotected sourceActor <Actor> = s.\rprotected destinationActor <Actor> = d.\rprotected resolver <InternalResolver> = r.\r|)",
 " ",
 " ",
 "public reactBroken: r = (\r	| msg |\r	currentActor == sourceActor ifFalse: [halt].\r	msg:: PendingDelivery\r		receiver: resolver\r		selector: #internalResolve:\r		arguments: {InternalBrokenRef problem: r __owner: destinationActor}\r		resolver: nil.\r	destinationActor enqueueMessage: msg.\r)",
 "public reactMoreResolved: internalRef = (\r	internalRef redirectFrom: sourceActor to: destinationActor resolving: resolver.\r)",
 "public reactResolved: r = (\r	| msg |\r	currentActor == sourceActor ifFalse: [halt].\r	msg:: PendingDelivery\r		receiver: resolver\r		selector: #internalResolve:\r		arguments: {asInternalRef: (wrapArgument: r from: sourceActor to: destinationActor)}\r		resolver: nil.\r	destinationActor enqueueMessage: msg.\r)",
 "class Ref wrapping: ref = (|\rprotected internalRef = ref.\r|internalRefs at: self put: ref)",
 " ",
 " ",
 "protected doesNotUnderstand: message <Message> = (\r	(* For the debugger/inspector. Questionable. *)\r	(* Should probably override public method of Object as well. *)\r	0 = message arguments size ifTrue: [(message selector startsWith: 'is') ifTrue: [^false]].\r	^internalRef immediateSend: message\r)",
 "public isPromise = (\r	^true\r)",
 "public printOn: stream = (\r	(* BOGUS - debugging *)\r	internalRef refPrintOn: stream.\r)",
 "protected yourself = (\r	^super yourself\r)",
 "public class Resolver = (\r(*A Resolver represents the authority to resolve a Promise and is the control facet of the promise's eventual resolution.*)\r|\r	private (* N.B. We must not leak access to an InternalResolver via subobjects. *) internalResolver = InternalLocalPromise __owner: currentActor.\r	public promise <Promise[V, E]> = internalResolver externalRef.\r|)",
 " ",
 " ",
 "public break: error <E> = (\r	internalResolver internalResolve: (InternalBrokenRef problem: error __owner: currentActor).\r)",
 "public fulfill: value <V> = (\r	internalResolver internalResolve: (asInternalRef: value).\r)",
 "public isResolver ^<Boolean> = (\r	^true\r)",
 "class Scheduler = ()",
 " ",
 " ",
 "public eventualSendTo: r selector: s arguments: a = (\r)",
 "public class Timer __duration: milliseconds callback: callback repeating: repeating = (|\r	protected cancelled ::= false.\r|repeating\r		ifTrue: [self schedule: callback every: milliseconds]\r		ifFalse: [self schedule: callback after: milliseconds])",
 " ",
 " ",
 "public cancel = (\r	cancelled:: true.\r	nil == process ifFalse: [process terminate. process:: nil].\r)",
 "public isActive ^<Boolean> = (\r	cancelled ifTrue: [^false].\r	^nil ~= process\r)",
 "public isTimer ^<Boolean> = (\r	^true\r)",
 "protected schedule: callback after: ms = (\r	js call: (js propertyOf: (js ident: 'window') at: (js literal: 'setTimeout'))\r	with: {callback. ms}\r)",
 "protected schedule: callback every: ms = (\r	js call: (js propertyOf: (js ident: 'window') at: (js literal: 'setInterval'))\r	with: {callback. ms}\r)",
 "public after: duration do: callback <[]> ^<Timer> = (\r	^self __duration: duration callback: callback repeating: false\r)",
 "public every: duration do: callback <[:Timer]> ^<Timer> = (\r	^self __duration: duration callback: callback repeating: true\r)",
 "protected class WhenReactor onValue: v onError: e resolver: r = (\r(* A when-catch for a promise.\r\rNote that all slots contain objects that belong to the actor which sent #whenResolved:. *)\r|\r	protected onValue <[:V] | []> = v.\r	protected onError <[:E] | []> = e.\r	protected resolver <InternalResolver> = r.\r|)",
 " ",
 " ",
 "public reactBroken: value = (\r	resolver __owner == currentActor ifFalse: [halt].\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: onError\r			selector: #cull:\r			arguments: {value}\r			resolver: resolver).\r)",
 "public reactMoreResolved: internalRef = (\r	resolver internalResolve: (asInternalRef: (internalRef whenFulfilled: onValue whenBroken: onError)).\r)",
 "public reactResolved: value = (\r	resolver __owner == currentActor ifFalse: [halt].\r	currentActor enqueueMessage:\r		(PendingDelivery\r			receiver: onValue\r			selector: #cull:\r			arguments: {value}\r			resolver: resolver).\r)",
 "class AliensForV8 usingPlatform: p = (\r(* Aliens are a capability-based API for a foreign function interface (FFI). On NS2V8, they allow Newspeak code to invoke JavaScript code and vice versa.\r\rAn Alien is a Newspeak proxy for a JavaScript object. Upon receiving a message, an Alien expatriates the arguments, sends the message to the target JavaScript object, and alienates the result.\r\rAn Expat is a JavaScript proxy for a Newspeak object. Unpon receiving a message, an Expat alienates the arguments, sends the message to the target Newspeak object, and expatriates the result.\r\rA bilingual object is one whose representation is the same in both languages: unwrapped basic types such as numbers, booleans. Note that even though Newspeak and JavaScript closures have the same representation, they are not bilingual and wrapping should occur because Newspeak closures expect Newspeak/Alien arguments and JavaScript closures expect JavaScript/Expat arguments. What about strings and arrays? It would seem we have to wrap arrays because their elements should be alieniated/expatriated. It may be safe to treat strings as bilingual if they always respond to messages with other bilingual objects.\r\rAlien mappings:\ralien sort: a ignored: b ignored: c -> alien.sort(a, b, c)\ralien new: a ignored: b ignored: c  -> new alien(a, b, c)\ralien at: 'a' -> alien.a\ralien at: 'a' put: b -> alien.a = b\r\rExpat mappings:\r?\r\r*)\r|\rpublic global = Alien wrapping: (js ident: 'theGlobalObject').\r|)",
 " ",
 " ",
 "alienate: jsObj = (\r	#TODO.\r	(js operator: '===' with: (js ident: 'null') and: jsObj) ifTrue: [^nil].\r	(js prefixOperator: 'typeof ' on: jsObj) == 'string' ifTrue: [^jsObj].\r	(js prefixOperator: 'typeof ' on: jsObj) == 'number' ifTrue: [^jsObj].\r	(js prefixOperator: 'typeof ' on: jsObj) == 'boolean' ifTrue: [^jsObj].\r	(* This does not discrimate NS vs JS closures *)\r	(js prefixOperator: 'typeof ' on: jsObj) == 'function' ifTrue: [^Alien wrapping: jsObj].\r	(js operator: 'instanceof' with: jsObj and: (js propertyOf: (js propertyOf: Object at: (js literal: 'runtimeClass')) at: (js literal: 'basicNew')))\r		ifTrue:\r			[jsObj isAlien ifTrue: [Error signal: 'Shouldnt be asked to double alienate...'].\r			jsObj isExpat ifTrue: [^js propertyOf: jsObj at: (js literal: 'nsTarget')].\r			Error signal: 'Asked to alienate a raw Newspeak object...'].\r	(js operator: 'instanceof' with: jsObj and: (js ident: 'Array')) ifTrue:\r		[(* :todo: We should stamp NS arrays so we can verify everything commutes. *)\r		^jsObj collect: [:element | alienate: element]].\r	^Alien wrapping: jsObj\r)",
 "copyUntilFirstColon: sel = (\r	#BOGUS. (* DNU does not yet pass unmangled selectors. *)\r	2 to: sel size do: [:i |\r		((sel at: i) = \"$\") ifTrue: [^sel copyFrom: 2 to: i - 1]].\r	^sel copyFrom: 2 to: sel size\r)",
 "expatriate: nsObj = (\r	#TODO.\r	(js operator: '===' with: nil and: nsObj) ifTrue: [^js ident: 'null'].\r	(js prefixOperator: 'typeof ' on: nsObj) == 'string' ifTrue: [^nsObj].\r	(js prefixOperator: 'typeof ' on: nsObj) == 'number' ifTrue: [^nsObj].\r	(js prefixOperator: 'typeof ' on: nsObj) == 'boolean' ifTrue: [^nsObj].\r	(* This does not discrimate NS vs JS closures *)\r	(js prefixOperator: 'typeof ' on: nsObj) == 'function' ifTrue: [^expatriateBlock: nsObj].\r	(js operator: 'instanceof' with: nsObj and: (js propertyOf: (js propertyOf: Object at: (js literal: 'runtimeClass')) at: (js literal: 'basicNew')))\r		ifTrue:\r			[nsObj isAlien ifTrue: [^js propertyOf: nsObj at: (js literal: 'jsTarget')].\r			nsObj isExpat ifTrue: [Error signal: 'Shouldnt be asked to double expatriate...'].\r			^Expat wrapping: nsObj.].\r	(js operator: 'instanceof' with: nsObj and: (js ident: 'Array')) ifTrue:\r		[(* :todo: We should stamp NS arrays so we can verify everything commutes. *)\r		^nsObj collect: [:element | expatriate: element]].\r	Error signal: 'Asked to expatriate a raw JS object...'\r)",
 "expatriateBlock: b = (\r	^js functionOf: {} body: (\r		js return: (\r			expatriate: (\r				b valueWithArguments: (\r					(js verbatim: 'Array.prototype.slice.call(arguments, 0)') collect: [:ea | alienate: ea]))))\r)",
 "class Alien wrapping: o = (\r	js assign: (js propertyOf: self at: (js literal: 'jsTarget')) toBe: o.\r)",
 " ",
 " ",
 "applyConstructorUsingEval: jsArguments = (\r	(* On at least Safari, some objects used as constructors are not functions (*face palm*) and the trick with bind and apply doesn't work. Fall back to eval, sigh... *)\r	js verbatim:\r'function applyNewUsingEval(weirdConstructor, args) {\r	var a = [];\r	for (var i = 0; i < args.length; i++)\r		a[i] = \"args[\" + i + \"]\";\r	return eval(\"new weirdConstructor(\" + a.join() + \")\");\r}'.\r	^js call: (js ident: 'applyNewUsingEval') with: {(js propertyOf: self at: (js literal: 'jsTarget')). jsArguments}\r)",
 "public at: memberName = (\r	^alienate: (js propertyOf: (js propertyOf: self at: (js literal: 'jsTarget')) at: memberName)\r)",
 "public at: memberName put: value = (\r	js assign: (js propertyOf: (js propertyOf: self at: (js literal: 'jsTarget')) at: memberName) toBe: (expatriate: value).\r	^value\r)",
 "doesNotUnderstand: msg = (\r	| jsTarget jsArguments jsSelector |\r	jsTarget:: js propertyOf: self at: (js literal: 'jsTarget').\r	jsArguments:: msg arguments collect: [:arg | expatriate: arg].\r	jsSelector:: copyUntilFirstColon: msg mangledSelector.\r	jsSelector = 'new'\r		ifTrue:\r			[ (* var args = [null].concat(jsArguments);\r				var boundFunction = _jsTarget.bind.apply(_jsTarget, args);\r				return new boundFunction(); *)\r			| args boundFunction |\r			(js operator: '===' with: (js prefixOperator: 'typeof ' on: jsTarget) and: (js literal: 'function'))\r				ifFalse: [^alienate: (applyConstructorUsingEval: jsArguments)].\r			args:: js call: (js propertyOf: (js array: {js ident: 'null'}) at: (js literal: 'concat')) with: {jsArguments}.\r			boundFunction:: (js call: (js propertyOf: (js propertyOf: jsTarget at: (js literal: 'bind')) at: (js literal: 'apply')) with: {jsTarget. args}).\r			^alienate: (js new: boundFunction with: {}) ]\r\r		ifFalse:\r			[ | jsFunction jsResult |\r			jsFunction:: js propertyOf: jsTarget at: jsSelector.\r			(js operator: '===' with: jsFunction and: (js ident: 'undefined'))\r				ifTrue: [^super doesNotUnderstand: msg].\r			jsResult:: js call: (js propertyOf: jsFunction at: (js literal: 'apply')) with: {jsTarget. jsArguments}.\r			^alienate: jsResult].\r)",
 "public isAlien ^<Boolean> = (\r	^true\r)",
 "public isExpat ^<Boolean> = (\r	^false\r)",
 "public isUndefined = (\r	^js operator: '===' with: (js propertyOf: self at: (js literal: 'jsTarget')) and: (js ident: 'undefined')\r)",
 "public printString = (\r	^'Alien wrapping: ', (js call: (js propertyOf: (js propertyOf: self at: (js literal: 'jsTarget')) at: (js literal: 'toString')) with: {})\r)",
 "public value = (\r	| jsTarget = js propertyOf: self at: (js literal: 'jsTarget'). |\r	^alienate: (js\r		call: (js propertyOf: jsTarget at: (js literal: 'call'))\r		with: {jsTarget})\r)",
 "public value: a1 = (\r	| jsTarget = js propertyOf: self at: (js literal: 'jsTarget'). |\r	^alienate: (js\r		call: (js propertyOf: jsTarget at: (js literal: 'call'))\r		with: {jsTarget. expatriate: a1})\r)",
 "public value: a1 value: a2 = (\r	| jsTarget = js propertyOf: self at: (js literal: 'jsTarget'). |\r	^alienate: (js\r		call: (js propertyOf: jsTarget at: (js literal: 'call'))\r		with: {jsTarget. expatriate: a1. expatriate: a2})\r)",
 "public value: a1 value: a2 value: a3 = (\r	| jsTarget = js propertyOf: self at: (js literal: 'jsTarget'). |\r	^alienate: (js\r		call: (js propertyOf: jsTarget at: (js literal: 'call'))\r		with: {jsTarget. expatriate: a1. expatriate: a2. expatriate: a3})\r)",
 "public valueWithArguments: args = (\r	| jsTarget = js propertyOf: self at: (js literal: 'jsTarget'). |\r	^alienate: (js\r		call: (js propertyOf: jsTarget at: (js literal: 'apply'))\r		with: {jsTarget. args collect: [:nsArg | expatriate: nsArg]})\r)",
 "class Expat wrapping: o = (\r	(* :todo: Implement with ES6 Proxy instead. *)\r	js assign: (js propertyOf: self at: (js literal: 'nsTarget')) toBe: o.\r)",
 " ",
 " ",
 "public isAlien ^<Boolean> = (\r	^false\r)",
 "public isExpat ^<Boolean> = (\r	^true\r)",
 "class Collections usingPlatform: p = (\r(*\rNewspeak collections library.\rThis code was derived by converting the Strongtalk Collections classes to Newspeak, which is why the Sun Microsystems copyright and BSD license below applies.\r\rCopyright (c) 1995-2006 Sun Microsystems, Inc. ALL RIGHTS RESERVED.\rCopyright 2008-2009 Yardena Meymann, Gilad Bracha and other contributors.\r\rRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\r\r* Redistributions of source code must retain the above copyright notice,\r this  list of conditions and the following disclaimer.\r\r* Redistribution in binary form must reproduce the above copyright notice,\rthis list of conditions and the following disclaimer in the documentation and/o other materials provided with the distribution.\r\rNeither the name of Sun Microsystems or the names of contributors may\rbe used to endorse or promote products derived from this software without\rspecific prior written permission.\r\r>>\rTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\rTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\rBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\rGOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\rLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\rDAMAGE.>> *)\r|	private MutableAddableList = MutableList mixinApply: AddableList. (* -- streams -- *)	private ListReadStream = p streams SeqCltnReadStream. 	private ListReadWriteStream = p streams SeqCltnReadWriteStream.		(* magic collections *)	(* Not yet supported by NS2JS or NS2Dart *)	public WeakArray = Future computing: [p squeak WeakArray]. |)",
 " ",
 " ",
 "public IdentityMap = (\r	^IdentityMutableHashedMap\r)",
 "public List = (\r	^MutableArrayList\r)",
 "public Map = (\r	^MutableHashedMap\r)",
 "error: s = (\r	^Error signal: s\r)",
 "class AbstractList = Collection (\r(* This class implements the read-only protocol for indexed collections that order their elements using integer indices. *)\r)",
 "Collection",
 "Collection",
 "public , other <List[X]> ^<MutableList[E | X]> = (\r	^self copyReplaceFrom: size + 1 to: size with: other\r)",
 "public allButFirst ^ <MutableList[E]> = (\r	^copyFrom: 2 to: size\r)",
 "public allButLast ^ <MutableList[E]> = (\r	^copyFrom: 1 to: size - 1\r)",
 "public anyOne = (\r	^ first\r)",
 "public at: index <Integer> ^<E> = (\r	subclassResponsibility\r)",
 "public at: index <Integer> ifAbsent: fail <[X def]> ^<E|X> = (\r	^(index between: 1 and: size)\r		ifTrue: [ at: index ]\r		ifFalse: [ fail value ]\r)",
 "binarySearchFor: el <EL>\rbetween: start <Integer>\rand: end <Integer>\rtoCompare: compare <[:EL def:EL| Boolean]>\r^<Int>\r= (\r			(* {where CONSTRAINER <EL> is returnType of #anElement message of receiverType} *)\r	(* This does a binary search for the index such that if el was inserted before it\r	  the receiver would remain sorted.  The receiver must be sorted relative to the\r	  comparison block.  The comparison block should return true if the first block argument\r	  cannot appear after the second block argument *)\r\r	| low <Integer> high <Integer> |\r	low:: start.\r	high:: end.\r	[ low <= high ]\r		whileTrue:\r				[ | mid <Integer> |\r					mid:: (low + high)  // 2.\r	  				(* The guaranteed below is safe because of the inference clause *)\r					(compare value: (\r(* guaranteed <EL> *) (at: mid)) value: el)\r						ifTrue: [ low:: mid + 1 ]\r						ifFalse: [ high:: mid - 1 ].\r				].\r	^low\r)",
 "public binarySearchFor: el <EL>\rtoCompare: compare <[:EL def:EL| Boolean]>\r^ <Integer>\r= (\r	#BOGUS. (* Remove me. *)\r	(* {where CONSTRAINER <EL> is returnType of #anElement message of receiverType} *)\r\r	(* The guarantee is safe because of the inference clause *)\r	^(\r(* guaranteed <List[EL]> *) self)\r			binarySearchFor: el\r			between: 1\r			and: size\r			toCompare: compare\r)",
 "public collect: map <[:E | R def]> ^<List[R]> = (\r	^collectUsingAtPut: map\r)",
 "protected collectUsingAtPut: map <[:E | R def]> ^<List[R]> = (\r	| c <MutableList[R]> |\r	(* See #newForCollect: for explanation of why the guarantee is safe *)\r	c:: (* guaranteed <MutableList[R]> ( *)newForCollectUsingAtPut: size(* ) *).\r	1 to: self size do:\r		[:i <Integer> |\r			c at: i put: (map value: (at: i)) ].\r	^c\r)",
 "collection: cltn <List[Object]>\rmatchesElementsAt: index <Integer>\r^<Boolean> = (\r	(* Test whether we contain the given subcollection at index.  This method assumes\r	  that there are at least as many elements in this collection after index as cltn size *)\r\r	| offset <Integer> |\r	offset:: index - 1.\r	1 to: cltn size do:\r		[:i <Integer> |\r			(cltn at: i) = (at: i+offset)\r				ifFalse: [ ^false ]		].\r	^true\r)",
 "public copyFrom: start <Integer> to: stop <Integer> ^<MutableList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r\r	(* The guarantee is typesafe since the inference clause guarantees that E < EX at the call site *)\r	| cp <MutableList[EX]> safeme <List[EX]> |\r	safeme:: (* guaranteed <List[EX]> *) self.\r	cp:: (* guaranteed <MutableList[EX]> *)\r				newCopyOfSize: (stop - start) + 1 thatCanAlsoHoldElementsOf: safeme.\r	cp replaceFrom: 1 to: cp size with: safeme startingAt: start.\r	^cp\r)",
 "public copyReplaceAll: oldSub <List[Object]> with: newSub <List[X]> ^<MutableList[EX | X]> = (\r	(* {where EX is returnType of #anElement message of receiverType;\r			where X is returnType of #anElement message of arg 2} *)\r\r	|	spots <List[Integer]>\r		subDelta <Integer>\r		copy <MutableList[EX | X]>\r		current <Integer>\r		offset <Integer>\r		newSubSize <Integer>\r		oldSubSize <Integer>\r		safeself <List[EX]>\r		|\r	newSubSize:: newSub size.\r	oldSubSize:: oldSub size.\r	subDelta:: newSub size - oldSubSize.\r	spots:: indicesOfSubCollection: oldSub.\r\r	(* This guarantee is typesafe since the inference clause guarantees that E < EX at the call site *)\r	safeself:: (* guaranteed <List[EX]> *) self.\r\r	spots size = 0\r		ifTrue: [ copy:: safeself newCopyOfSize: size\r								thatCanAlsoHoldElementsOf: newSub.\r						copy replaceFrom: 1 to: size with: safeself.\r						^copy\r						].\r\r	copy:: safeself newCopyOfSize: size + (spots size * subDelta)\r				thatCanAlsoHoldElementsOf: newSub.\r	current:: 1.\r	offset:: 0.\r	spots do:\r		[:spot <Int> |	| offspot <Int> |\r			offspot:: spot + offset.\r\r			(* copy segment of self before the next occurrence *)\r			copy	replaceFrom: current + offset\r					to: offspot - 1\r					with: safeself\r					startingAt: current.\r			(* copy the new subcollection at the next occurrence *)\r			copy	replaceFrom: offspot\r					to: (offspot + newSubSize) - 1\r					with: newSub.\r			current:: spot + oldSubSize.\r			offset:: offset + subDelta.	].\r	(* copy the final segment from self after the last occurrence *)\r	copy	replaceFrom: current + offset\r			to: copy size\r			with: safeself\r			startingAt: current.\r	^copy\r)",
 "copyReplaceFrom: start <Integer> to: stop <Integer> with: other <List[X]> ^<MutableList[EX | X]> = (\r	(* {where EX is returnType of #anElement message of receiverType;\r			where X is returnType of #anElement message of arg 3} *)\r\r	|	copy <MutableList[EX | X]>\r		sizeChange <Integer>\r		sz <Integer>\r		afterNew <Integer>\r		safeself <List[EX]> |\r\r	(* The guarantee is typesafe since the inference clause guarantees that E < EX at the call site *)\r	safeself:: (* guaranteed <List[EX]> *) self.\r\r	sizeChange:: other size - ((stop - start) + 1).\r	sz:: size.\r	copy:: safeself newCopyOfSize: sz + sizeChange\r				thatCanAlsoHoldElementsOf: other.\r	afterNew:: start + other size.\r	copy replaceFrom: 1 to: start - 1 with: safeself startingAt: 1.\r	copy replaceFrom: start to: afterNew - 1 with: other.\r	copy replaceFrom: afterNew to: copy size with: (\r(* guaranteed <List[EX]> *) self) startingAt: stop + 1.\r	^copy\r)",
 "public copyWith: element <X> ^<MutableList[E | X]> = (\r	^self , {element}\r)",
 "public copyWithSize: s <Integer> ^<MutableList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r\r	(* return a mutable copy of the receiver of a different size, that is either truncated\r		or extended with nils as necessary.  Note this works even if the receiver itself\r		is not mutable *)\r\r	(* %note: the inference clause above is a tricky way of doing something very difficult:\r	  it allows us to effectively return a mutable copy of the receiver in a typesafe way,\r	  even though the\r	  receiver itself may not be mutable.  This would be impossible to type reasonably\r	  without the inference clause, because we would have to have a return type of\r	 <MutableList[E]>, which isn't typesafe since  E is a 'covariant' generic variable of this\r	  class, whereas E is an 'unrelated' generic variable in MutableList. - D.G. *)\r\r	(* %note: The inference clause above should really read ... EX <E> ..., but the type\r		system implementation for some reason can't deal with implementations\r		of such a method in subclasses that have bound E (i.e. are not generic on E).\r		For an example, see the implementation in ReadString, which would not have to\r		have a guarantee in the method body if this worked right - D.G. *)\r\r	subclassResponsibility\r)",
 "public copyWithout: el <Object> ^<MutableList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r\r	| safeself <List[EX]> |\r\r	(* The following guarantee is safe because the inference clause ensures that E < EX\r		at the call site *)\r	safeself:: (* guaranteed <List[EX]> *) self.\r\r	^safeself copyReplaceAll: (Array(* [Object] *) with: el) with: {}\r)",
 "public do: f <[:E]> = (\r	1 to: size do:\r		[:i <Integer> |\r			f value: (at: i)	]\r)",
 "public doWithIndex: f <[:E :Integer]> = (\r	1 to: size do:\r		[:i <Integer> |\r			f value: (at: i) value: i]\r)",
 "public findFirst: predicate <[:E| Boolean]> ^<Integer> = (\r	1 to: size do:\r		[:i <Integer> |\r			(predicate value: (at: i))\r				ifTrue: [ ^i ]	].\r	^0\r)",
 "public findLast: predicate <[:E| Boolean]> ^<Integer> = (\r	size to: 1 by: -1 do:\r		[:i <Integer> |\r			(predicate value: (at: i))\r				ifTrue: [ ^i ]	].\r	^0\r)",
 "public first ^<E> = (\r	^self at: 1\r)",
 "public hasSameElementsAndOrderAs: other <List[Object]> ^<Boolean> = (\r	#ACCESSBOGUS.\r	(* Like #hasSameElementsAs:, but also requires the elements to be in the same order *)\r\r	size = other size\r		ifFalse: [ ^false ].\r	1 to: size do:\r		[:i <Integer> |\r			(at: i) = (other at: i)\r				ifFalse: [ ^false ]	].\r	^true\r)",
 "public hash ^<Integer> = (\r	(* This function should not be changed, since it is designed to produce the\r		same results as the identityHash primitive, for strings and symbols *)\r	| sz <Integer> val <Integer> |\r	sz:: size.\r	sz < 2\r		ifTrue: [ ^sz = 1 ifTrue: [ self hashAt: 1 ] ifFalse: [ 1 ] ].\r	val:: hashAt: 1.\r	val:: (val bitShift: 3) bitXor: ((hashAt: 2) bitXor: val).\r	val:: (val bitShift: 3) bitXor: ((hashAt: sz) bitXor: val).\r	val:: (val bitShift: 3) bitXor: ((hashAt: sz - 1) bitXor: val).\r	val:: (val bitShift: 3) bitXor: ((hashAt: (sz bitShift: -1) + 1) bitXor: val).\r	val:: (val bitShift: 3) bitXor: (sz bitXor: val).\r\r	(* mask it to 20 bits to match VM *)\r	val:: val bitAnd: 16rFFFFF.\r	^val\r)",
 "protected hashAt: index <Integer> ^<Integer> = (\r	^(at: index) hash\r)",
 "protected includesIndex: index <Integer> ^<Boolean> = (\r	^index between: 1 and: size\r)",
 "public indexOf: element <Object> ^<Integer> = (\r	^self indexOf: element ifAbsent: [ 0 ]\r)",
 "public indexOf: element <Object> ifAbsent: f <[X def]> ^<Integer | X> = (\r	1 to: size do:\r [:index <Integer> |\r (at: index) =\relement ifTrue: [^index]].\r	^f value\r)",
 "indexOfSubCollection: sub <List[Object]>\rstartingAt: index <Integer>\r^<Integer> = (\r	^indexOfSubCollection: sub\r		startingAt: index\r		ifAbsent: [ error: 'subcollection not found' ]\r)",
 "indexOfSubCollection: sub <List[Object]>\rstartingAt: index <Integer>\rifAbsent: f <[X def]>\r^<Integer | X> = (\r	index to: (size - sub size) + 1 do:\r		[:i <Integer> |\r			(collection: sub matchesElementsAt: i)\r				ifTrue: [ ^i ]		].\r	^f value\r)",
 "indicesOfSubCollection: sub <List[Object]> ^<List[Int]> = (\r	^indicesOfSubCollection: sub startingAt: 1\r)",
 "indicesOfSubCollection: sub <List[Object]>\rstartingAt: index <Integer>\r^<List[Integer]> = (\r	| indices <MutableArrayList[Integer]> subSize <Integer> current <Integer> |\r	indices:: MutableArrayList(* [Int] *) new.\r	subSize:: sub size.\r	current:: index.\r	[ current:: self indexOfSubCollection: sub startingAt: current ifAbsent: [ 0 ].\r	  current = 0\r		] whileFalse:\r			[ indices addLast: current.\r				current:: current + subSize.		].\r	^indices\r)",
 "public isKindOfList ^ <Boolean> = (\r	^true\r)",
 "public isSequenceable = (\r	^true\r)",
 "isSortedBy: compare <[:E:E| Boolean]> ^<Boolean> = (\r	(* Returns true if the receiver is in sorted order, using the specified comparison *)\r\r	| last <E> |\r	size < 2\r		ifTrue: [ ^true ].\r	last:: at: 1.\r	2 to: size do:\r		[:i <Integer> |\r			(compare value: last value: (at: i))\r				ifFalse: [ ^false ]	].\r	^true\r)",
 "public keysAndValuesDo: action <[:Integer :E]> = (\r	1 to: size do:\r		[:index <Integer> |\r action value: index value: (at: index)]\r)",
 "public last ^<E> = (\r	^self at: self size\r)",
 "public newCopyOfSize: size <Integer>\rthatCanAlsoHoldElementsOf: other <List[X]>\r^<MutableList[EX | X]>\r= (\r		(* {where X is returnType of #anElement message of arg 2;\r		     where EX is returnType of #anElement message of receiverType} *)\r\r	(* Return a fresh collection of a closely related type\r	that can hold both elements of self and elements of the other collection *)\r\r	^Array(* [EX | X] *) new: size\r)",
 "newForCollectUsingAtPut: size <Integer> ^<MutableList[Object]> = (\r	(* Return a new extensible collection that is as closely related to the receiver's class as possible.  The\r	 returned collection must be unaliased and empty, so it is safe for the caller to guarantee that the type\r	 variable is of a more specific type *)\r\r	^Array(* [Object] *) new: size\r)",
 "public readStream ^<ReadStream[E]> = (\r	^ListReadStream on: self\r)",
 "public reverse ^<MutableList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r\r	(* The guarantees are typesafe since the inference clause guarantees that E < EX at the call site *)\r	| copy <MutableList[EX]> |\r\r	#BOGUS. (* #reverse implies an in-place operation, should be #reversed *)\r	copy:: (* guaranteed <MutableList[EX]> *)\r		(newCopyOfSize: size thatCanAlsoHoldElementsOf: self).\r	1 to: size do:\r		[:i <Integer> |\r			| el <EX> |\r			el:: (\r(* guaranteed <MutableList[EX]> *) self) at: i.\r			copy at: size + 1 - i put: el.	].\r	^copy\r)",
 "public reverseDo: action <[:E]> = (\r	size to: 1 by: -1 do:\r		[:index <Integer> |\r action value: (at: index)]\r)",
 "public size ^<Integer> = (\r	subclassResponsibility\r)",
 "public species ^<Collection[E] class> = (\r	^Array(* [E] *)\r)",
 "public with: other <List[X def]> do: action <[:E :X]> = (\r	assert: [ self size = other size ] message: 'Cannot jointly interate collections of different size'.\r	1 to: size do:\r		[:index <Integer> |\r action value: (at: index) value: (other at: index)].\r)",
 "class AddableList = AbstractList (\r(* AddableLists are Lists that support the Extensible protocol, and which support indexing in constant time. *)\r|\r	protected contents <Array[E]>\r	protected startGap <Integer> (* number of empty slots at the beginning of contents *)\r	protected lastIndex <Integer> (* (internal) index of last occupied table entry *)\r|initCapacity: self class defaultCapacity)",
 "AbstractList",
 "AbstractList",
 "public add: e <E> ^<E> = (\r	subclassResponsibility\r)",
 "public addAll: c <Collection[E]> ^<Collection[E]> = (\r	c do: [:el <E> |\r		add: el	].\r	^c\r)",
 "public at: i <Integer> ^<E> = (\r	| adjusted <Int> |\r	adjusted:: i + startGap.\r	((0 < i) and: [adjusted <= self lastIndex])\r		ifFalse: [ error: 'invalid index' ].\r	^contents at: adjusted\r)",
 "public at: i <Integer> ifAbsent: f <[X def]> ^<E | X> = (\r	| internal <Int> |\r	internal:: i + self startGap.\r	^(internalIndexIsValid: internal)\r		ifTrue: [ contents at: internal ]\r		ifFalse: [ f value ]\r)",
 "public copyWithSize: s <Integer> ^<MutableList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r\r	| safeself <List[EX]> |\r\r	(* This guarantee is safe because the inference clause guarantees\r		that E < EX at each call site *)\r	safeself:: (* guaranteed <List[EX]> *) self.\r\r	^(Array(* [EX] *) new: s)\r		replaceFrom: 1 to: (s min: size) with: safeself\r)",
 "public do: action <[:E]> = (\r	startGap + 1 to: lastIndex do:\r		[:index <Integer> | action value: (contents at: index) ]\r)",
 "endGap ^<Integer> = (\r	^contents size - lastIndex\r)",
 "firstIndex ^<Integer> = (\r	^1 + startGap\r)",
 "public include: e <E> ^<E> = (\r	^include: e ifNew: []\r)",
 "public include: e <E> ifNew: blk <[]> ^<E> = (\r	(includes: e)\r		ifFalse: [ add: e.\r						blk value. ].\r	^e\r)",
 "public includeAll: c <Collection[E]> ^<Collection[E]> = (\r	c do: [:el <E> |\r		include: el ].\r	^c\r)",
 "public indexOf: el <Object> ifAbsent: f <[X def]> ^<Integer | X> = (\r	1 to: size do: [:i <Integer> |\r		(at: i) = el\r			ifTrue: [ ^i ].	].\r	^f value\r)",
 "public initCapacity: c <Integer> = (\r	(* Need proper factories to pass initial capacity and make this non-public. *)\r\r	contents:: Array(* [E] *) new: c.\r	startGap:: 0.\r	lastIndex:: 0.\r)",
 "internalIndexIsValid: index <Integer> ^<Boolean> = (\r	^index > startGap and: [ index <= lastIndex ]\r)",
 "internalRangeCheck: index <Integer> = (\r	(internalIndexIsValid: index )\r		ifFalse: [ error: 'invalid index' ].\r)",
 "makeSpace: slots <Integer> beforeIndex: i <Integer> ^<Integer> = (\r	(* assume: i is a valid internal index.  The index is returned, adjusted\r	 for any resizing of the internal array that may have taken place\r	 (i.e. the index of the beginning of the created gap is returned) *)\r\r	(* # before i is (i - startGap) - 1, # after is (lastIndex - i) + 1 *)\r	^((i - startGap) - 1) > ((lastIndex - i) + 1)\r		ifTrue: [ 	(* fewer elements after, so move them *)\r			      	needSpaceAtEnd: slots.\r			      	contents\r					replaceFrom: i + slots\r					to: lastIndex + slots\r					with: contents\r					startingAt: i.\r			    	lastIndex:: lastIndex + slots.\r				i	]\r		ifFalse: [ (* fewer elements before, so move them *)\r				| newI <Integer> |\r				newI:: i + (needSpaceAtStart: slots) - slots.\r				contents\r					replaceFrom: (startGap + 1) - slots\r					to: newI - 1\r					with: contents\r					startingAt: startGap + 1.\r				startGap:: startGap - slots.\r				newI	].\r)",
 "makeSpaceAtStart: nslots <Integer> ^<Integer> = (\r	(* Make sure that there are at least nslots of unused capacity at the low\r	 end of contents.  The # of slots added at the beginning is returned. *)\r\r	|	newGap <Integer>\r		diff <Integer>\r		newContents <AbsoluteArray[E]>\r		sz <Integer>\r		newLastIndex <Integer> |\r	(isEmpty and: [nslots <= contents size])\r		ifTrue: [startGap: nslots.\r  				lastIndex: nslots.\r				^nslots].\r\r	sz:: size.\r	newGap:: nslots max: sz.\r	diff:: newGap - startGap.\r	newLastIndex:: newGap + sz.\r	newContents:: Array(* [E] *) new:\r		contents size + diff.\r	newContents\r		replaceFrom: newGap + 1\r		to: newLastIndex\r		with: contents\r		startingAt: firstIndex.\r	startGap: newGap.\r	contents: newContents.\r	lastIndex: newLastIndex.\r	^diff\r)",
 "needSpaceAtEnd: slots <Integer> = (\r	slots > endGap\r		ifTrue: [ contents:\r							(contents copyWithSize:\r								contents size + (slots max: size)	)]\r)",
 "needSpaceAtStart: nslots <Integer> ^<Integer> = (\r	(* Make sure that there are at least nslots of unused capacity at the low\r	 end of contents.  The # of slots added at the beginning is returned. *)\r\r	^nslots > startGap\r		ifTrue: [makeSpaceAtStart: nslots]\r		ifFalse: [ 0 ]\r)",
 "public postCopy = (\r	super postCopy.\r	(* We potentially may change the size of the contents array so that this can work for copyWithSize:\r	  as well *)\r	contents: (contents copyWithSize: (contents size max: lastIndex))\r)",
 "public remove: el <E> ^<E> = (\r	^remove: el\r		ifAbsent: [ error: 'element not found' ]\r)",
 "public remove: nElements <Integer> at: i <Integer> = (\r	| el <E> internal <Integer> |\r	el:: at: i.\r	internal:: startGap + i.\r	internalRangeCheck: internal.\r	internalRangeCheck: (internal + nElements) - 1.\r	internal  to: lastIndex - nElements\r		 do: [:index <Integer> |\r			  contents at: index put: (contents at: index + nElements).	].\r	contents at: lastIndex put: nil.\r	lastIndex: lastIndex - nElements.\r)",
 "public remove: el <E> ifAbsent: f <[X def]> ^<E|X> = (\r	removeAt: (indexOf: el ifAbsent: [^f value]).\r	^el\r)",
 "public removeAll = (\r	startGap + 1 to: lastIndex do:\r		[:i <Integer> |\r			contents at: i put: nil].\r	lastIndex: startGap\r)",
 "public removeAll: c <Collection[E]> ^<Collection[E]> = (\r	c do: [:el <E> |\r		remove: el ].\r	^c\r)",
 "public removeAllSuchThat: test <[:E | Boolean]> = (\r	| i <Integer> |\r	i:: 1.\r	[ i <= size ]\r		whileTrue:\r			[ (test value: (at: i))\r					ifTrue: [ removeAt: i ]\r					ifFalse: [ i:: i + 1 ]	]\r)",
 "public removeAt: index <Integer> ^<E> = (\r	| el <E> |\r	el:: at: index.\r	remove: 1 at: index.\r	^el\r)",
 "public removeEvery: val <E> ^<E> = (\r	^removeEvery: val startingAt: 1\r)",
 "public removeEvery: val <X def> startingAt: start <Integer> ^<X> = (\r	| index <Integer> |\r	index:: indexOf: val ifAbsent: [ ^val ].\r	removeAt: index.\r	^removeEvery: val startingAt: index\r)",
 "public removeFirst ^<E> = (\r	^removeAt: 1\r)",
 "public removeLast ^<E> = (\r	^removeAt: size\r)",
 "public size ^<Integer> = (\r	^lastIndex - startGap\r)",
 "public size: s <Integer> = (\r	(* Change the size of the ordered collection to s (not the capacity).  This will truncate elements at the end if the current size\r	  is larger.  If the current size is smaller, the added elements will be undefined, in which case it is erroneous to access them until they have been set.\r	  This method should be used very rarely and carefully as a result. *)\r\r	| delta <Integer> newLastIndex <Integer> |\r	delta:: s - size.\r	newLastIndex:: lastIndex + delta.\r	delta < 0\r		ifTrue: [ newLastIndex + 1 to: lastIndex do:\r					[:i <Integer> |\r						contents at: i put: nil]].\r	delta > 0\r		ifTrue: [ needSpaceAtEnd: delta ].\r	lastIndex: lastIndex + delta.\r)",
 "public sort: compare <[:E :E | Boolean]> = (\r	(* In-place sort. *)\r	lastIndex < firstIndex ifTrue: [^self].\r	contents\r		mergeSortFrom: firstIndex\r		to: lastIndex\r		by: compare\r)",
 "public defaultCapacity ^<Integer> = (\r	^5\r)",
 "public new: capacity <Integer> ^<Instance> = (\r	^new initCapacity: capacity\r)",
 "public with: val1 <E> ^<Instance> = (\r	^(new: 1) add: val1; yourself\r)",
 "public withAll: cltn <Collection[E]> ^<Instance> = (\r	^(new: cltn size) addAll: cltn; yourself\r)",
 "public class Association key: k value: v = (\r(* Associates an object of type K with an object of type V. *)\r|\r	public key <K> ::= k.\r	public value <V> ::= v.\r|)",
 " ",
 " ",
 "public = other <Object> ^<Boolean> = (\r	(* | othera <Assoc[Object,Object]> | *)\r	(* %todo: replace Association with Assoc when typecase is fully impl *)\r	(* othera:: Association[Object,Object] coerce: other else: [ ^false ]. *)\r	^key = other key and: [ value = other value ].\r)",
 "public copy = (\r	^class key: key value: value\r)",
 "public hash ^<Integer> = (\r	^key hash bitXor: value hash\r)",
 "public printOn: strm <CharOutputStream> = (\r	key printOn: strm.\r	strm nextPutAll: ' -> '.\r	value printOn: strm.\r)",
 "public new ^<Instance> = (\r	self warnObsolete.\r	^self key: nil value: nil\r)",
 "public class Collection = (\r(* A Collection is an object that represents a group of objects.\r\rThe only message that must be implemented by subclasses is the #do: message.\rAll other Collection messages are then defined in terms of #do:.\r\r%responsibility size\r	Subclasses usually reimplement the #size message if possible, since the\r	implementation provided in this class is very inefficient.\r%responsibility collect:\r	Subclasses may wish to consider overriding the #collect: (and #select: and #reject:)\r	messages to specialize their return\r	types to match the receiver type more closely. *)\r)",
 " ",
 " ",
 "public allSatisfy: predicate <[:E | Boolean]> ^<Boolean> = (\r	self do: [:each | (predicate value: each) ifFalse: [^false]].\r	^true\r)",
 "public anySatisfy: predicate <[:E | Boolean]> ^<Boolean> = (\r	self do: [:each | (predicate value: each) ifTrue: [^true]].\r	^false\r)",
 "public asArray ^<Array[E]> = (\r	|\r	array <Array[E]> = Array new: size.\r	index <Integer> ::= 1.\r	|\r	self do: [:element <E> |\r		array at: index put: element.\r		index:: index + 1].\r	^array\r)",
 "public asCollection = (\r	(* Squeak 5.0 *)\r	^self\r)",
 "public asMutableArrayList ^<MutableArrayList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r(* Return a new MutableArrayList holding the elements of this collection.  The element type of the ordered collection\r	is whatever the static type of the receiver is at the point of send. *)\r	^MutableArrayList(* [EX] *) withAll: (* (guaranteed <CollectionEX]> *)self(* ) *)\r)",
 "public asSet ^<Extensible[EX]> = (\r	 (* Return a new extensible collection holding the elements of this collection. *)\r\r	^Set(* [EX] *) withAll: (* (guaranteed <Collection[EX]> *)self(* ) *)\r)",
 "public asSortedList ^<List[Object]> = (\r	(* This message is NOT typesafe, and should only be used for compatibility reasons, since there is\r 	 no way of knowing whether the elements of this collection support #< or not.  You should use\r	 #asSortedList: instead, if possible *)\r\r	^SortedList(* [Object] *) withAll: self\r)",
 "public asSortedList: sortPredicate <[:E:EX | Boolean]> ^<SortedList[EX]> = (\r	(* { where EX is  arg 1 of #value:value: message of arg 1 } *)\r	(* Return a new sorted collection ordered by the given sortPredicate.  Note that Magnitude\r	 supports the defaultSort message for convenience, so that for example if you have a collection\r	 of strings strc, you can say:\r		strc asSortedList: String defaultSort\r	*)\r\r	(* This is typesafe despite the guarantee because the inference clause requires that E = EX at the\r	call site *)\r	^(SortedList(* [EX] *) new: size sortBlock: (* (guaranteed <[EX,EX,^Boolean]> *)sortPredicate(* ) *))\r		addAll: (* (guaranteed <Collection[EX]> *)self(* ) *); yourself\r)",
 "public collect: map <[:E | R def]> ^<Collection[R]> = (\r	^self collectUsingAdd: map\r)",
 "protected collectUsingAdd: map <[:E | R def]> ^<Collection[R]> = (\r	| c |\r	(* See #newForCollect: for explanation of why the guarantee is safe *)\r	c:: (newForCollectUsingAdd: size).\r	do: [:e | c add: (map value: e) ].\r	^c\r)",
 "public copy = (\r	#BOGUS. (* Questionable. Probably should be shallowCopy if we keep it. *)\r	^self class withAll: self\r)",
 "public detect: predicate <[:E | Boolean]> ^<E> = (\r	^self detect: predicate ifNone: [Error signal: 'No matching element detected']\r)",
 "public detect: aBlock ifFound: foundBlock ifNone: exceptionBlock = (\r	self\r		do: [ :each |\r			(aBlock value: each)\r				ifTrue: [ ^ foundBlock cull: each ] ].\r	^ exceptionBlock value\r)",
 "public detect: predicate <[:E | Boolean]> ifNone: fail <[X def]> ^<E | X> = (\r	self do: [:element | (predicate value: element) ifTrue: [^element]].\r	^fail value\r)",
 "public do: action <[:E]> = (\r	subclassResponsibility\r)",
 "public do: action <[:E]> separatedBy: betweenAction <[]> = (\r	(* Useful when you need to do something 'between' elements (i.e. not before the first one, and not after the last one). [action] is evaluated the same way as for #do:, but [betweenAction] is evaluated once between each pair of elements. *)\r	| firstTime <Boolean> ::= true. |\r	firstTime:: true.\r	self do:\r		[:element <E> |\r		firstTime\r			ifTrue: [firstTime:: false]\r			ifFalse: [betweenAction value].\r			action value: element].\r)",
 "public flatMap: map <[:E | R def]> ^<Collection[R]> = (\r	^(collect: map) flatten\r)",
 "public flatten ^ <Collection[E]> = (\r	| totalSize <Integer> ::= 0. c |\r	do: [:e <E> | totalSize:: totalSize + (e isKindOfCollection ifTrue: [e size] ifFalse: [1])].\r	c:: newForCollectUsingAdd: totalSize.\r	do: [:e <E> | e isKindOfCollection ifTrue: [e do: [:x | c add: x]] ifFalse: [c add: e]].\r	^c\r)",
 "public hash ^<Integer> = (\r	| count ::= 0. |\r	^self inject: 0 into:\r		[:previousHash <Integer> :element <E> |\r		| newHash |\r		newHash:: previousHash bitXor: element hash.\r		count:: count + 1.\r		count > 2 ifTrue: [^newHash].\r		newHash]\r)",
 "public includes: o <Object> ^<Boolean> = (\r	self do: [:element <E> | element = o ifTrue: [^true]].\r	^false\r)",
 "public inject: initialValue <X> into: foldBlock <[:X def :E | X]> ^<X> = (\r	| runningValue <X> |\r	runningValue:: initialValue.\r	self do: [:element <X> | runningValue:: foldBlock value: runningValue value: element].\r	^runningValue\r)",
 "public intersection: other <Collection[Object]> ^<List[E]> = (\r	^self select: [:each | other includes: each]\r)",
 "public isCollection ^<Boolean> = (\r	^true\r)",
 "public isEmpty ^<Boolean> = (\r	^0 == self size\r)",
 "public isKindOfCollection = (\r	(* Should be auto-generated *)\r	^true\r)",
 "public max = (\r	^ self inject: self anyOne into: [:m :each | m max: each]\r)",
 "protected maxPrintElements ^<Int> = (\r	^100\r)",
 "protected newForCollectUsingAdd: size <Int> ^<MutableArrayList[Object]> = (\r	(* Return a new extensible collection that is as closely related to the receiver's class as possible.  The\r	 returned collection must be unaliased and empty, so it is safe for the caller to guarantee that the type\r	 variable is of a more specific type *)\r\r	^MutableArrayList new: size\r)",
 "public noneSatisfy: predicate <[:E | Boolean]> ^<Boolean> = (\r	self do: [:each | (predicate value: each) ifTrue: [^false]].\r	^true\r)",
 "protected occurrencesOf: o <Object> ^<Int> = (\r	| c <Int> |\r	#BOGUS. (* Questionable *)\r	c:: 0.\r	do: [:e <E> | e = o ifTrue: [ c:: c + 1 ]].\r	^c\r)",
 "public postCopy = (\r	#BOGUS. (* Squeakism *)\r)",
 "protected printElementsDo: f <[:Object]> = (\r	(* Evaluate the block with all the elements that should be shown as the contents in the printstring.  This provides a hook for things like MutableHashedMaps, which want to show their associations, not their values *)\r	self do: f\r)",
 "public printOn: stream <CharOutputStream> = (\r	| count <Integer> first <Boolean> |\r	stream	nextPutAll: class mixin simpleName;\r			nextPut: \"(\".\r	count:: 0.\r	first:: true.\r	self printElementsDo:\r		[:element <Object> |\r		first\r			ifTrue: [ first:: false ]\r			ifFalse: [ stream space ].\r		element printOn: stream.\r		count:: count + 1.\r		count >= maxPrintElements\r			ifTrue: [ stream nextPut: \"<\"; print: size - count; nextPutAll: ' more elements>)'.\r						^self]].\r	stream nextPut: \")\".\r)",
 "public reduce: reduceFn <[:RE def :RE | RE]> ^<RE> = (\r	(* {where CONSTRAINER <RE> is returnType of #anElement message of receiverType} *)\r	(* Like reduce:ifEmpty: except that it is a dynamic error to send this to an empty collection *)\r\r	^self reduce: reduceFn ifEmpty: [Error signal: 'Cannot reduce an empty collection' ]\r)",
 "public reduce: reduceFn <[:RE def:RE| RE]> ifEmpty: onEmpty <[X def]> ^<RE | X> = (\r	(* {where CONSTRAINER <RE> is returnType of #anElement message of receiverType} *)\r	(* Reduce is similar to inject except that the first element is used as the injected\r	  element for the rest of the collection.  It is often handier than inject.  For example:\r		(#(1 2 3 4) reduce: [:a <Int> :b <Int> | a + b ]) sums a collection of numbers. *)\r\r	(* esoteric typing %note: We need to ensure that E is a subtype of RE (the argument type for the reduction\r		function), but since that would require a\r		supertype constraint (which neither we nor anyone else support, we accomplish the same\r	    thing indirectly by introducing an unreferenced type\r		variable CONSTRAINER that is inferred to be E at the call site, and then constraining it with a bound\r		of RE.  This will prevent any call where E > RE from typechecking.  However, since the\r		typesystem doesn't 'know' that, we have to tell it that with a guarantee in the method body.\r		Because of the CONSTRAINER, we know that the guarantee is true for all calls that typecheck.\r		Of course, this is tricky, but at least we can express it, and in a way that hides the guarantee from\r		callers! *)\r\r	| current <RE> |\r	self do:\r		[:element <E> |\r		| rel <RE> |\r		rel:: element.\r		current isNil\r			ifTrue: [ current:: rel ]\r			ifFalse: [ current:: reduceFn value: current value: rel ]	].\r	^current isNil\r		ifFalse: [ current ]\r		ifTrue: [ onEmpty value ]\r)",
 "public reject: predicate <[:E | Boolean]> ^<List[E]> = (\r	^self select: [:e | (predicate value: e) not ]\r)",
 "public select: predicate <[:E | Boolean]> ^<List[E]> = (\r	| result <MutableArrayList[E]> |\r	result:: self newForCollectUsingAdd: size.\r	self do: [:element | (predicate value: element) ifTrue: [result add: element]].\r	^result\r)",
 "public size ^<Integer> = (\r	| count ::= 0. |\r	self do: [:element <E> | count:: count + 1 ].\r	^count\r)",
 "public species ^<Collection[E] class> = (\r	^Set\r)",
 "public union: other <Collection[Object]> ^ <Set[Object]> = (\r	^self asSet addAll: other; yourself\r)",
 "public value = (\r	#BOGUS. (* Questionable *)\r	^self\r)",
 "class HashedCollection new: cap = Collection (|\r	protected table_0 <Array[A|Object]>\r			(* The table holds either included entries, or an object indicating a deleted entry,\r			which is currently the table itself.  This of course means that the table is not allowed\r			as a valid element of the collection, but this is only an issue when writing reflective\r			system code that violates encapsulation. *)\r	protected size_0 <Integer>\r			(* the number of collection elements (not the size of the table) *)\r	protected deleted <Integer>\r			(* the number of slots marked with the deletion placeholder *)\r|initCapacity: cap)",
 "Collection",
 "Collection",
 "public add: val <A> ^<A> = (\r	^include: val\r)",
 "public addAll: c <Collection[A]> ^<Collection[A]> = (\r	c do: [:e <A> |\r		add: e. ].\r	^c\r)",
 "advanceAmount ^<Int> = (\r	(* a large prime - 1 *)\r		^99990\r)",
 "public at: key <K> ^<E> = (\r	^at: key ifAbsent: [ Error signal: 'key not found' ]\r)",
 "public at: key <Object> ifAbsent: f <[X def]> ^<E|X> = (\r	^elementFor:\r			(valAt: key ifAbsent: [ ^f value ])\r)",
 "atIndex: i <Int>\rinTable: tbl <Array[Object|A]>\roccupiedSlotDo: occupied <[:A| X def]>\remptySlotDo: empty <[Y def]>\rdeletedSlotDo: deleted <[Z def]>\r^<X|Y|Z> = (\r	(* This is the core method that does the case analysis for a slot to\r		determine whether it is occupied, deleted, or empty *)\r\r	| el <A|Object> |\r	el:: tbl at: i.\r	el == nil\r		ifTrue: [ ^empty value ].\r	el == tbl\r		ifTrue: [ ^deleted value ].\r\r	(* The following guarantee is because the table uses a non-typesafe trick in\r	  which the table pointer itself is used to indicate a deleted slot; thus the table\r	  doesn't hold only values of type A.  The guarantee is safe because we know that\r	  we only put either values or the table into the table, and the previous\r	  statement already handled the case when el is the table pointer-\r	  thus at this point by elimination el has to be a value of type A *)\r	^occupied value: (* (guaranteed <A> *)el(* ) *)\r)",
 "buildValForKey: k <K> element: el <E> ^<A> = (\r	(* construct an A from a K and an E *)\r	subclassResponsibility\r)",
 "checkValidity = (\r	(* This method performs various validity checks on the receiver *)\r\r	| c <Int> |\r	c:: 0.\r	contentsDo:\r		[:val <A> |\r			assert: [ (at: (keyFor: val)) = (elementFor: val) ] message: ''.\r			c:: c + 1.		].\r\r	assert: [ c = size ] message: ''.\r)",
 "public contentsDo: f <[:A]> = (\r	| tbl <Array[A|Object]> |\r	#ACCESSBOGUS.\r	tbl:: table.\r	tbl == nil\r		ifTrue: [ ^self ].\r\r	1 to: tbl size do:\r		[:index <Int> |\r				atIndex: index\r					inTable: tbl\r					occupiedSlotDo:\r						[:val <A> |\r							f value: val	]\r					emptySlotDo: [ ]\r					deletedSlotDo: [ ]\r		]\r)",
 "createFirstTable = (\r	table:: newTableWithSize: firstTableSize.\r)",
 "public do: f <[:E]> = (\r	contentsDo:\r		[:val <A> |\r			f value: (elementFor: val)		]\r)",
 "elementFor: val <A> ^<E> = (\r	(* extract an E from an A *)\r	subclassResponsibility\r)",
 "elementForCopy: el <A> ^<A> = (\r	(* When a copy of the collection is made, this method implements what happens\r	  to each element.  For example, MutableHashedMaps copy their elements, since the\r	  associations are really part of the MutableHashedMap, whereas KeyedSets don't since the\r	  associations are really elements of the collection. *)\r\r	subclassResponsibility\r)",
 "firstTableSize ^<Integer> = (\r	(* The size used for the table when the capacity is 0 and the first element is added *)\r\r	^8\r)",
 "growIfNeeded = (\r	(minTableSizeForCapacity: occupied) > table size\r		ifTrue: [ growTable ]\r)",
 "growTable = (\r	| new <Array[A|Object]> |\r	new:: newTableWithSize: table size + table size.\r	contentsDo:\r		[:a_value <A> |\r				lookup: (keyFor: a_value)\r					inTable: new\r					matchingSlotDo:\r						[:index <Int> :val <A> |\r							shouldNotHappen	]\r					emptySlotDo:\r						[:index <Int> |\r							new at: index put: a_value	]\r					deletedSlotsDo:\r						[:index <Int> |\r							shouldNotHappen ]\r					mismatchingSlotsDo:\r						[:index <Int> | (* ignore *) ]\r		].\r	deleted: 0.\r	table: new.\r)",
 "hashFor: key <Object> ^<Int> = (\r	(* return the appropriate hash value for a key *)\r	subclassResponsibility\r)",
 "public include: val <A> ^<A> = (\r	^include: val ifNew: []\r)",
 "public include: val <A> ifNew: ifNew <[]> ^<A> = (\r	^tableAt: (keyFor: val) put: (elementFor: val) ifNew: ifNew\r)",
 "public includeAll: c <Collection[A]> ^<Collection[A]> = (\r	c do: [:el <A> |\r		include: el ].\r	^c\r)",
 "public includesIndex: k <Object> ^<Boolean> = (\r	valAt: k ifAbsent: [ ^false ].\r	^true\r)",
 "public includesKey: k <Object> ^<Boolean> = (\r	^includesIndex: k\r)",
 "public indexOf: el <Object> ^<K> = (\r	^indexOf: el\r			ifAbsent: [ error: 'Element not found' ]\r)",
 "public indexOf: el <Object> ifAbsent: blk <[X def]> ^<K | X> = (\r	contentsDo:\r		[:v <A> |\r			(elementFor: v) = el\r				ifTrue: [ ^keyFor: v ] ].\r	^blk value\r)",
 "indexOf: key <Object> tableMask: mask <Int> ^<Int> = (\r	^((hashFor: key) bitAnd: mask) + 1\r)",
 "initCapacity: cap <Int> = (\r	size: 0.\r	deleted: 0.\r	cap > 0\r		ifTrue: [ table:: newTableWithSize: (tableSizeForCapacity: cap). ].\r)",
 "key: key1 <Object> matches: key2 <Object> ^<Boolean> = (\r	(* Test whether two keys match *)\r	self subclassResponsibility\r)",
 "public keyAtValue: v <Object> ^<K> = (\r	^indexOf: v\r)",
 "public keyAtValue: v <Object> ifAbsent: blk <[X def]> ^<K | X> = (\r	^indexOf: v ifAbsent: blk\r)",
 "keyFor: val <A> ^<K> = (\r	(* extract an K from an A *)\r	subclassResponsibility\r)",
 "public keysDo: f <[:K]> = (\r	contentsDo:\r		[:val <A> |\r			f value: (keyFor: val)		]\r)",
 "lookup: key <Object>\rinTable: tbl <Array[Object|A]>\rmatchingSlotDo: matching <[:Int:A| X def]>\remptySlotDo: empty <[:Int | Y def]>\rdeletedSlotsDo: marked <[:Int]>\rmismatchingSlotsDo: mismatch <[:Int]>\r^<X|Y> = (\r	(* This is the core method that looks for a slot suitable for the key,\r		and evaluates the appropriate blocks.\r	   The lookup process is iterative, terminating when a slot that is empty\r	   or has a matching key is found *)\r\r	| i <Int> mask <Int> |\r	mask:: tbl size - 1.\r	i:: indexOf: key tableMask: mask.\r	[ 			atIndex: i\r				inTable: tbl\r				occupiedSlotDo:\r					[:val <A> |\r						(key: key matches: (keyFor: val))\r							ifTrue: [ ^matching value: i value: val	 ]\r							ifFalse: [ mismatch value: i	 ]\r					]\r				emptySlotDo:\r					[ ^empty value: i ]\r				deletedSlotDo:\r					[ marked value: i	 ].\r		i:: ((i + advanceAmount) bitAnd: mask) + 1.\r	] repeat\r)",
 "lookup: key <Object>\rmatchingSlotDo: matching <[:Integer:A| X def]>\remptySlotDo: empty <[:Integer | Y def]>\rdeletedSlotsDo: marked <[:Integer]>\r^<X|Y> = (\r	^self		lookup: key\r				inTable: self table\r				matchingSlotDo: matching\r				emptySlotDo: empty\r				deletedSlotsDo: marked\r				mismatchingSlotsDo: [:index <Integer> | (* ignore *) ]\r)",
 "markDeleted: index <Int> = (\r	| tbl <Array[A|Object]> |\r	tbl:: table.\r	tbl at: index put: tbl.\r	deleted: deleted + 1\r)",
 "minTableSize ^<Int> = (\r	^4\r)",
 "minTableSizeForCapacity: cap <Integer> ^<Integer> = (\r	(* max density is 50% full *)\r	^cap + cap\r)",
 "newTableWithSize: tableSize <Int> ^<Array[A|Object]> = (\r	^Array new: tableSize\r)",
 "objToIncludeFor: new <A> withExisting: other <A> ^<A> = (\r	(* In the situation where a new value  is being 'include'ed in the collection, and there is already an existing\r	 value with a matching key, this method determines what value is actually placed in the collection *)\r\r	subclassResponsibility\r)",
 "occupied ^<Integer> = (\r	^size + deleted\r)",
 "postCopy = (\r	| tbl <Array[A|Object]> newtbl <Array[A|Object]> |\r\r	super postCopy.\r	tbl:: table.\r	tbl == nil\r		ifTrue: [ ^self ].\r\r	newtbl:: newTableWithSize: tbl size.\r	1 to: tbl size do:\r		[:index <Int> |\r			atIndex: index\r					inTable: tbl\r					occupiedSlotDo:\r						[:val <A> |\r							newtbl at: index put: (elementForCopy: val)	]\r					emptySlotDo: [ ]\r					deletedSlotDo:\r						[ newtbl at: index put: newtbl		]\r		].\r	setTable: newtbl\r)",
 "printElementsDo: f <[:Object]> = (\r	contentsDo: f\r)",
 "public remove: val <A> ^<A> = (\r	^remove: val ifAbsent: [ error: 'value not in collection' ]\r)",
 "public remove: val <A> ifAbsent: f <[X def]> ^<A|X> = (\r	removeKey: (keyFor: val) ifAbsent: f.\r	^val\r)",
 "public removeAll: c <Collection[A]> ^<Collection[A]> = (\r	c do: [:el <A> |\r		remove: el ].\r	^c\r)",
 "public removeAllSuchThat: test <[:A | Boolean]> = (\r	copy contentsDo:\r		[:el <A> |\r			(test value: el)\r				ifTrue: [ remove: el ]		]\r)",
 "public removeAt: k <K> ^<E> = (\r	(* A synonym for #removeKey: for consistency with AddableList *)\r\r	^removeKey: k\r)",
 "public removeAt: k <K> ifAbsent: f <[X def]> ^<E|X> = (\r	(* A synonym for #removeKey:ifAbsent: for consistency with AddableList *)\r\r	^removeKey: k ifAbsent: f\r)",
 "public removeEvery: val <A> ^<A> = (\r	remove: val ifAbsent: [].\r	^val\r)",
 "public removeKey: key <K> ^<E> = (\r	^removeKey: key ifAbsent: [ error: 'key not found' ]\r)",
 "public removeKey: key <K> ifAbsent: f <[X def]> ^<E|X> = (\r	table == nil\r		ifTrue: [ ^f value	 ].\r	^			lookup: key\r				matchingSlotDo:\r						[:index <Int> :val <A> |\r							markDeleted: index.\r							size: size - 1.\r							elementFor: val		]\r				emptySlotDo:\r						[:index <Int> |\r							f value	]\r				deletedSlotsDo:\r						[:index <Int> |\r							(* ignore *)\r						]\r)",
 "setTable: t <Array[A|Object]> = (\r	table_0:: t.\r)",
 "public size ^<Int> = (\r	^size_0\r)",
 "size: s <Int> = (\r	size_0:: s\r)",
 "table = (\r	^table_0\r)",
 "table: t <Array[A|Object]> = (\r	setTable: t.\r	assert: [deleted = 0] message: ''.\r)",
 "tableAt: key <K> put: el <E> ifNew: onNew <[]> ^<A> = (\r	(* put a value for el in the right spot in the table, and return the val *)\r\r	| reusableSlot <Integer> |\r	table == nil\r		ifTrue: [ self createFirstTable.	 ].\r	^			lookup: key\r				matchingSlotDo:\r						[:index <Integer> :val <A> |\r							self tableAt: key put: el inMatchingSlot: index value: val		]\r				emptySlotDo:\r						[:index <Integer> |\r							| newVal <A> |\r							reusableSlot == nil\r								ifTrue: [ newVal:: self tableAt: key put: el inEmptySlot: index ]\r								ifFalse: [ newVal:: self tableAt: key put: el inDeletedSlot: reusableSlot ].\r							onNew value.\r							newVal	]\r				deletedSlotsDo:\r						[:index <Integer> |\r							reusableSlot == nil\r								ifTrue: [ reusableSlot:: index ].\r						]\r)",
 "tableAt: key <K>\rput: el <E>\rinDeletedSlot: index <Integer>\r^<A> = (\r	| val <A> |\r	val:: tableAt: key put: el inUnusedSlot: index.\r	deleted: deleted - 1.\r	(* we don't have to check for growth when reusing a previously used slot *)\r	^val\r)",
 "tableAt: key <K>\rput: el <E>\rinEmptySlot: index <Integer>\r^<A> = (\r	| val <A> |\r	val:: tableAt: key put: el inUnusedSlot: index.\r	growIfNeeded.\r	^val\r)",
 "tableAt: key <K>\rput: el <E>\rinMatchingSlot: index <Integer>\rvalue: val <A>\r^<A> = (\r	| newVal <A> |\r	newVal:: objToIncludeFor: (buildValForKey: key element: el)\r								withExisting: val.\r	table at: index put: newVal.\r	^newVal\r)",
 "tableAt: key <K>\rput: el <E>\rinUnusedSlot: index <Integer>\r^<A> = (\r	(* This does the core work for #tableAt:put: [inDeletedSlot:|inEmptySlot:] *)\r\r	| newVal <A> |\r	newVal:: buildValForKey: key element: el.\r	table at: index put: newVal.\r	size: size + 1.\r	^newVal\r)",
 "tableSizeForCapacity: cap <Integer> ^<Integer> = (\r	| min <Integer> tsize <Integer> |\r	min:: minTableSizeForCapacity: cap.\r	(* search for the smallest power of two that is >= min *)\r	tsize:: minTableSize.\r	[ tsize < min ]\r	      whileTrue: [ tsize:: tsize + tsize ].\r	^tsize\r)",
 "valAt: key <Object> ifAbsent: f <[X def]> ^<A|X> = (\r	table == nil\r		ifTrue: [ ^f value ].\r\r	^			lookup: key\r				matchingSlotDo:\r					[:index <Integer> :val <A> |\r						val	]\r				emptySlotDo:\r					[:index <Integer> |\r						f value	]\r				deletedSlotsDo:\r					[:index <Integer> |\r						(* ignore deleted slots *) ]\r)",
 "public defaultCapacity ^<Integer> = (\r	^0\r)",
 "class IdentityMutableHashedMap new: cap = MutableHashedMap new: cap (\r(* IdentityMutableHashedMaps are efficient HashedCollections that let you dynamically associate key->value\rpairs,  where the keys are matched using the #== message. *)\r)",
 "new: cap",
 "new: cap",
 "hashFor: key <Object> ^<Int> = (\r	^key identityHash\r)",
 "key: k <Object> matches: another <Object> ^<Boolean> = (\r	^k == another\r)",
 "public defaultCapacity ^<Int> = (\r	^0\r)",
 "public new = (\r	^new: defaultCapacity\r)",
 "public class IdentitySet new: cap <Integer> = Set new: cap ()",
 "new: cap",
 "new: cap",
 "hashFor: key <Object> ^<Int> = (\r		^key identityHash\r)",
 "key: k <Object> matches: another <Object> ^<Boolean> = (\r	^k == another\r)",
 "public defaultCapacity = (\r	^0\r)",
 "public new ^ <Instance> = (\r	^self new: defaultCapacity\r)",
 "public withAll: cltn <Collection[A]> ^<Instance> = (\r	^(new: cltn size) includeAll: cltn; yourself\r)",
 "public class Interval from: p_start <Number> to: p_stop <Number> by: p_step <Number> = AbstractList (\r(* Intervals are Lists that generate their contents on the fly as a progression\rof numbers from a start number to a stop number, separated by a step number.  Usually, the\rto: [by:]do: messages defined in the Number subclasses are used instead of Intervals\rwhen just a control structure is needed, since they are much faster.\r\rNote on strong typing issues:\r\rThe to: [by:]do: messages in the Number hierarchy are typed restrictively, in such a way that they\rcan only be used in non-coercive situations (i.e. where the start, stop, and step are all integers,\ror all floats, etc.).  This is done to preserve the type of the iteration value passed to the iteration block\rin the pure integer form, so that bit operations etc. can be performed etc.  This would not be possible\rif Number was the type for the step.  Although this may seem restrictive, the following points should\rbe noted about this design:\r\r	1) explicit coercions handle the vast majority of these cases;\r		for example, use (j asFloat to: k asFloat by: 0.1) rather than\r		 (j to: k by: 0.1) when j and k are typed as Numbers or Integers.\r	2) this scheme is perfectly compatible with untyped code, since the typed versions will work correctly\r	    even if called with arguments of mismatched numeric types, so that things like (1 to: 10 by: 0.1) will\r	    work, even though they don't typecheck.\r	3) If full coercive generality is needed in typesafe code, the Interval class can be used, which has been\r	    designed using values of type Number, so that things like (1 to: 10 by: 0.1) are ok.  They cannot, however,\r		preserve more detailed information about the kinds of numbers in the Interval. *)\r|\r	public start <Number> = p_start.\r	public stop <Number> = p_stop.\r	public increment <Number> = p_step.\r|)",
 "AbstractList",
 "AbstractList",
 "public at: index <Integer> ^<Number> = (\r	(start - stop) sign = increment sign\r		ifFalse: [ | value <Number> |\r						value: start + (increment * (index - 1)).\r						increment >= 0\r							ifTrue: [ ( value between: start and: stop)\r												ifTrue: [ ^value ]	]\r							ifFalse: [ (value between: stop and: start)\r												ifTrue: [ ^value ]	]	].\r	Error signal: 'Index out-of-range'.\r)",
 "copyWithSize: s <Int> ^<MutableList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r	self unimplemented\r)",
 "public do: action <[:Number]> = (\r	|\r	value <Number> ::= self start.\r	incr <Number> = self increment.\r	stp <Number> = self stop.\r	|\r	incr >= 0\r		ifTrue: [ [ value <= stp ]\r							whileTrue: [ action value: value.\r										value:: value + incr.	]	]\r		ifFalse: [ [ value >= stp ]\r							whileTrue: [ action value: value.\r										value:: value + incr.	]	]\r)",
 "public size ^<Integer> = (\r	^((stop - start) // increment) + 1 max: 0\r)",
 "public from: start <Number> to: stop <Number> ^<Instance> = (\r	^self from: start to: stop by: 1\r)",
 "class MutableArrayList = MutableAddableList (\r(* MutableArrayLists are AddableLists that also support setting\relements in place (the MutableList protocol). *)\r)",
 "MutableAddableList",
 "MutableAddableList",
 "public add: e <E> ^<E> = (\r	^addLast: e\r)",
 "public add: el <E> after: existing <E> ^<E> = (\r	| index <Int> |\r	index:: indexOf: existing.\r	index = size\r		ifFalse: [ index:: makeSpace: 1\r							beforeIndex: index + startGap + 1 ]\r		ifTrue: [ needSpaceAtEnd: 1.\r						index:: index + startGap + 1.	].\r	^contents at: index put: el.\r)",
 "public add: el <E> afterIndex: i <Int> ^<E> = (\r	^add: el beforeIndex: i + 1\r)",
 "public add: el <E> before: existing <E> ^<E> = (\r	| index <Int> |\r	index:: indexOf: existing.\r	index:: makeSpace: 1 beforeIndex: index + startGap.\r	^contents at: index put: el.\r)",
 "public add: el <E> beforeIndex: i <Int> ^<E> = (\r	| index <Int> |\r	i > size\r		ifFalse: [ index:: makeSpace: 1 beforeIndex: i + startGap]\r		ifTrue: [ needSpaceAtEnd: 1.\r					index:: i + startGap. ].\r	^contents at: index put: el.\r)",
 "public addAllFirst: c <Collection[E]> ^<Collection[E]> = (\r	c do: [:el <E> | 	addFirst: el ].\r	^c\r)",
 "public addAllLast: c <Collection[E]> ^<Collection[E]> = (\r	c do: [:el <E> | 	addLast: el ].\r	^c\r)",
 "public addFirst: e <E> ^<E> = (\r	needSpaceAtStart: 1.\r	contents at: startGap put: e.\r	startGap: startGap - 1.\r	^e\r)",
 "public addLast: e <E> ^<E> = (\r	needSpaceAtEnd: 1.\r	lastIndex: lastIndex + 1.\r	contents at: lastIndex put: e.\r	^e\r)",
 "public asMutableArrayList ^<MutableArrayList[EX]> = (\r		(* {where EX is returnType of #anElement message of receiverType} *)\r\r	(* the guarantee is safe because of the inference clause *)\r	^(* guaranteed <MutableArrayList[EX]> *) self\r)",
 "public at: i <Int> put: el <E> ^<E> = (\r	| adjusted <Int> |\r	adjusted:: i + startGap.\r	((0 < i) and: [adjusted <= lastIndex])\r		ifFalse: [ error: 'invalid index' ].\r	^contents at: adjusted put: el\r)",
 "public collect: map <[:E | R def]> ^<MutableArrayList[R]> = (\r	^(collectUsingAdd: map) asMutableArrayList\r)",
 "public copyWithSize: s <Int> ^<MutableArrayList[EX]> = (\r	(* {where EX is returnType of #anElement message of receiverType} *)\r\r	(* Note: this method temporarily mutates the receiver, so it should not be sent to an object that\r		another process might be accessing. *)\r\r	(* We use a trick here: we temporarily fudge the lastIndex to be the value we want to use in the copy,\r	  which will cause postCopy to copy the contents with a different size, and then we restore the old\r	  lastIndex value for this instance.  This lets the normal copy mechanism handle subclass instance\r	  variable copying. *)\r	| oldLastIndex <Int> safeself <MutableArrayList[EX]> copy <MutableArrayList[EX]> |\r\r	(* This guarantee is safe because the inference clause guarantees\r		that E < EX at each call site *)\r	safeself:: (* guaranteed <MutableArrayList[EX]> *) self.\r\r	oldLastIndex:: lastIndex.\r	lastIndex: s + startGap.\r	copy:: safeself copy.\r	lastIndex: oldLastIndex.\r\r	^copy\r)",
 "public newCopyOfSize: size <Int>\rthatCanAlsoHoldElementsOf: other <List[X]>\r^<MutableArrayList[EX | X]> = (\r		(* {where X is returnType of #anElement message of arg 2;\r		     where EX is returnType of #anElement message of receiverType} *)\r\r	^(MutableArrayList(* [EX | X] *) new: size) size: size\r)",
 "public replaceFrom: start <Int>\rto: stop <Int>\rwith: other <List[E]>\rstartingAt: repStart <Int> = (\r	(* replace the elements of the receiver from start to stop with elements from other,\r	  starting with the element of other with index repStart. *)\r\r	| otheri <Int> |\r	(start >= 1 and: [ stop <= size ])\r		ifFalse: [ error: 'range out of bounds' ].\r\r	contents replaceFrom: start + startGap to: stop + startGap with: other startingAt: repStart\r)",
 "public defaultCapacity ^<Int> = (\r	^5\r)",
 "public new: capacity <Int> ^<Instance> = (\r	^new initCapacity: capacity\r)",
 "public with: val1 <E> ^<Instance> = (\r	^(new: 1) add: val1; yourself\r)",
 "public withAll: cltn <Collection[E]> ^<Instance> = (\r	^(new: cltn size) addAll: cltn; yourself\r)",
 "class MutableHashedMap new: cap = HashedCollection new: cap (\r(* MutableHashMaps are efficient HashedCollections that let you dynamically associate key->value\rpairs,  where the keys are matched using the #= message.  Equal keys must have equal #hash\rvalues. *)\r)",
 "new: cap",
 "new: cap",
 "public = other <Object> ^<Boolean> = (\r	^super = other and: [\r		self == other or: [\r			(* We already know that the other object must be a MutableHashedMap *)\r			self keys = other keys	]]\r)",
 "associationAt: key <K> ^<Assoc[K,E]> = (\r	^associationAt: key ifAbsent: [ error: 'key not found' ]\r)",
 "associationAt: key <K> ifAbsent: failBlock <[X def]> ^<Assoc[K,E] | X> = (\r	^valAt: key ifAbsent: failBlock\r)",
 "associations ^<MutableArrayList[Assoc[K,E]]> = (\r	| oc <MutableArrayList[Assoc[K,E]]> |\r\r	oc:: MutableArrayList new: size.\r	associationsDo:\r		[:assoc <Assoc[K,E]> |\r			oc add: assoc	].\r	^oc\r)",
 "associationsDo: f <[:Assoc[K,E]]> = (\r	contentsDo:\r		[:assoc <Assoc[K,E]> |\r			f value: assoc ]\r)",
 "public at: key <K> ifAbsentPut: ablk <[V]> ^<V> = (\r	^self at: key ifPresent: [:e | e] ifAbsentPut: ablk\r)",
 "public at: key <K> ifPresent: pblk <[:E]> ifAbsentPut: ablk <[E]> ^<E> = (\r	(* This is a method that is useful in the common case when you want\r		to find out if a key is present, and if it isn't, put an entry in for it.\r		It is much faster than a construct like (hc at: k ifAbsent: [ hc at: k put: e ])\r		for the case when a new entry must be added.\r		If the key is present, pblk is evaluated with the associated element.\r		If it is absent, then ablk is evaluated, and the value that it returns\r		is associated with k in the receiver.  In either case, the associated element\r		is returned. *)\r\r	| reusableSlot <Int> |\r	#BOGUS. (* Remove this method. *)\r	table == nil\r		ifTrue: [ createFirstTable.	 ].\r	^lookup: key\r				matchingSlotDo:\r						[:index <Int> :assoc <VarAssoc[K,E]> |\r							| el <E> |\r							el:: assoc value.\r							pblk value: el.\r							el		]\r				emptySlotDo:\r						[:index <Int> |\r							| newEl <E> |\r							newEl:: ablk value.\r							reusableSlot == nil\r								ifTrue: [ tableAt: key put: newEl inEmptySlot: index ]\r								ifFalse: [ tableAt: key put: newEl inDeletedSlot: reusableSlot ].\r							newEl	]\r				deletedSlotsDo:\r						[:index <Int> |\r							reusableSlot == nil\r								ifTrue: [ reusableSlot:: index ].\r						]\r)",
 "public at: key <K> put: el <E> ^<E> = (\r	^at: key put: el ifNew: []\r)",
 "protected at: key <K> put: el <E> ifNew: blk <[]> ^<E> = (\r	#BOGUS. (* Remove this method. *)\r	tableAt: key put: el ifNew: blk.\r	^el\r)",
 "protected buildValForKey: k <K> element: el <E> ^<VarAssoc[K,E]> = (\r	^Association key: k value: el\r)",
 "protected elementFor: assoc <Assoc[K,E]> ^<E> = (\r	^assoc value\r)",
 "protected elementForCopy: el <VarAssoc[K,E]> ^<VarAssoc[K,E]> = (\r	^el copy\r)",
 "protected hashFor: key <Object> ^<Int> = (\r	^key hash\r)",
 "public includesAssociation: assoc <Assoc[K,Object]> ^<Boolean> = (\r	^(at: assoc key ifAbsent: [ ^false ]) = assoc value\r)",
 "public isDictionary ^<Boolean> = (\r	^true\r)",
 "public isKindOfMap ^<Boolean> = (\r	^true\r)",
 "protected key: k <Object> matches: another <Object> ^<Boolean> = (\r	^k = another\r)",
 "protected keyFor: assoc <Association[K, V]> ^<K> = (\r	^assoc key\r)",
 "public keys ^<Set[K]> = (\r	| s <Set[K]> |\r	s:: Set new: size.\r	self keysDo: [:key <K> | s include: key ].\r	^s\r)",
 "public keysAndValuesDo: action <[:K :V]> = (\r	self contentsDo:\r		[:assoc <Association[K, V]> | action value: assoc key value: assoc value ]\r)",
 "protected objToIncludeFor: newAssoc <VarAssoc[K,E]> withExisting: assoc <VarAssoc[K,E]> ^<VarAssoc[K,E]> = (\r	(* MutableHashMaps reuse the previous association *)\r	assoc value: newAssoc value.\r	^assoc\r)",
 "protected tableAt: key <K>\rput: el <E>\rinMatchingSlot: index <Int>\rvalue: val <VarAssoc[K,E]>\r^<VarAssoc[K,E]> = (\r	val value: el.\r	^val\r)",
 "public values ^<MutableArrayList[V]> = (\r	^self inject: (MutableArrayList new: size) into:\r		[:oc <MutableArrayList[V]> :el <V> |\r			oc add: el; yourself ]\r)",
 "public defaultCapacity ^<Integer> = (\r	^0\r)",
 "public new = (\r	^self new: defaultCapacity\r)",
 "public with: val1 <A> ^<Instance> = (\r	^(self new: 1) include: val1; yourself\r)",
 "public withAll: cltn <Collection[A]> ^<Instance> = (\r	^(self new: cltn size) includeAll: cltn; yourself\r)",
 "class MutableList = AbstractList (\r(* This class extends List[E] with mutation operations defined in terms of #at:put:.\rThe List[E] protocol is defined from this class' interface. *)\r)",
 "AbstractList",
 "AbstractList",
 "public at: index <Int> put: el <E> ^<E> = (\r	self subclassResponsibility\r)",
 "defaultMedianOf: a <Int> and: b <Int> and: c <Int> ^<Int> = (\r	(* This is an untypesafe method that only works for MutableLists of elements that\r		have Magnitude relationships with each other.  It is used by the default sorting\r		method. *)\r\r	| atA <E> atB <E> atC <E> |\r	atA:: at: a.\r	atB:: at: b.\r	atC:: at: c.\r	^atB <= atA\r		ifFalse: [ atC <= atB\r							ifFalse: [ b ]\r							ifTrue: [ atC <= atA\r												ifFalse: [ c ]\r												ifTrue: [ a ] 	] ]\r		ifTrue: [ atB <= atC\r							ifFalse: [ b ]\r							ifTrue: [ atA <= atC\r												ifFalse: [ c ]\r												ifTrue: [ a ] 	] ]\r)",
 "defaultSort: l <Int> to: r <Int> = (\r	(* This is an untypesafe method that only works for MutableLists of elements that\r		have Magnitude relationships with each other *)\r\r	| i <Int> j <Int> x <E> m <Int> n <Int> |\r	i:: l.\r	j:: r.\r	n:: ((r - l) + 1).\r	n == 0\r		ifTrue: [ ^self ].\r\r	(* Pick the partition value.  For <=7 elements, use the middle element.\r		For more than 7 but <= 40, use a median of three elements.  For > 40,\r		use a median of three medians of three *)\r	m:: (l + r) // 2.\r	n > 7\r		ifTrue: [ | pl <Int> pn <Int> s <Int> |\r						pl:: l.\r						pn:: r.\r						n > 40\r							ifTrue: [ s:: n // 8.\r											pl:: defaultMedianOf: pl and: pl+s and: pl+s+s.\r											m:: defaultMedianOf: m-s and: m and: m+s.\r											pn:: defaultMedianOf: (pn-s)-s and: pn-s and: pn.	].\r						m:: defaultMedianOf: pl and: m and: pn.		].\r	x:: at: m.\r\r	[i <= j]\r		whileTrue:\r			[ | ati <E> atj <E> |\r			 	[ x <= (ati:: at: i)]\r					whileFalse: [i:: i + 1].\r				[(atj:: at: j) <= x]\r					whileFalse: [j:: j - 1].\r				i <= j\r					ifTrue: [ at: i put: atj.\r									at: j put: ati.\r									i:: i + 1.\r									j:: j - 1]\r			].\r	l < j ifTrue: [defaultSort: l to: j ].\r	i < r ifTrue: [defaultSort: i to: r ].\r)",
 "medianOf: a <Int> and: b <Int> and: c <Int> using: compare <[:E:E| Boolean]> ^<Int> = (\r	| atA <E> atB <E> atC <E> |\r	atA:: at: a.\r	atB:: at: b.\r	atC:: at: c.\r	^(compare value: atB value: atA)\r		ifFalse: [ (compare value: atC value: atB)\r							ifFalse: [ b ]\r							ifTrue: [ (compare value: atC value: atA)\r												ifFalse: [ c ]\r												ifTrue: [ a ] 	] ]\r		ifTrue: [ (compare value: atB value: atC)\r							ifFalse: [ b ]\r							ifTrue: [ (compare value: atA value: atC)\r												ifFalse: [ c ]\r												ifTrue: [ a ] 	] ]\r)",
 "readWriteStream ^<ReadWriteStream[E]> = (\r	^ListReadWriteStream on: self\r)",
 "public replaceFrom: start <Int>\rto: stop <Int>\rwith: other <List[E]> = (\r	(* replace the elements of the receiver from start to stop with elements from other,\r	  starting with the first element of other. *)\r\r	^replaceFrom: start to: stop with: other startingAt: 1\r)",
 "public replaceFrom: start <Int>\rto: stop <Int>\rwith: other <List[E]>\rstartingAt: repStart <Int> = (\r	(* replace the elements of the receiver from start to stop with elements from other,\r	  starting with the element of other with index repStart. *)\r\r	| otheri <Int> |\r\r	repStart < start\r		ifFalse: [ otheri:: repStart.\r				  start to: stop do:\r					[:i <Int> |\r						at: i put: (other at: otheri).\r						otheri:: otheri + 1.	]]\r		ifTrue: [ otheri:: repStart + (stop - start).\r				stop to: start by: -1 do:\r					[:i <Int> |\r						at: i put: (other at: otheri).\r						otheri:: otheri - 1.	]]\r)",
 "swap: i <Int> with: j <Int> = (\r	| t <E> |\r	t:: at: i.\r	at: i put: (at: j).\r	at: j put: t.\r)",
 "writeStream ^<WriteStream[E]> = (\r	^readWriteStream\r)",
 "public class Set new: cap = HashedCollection new: cap ()",
 "new: cap",
 "new: cap",
 "public asSet ^<Extensible[EX]> = (\r		(* {where EX is returnType of #anElement message of receiverType} *)\r\r	(* The guarantee is safe because of the inference clause *)\r	^(* guaranteed <Set[EX]> *) self\r)",
 "buildValForKey: key <Object> element: el <E> ^<E> = (\r	^el\r)",
 "elementFor: el <E> ^<E> = (\r	^el\r)",
 "elementForCopy: el <E> ^<E> = (\r	^el\r)",
 "public hasSameElementsAs: other <Collection[Object]> ^<Boolean> = (\r	(* A faster reimplementation of the inherited version, to speed up set comparisons *)\r\r	| otherSet <Extensible[Object]> |\r	size = other size\r		ifFalse: [ ^false ].\r	otherSet:: other asSet.\r	size = otherSet size\r		ifFalse: [ ^false ].\r	do:\r		[:el <Object> |\r			(otherSet includes: el)\r				ifFalse: [ ^false ] ].\r	^true\r)",
 "hashFor: key <Object> ^<Int> = (\r	^key hash\r)",
 "public includes: o <Object> ^<Boolean> = (\r	^includesKey: o\r)",
 "public isKindOfSet ^ <Boolean> = (\r	^true\r)",
 "key: k <Object> matches: another <Object> ^<Boolean> = (\r	^k = another\r)",
 "keyFor: e <E> ^<Object> = (\r	^e\r)",
 "objToIncludeFor: new <E> withExisting: other <E> ^<E> = (\r	^new\r)",
 "public defaultCapacity = (\r	^0\r)",
 "public new = (\r	^new: defaultCapacity\r)",
 "public with: val1 <A> ^<Instance> = (\r	^(new: 1) include: val1; yourself\r)",
 "public withAll: cltn <Collection[A]> ^<Instance> = (\r	^(new: cltn size) includeAll: cltn; yourself\r)",
 "public class SortedList = AddableList (\r	(* Sorted collections are addable collections that always keep their elements in sorted order.  The\r	sort order is determined by the sortPredicate, which is a function that compares 2 elements and\r	returns true if the first argument should be before the second argument in the collection.\r	The sortPredicate should be provided when the collection is created.\r\r	Unfortunately, Smalltalk defines SortedList as having a default sortPredicate that uses #<= to compare\r	elements.  This is NOT typesafe, since there are many kinds of objects that you might want to sort that don't support\r	the #<= operator; however, this feature is retained in Strongtalk for compatibility.   If you wish to write typesafe programs,\r	then SortedLists should always be given a sort block when they are created.  This involves using the creation\r	messages #new:sortBlock:, #sortBlock: and the Collection utility message #asSortedList: instead of #new:, #new,\r	and #asSortedList, respectively. *)\r|\r	private usesDefaultSortBlock_private <Boolean>\r	private sortBlock_private <[:E:E| Boolean]>\r|initCapacity: self class defaultCapacity.\r	sortBlock_private:: SortedList defaultSortBlock.\r	usesDefaultSortBlock_private:: true)",
 "AddableList",
 "AddableList",
 "public add: el <E> ^<E> = (\r	| index <Integer> |\r	index:: indexFor: el.\r	index > contents size\r		ifFalse: [ index:: makeSpace: 1 beforeIndex: index]\r		ifTrue: [ needSpaceAtEnd: 1.\r						lastIndex: lastIndex + 1. ].\r	^contents at: index put: el.\r)",
 "public addAll: els <Collection[E]> ^<Collection[E]> = (\r	els size > (size // 8) 		 (* %todo: do measurements to see if 8 is reasonable *)\r		ifTrue: [ 	needSpaceAtEnd: els size.\r				els do: [:el <E> |\r					lastIndex: lastIndex + 1.\r					contents at: lastIndex put: el.	].\r				sort.		]\r		ifFalse: [ els do: [:el <E> |\r					add: el	]].\r	^els\r)",
 "public asSortedList ^<List[Object]> = (\r	^self\r)",
 "indexFor: el <E> ^<Integer> = (\r	(* This returns an internal index such that if el was inserted before it\r	  the collection would remain sorted *)\r\r	^contents\r		binarySearchFor: el\r		between: startGap + 1\r		and: lastIndex\r		toCompare: sortBlock\r)",
 "public initCapacity: cap <Int> = (\r	super initCapacity: cap.\r)",
 "public isSorted ^<Boolean> = (\r	(* testing function used for sort routine validation *)\r\r	^isSortedBy: sortBlock\r)",
 "public sort = (\r	usesDefaultSortBlock\r		ifTrue: [ contents defaultSort: startGap + 1 to: lastIndex ]\r		ifFalse: [ 	contents sort: startGap + 1 to: lastIndex using: sortBlock ]\r)",
 "public sortBlock ^<[:E:E| Boolean]> = (\r	^sortBlock_private\r)",
 "public sortBlock: sortBy <[:E:E| Boolean]> = (\r	sortBlock_private:: sortBy.\r	usesDefaultSortBlock_private:: false.\r	isEmpty ifFalse: [ sort. ].\r)",
 "public usesDefaultSortBlock ^<Boolean> = (\r	^usesDefaultSortBlock_private\r)",
 "public defaultCapacity ^<Int> = (\r	^5\r)",
 "public defaultSortBlock ^<[:E:E| Boolean]> = (\r	^[:el1 <E> :el2 <E> |\r		(* The default sort block for SortedLists is is not typesafe, but is included for\r		 Smalltalk compatibility (that's the way Smalltalk is!). *)\r		(\r(* guaranteed <Magnitude[E]> *) el1) <= el2	].\r)",
 "public new: capacity <Integer> ^<Instance> = (\r	^new initCapacity: capacity\r)",
 "public new: capacity <Integer> sortBlock: sort <[:E :E | Boolean]> ^<Instance> = (\r	^(new: capacity) sortBlock: sort\r)",
 "public sortBlock: sort <[:E :E | Boolean]> ^<Instance> = (\r	^new: defaultCapacity sortBlock: sort\r)",
 "public with: val1 <E> ^<Instance> = (\r	^(new: 1) add: val1; yourself\r)",
 "public withAll: cltn <Collection[E]> ^<Instance> = (\r	^(new: cltn size) addAll: cltn; yourself\r)",
 "class MirrorsForV8 usingPlatform: p runtime: r vmMirror: vmm = (\r(* The reflection library for the Javascript-based implementation of Newspeak.\r\rCopyright Google Inc. 2014 - 2017\r*)\r|\rprivate List = p collections List.\rprivate Map = p collections Map.\rprivate Mixin = p kernel Mixin.\rprivate StringBuilder = p kernel StringBuilder.\rprivate ImmutableMirrorGroup = (r MirrorGroups usingLib: p) ImmutableMirrorGroup.\rprivate vmmirror = vmm.\r\rprivate parserLib = Future computing: [r CombinatorialParsing usingPlatform: p].\rprivate grammar = Future computing: [r NewspeakGrammar usingPlatform: p parsers: parserLib].\rprivate asts = Future computing: [r NewspeakASTs usingLib: p].\rprivate parsing = Future computing: [r NewspeakParsing usingPlatform: p grammar: grammar asts: asts].\rprivate generation = Future computing: [r JavascriptGeneration usingPlatform: p].\rprivate compilation = Future computing: [r Compilation usingPlatform: p asts: asts parsing: parsing generation: generation].\rprivate compiler = Future computing: [compilation Compiler new].\r|)",
 " ",
 " ",
 "classDeclIRFor: mixin within: enclosing = (\r	| source = 'Newspeak3 ''Uncategorized'' ', (ClassDeclarationMirror reflecting: mixin) source. |\r	(*('compiling class:', source) out.*)\r	^compiler compileClassSource: source within: enclosing\r)",
 "classMixinOf: m <InstanceMixin> ^ <ClassMixin> = (\r (* Sometimes we need to get the class side of a mixin. Since reflectee is not exposed by MixinMirror, we must rely\r	on knowledge of the runtime structure.\r *)\r	^Mixin fromRuntimeMixin: (js propertyOf: (js propertyOf: m at: (js literal: 'runtimeMixin')) at: (js literal: 'meta'))\r)",
 "sourceForMethod: methodName <String> ofMixin: m <Mixin> ^ <String> = (\r	| js = generation factory. sourceIndex <Integer> |\r	sourceIndex:: sourceIndexForMethod: methodName ofMixin: m.\r	^js propertyOf: (js ident: 'sources') at: sourceIndex.\r)",
 "sourceIndexForMethod: methodName <String> ofMixin: m <Mixin> ^ <Integer> = (\r	| js = generation factory. methodMetadata |\r	methodMetadata:: (js propertyOf: m at: (js literal: 'methods')) select: [:e | (js propertyOf: e at: 'name') = methodName].\r	^js propertyOf: methodMetadata at: 'source'. (* compute the source index from the metadata *)\r)",
 "class AbstractClassHeaderMirror = (\r)",
 " ",
 " ",
 "public accessModifier = (\r(* Ths won't work for slots. So should we set this up explicitly and store the access? If we had the mangled name we could use that to decided; might be easier to keep mangled name and unmangle it on demand *)\r	(source startsWith: 'public ') ifTrue: [^#public].\r	(source startsWith: 'private ') ifTrue: [^#private].\r	^#protected\r)",
 "public classComment ^ <String> = (\r	^(compilation parser classHeader parseString: source) classComment\r)",
 "public source ^ <String> = (\r	subclassResponsibility\r)",
 "public class ClassDeclarationBuilder forExistingMixin: m <Mixin> within: enclosing <ClassDeclarationBuilder> = (\r(*\rA mutable description of a class, ready for installation. This class is the abstract superclass of two alternate\rimplementations: IRBasedClassDeclarationBuilder and MixinBasedClassDeclarationBuilder.\r\rThe former is created based upon the compiler's intermediate representation, and is useful when producing a\rcomplete class from source code.  The latter is created based upon an existing class declaration, specifically\rits mixin. This is much faster, as it does not require compilation to produce the builder. This is important\rsince some IDE presenters work off a builder, and requiring a complete compile may introduce a noticeable\rdelay (at least until the compiler gets a lot faster).\r\rSubclasses must implement a number of methods: computeInstanceSide, computeClassSide, name and declarationData.\rThe first two specify how the MixinBuilders that represent the two sides of the class are computed. The name\rcomputation also depends on the underlying structure.\r\rThe last subclass responsibility method, declarationData,\rspecifies how to compute other data representing the class under construction. These will differ depending\ron whether the initial input for the new class is an IR (obtained by compiling source code) or a mixin (obtained\rfrom an existing class in the runtime). The builders for the sides are stored in the instanceSide and classSide slots.\r\rIn all cases, the builder retains a copy of the existing mixin, if it exists. This the first formal parameter, m,\rwhich is saved in the slot prvtExistingMixin.\rIf the class is new, m is nil.\rIn addition, the builder expect another builder representing the enclosing class declaration. For top level classes\rthis is nil.\r\rThe remaining slots are reserved for future use to support deletion of members.\r\rInstallation is always based on recompiling the current (likely modified) version of the class from source.\rThis is because the compiled representation statically resolves the lexical level of a here send, and adding\ror removing members may impact that resolution within the class (including its nested classes).\r\rThe recompiled IR is installed, either by updating the existing mixin in the runtime, or by creating a new one,\rwhich is stored in prvtExistingMixin so that it becomes the \"existing mixin \" from that point on.\r\rStill lacking are facilities for correctly adding slots (and hence nested classes) and for delteions.\r*)\r|\rprvtExistingMixin <Mixin> ::= m.\rpublic enclosingClass <ClassDeclarationBuilder> = enclosing.\rprivate instanceSideSlot <MixinBuilder>\rprivate classSideSlot <MixinBuilder>\rdeletedInstanceMethods <List[Symbol]>\rdeletedClassMethods <List[Symbol]>\r|)",
 " ",
 " ",
 "public accessModifier = (\r	^declarationData accessModifier\r)",
 "public classSide ^ <MixinBuilder> = (\r	nil = classSideSlot ifTrue: [classSideSlot:: computeClassSide].\r	^classSideSlot\r)",
 "public computeClassDeclIR ^ <IntermediateClassDeclaration> = (\r(*  Compile latest source into an IR.  But this won't work for nested classes\r	| src = 'Newspeak3 ''Uncategorized'' ',  source. |\r	('compiling class:', src) out.*)\r\r	^nil = enclosingClass\r	  ifTrue: [\r		compiler compileClassSource: 'Newspeak3 ''Uncategorized'' ', source within: nil.\r		]\r	  ifFalse: [(* compiler compileClassSource: source within: enclosingClass.\r		Is enclosingClass the right kind of argument?\r		Can we make the compiler API more uniform so we can always just make this call?\r		This assumes we can dispense with compiling the entire module.\r		 *)\r		enclosingClass computeClassDeclIR instanceSide nestedClasses detect:\r		 [:ncd <IntermediateClassDeclaration> | ncd qualifiedName = qualifiedName]\r		]\r)",
 "computeClassSide ^ <MixinBuilder> = (\r	subclassResponsibility\r)",
 "computeInstanceSide ^ <MixinBuilder> = (\r	subclassResponsibility\r)",
 "declarationData = (\r	subclassResponsibility\r)",
 "public install ^<ClassDeclarationMirror> = (\r	| writer sb <StringBuilder> src <String> runtimeMixin <JRM> cdir <IntermediateClassDeclaration> |\r\r	writer:: generation Writer new.\r	sb:: StringBuilder new.\r	cdir:: computeClassDeclIR.\r	writer generateSourceFor: cdir runtimeMixin on: sb. (* compute up to date JS translation *)\r	src:: sb asString.\r	(*src out.*)\r	runtimeMixin:: js call: (js ident: 'eval') with: {src}. (* compute up to date runtime mixin *)\r	prvtExistingMixin isNil (* Update based on latest mixin *)\r		ifTrue: [\r			prvtExistingMixin:: Mixin fromRuntimeMixin: runtimeMixin.\r			updateSourceIndicesOfNewRuntimeMixin: runtimeMixin from: cdir.\r			(* this is where we should recompile the enclosing class*)\r			]\r		ifFalse: [updateMixinFrom: runtimeMixin with: cdir].\r	^ClassDeclarationMirror reflecting: prvtExistingMixin.\r)",
 "public instanceSide ^ <MixinBuilder> = (\r	nil = instanceSideSlot ifTrue: [instanceSideSlot:: computeInstanceSide].\r	^instanceSideSlot\r)",
 "public name ^<Symbol> = (\r	^subclassResponsibility\r)",
 "public qualifiedName = (\r	^declarationData qualifiedName\r)",
 "public simpleName ^<Symbol> = (\r	^name\r)",
 "public source ^<String> = (\r	| sb = StringBuilder new. |\r	sb add: header source.\r	sb writeln: ' ( '.\r	instanceSide nestedClasses do: [:ea <ClassDeclarationMirror | ClassDeclarationBuilder> | sb writeln: ea source].\r	instanceSide methods do: [:ea <MethodMirror | MethodBuilder> | sb writeln: ea source].\r	sb writeln: ' ) : ( '.\r	classSide methods do: [:ea <MethodMirror | MethodBuilder> | sb writeln: ea source].\r	sb writeln: ' )'.\r	^sb asString\r)",
 "updateApplicationsOf: oldRuntimeMixin <JRM> from: newRuntimeMixin <JRM> by: classDeclIR <IntermediateClassDeclaration> = (\r	|\r	newRuntimeMetamixin <MJRM> = js propertyOf: newRuntimeMixin at: (js literal: 'meta').\r	applications <Array[JRC]> = js propertyOf: oldRuntimeMixin at: (js literal: 'applications').\r	|\r	(* TODO: handle deletes *)\r	(* TODO: copy nested classes also? *)\r	(* TODO: copy new metadata *)\r	applications do: [:runtimeClass <JRC> |\r		|\r		runtimeMetaclass <MJRC> = js propertyOf: runtimeClass at: (js literal: 'meta').\r		|\r		(*runtimeClass out.*)\r		(* Cf. IntermediateClassDeclaration copyMethods: *)\r		classDeclIR instanceSide methods do: [:ea <IntermediateMethod> |\r			| jsProName <String> jsPubName <String> |\r			jsPubName:: compilation names manglePublic: ea name.\r			jsProName:: compilation names mangleProtected: ea name.\r			ea isProtected ifTrue: [\r				js assign: (js propertyOf: runtimeClass at: jsProName) toBe: (js propertyOf: newRuntimeMixin at: jsPubName).\r				js assign: (js propertyOf: runtimeClass at: jsPubName) toBe: (js call: (js ident: 'dnuCatcher') with: {jsPubName}).\r			].\r			ea isPublic ifTrue: [\r				js assign: (js propertyOf: runtimeClass at: jsProName) toBe: (js propertyOf: newRuntimeMixin at: jsPubName).\r				js assign: (js propertyOf: runtimeClass at: jsPubName) toBe: (js propertyOf: newRuntimeMixin at: jsPubName).\r			].\r		].\r		classDeclIR classSide methods do: [:ea <IntermediateMethod> |\r			| jsProName <String> jsPubName <String> |\r			jsPubName:: compilation names manglePublic: ea name.\r			jsProName:: compilation names mangleProtected: ea name.\r			ea isProtected ifTrue: [\r				js assign: (js propertyOf: runtimeMetaclass at: jsProName) toBe: (js propertyOf: newRuntimeMetamixin at: jsPubName).\r				js assign: (js propertyOf: runtimeMetaclass at: jsPubName) toBe: (js call: (js ident: 'dnuCatcher') with: {jsPubName}).\r			].\r			ea isPublic ifTrue: [\r				js assign: (js propertyOf: runtimeMetaclass at: jsProName) toBe: (js propertyOf: newRuntimeMetamixin at: jsPubName).\r				js assign: (js propertyOf: runtimeMetaclass at: jsPubName) toBe: (js propertyOf: newRuntimeMetamixin at: jsPubName).\r			].\r		].\r	].\r)",
 "updateHeaderSourceForNewRuntimeMixin: runtimeMixin <JRM> from: cdir <IntermediateClassDeclaration> = (\r |\r  headerSourceIndex <Integer> ::= js propertyOf: (js ident: 'sources') at: (js literal: 'length').\r  headerSource = cdir headerSource.\r |\r\r  js assign: (js propertyOf: runtimeMixin at: (js literal: 'header')) toBe: headerSourceIndex.\r  js assign: (js propertyOf: (js ident: 'sources') at: headerSourceIndex) toBe: headerSource.\r)",
 "updateInstanceMixin: oldRuntimeMixin <JRM> from: newRuntimeMixin <JRM> by: classDeclIR <IntermediateClassDeclaration> ^ <List[Symbol]> = (\r	(* TODO: handle deletes\r	go thru old methods and see if they exist in new methods, if not add them to deleted list? and remove from old.\r	*)\r	| newMethods <List[IntermediateMethod]> = classDeclIR instanceSide methods. |\r\r	deletedInstanceMethods:: List new.\r\r	(* (js propertyOf: oldRuntimeMixin at: #methods) forEach: [:m <MM> |\r		(newMethods anySatisfy: [:im <IntermediateMethod> |\r			im name = (compilation names manglePublic: (js propertyOf: m at: #name))\r			])\r		   ifFalse: [\r			deletedInstanceMethods add: im name.\r			(* remove from old; need to add delete support to JavascriptGeneration; not critical *)\r			].\r		].*)\r	(* TODO: copy nested classes also? *)\r	(* TODO: copy new metadata *)\r	newMethods do: [:ea <IntermediateMethod> | (* insert modified or new instance methods into mixin *)\r		| jsName <String> |\r		jsName:: compilation names manglePublic: ea name.\r		js assign: (js propertyOf: oldRuntimeMixin at: jsName) toBe: (js propertyOf: newRuntimeMixin at: jsName).\r	].\r	{#name. #header. #slots. #methods. #nestedClasses} do: [:jsName |\r		js assign: (js propertyOf: oldRuntimeMixin at: jsName) toBe: (js propertyOf: newRuntimeMixin at: jsName).\r	].\r)",
 "updateMetaMixin: oldRuntimeMetamixin <MJRM> from: newRuntimeMetamixin <MJRM> by: classDeclIR <IntermediateClassDeclaration> ^ <List[Symbol]> = (\r	| newMethods <List[IntermediateMethod]> = classDeclIR classSide methods. |\r\r	(* TODO: handle deletes *)\r	deletedClassMethods:: List new.\r	(* TODO: copy nested classes also? *)\r	(* TODO: copy new metadata *)\r	newMethods do: [:ea <IntermediateMethod> | (* insert modified or new class methods into mixin *)\r		| jsName <String> |\r		jsName:: compilation names manglePublic: ea name.\r		js assign: (js propertyOf: oldRuntimeMetamixin at: jsName) toBe: (js propertyOf: newRuntimeMetamixin at: jsName).\r	].\r	{#slots. #methods. #nestedClasses} do: [:jsName <Symbol> |\r		js assign: (js propertyOf: oldRuntimeMetamixin at: jsName) toBe: (js propertyOf: newRuntimeMetamixin at: jsName).\r	].\r)",
 "updateMixin: oldMixin <Mixin> from: newRuntimeMixin <JRM> by: classDeclIR <IntermediateClassDeclaration> = (\r	|\r	deletedInstanceMethods <List[Symbol]>\r	deletedClassMethods <List[Symbol]>\r	oldRuntimeMixin <JRM> = js propertyOf: oldMixin at: (js literal: 'runtimeMixin').\r	oldRuntimeMetamixin <MJRM> = js propertyOf: oldRuntimeMixin at: (js literal: 'meta').\r	newRuntimeMetamixin <MJRM> = js propertyOf: newRuntimeMixin at: (js literal: 'meta').\r	|\r	(* TODO: handle deletes *)\r	(* TODO: copy nested classes also? *)\r	(* TODO: copy new metadata *)\r	deletedInstanceMethods:: updateInstanceMixin: oldRuntimeMixin from: newRuntimeMixin  by: classDeclIR.\r	deletedClassMethods:: updateMetaMixin: oldRuntimeMetamixin from: newRuntimeMetamixin by: classDeclIR.\r	updateApplicationsOf: oldRuntimeMixin from: newRuntimeMixin by: classDeclIR.\r)",
 "updateMixinFrom: runtimeMixin <JRM> with: cdir <IntermediateClassDeclaration> = (\r |\r  instanceMethodSourceIndices <Map[String, Integer]> = Map new.\r  classMethodSourceIndices <Map[String, Integer]> = Map new.\r  runtimeMetamixin <MJRM> = js propertyOf: runtimeMixin at: (js literal: 'meta').\r  existingMixin <JRM> = js propertyOf: prvtExistingMixin at: (js literal: 'runtimeMixin').\r  existingMetamixin <MJRM> = js propertyOf: existingMixin at: (js literal: 'meta').\r  newSourceIndex <Integer> ::= js propertyOf: (js ident: 'sources') at: (js literal: 'length').\r |\r(* TODO: Also update source indices for header. *)\r(* TODO: update access modifiers if they have changed? *)\r	(* collect existing mixin's source indices into a map keyed by name *)\r	(js propertyOf: existingMixin at: (js literal: 'methods'))  do: [:ea <MM> |\r	   instanceMethodSourceIndices at: (js propertyOf: ea at: (js literal: 'name')) put: (js propertyOf: ea at: (js literal: 'source'))\r	].\r	(js propertyOf: existingMetamixin at: (js literal: 'methods')) do: [:ea <MM> |\r	  classMethodSourceIndices at: (js propertyOf: ea at: (js literal: 'name')) put: (js propertyOf: ea at: (js literal: 'source'))\r	].\r	(* Augment maps of source indices with entries for any new methods *)\r	(js propertyOf: runtimeMixin at: (js literal: 'methods')) do:\r		[:e <MM> | | selector |\r		   selector:: (js propertyOf: e at: (js literal: 'name')).\r		   instanceMethodSourceIndices at: selector ifAbsent: [instanceMethodSourceIndices at: selector put: newSourceIndex].\r		   newSourceIndex:: newSourceIndex + 1.\r		 ].\r	(js propertyOf: runtimeMetamixin at: (js literal: 'methods')) do:\r		[:e <MM> | | selector |\r		   selector:: (js propertyOf: e at: (js literal: 'name')).\r		   classMethodSourceIndices at: selector ifAbsent: [classMethodSourceIndices at: selector put: newSourceIndex].\r	         newSourceIndex:: newSourceIndex + 1.\r		 ].\r\r	  (* Update global sources array with any changed or new source code *)\r	instanceSide methods do: [:m <MethodBuilder> | | sourceIndex <Integer> |\r		  sourceIndex:: instanceMethodSourceIndices at: m name.\r		  m source ~= nil ifTrue: [js assign: (js propertyOf: (js ident: 'sources') at: sourceIndex) toBe: m source].\r		].\r	classSide methods do: [:m <MethodBuilder> | | sourceIndex <Integer> |\r		  sourceIndex:: classMethodSourceIndices at: m name.\r		  m source ~= nil ifTrue: [js assign: (js propertyOf: (js ident: 'sources') at: sourceIndex) toBe: m source].\r		].\r	  (* Ensure new runtime structure has correct source indices in its metadata*)\r	  (* what about the name itself? And the access modifier *)\r	(js propertyOf: runtimeMixin at: (js literal: 'methods')) do: [:mm <MM> |\r			js assign: (js propertyOf: mm at: (js literal: 'source'))\r			    toBe: (instanceMethodSourceIndices at: (js propertyOf: mm at: (js literal: 'name'))).\r	].\r	(js propertyOf: runtimeMetamixin at: (js literal: 'methods')) do: [:mm <MM> |\r		    js assign: (js propertyOf: mm at: (js literal: 'source'))\r		       toBe: (classMethodSourceIndices at: (js propertyOf: mm at: (js literal: 'name'))).\r		].\r		  (* Update class header source index *)\r	js assign: (js propertyOf: runtimeMixin at: (js literal: 'header')) toBe: (js propertyOf: existingMixin at: (js literal: 'header')).\r\r	(* Update the  existing runtime based on the new one *)\r	updateMixin: prvtExistingMixin from: runtimeMixin by: cdir\r)",
 "updateSourceIndicesOfNewRuntimeMixin: runtimeMixin <JRM> from: cdir <IntermediateClassDeclaration> = (\r |\r  instanceMethodSourceIndices <Map[String, Integer]> = Map new.\r  classMethodSourceIndices <Map[String, Integer]> = Map new.\r  runtimeMetamixin <MJRM> = js propertyOf: runtimeMixin at: (js literal: 'meta').\r  newSourceIndex <Integer> ::= js propertyOf: (js ident: 'sources') at: (js literal: 'length').\r |\r(* TODO: update access modifiers if they have changed? *)\r	(* Augment maps of source indices with entries for any new methods *)\r	(js propertyOf: runtimeMixin at: (js literal: 'methods')) do:\r		[:e <MM> | | selector |\r		   selector:: (js propertyOf: e at: (js literal: 'name')).\r		   instanceMethodSourceIndices at: selector ifAbsent: [instanceMethodSourceIndices at: selector put: newSourceIndex].\r		   newSourceIndex:: newSourceIndex + 1.\r		 ].\r	(js propertyOf: runtimeMetamixin at: (js literal: 'methods')) do:\r		[:e <MM> | | selector |\r		   selector:: (js propertyOf: e at: (js literal: 'name')).\r		   classMethodSourceIndices at: selector ifAbsent: [classMethodSourceIndices at: selector put: newSourceIndex].\r	         newSourceIndex:: newSourceIndex + 1.\r		 ].\r\r	  (* Update global sources array with any changed or new source code *)\r	instanceSide methods do: [:m <MethodBuilder> | | sourceIndex <Integer> |\r		  sourceIndex:: instanceMethodSourceIndices at: m name.\r		  m source ~= nil ifTrue: [js assign: (js propertyOf: (js ident: 'sources') at: sourceIndex) toBe: m source].\r		].\r	classSide methods do: [:m <MethodBuilder> | | sourceIndex <Integer> |\r		  sourceIndex:: classMethodSourceIndices at: m name.\r		  m source ~= nil ifTrue: [js assign: (js propertyOf: (js ident: 'sources') at: sourceIndex) toBe: m source].\r		].\r	  (* Ensure new runtime structure has correct source indices in its metadata*)\r	  (* what about the name itself? And the access modifier *)\r	(js propertyOf: runtimeMixin at: (js literal: 'methods')) do: [:mm <MM> |\r			js assign: (js propertyOf: mm at: (js literal: 'source'))\r			    toBe: (instanceMethodSourceIndices at: (js propertyOf: mm at: (js literal: 'name'))).\r	].\r	(js propertyOf: runtimeMetamixin at: (js literal: 'methods')) do: [:mm <MM> |\r		    js assign: (js propertyOf: mm at: (js literal: 'source'))\r		       toBe: (classMethodSourceIndices at: (js propertyOf: mm at: (js literal: 'name'))).\r		].\r		  (* Update class header source index *)\r	updateHeaderSourceForNewRuntimeMixin: runtimeMixin from: cdir.\r)",
 "public fromSource: src <String> ^<ClassDeclarationBuilder> = (\r	^self fromUnitSource: 'Newspeak3 ''Uncategorized'' ', src\r)",
 "public fromUnitSource: src <String> ^<ClassDeclarationBuilder> = (\r	| ir <IntermediateMixin> = (compiler compileClassSource: src within: nil). |\r(* source indices will be BOGUS here *)\r	^IRBasedClassDeclarationBuilder fromIR: ir existingMixin: nil within: nil\r)",
 "public reflecting: mixin <InstanceMixin> ^<ClassDeclarationBuilder> = (\r	| m = ClassDeclarationMirror reflecting: mixin. |\r	nil = m enclosingClass ifFalse:\r		[^m enclosingClass asBuilder instanceSide nestedClasses findMirrorNamed: m simpleName].\r\r	^MixinBasedClassDeclarationBuilder\r		forExistingMixin: mixin\r		within: nil\r)",
 "class ClassDeclarationMirror reflecting: mixin = (|\r	private reflectee = mixin.\r	public instanceSide <MixinMirror> = MixinMirror reflecting: mixin.\r	public classSide <MixinMirror> = MixinMirror reflecting: (classMixinOf: mixin).\r|)",
 " ",
 " ",
 "public accessModifier ^ <Symbol> = (\r	^header accessModifier\r)",
 "public applyToObject ^<ClassMirror> = (\r	nil = enclosingClass ifFalse: [^notTopLevel].\r	^ClassMirror reflecting: (reflectee applyTo: Object withName: simpleName)\r)",
 "public asBuilder ^<ClassDeclarationBuilder> = (\r	^ClassDeclarationBuilder reflecting: reflectee\r)",
 "public enclosingClass ^ <ClassDeclarationMirror> = (\r	| enclosing <Class> |\r	enclosing:: (js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'enclosingMixin')).\r	(js operator: '===' with: enclosing and: (js ident: 'undefined')) ifTrue: [^nil].\r	^ClassDeclarationMirror reflecting: (Mixin fromRuntimeMixin: enclosing)\r)",
 "public header ^<ClassHeaderMirror> = (\r	^ClassHeaderMirror reflecting: reflectee\r)",
 "public name = (\r	^(reflectee name splitBy: '`') last\r)",
 "public qualifiedName = (\r	#BOGUS. (* Remove when currentMixinUID uses a proper token. *)\r	^reflectee name\r)",
 "public simpleName = (\r	^name\r)",
 "public source ^<String> = (\r	| sb = StringBuilder new. |\r	sb add: header source.\r	sb writeln: ' ( '.\r	instanceSide nestedClasses do: [:ea | sb writeln: ea source].\r	instanceSide methods do: [:ea | sb writeln: ea source].\r	sb writeln: ' ) : ( '.\r	classSide methods do: [:ea | sb writeln: ea source].\r	sb writeln: ' )'.\r	^sb asString\r)",
 "class ClassHeaderMirror reflecting: mixin = AbstractClassHeaderMirror (|\r	private reflectee <Mixin> = mixin.\r|)",
 "AbstractClassHeaderMirror",
 "AbstractClassHeaderMirror",
 "public preamble ^ <String> = (\r	(* Foo factory = SuperFoo superFactory *)\r	| headerAst |\r	headerAst:: compilation parser classHeader parseString: source.\r	^source copyFrom: headerAst start to: headerAst superConstructorCall end\r)",
 "public source ^<String> = (\r	| sourceIndex = js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'header'). |\r	^js propertyOf: (js ident: 'sources') at: sourceIndex.\r)",
 "public class ClassMirror reflecting: r <Class> = (|\rpublic reflectee <Class> = r.\r|)",
 " ",
 " ",
 "public allSuperclasses ^ <List[ClassMirror]> = (\r	| klass <Class> superclasses <List[Class]> |\r	superclasses:: List new.\r	klass:: superclass.\r	[klass isNil] whileFalse: [\r		superclasses add: klass.\r		klass:: klass superclass.\r	].\r	^superclasses\r)",
 "private computeMirrorGroup: mgAccessor <[:MixinMirror | MirrorGroup]> ^ <List[Mirror]> = (\r(* Return a mirror group based on the mixins group and those of all superclasses. The argument mgAccessor extracts a mirror group from any mirror provided to it. *)\r	| mg <MirrorGroup> |\r	mg:: List new.\r	(allSuperclasses reverse add: self; yourself)\r		do: [:klass <ClassMirror> | mg addAll: (mgAccessor value: klass mixin)].\r	^mg\r)",
 "public declaration ^ <ClassDeclarationMirror> = (\r(* Convenience method to make the API more usable *)\r	^mixin declaration\r)",
 "public enclosingObject ^<ObjectMirror> = (\r	^ObjectMirror reflecting: reflectee enclosingObject\r)",
 "public methods ^ <MirrorGroup[MethodMirror]> = (\r	^computeMirrorGroup: [:r | r methods]\r)",
 "public mixin ^ <MixinMirror> = (\r	^MixinMirror reflecting: reflectee mixin\r)",
 "public name = (\r	^reflectee name\r)",
 "public nestedClasses ^ <MirrorGroup[ClassDeclarationMirror]> = (\r	^computeMirrorGroup: [:r | r nestedClasses]\r)",
 "public simpleName = (\r	^(reflectee name splitBy: '`') last\r)",
 "public slots ^ <MirrorGroup[SlotMirror]> = (\r	^computeMirrorGroup: [:r | r slots].\r)",
 "public superclass ^ <ClassMirror> = (\r	reflectee superclass isNil ifTrue: [^nil].\r	^ClassMirror reflecting: reflectee superclass\r)",
 "class IRBasedClassDeclarationBuilder fromIR: ir <IntermediateClassDeclaration> existingMixin: m <Mixin> within: enclosing <ClassDeclarationBuilder> = ClassDeclarationBuilder forExistingMixin: m  within: enclosing (\r|\rprvtIR <IntermediateClassDeclaration> = ir.\r|)",
 "forExistingMixin: m  within: enclosing",
 "forExistingMixin: m  within: enclosing",
 "computeClassSide ^ <MixinBuilder> = (\r	| existingClassMixin = nil = prvtExistingMixin ifFalse: [classMixinOf: prvtExistingMixin]. |\r	^MixinBuilder for: prvtIR classSide classDeclaration: self existingMixin: existingClassMixin.\r)",
 "computeInstanceSide ^ <MixinBuilder> = (\r	^MixinBuilder for: prvtIR instanceSide classDeclaration: self existingMixin: prvtIR instanceSide.\r)",
 "declarationData = (\r	^prvtIR\r)",
 "public header ^ <ClassHeaderMirror> = (\r	^SourceBasedClassHeaderMirror from: prvtIR headerSource\r)",
 "public name ^<Symbol> = (\r	^compilation names fullyQualifiedNameToSimple: qualifiedName\r)",
 "class MethodBuilder reflecting: mir in: mb source: s = (|\rreflecteeX <IntermediateMethod> = mir.\rdefiningMixinX <MixinBuilder> = mb.\rpublic source <String> = s.\r|)",
 " ",
 " ",
 "public accessModifier = (\r	^reflecteeX accessModifier\r)",
 "public definingMixin ^ <MixinBuilder> = (\r	^definingMixinX\r)",
 "public name ^<Symbol> = (\r	^reflecteeX name\r)",
 "public simpleName ^<Symbol> = (\r	^reflecteeX name\r)",
 "class MethodMirror named: n in: dm source: s = (|\r	public name <Symbol> = n.\r	public definingMixin <MixinMirror> = dm.\r	private sourceIndex <Integer> = s.\r|)",
 " ",
 " ",
 "public accessModifier = (\r(* Ths won't work for slots. So should we set this up explicitly and store the access? If we had the mangled name we could use that to decided; might be easier to keep mangled name and unmangle it on demand *)\r	(source startsWith: 'public ') ifTrue: [^#public].\r	(source startsWith: 'private ') ifTrue: [^#private].\r	^#protected\r)",
 "public simpleName ^<Symbol> = (\r	^name\r)",
 "public source ^<String> = (\r	^js propertyOf: (js ident: 'sources') at: sourceIndex.\r)",
 "public class MixinBasedClassDeclarationBuilder forExistingMixin: m <InstanceMixin> within: enclosing <ClassDeclarationBuilder> =\rClassDeclarationBuilder forExistingMixin: m  within: enclosing (\r| mixinMirror = MixinMirror reflecting: m. |\r)",
 "forExistingMixin: m  within: enclosing",
 "forExistingMixin: m  within: enclosing",
 "computeClassSide ^ <MixinBuilder> = (\r	| existingClassMixin = classMixinOf: prvtExistingMixin. |\r	^MixinBuilder for: mixinMirror declaration classSide classDeclaration: self existingMixin: existingClassMixin.\r)",
 "computeInstanceSide ^ <MixinBuilder> = (\r	^MixinBuilder for: mixinMirror classDeclaration: self existingMixin: prvtExistingMixin.\r)",
 "declarationData ^ <ClassDeclarationMirror> = (\r	^mixinMirror declaration\r)",
 "public header ^ <ClassHeaderMirror> = (\r	^declarationData header\r)",
 "public name ^<Symbol> = (\r	^declarationData name\r)",
 "class MixinBuilder for: dataSource <IntermediateMixin | MixinMirror> classDeclaration: cdb <ClassDeclarationBuilder> existingMixin: em <Mixin> = (\r(*\rA mutable description of a mixin. Used by ClassDeclarationBuilder, which is the actual unit of installation.\rInstances of this class are created from dataSource, which  may be either the compiler's intermediate representation for mixins,\ror a mixin mirror. In all cases, a builder, cdb,  for the entire class must be supplied as a reference to the overall\rdeclaration. If the mixin, em, that is being described already exists, it too is required - otherwise em should be nil.\r\rThe working representation for the builder consists of slots representing the methods, nested classes and slots of the mixin.\rThese are computed upon instantiation. Changing the mixin elsewhere will have no effect on this builder once it has\rbeen instantiated!\r\rArguably, it might be cleaner to separate out MixinBuilders into different implementations just like ClassDeclarationBuilders.\rIn practice, the only point where a difference arises is in computing nestedClasses, the set of nested class builders.\rThus, it seems simpler to factor out that decision to the method #nestedClassBuildrFor:within:, which does a test\ron the data to decide what action to take.\r*)\r|\rdata <IntermediateMixin | MixinMirror> = dataSource.\rpublic declaration <ClassDeclarationBuilder> = cdb.\rpublic slots <MutableMirrorGroup> = MutableMirrorGroup group: ((dataSource slots reject: [:ea | ea isSynthetic])) within: self.\rpublic methods <MutableMethodGroup> = MutableMethodGroup group: ((dataSource methods reject: [:ea | ea isSynthetic]) collect: [:ea | MethodBuilder reflecting: ea in: self source: ea source]) within: self.\rpublic nestedClasses <MutableNestedClassGroup> =\r   MutableNestedClassGroup group: (dataSource nestedClasses collect: [:ea <IntermediateClassDeclaration | ClassDeclarationMirror> |\r	nestedClassBuilderFor: ea within: em]) within: self.\r|)",
 " ",
 " ",
 "public canUnderstand: selector <Symbol> ^ <Boolean> = (\r	^methods includesMirrorNamed: selector\r)",
 "find: name <String> in: aMixin <Mixin>^ <Mixin> = (\r	^Mixin fromRuntimeMixin:\r		(js propertyOf:\r			(js propertyOf: aMixin at: (js literal: 'runtimeMixin')) at: (compilation names manglePublic: name)).\r)",
 "public isKindOfMixinMirror ^<Boolean> = (\r	^true\r)",
 "public isMeta ^ <Boolean> = (\r	^data isMeta\r)",
 "nestedClassBuilderFor: nc <IntermediateClassDeclaration | ClassDeclarationMirror> within: em <Mixin> ^ <ClassDeclartionBuilder> = (\r	data isKindOfIntermediateMixin ifTrue: [\r		^IRBasedClassDeclarationBuilder fromIR: nc existingMixin: (find: nc qualifiedName in: em) within: declaration\r		].\r	^MixinBasedClassDeclarationBuilder forExistingMixin: (find: nc qualifiedName in: em) within: declaration\r)",
 "public reflecting: mxn <Mixin | ClassMixin> ^<MixinBuilder> = (\r	^mxn isMeta\r		ifTrue: [(ClassDeclarationBuilder reflecting: (MixinMirror reflecting: mxn) declaration instanceSide reflectee) classSide]\r		ifFalse: [(ClassDeclarationBuilder reflecting: mxn) instanceSide]\r)",
 "class MixinMirror reflecting: mixin <Mixin> = (|\r	private reflectee <Mixin> = mixin.\r|)",
 " ",
 " ",
 "public apply: newSuperclass <Class> withName: n <Symbol> ^ <ClassMirror> = (\r	^ClassMirror reflecting: (reflectee applyTo: newSuperclass withName: n)\r)",
 "public asBuilder ^<MixinBuilder> = (\r	^isMeta\r		ifTrue: [declaration asBuilder classSide]\r		ifFalse: [declaration asBuilder instanceSide]\r)",
 "public canUnderstand: selector <Symbol> ^ <Boolean> = (\r	^methods includesMirrorNamed: selector\r)",
 "public declaration ^<ClassDeclarationMirror> = (\r	^ClassDeclarationMirror\r		reflecting: (isMeta\r			ifFalse: [reflectee]\r			ifTrue: [(Mixin fromRuntimeMixin: (js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'nonMeta')))])\r)",
 "public isKindOfMixinMirror ^<Boolean> = (\r	^true\r)",
 "public isMeta ^<Boolean> = (\r	^reflectee isMeta\r)",
 "public methods ^<MirrorGroup[MethodMirror]> = (\r	| raw <Array[MethodMirror]> |\r	raw:: ((js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'methods'))\r		select: [:each | (js propertyOf: each at: (js literal: 'isSynthetic')) not])\r		collect: [:each | MethodMirror named: (js propertyOf: each at: (js literal: 'name')) in: self source: (js propertyOf: each at: (js literal: 'source'))].\r	^ImmutableMirrorGroup group: raw\r)",
 "public name = (\r	^(reflectee name splitBy: '`') last\r)",
 "public nestedClasses ^<MirrorGroup[ClassDeclarationMirror]> = (\r	| raw <Array[ClassDeclarationMirror]> |\r	raw:: (js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'nestedClasses'))\r		collect: [:each | ClassDeclarationMirror reflecting:\r			(Mixin fromRuntimeMixin:\r				(js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (vmmirror mangleSelector: each)))].\r	^ImmutableMirrorGroup group: raw\r)",
 "public slots ^<MirrorGroup[SlotDeclarationMirror]> = (\r	| raw <Array[SlotDeclarationMirror]> |\r	isMeta ifTrue: [^ImmutableMirrorGroup group: {}].\r	raw:: ((js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'slots'))\r		select: [:each | (js propertyOf: each at: (js literal: 'isSynthetic')) not])\r		collect: [:each | SlotDeclarationMirror named: (js propertyOf: each at: (js literal: 'name'))].\r	^ImmutableMirrorGroup group: raw\r)",
 "class MutableMethodGroup group: ms <List[Mirror]>\r  within: mb <MixinBuilder>\r = MutableMirrorGroup group: ms within: mb  ()",
 "group: ms within: mb",
 "group: ms within: mb",
 "public addFromSource: s <String> ^ <MethodBuilder> = (\r	|\r	result <IntermediateMethod>\r	newM <MethodBuilder>\r	sourceIndex <Integer>\r	|\r	result:: compiler\r		compileMethodSource: s\r		within: definingMixin.\r\r	(* TODO: check for name conflicts *)\r\r	newM:: MethodBuilder reflecting: result in: definingMixin source: s.\r	removeMirrorNamed: result name.\r	(*mixinIR methods add: result.*)\r	addMirror: newM.\r	^newM\r)",
 "public removeMirrorNamed: m <Symbol | String>^ <Mirror> = (\r	| 	oldMirror <MethodMirror> |\r	oldMirror:: super removeMirrorNamed: m.\r	oldMirror isNil\r	  ifFalse: [ (* we are removing an existing method *)\r		(*mixinIR methods removeAllSuchThat: [:ea <IntermediateMethod> | ea name = m].*)\r	 ].\r	^oldMirror\r)",
 "class MutableMirrorGroup group: mirrors <List[Mirror]> within: mb <MixinBuilder> = ImmutableMirrorGroup group: mirrors (\r	|\r	protected definingMixin <MixinBuilder> = mb.\r	|\r)",
 "group: mirrors",
 "group: mirrors",
 "addMirror: m <Mirror> ^ <Mirror> = (\r	mirrors keysAndValuesDo: [:index <Integer> :mirror <Mirror> |\r		mirror simpleName = m simpleName ifTrue: [^mirrors at: index put: m]].\r	^mirrors addLast: m\r)",
 "public removeMirrorNamed: m <Symbol | String>^ <Mirror> = (\r	mirrors keysAndValuesDo: [:index :mirror |\r		mirror simpleName = m  ifTrue: [^mirrors remove: mirror]].\r	^nil\r)",
 "class MutableNestedClassGroup group: ms within: mb = MutableMirrorGroup group: ms within: mb  (\r)",
 "group: ms within: mb",
 "group: ms within: mb",
 "public class ObjectMirror reflecting: r = (|\r	public reflectee = r.\r|)",
 " ",
 " ",
 "private compileExpression: expression <String> ^<JS[Function]> = (\r	|\r	compiler\r	ir\r	dnuHandlers\r	writer\r	sb\r	src\r	func\r	|\r\r	compiler:: compilation Compiler new.\r	ir:: compiler\r			compileExpressionSource: expression\r			inMixin: getClass mixin.\r	dnuHandlers:: compiler dnuHandlers.\r\r	writer:: generation Writer new.\r	sb:: StringBuilder new.\r	writer generateSourceFor: dnuHandlers on: sb.\r	src:: sb asString.\r	func:: js call: (js ident: 'eval') with: {'(',src, ')'}.\r	js call: func with: {js verbatim: 'Object.prototype'}.\r\r	writer:: generation Writer new.\r	sb:: StringBuilder new.\r	writer generateSourceFor: ir function on: sb.\r	src:: sb asString.\r(*	src out.*)\r	^js call: (js ident: 'eval') with: {'(',src, ')'}\r)",
 "public evaluate: expression <String> ^<ThreadMirror> = (\r	| func state result |\r\r	func:: compileExpression: expression.\r	\r	[result:: js call: (js propertyOf: func at: (js literal: 'call')) with: {reflectee}.\r	 state:: #fulfilled]\r		on: Error do: [:e | result:: e. state:: #broken].\r\r	^ThreadMirror\r		state: state\r		result: (ObjectMirror reflecting: result)\r)",
 "public getClass = (\r	#BOGUS. (* Wrong for bilingual objects. *)\r	^ClassMirror reflecting:\r		(js propertyOf: reflectee at: (js literal: 'newspeakClass')).\r)",
 "public getSlot: selector = (\r	|\r	mangledName = vmmirror mangleSelector: selector, '`slot'.\r	raw = js propertyOf: reflectee at: mangledName.\r	|\r	(js operator: '===' with: (js ident: 'undefined') and: raw) ifTrue: [halt].\r	^ObjectMirror reflecting: raw\r)",
 "public setSlot: selector to: value = (\r	|\r	mangledName = vmmirror mangleSelector: selector, '`slot'.\r	raw = js propertyOf: reflectee at: mangledName.\r	|\r	(js operator: '===' with: (js ident: 'undefined') and: raw) ifTrue: [^halt].\r	js assign: (js propertyOf: reflectee at: mangledName) toBe: value.\r)",
 "class SlotDeclarationMirror named: n = (|\r	public name <Symbol> = n.\r	public accessModifier <Symbol> = #public. (*BOGUS*)\r|)",
 " ",
 " ",
 "class SourceBasedClassHeaderMirror from: src <String> = AbstractClassHeaderMirror (\r|\r	public source = src.\r|\r)",
 "AbstractClassHeaderMirror",
 "AbstractClassHeaderMirror",
 "class ThreadMirror state: s result: r = (\r	|\r	protected state = s.\r	public result <ObjectMirror | nil> = r.\r	|\r)",
 " ",
 " ",
 "public isBroken ^<Boolean> = (\r	^state = #broken\r)",
 "public isFulfilled ^<Boolean> = (\r	^state = #fulfilled\r)",
 "public isSuspended ^<Boolean> = (\r	^state = #suspended\r)",
 "class MirrorGroups usingLib: platform = (\r(* Mirror groups are designed to aggregate mirrors of any kind.\rThey make the mirror API compositional and not too\rheavyweight.  Consider the API of an immutable mixin mirror:\r\r\rname\rmethods\rslots\rclasses\r\rthe latter three all return mirror groups, which all share a common protocol:\r\rfindMirrorNamed: #foo\rincludesMirrorNamed: #foo\rdo: blk\r\rIn a more traditional API, we would need to support methods like:\r\rfindMethodNamed: #foo\rfindSlotNamed: #foo\rfindClassNamed: #foo\r\rincludesMethodNamed: #foo\rincludesSlotNamed: #foo\rincludesClassNamed: #foo\r\rmethodsDo: blk\rslotsDo: blk\rclassesDo: blk\r\rThis means 3 times as many methods, which need to be kept consistent.\rWhen the mirror is mutable, the actual mixin API does not change much. The\rimplementation returns mutable mirror groups, which support:\r\raddMirror: aMirror\raddFromSource: aSourceString\r\rinstead of having the mutable mixin support:\r\raddMethodMirror:\raddMethodFromSource:\raddSlotMirror:\raddSlotFromSource:\raddClassStencilMirror:\raddClassFromSource:\r\r   Copyright 2008 Cadence Design Systems, Inc.\r   Copyright 2011 Ryan Macnak\r\r   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)\r|\rprivate Collection = platform collections Collection.\rprivate List = platform collections List.\r|)",
 " ",
 " ",
 "public class ImmutableMirrorGroup group: ms <List[Mirror]> = Collection (\r(* Immutable mirror groups do not support adding or removing mirrors. They are created from an initial set of mirrors passed to the factory method.\r\rHowever, the API does include mutators, which all fail if called.  This allows them to provide good error messages when used in a context that might attempt to mutate them. An example would be a mutable mixin mirror that does not allow changes to its representation; it includes immutable mirror groups for its slots and classes, and a mutable mirror group for its methods. *)\r|\r	protected mirrors <List[Mirror]> = List withAll: ms. (* Preserve order.  Keep source code order if applicable.  Shape is important for many classes known to the VM. *)\r|)",
 "Collection",
 "Collection",
 "public addFromSource: s <String> = (\r	^Error signal: 'Adding mirrors not allowed on an immutable mirror group!'\r)",
 "public addMirror: m <Mirror> = (\r	^Error signal: 'Adding mirrors not allowed on an immutable mirror group!'\r)",
 "public do: blk <[:Mirror]> = (\r	mirrors do: blk\r)",
 "public findMirrorNamed: n <Symbol> ^ <Mirror> = (\r	mirrors do: [:mirror <Mirror> | mirror name = n ifTrue: [^mirror]].\r	^nil\r)",
 "public includesMirrorNamed: n <Symbol> = (\r	mirrors do: [:mirror <Mirror> | mirror name = n ifTrue: [^true]].\r	^false\r)",
 "public removeMirror: m <Mirror> = (\r	^Error signal: 'Removng mirrors not allowed on an immutable mirror group!'\r)",
 "public removeMirrorNamed: m <Symbol | String> = (\r	^Error signal: 'Removng mirrors not allowed on an immutable mirror group!'\r)",
 "public size ^ <Integer> = (\r	^mirrors size\r)",
 "class MirrorGroup group: ms <Collection[Mirror]> = ImmutableMirrorGroup group: ms (\r(* A mutable mirror group; mirrors can be added or removed after its creation. *)\r)",
 "group: ms",
 "group: ms",
 "public addFromSource: s <String> = (\r	self subclassResponsibility\r)",
 "addMirror: m <Mirror> = (\r	mirrors keysAndValuesDo: [:index :mirror |\r		mirror simpleName = m simpleName ifTrue: [^mirrors at: index put: m]].\r	^mirrors addLast: m\r)",
 "removeAll = (\r	mirrors: List new.\r)",
 "removeAllSuchThat: blk = (\r	mirrors select: blk thenDo: [:m <Mirror> | removeMirrorNamed: m name].\r)",
 "removeMirror: m <Mirror> = (\r	^mirrors remove: m\r)",
 "removeMirrorNamed: n <Symbol | String> = (\r	| m |\r	m:: findMirrorNamed: n.\r	^m ifNotNil: [removeMirror: m].\r)",
 "class Streams usingPlatform: platform = (\r(*\rInterim Newspeak Streams library.\rThis code was derived by converting the Strongtalk Stream classes to Newspeak, which is why the Sun Microsystems copyright and BSD license below applies.\r\rConverting Strongtalk code gives Newspeak a quick route to its own library, that is small, quite clean and  has a typed interface, with desirable license, and also quite close to the Smalltalk libraries we've been using. However, it may not be the final or ideal design.\r\rIt is not yet clear to me what the dividing lines between this module and the modules for files or even strings are. For example, the various character streams might really belong with strings, and the external streams may belong with files.\r\rThe naming conventions are probably too verbose as well. Finally, the fine grain breakdown into many mixins may not be ideal.\r\rCopyright (c) 1995-2006 Sun Microsystems, Inc. ALL RIGHTS RESERVED.\rCopyright 2008-2009 Gilad Bracha and other contributors.\r\rRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\r\r* Redistributions of source code must retain the above copyright notice,\r this  list of conditions and the following disclaimer.\r\r* Redistribution in binary form must reproduce the above copyright notice,\rthis list of conditions and the following disclaimer in the documentation and/o other materials provided with the distribution.\r\rNeither the name of Sun Microsystems or the names of contributors may\rbe used to endorse or promote products derived from this software without\rspecific prior written permission.\r\r>>\rTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\rTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\rBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\rGOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\rLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\rDAMAGE.>> *)\r|\rprivate BasicOutputReadStream = BasicOutputStream mixinApply: BasicReadStream.\r\rprivate CharacterIStream = CharacterInput mixinApply: BasicInputStream.\rprivate CharacterOStream = CharacterOutput mixinApply: BasicOutputStream.\r\rprivate CharacterConverterWithOutput = BasicOutputStream mixinApply: CharacterInputConverter.\rprivate OutputInputConverter = CharacterOutput mixinApply: CharacterConverterWithOutput.\rprivate BasicIExStream = BasicInputStream mixinApply: ExternalStream.\rprivate EIStream = BasicReadStream mixinApply: ExternalInputStream.\rprivate ReadExternalOutputStream = BasicOutputStream mixinApply: ExternalReadStream.\rprivate EOStream = BasicOutputStream mixinApply: ExternalStream.\rprivate EIOStream = ExternalOutputStream mixinApply: ReadExternalOutputStream.\r|)",
 " ",
 " ",
 "usingCrLfConvention = (\r	(* The current code only distinguishes systems that use CR and systems use CRLF for line endings. In order to generate files that are printed correctly on systems that use LF (Linux, OS X), we default to CRLF for now. *)\r	^true\r)",
 "public class BasicInputStream = (\r(* This class provides the standard implementation of the InputStream[E] protocol, where E is the type of the elements of the stream.  It implements all functionality\rin terms of the two messages #actualNext and #actualAtEnd, which subclasses must provide.\r\rNote that streams support all collection operations.  However, when using collection messages with\rstreams, the caller must be aware that iteration on a stream changes the state of the stream, so that\riterations are not repeatable.  Also, care must be taken with infinite streams, since most collection\rmessages will not terminate on their own for infinite streams.\r\r%responsibility #newCollectionOfSize:\r	Optionally override\r%responsibility #close\r	Close must be reimplemented if any work must be done when the stream is closed. *)\r|\rhavePeeked_0 <Boolean> ::= false.\r(* If true, then peekVal is the next element *)\rpeekVal <E>\r|)",
 " ",
 " ",
 "accumulateUntil: predicate <[Boolean]> ^ <List[E]> = (\r	| build <ReadWriteStream[E]> |\r\r	build:: self newBuildStream.\r	[ predicate value ]\r		whileFalse: [ build nextPut: self next ].\r	^build contentsWritten\r)",
 "actualAtEnd ^ <Boolean> = (\r	(* Test whether there are elements remaining in the stream, disregarding peekVal *)\r\r	self subclassResponsibility\r)",
 "actualNext ^ <E> = (\r	(* Return the next element of the stream, disregarding peekVal *)\r\r	self subclassResponsibility\r)",
 "atEnd ^ <Boolean> = (\r	^self havePeeked\r		ifTrue: [ false ]\r		ifFalse: [ self actualAtEnd ]\r)",
 "atEndOrPeekIs: delimiter <Object> ^ <Boolean> = (\r	^(self peekIfAbsent: [ ^true ]) = delimiter\r)",
 "close = (\r	(* by default, do nothing *)\r)",
 "contentsRemaining ^ <List[E]> = (\r	^self accumulateUntil: [ self atEnd ]\r)",
 "defaultExpected ^ <Integer> = (\r	^10\r)",
 "do: f <[:E]> = (\r	[ self atEnd ]\r		whileFalse: [ f value: self next ]\r)",
 "havePeeked ^ <Boolean> = (\r	^havePeeked_0\r)",
 "havePeeked: f <Boolean> = (\r	f ifFalse: [ peekVal:: nil ].\r	havePeeked_0:: f.\r)",
 "newBuildStream ^ <ReadWriteStream[E]> = (\r	(* Returns a readwrite stream to be used for accumulating elements\r	 for the various contents messages, etc. *)\r\r	^BasicReadWriteStream(* [E] *) on: (self newCollectionOfSize: self defaultExpected)\r)",
 "newCollectionOfSize: n <Integer> ^ <MutableList[E]> = (\r	(* Create and return a new collection of a class appropriate for\r	 holding elements of this stream.  By overriding this, subclasses\r	can customize the kind of collection returned by the various\r	contents messages, as well as #upTo:, etc. *)\r\r	^Array(* [E] *) new: n\r)",
 "next ^ <E> = (\r	^self havePeeked\r		ifTrue: [ self nextFromPeek ]\r		ifFalse: [ self actualNext ]\r)",
 "next: nElements <Integer> ^ <List[E]> = (\r	| cltn <VarSeqCltn[E]> |\r\r	cltn:: self newCollectionOfSize: nElements.\r	1 to: nElements do: [:i <Integer> |\r		self atEnd\r			ifTrue: [ self error: 'Not enough elements' ].\r		cltn at: i put: self next.	].\r	^cltn\r)",
 "nextFromPeek ^ <E> = (\r	| v <E> |\r	v:: self peekVal.\r	self	noPeekVal.\r	^v\r)",
 "public nextIfAbsent: f <[X def]> ^ <E | X> = (\r	^self havePeeked\r		ifTrue: [ self nextFromPeek ]\r		ifFalse: [ self actualAtEnd\r							ifFalse: [ self actualNext ]\r							ifTrue: [ f value ]	 ]\r)",
 "nextMatchFor: o <Object> ^ <Boolean> = (\r	^self next = o\r)",
 "noPeekVal = (\r	havePeeked:: false.\r	peekVal:: nil\r)",
 "peek ^ <E> = (\r	self havePeeked\r		ifFalse: [ self peekVal: self actualNext.\r				self havePeeked: true.	 ].\r	^self peekVal\r)",
 "peekFor: o <Object> ^ <Boolean> = (\r	^self peek = o\r		ifTrue: [ self next.\r				true	]\r		ifFalse: [ false ]\r)",
 "peekIfAbsent: f <[X def]> ^ <E | X> = (\r	self havePeeked\r		ifFalse: [ self actualAtEnd\r							ifTrue: [ ^f value ].\r						self peekVal: self actualNext.\r						self havePeeked: true.	 ].\r	^self peekVal\r)",
 "public printOn: strm <CharOutputStream> = (\r	strm	nextPutAll: self class name\r)",
 "skip: nElements <Integer> = (\r	nElements timesRepeat: [ self next ]\r)",
 "skipTo: o <Object> ^ <Boolean> = (\r	[ self atEnd ] whileFalse: [\r			self next = o\r				ifTrue: [ ^true ]	].\r	^false\r)",
 "upTo: delimiter <Object> ^ <List[E]> = (\r	| s <SeqCltn[E]> |\r	s:: self accumulateUntil: [ self atEndOrPeekIs: delimiter ].\r	self nextIfAbsent: [ ].\r	^s\r)",
 "public class BasicOutputStream = (\r(* This class provides the standard implementation of the OutputStream protocol.  It implements all functionality in terms of the message #nextPut:, which subclasses must provide.\r\r%responsibility #flush\r	Subclasses may have to reimplement this to flush any internal buffers.\r\r%todo: if this class doesn't end up with more methods than next:put: and nextPutAll:, then we\rshould remove it and copy those two methods into its subclasses and invocations.\r*)\r)",
 " ",
 " ",
 "externalFlush = (\r	(* Flush both internal Smalltalk buffers and any buffers external to Smalltalk *)\r\r	(* By default do regular flush.  Subclasses should extend to deal with any external buffers *)\r	self flush\r)",
 "public flush = (\r	(* Flush any information buffered in Smalltalk.  This does NOT\r	 flush the external medium; use #externalFlush for that. *)\r\r	(* By default do nothing *)\r)",
 "next: nElements <Integer> put: el <E> ^ <E> = (\r	nElements timesRepeat: [\r		self nextPut: el		].\r	^el\r)",
 "public nextPut: el <E> ^ <E> = (\r	self subclassResponsibility\r)",
 "public nextPutAll: els <Collection[E]> ^ <Collection[Object]> = (\r	els do: [:el <E> |\r		self nextPut: el		].\r	^els\r)",
 "put: el <E> ^ <E> = (\r	(* A better name for nextPut: *)\r\r	^self nextPut: el\r)",
 "putAll: els <Collection[E]> ^ <Collection[Object]> = (\r	(* Better name for nextPutAll: *)\r\r	^self nextPutAll: els\r)",
 "show: els <Collection[E]> ^ <Collection[Object]> = (\r	(* basically like for #nextPutAll, except that it should flush immediately. *)\r\r	self nextPutAll: els; flush.\r	^els\r)",
 "class BasicReadStream = BasicInputStream (\r(* This class provides the standard implementation of the ReadStream protocol.\r\rSubclass responsibilities:\r	%responsibility actualPosition:\r	Should be extended in subclasses to change any external position cursor, if necessary.\r	%responsibility actualNext\r	Subclasses must ensure that their implementation of next and nextFromPeek increments the position. *)\r| actualPosition_slot <Integer> ::= 0. |)",
 "BasicInputStream",
 "BasicInputStream",
 "actualAtEnd ^ <Boolean> = (\r	^self actualPosition >= self size\r)",
 "actualPosition ^ <Integer> = (\r	^actualPosition_slot\r)",
 "actualPosition: p <Integer> = (\r	actualPosition_slot: p\r)",
 "at: index <Integer> ^ <E> = (\r	| pos <Integer> result <E> |\r	pos:: self position.\r	self position: index - 1.\r	result:: self next.\r	self position: pos.\r	^result\r)",
 "collection ^ <List[E]> = (\r	| cltn <MutableList[E]> origPos <Integer> |\r\r	cltn:: self newCollectionOfSize: self size.\r	origPos:: self position.\r	self position: 0.\r	1 to: self size do: [:i <Integer> |\r		cltn at: i put: self next.	].\r	self position: origPos.\r	^cltn\r)",
 "public contents ^ <List[E]> = (\r	(* Obsolete: this method is included purely for BlueBook compatibility.  If possible, use\r	 #contentsRemaining and #contentsWritten, which will work when a ReadWriteStream\r	 is substituted for a ReadStream or a WriteStream, unlike this method *)\r\r	(* This originally referred to contentsRemaining. The result of 'contents' should not depend on how much of a stream has already been read, see Blue Book - Protocol for Streams *)\r\r	^self collection\r)",
 "contentsRemaining ^ <List[E]> = (\r	| cltn <MutableList[E]> n <Integer> |\r\r	n:: self size - self position.\r	cltn:: self newCollectionOfSize: n.\r	1 to: n do: [:i <Integer> |\r		cltn at: i put: self next.	].\r	^cltn\r)",
 "copyFrom: start <Integer> to: stop <Integer> ^ <MutableList[EX]>\r	(* {where EX is returnType of #anElement message of receiverType} *)\r= (\r	| pos <Integer> n <Integer> result <Array[EX]> offset <Integer> |\r	pos:: self position.\r	n:: (stop - start) + 1.\r	result:: Array(* [EX] *) new: n.\r	offset:: start - 1.\r	1 to: n do:\r		[:i <Integer> |\r			(* guarantee is safe because of inference clause *)\r			result at: i put: (\r(* guaranteed <EX> *) (self repositioningAt: offset + i)). ].\r	self position: pos.\r	^result\r)",
 "isEmpty ^ <Boolean> = (\r	^self size = 0\r)",
 "public position ^ <Integer> = (\r	^self havePeeked\r		ifFalse: [ self actualPosition ]\r		ifTrue: [ self actualPosition - 1 ]\r)",
 "public position: p <Integer> = (\r	self actualPosition: p.\r	self noPeekVal.\r)",
 "repositioningAt: index <Integer> ^ <E> = (\r	(* Like at:, but may leave the position changed *)\r\r	^self at: index\r)",
 "reset = (\r	self position: 0.\r)",
 "setToEnd = (\r	self position: self size.\r)",
 "size ^ <Integer> = (\r	self subclassResponsibility\r)",
 "skip: nElements <Integer> = (\r	self position: (self position + nElements max: self size)\r)",
 "skipTo: o <Object> ^ <Boolean> = (\r	| pos <Integer> n <Integer> sz <Integer> |\r	sz:: self size.\r	pos:: self position.\r	pos + 1 to: sz do:\r		[:i <Integer> |\r			(self repositioningAt: i) = o\r				ifTrue: [ self position: i.\r								^true ]\r		].\r	self position: sz.\r	^false\r)",
 "upTo: delimiter <Object> ^ <SeqCltn[E]> = (\r	| pos <Integer> n <Integer> result <List[E]> |\r	pos:: self position.\r	^(self skipTo: delimiter)\r		ifTrue: [ self copyFrom: pos + 1 to: self position - 1 ]\r		ifFalse: [ self copyFrom: pos + 1 to: self position ]\r\r(*	| pos <Integer> n <Integer> result <Array[E]> |\r	pos:: self position.\r	self skipTo: delimiter.\r	n:: (self position - pos) - 1.\r	self position: pos.\r	result:: Array[E] new: n.\r	1 to: n do:\r		[:i <Integer> |\r			result at: i put: self next ].\r	self nextIfAbsent: [].\r	^result *)\r)",
 "on: sc <List[E]> ^ <ReadStream[E]> = (\r	(* Create a new read stream on sc, assuming that all of its elements are readable.\r		This message is here for BlueBook compatibility.  For good style, use (sc readStream)\r		instead. *)\r\r	^SeqCltnReadStream(* [E] *) on: sc\r)",
 "on: sc <List[E]> from: firstIndex <Integer> to: lastIndex <Integer> ^ <ReadStream[E]> = (\r	(* Create a new read stream on a copy of the elements in sc from firstIndex to lastIndex, inclusive *)\r\r	^self on: (sc copyFrom: firstIndex to: lastIndex)\r)",
 "class BasicReadWriteStream = BasicOutputReadStream (\r(* This class provides the standard implementation of the WriteStream and ReadWriteStream protocols.\r\rThere is no BasicWriteStream class; this is because virtually all WriteStreams are on data structures with implicit readability (try thinking of a positionable collection that can be written and not read), so ReadStreams and ReadWriteStreams are used instead.\r\rBlue Book compatibility note: you can use ReadWriteStreams as you would in the Blue Book, with\rone exception: the #contents message acts like it would for a WriteStream (i.e. it returns the elements\rwritten) rather than returning the entire collection.  The messages #collection, #contentsRemaining, and #contentsWritten fulfill these kind of roles without ambiguity in our system, to make ReadWriteStreams\rfully substitutable for both ReadStreams and WriteStreams.\r\r%responsibility nextPut:\r	Subclasses must extend the nextPut: method to do the actual work of writing the element.\r%responsibility size:\r	Optional - Any subclass that wishes to start off with readable elements in the stream must send\r	the message size: to indicate how many there are.\r*)\r| size <Integer> ::= 0. |)",
 "BasicOutputReadStream",
 "BasicOutputReadStream",
 "public contents ^ <List[E]> = (\r	(* Obsolete: this method is included purely for BlueBook compatibility.  If possible, use\r	 #contentsRemaining and #contentsWritten, which will work when a ReadWriteStream\r	 is substituted for a ReadStream or a WriteStream, unlike this method *)\r\r	^self collection\r)",
 "public contentsWritten ^ <List[E]> = (\r	| cltn <MutableList[E]> origPos <Integer> |\r\r	cltn:: self newCollectionOfSize: self position.\r	origPos:: self position.\r	self position: 0.\r	1 to: origPos do: [:i <Integer> |\r		cltn at: i put: self next.	].\r	self position: origPos.\r	^cltn\r)",
 "public nextPut: el <E> ^ <E> = (\r	(* Subclasses must extend this to do the actual writing of the element.  This impl just keeps track of bookkeeping. *)\r\r	| pos <Integer> |\r	self position: (pos:: self position + 1).\r	pos > self size\r		ifTrue: [ self size: pos ].\r	^el\r)",
 "on: sc <MutableList[E]> ^ <ReadWriteStream[E]> = (\r	(* Create a new read write stream on a sequenceable collection, assuming that it contains no readable elements yet *)\r\r	^self on: sc numElements: 0\r)",
 "on: sc <MutableList[E]> numElements: n <Integer> ^ <ReadWriteStream[E]> = (\r	(* Create a new read write stream on a sequenceable collection, assuming that it contains n readable elements to start *)\r\r	^SeqCltnReadWriteStream on: sc numElements: n\r)",
 "class CharacterInput = (\r(* This mixin adds character specific messages to an InputStream class. *)\r)",
 " ",
 " ",
 "contentsRemaining ^ <String> = (\r	| con <List[Character]> |\r	con:: super contentsRemaining.\r\r	(* %todo use Str below when have first class protocols *)\r	^con isString\r		ifTrue: [ (* guaranteed <Str> *) con ]\r		ifFalse: [ String withAll: con ]\r)",
 "newCollectionOfSize: n <Integer> ^ <String> = (\r	^String(* [E] *) new: n\r)",
 "next: nElements <Integer> ^ <String> = (\r	| con <List[Character]> |\r	con:: super next: nElements.\r	^con isString\r		ifTrue: [ (* guaranteed <Str> *) con ]\r		ifFalse: [ String withAll: con ]\r)",
 "upTo: o <Object> ^ <String> = (\r	| con <List[Character]> |\r	con:: super upTo: o.\r	^con isString\r		ifTrue: [ (* guaranteed <String> *) con ]\r		ifFalse: [ String withAll: con ]\r)",
 "class CharacterInputConverter = CharacterIStream (\r(* Instances are used to create a CharInputStream that wraps a byte input stream\r*)\r| binaryStream <STRM> (* = binaryStrm. *) |)",
 "CharacterIStream",
 "CharacterIStream",
 "actualAtEnd ^ <Boolean> = (\r	^self binaryStream atEnd\r)",
 "actualNext ^ <Character> = (\r	| c <Character> |\r	c:: Character value: self binaryStream next.\r	(usingCrLfConvention and: [ c = Character cr ])\r	ifTrue: [ self binaryStream atEnd\r						ifFalse: [ self binaryStream peek = Character lf asciiValue\r											ifTrue: [ self binaryStream next ]	]].\r	^c\r)",
 "close = (\r	self binaryStream close.\r)",
 "initBinaryStream: binaryStrm <STRM> = (\r	self binaryStream: binaryStrm\r)",
 "upTo: del <Object> ^ <Str> = (\r	| bytes <List[Integer]> s <String> lfs <Integer> j <Integer> delimiter <Character> |\r\r	(self havePeeked and: [ self peek == del ])\r		ifTrue: [ ^super upTo: del ].\r\r	delimiter:: Character coerce: del.\r	bytes:: self binaryStream upTo: delimiter asciiValue.\r\r	usingCrLfConvention\r		ifTrue: [ delimiter == Character cr\r							ifTrue: [ (* If cr was the delim, got to check for reading the lf, since\r											it was at the lower level *)\r											(self binaryStream atEnd not and: [ self binaryStream peek == 10 ])\r												ifTrue: [ self binaryStream next ].\r										].\r					]\r		ifFalse: [ (* self havePeeked\r							ifFalse: [ s:: String new: bytes size.\r											1 to: bytes size do:\r												[:ind <Integer> |\r													s at: ind putUnicode: (bytes at: ind)	].\r										 ]\r							ifTrue:	[ s:: String new: bytes size + 1.\r											1 to: bytes size do:\r												[:ind <Integer> |\r													s at: ind + 1 putUnicode: (bytes at: ind)	].\r											s at: 1 put: self next.\r										 ]\r						^s *)\r					].\r\r	(* Count the line feeds *)\r	lfs:: 0.\r	1 to: bytes size do:\r		[:ind <Integer> |\r			(bytes at: ind) == 10\r				ifTrue: [ lfs:: lfs + 1 ]\r		].\r	self havePeeked\r		ifFalse: [ s:: String new: bytes size - lfs.\r						j:: 1.	 ]\r		ifTrue: [ s:: String new: (bytes size - lfs) + 1.\r						j:: 2.	 ].\r	bytes do:\r		[:b <Integer> |\r			b == 10\r				ifFalse: [ s at: j putUnicode: b.\r								j:: j + 1.	 ]\r		].\r	self havePeeked\r		ifTrue: [ s at: 1 put: self next ].\r	^s\r)",
 "on: binaryStrm <STRM> ^ <Instance> = (\r	^self new initBinaryStream: binaryStrm\r)",
 "public class CharacterInputOutputConverter = OutputInputConverter ()",
 "OutputInputConverter",
 "OutputInputConverter",
 "externalFlush = (\r	self binaryStream externalFlush.\r)",
 "public flush = (\r	self binaryStream flush.\r)",
 "public nextPut: c <Character> ^ <Character> = (\r	self binaryStream nextPut: c asciiValue.\r	 (usingCrLfConvention and: [ c = Character cr ])\r		ifTrue: [ self binaryStream nextPut: Character lf asciiValue ].\r	^c\r)",
 "public position ^ <Integer> = (\r	^self binaryStream position\r)",
 "public position: i <Integer> = (\r	self binaryStream position: i.\r	self noPeekVal.\r)",
 "setToEnd = (\r	self binaryStream setToEnd\r)",
 "public on: binaryStrm <STRM> ^ <Instance> = (\r	^self new initBinaryStream: binaryStrm\r)",
 "class CharacterOutput = (\r(* This mixin adds character specific messages to an OutputStream class. *)\r)",
 " ",
 " ",
 "public cr = (\r	self nextPut: Character cr\r)",
 "public crTab = (\r	self crTab: 1\r)",
 "public crTab: count <Integer> = (\r	count timesRepeat:\r		[ self nextPut: Character cr; nextPut: Character tab	]\r)",
 "public print: o <Object> = (\r	o printOn: self\r)",
 "public space = (\r	self nextPut: Character space\r)",
 "public tab = (\r	self nextPut: Character tab\r)",
 "class CharacterOutputConverter = CharacterOStream (\r| binaryStream <OutputStream[Integer]> (* = bstream. *) |)",
 "CharacterOStream",
 "CharacterOStream",
 "public close = (\r	self binaryStream close.\r)",
 "externalFlush = (\r	self binaryStream externalFlush.\r)",
 "public flush = (\r	self binaryStream flush.\r)",
 "initBinaryStream: binaryStrm <InputStream[Integer]> = (\r(* delete *)\r\r	self binaryStream: binaryStrm\r)",
 "public nextPut: c <Character> ^ <Character> = (\r	self binaryStream nextPut: c asciiValue.\r	 (usingCrLfConvention and: [ c = Character cr ])\r		ifTrue: [ self binaryStream nextPut: Character lf asciiValue ].\r	^c\r)",
 "public on: binaryStrm <OutputStream[Integer]> ^ <Instance> = (\r	^self new initBinaryStream: binaryStrm\r)",
 "public class CharacterReadConverter = CharacterInputConverter (\r(* Like CharacterInputConverter, but takes a ReadStream[Integer] rather than an InputStream[Integer], so that it can do some operations like\rupTo: faster.\r*)\r)",
 "CharacterInputConverter",
 "CharacterInputConverter",
 "numCharsUpToAscii: del <Integer> ^ <Integer> = (\r	(* Num chars from current pos to del, not counting lfs if they shouldn't be.  May leave the position changed. *)\r\r	| n <Integer> sz <Integer> |\r	n:: 0.\r	sz:: self binaryStream size.\r	self binaryStream position + 1 to: sz do:\r		[:i <Integer> |\r			| asc <Integer> |\r			asc:: self binaryStream repositioningAt: i.\r			(usingCrLfConvention and: [ asc == 10 ]) (* lf *)\r				ifFalse: [ asc == del\r									ifTrue: [ ^n ]\r									ifFalse: [ n:: n + 1 ]\r							 ]\r		].\r	^n\r)",
 "upTo: del <Object> ^ <String> = (\r	| sz <Integer> s <String> lfs <Integer> offset <Integer> delimiter <Integer> pos <Integer> bsize <Integer> i <Integer> |\r\r	(self havePeeked and: [ self peek == del ])\r		ifTrue: [ ^super upTo: del ].\r\r	delimiter:: (Character coerce: del) asciiValue.\r	pos:: self binaryStream position.\r\r	(* Scan for the delimiter in the binary stream *)\r	sz:: self numCharsUpToAscii: delimiter.\r\r	self havePeeked\r		ifFalse: [ s:: String new: sz.\r						offset:: 0]\r		ifTrue: [ s:: String new: sz + 1.\r						s at: 1 put: self next.\r						offset:: 1. ].\r\r	pos:: pos + 1.\r	i:: 1.\r	[ i <= sz ]\r		whileTrue: [ | code <Integer> |\r							code:: self binaryStream repositioningAt: pos.\r							s at: i + offset putUnicode: code.\r							i:: i + 1.\r							(code == 13 and: [usingCrLfConvention])\r								ifTrue: [ pos:: pos + 1. ].\r							pos:: pos + 1.	].\r	(* The following fiddly code is to set the binary stream position to pos without\r		going past the end of the stream *)\r	self binaryStream position: pos - 1.\r	self binaryStream atEnd\r		ifFalse: [ self binaryStream next ].\r	^s\r)",
 "public on: binaryStrm <STRM> ^ <Instance> = (\r	^self new initBinaryStream: binaryStrm\r)",
 "class ExternalInputStream = BasicIExStream (\r)",
 "BasicIExStream",
 "BasicIExStream",
 "actualAtEnd ^ <Boolean> = (\r	^self nextBufferPosition >= self bufferNumElements\r)",
 "actualNext ^ <Integer> = (\r	| pos <Integer> byte <Integer> |\r	self actualAtEnd\r		ifTrue: [ self error: 'attempt to read past the end of an external stream' ].\r	pos:: self nextBufferPosition.\r	byte:: self buffer (* byteAt: pos. *) unsignedByteAt: pos+1.\r	pos:: pos + 1.\r	pos >= self bufferSize\r	ifFalse: [ self nextBufferPosition: pos ]\r	ifTrue: [ self advanceBuffer ].\r	^byte\r)",
 "arrangeForFinalization = (\r	(* %todo: arrange for the finalize message to be sent to the stream before gc.\r	Is this right? *)\r	(* self descriptor register. *)\r)",
 "atEnd ^ <Boolean> = (\r	(* Reimplemented for speed since we have ensured that atEnd and actualAtEnd mean\r	  the same thing *)\r\r	^self actualAtEnd\r)",
 "public close = (\r	(* We have to reimplement this because BasicInputStream mixin in an inappropriate version *)\r	self doClose.\r)",
 "fillBuffer = (\r	self bufferNumElements:\r	(self descriptor readAt: self bufferOrigin\r	  ifFail: [:err <ExternalError> | self error: err ]).\r)",
 "public initDescriptor: d <DESCRIPTOR> = (\r	#ACCESSBOGUS.\r\r	super initDescriptor: d.\r	self fillBuffer.\r)",
 "newCollectionOfSize: n <Integer> ^ <ByteArray> = (\r	^ByteArray new: n\r)",
 "public next ^ <Integer> = (\r	(* Reimplemented for speed since we have ensured that next and actualNext mean\r	  the same thing *)\r\r	^self actualNext\r)",
 "peek ^ <Integer> = (\r	(* Reimplement so that we can ensure that next and actualNext are the same, for\r	 speed, since by design we always know we have another buffer byte to look at. *)\r\r	self assert: [ self atEnd not ] message: 'Can''t peak past the end of the stream'.\r	^self buffer unsignedByteAt: self nextBufferPosition + 1 (* byteAt: self nextBufferPosition *)\r)",
 "peekIfAbsent: f <[X def]> ^ <E | X> = (\r	(* Reimplement so that we can ensure that next and actualNext are the same, for\r	 speed, since by design we always know we have another buffer byte to look at. *)\r\r	^self atEnd\r		ifTrue: [ f value ]\r		ifFalse: [ self buffer byteAt: self nextBufferPosition ]\r)",
 "public class ExternalOutputStream = EOStream (\r(* %responsibility #updateBufferLocationAfterFlush\r	This method may have to be reimplemented (for example in read/write streams) depending\r	on whether the buffer contains only written elements, or a mix of read/written elements.\r\r%todo: we must make sure when %finalization is implemented that instances of this class are finalized before their descriptors, so that the buffer can be flushed.  See #finalize. *)\r|\rdirty <Boolean> ::= false. (* indicates whether the buffer contains unflushed modified data *)\r|)",
 "EOStream",
 "EOStream",
 "advanceBufferLocation = (\r	self bufferOrigin: self bufferOrigin + self bufferNumElements;\r		nextBufferPosition: 0;\r		bufferNumElements: 0.\r)",
 "arrangeForFinalization = (\r	(* %todo: arrange for the finalize message to be sent to the stream before gc. *)\r)",
 "public close = (\r	self flush.\r	super close.\r)",
 "externalFlush = (\r	self flush.\r	self descriptor flushIfFail: [:err <ExternalError> | self error: err ]\r)",
 "finalize = (\r	self close\r)",
 "public flush = (\r	self dirty\r		ifTrue: [ self bufferNumElements > 0\r					ifTrue: [ self writeBuffer; updateBufferLocationAfterFlush. 	].\r				self dirty: false.	].\r)",
 "logicalFlush = (\r	self dirty\r	ifTrue: [ self bufferNumElements > 0\r	          ifTrue: [ self writeBuffer; updateBufferLocationAfterFlush. ].\r	      self dirty: false. ].\r)",
 "public nextPut: byte <Integer> ^ <Integer> = (\r	| pos <Integer> |\r	pos:: self nextBufferPosition.\r	(* self buffer byteAt: pos put: byte. *)\r	self buffer unsignedByteAt: pos+1 put: byte.\r\r	pos:: pos + 1.\r	self nextBufferPosition: pos;\r	bufferNumElements: (pos max: self bufferNumElements).\r	pos >= self bufferSize\r	ifTrue: [ self writeBuffer; advanceBuffer; dirty: false]\r	ifFalse: [ self dirty: true ].\r	^byte\r)",
 "updateBufferLocationAfterFlush = (\r	self advanceBufferLocation\r)",
 "public writeBuffer = (\r	(* Caller is responsible for updating dirty *)\r	self descriptor\r	write: self bufferNumElements\r	at: self bufferOrigin\r	ifFail: [:err | self error: err ]\r)",
 "public onDescriptor: d <DESCRIPTOR> ^ <Instance> = (\r	^self new initDescriptor: d\r)",
 "public class ExternalReadStream = EIStream (\r(* %note: the actualPosition slot inherited from BasicReadStream is\rnot used; its access methods are reimplemented to use the\rbuffer origin and buffer position. *)\r)",
 "EIStream",
 "EIStream",
 "actualAtEnd ^ <Boolean> = (\r	(* copied-down implementation from ExternalInputStream for efficiency *)\r	^self nextBufferPosition >= self bufferNumElements\r)",
 "actualPosition ^ <Integer> = (\r	^self bufferOrigin + self nextBufferPosition\r)",
 "actualPosition: p <Integer> = (\r	| bufPos <Integer> |\r	bufPos:: p - self bufferOrigin.\r	(bufPos >= 0 and: [ bufPos < self bufferNumElements ])\r	ifTrue: [ self nextBufferPosition: bufPos ]\r	ifFalse: [ (* We need to reload the buffer *)\r					self assert: [ p between: 0 and: self size ] message: ''.\r	          self writeIfNeededBeforePositionChange.\r	          self bufferOrigin: (self goodBufferOriginForPosition: p).\r	          self descriptor position: self bufferOrigin.\r	          self fillBuffer.\r	          self nextBufferPosition: p - self bufferOrigin. ].\r)",
 "at: index <Integer> ^ <Integer> = (\r	| i <Integer> |\r	i:: index - self bufferOrigin.\r	^(i < 1 or: [ i > self bufferNumElements ])\r		ifFalse: [ self buffer byteAt: i - 1 ]\r		ifTrue: [ | pos <Integer> result <Integer> |\r						pos:: self position.\r						self position: index - 1.\r						(* Use a recursive call, which should now be in range *)\r						result:: self at: index.\r						self position: pos.\r						result	]\r)",
 "goodBufferOriginForPosition: nextPos <Integer> ^ <Integer> = (\r	(* Try to keep the origin on a buffer-aligned boundary *)\r	^nextPos - (nextPos \\\\ self bufferSize)\r)",
 "initializeActualPosition = (\r	(* disable initialization, since we don't use the inherited actualPosition instance variable *)\r)",
 "repositioningAt: index <Integer> ^ <Integer> = (\r	| i <Integer> |\r	i:: index - self bufferOrigin.\r	^(i < 1 or: [ i > self bufferNumElements ])\r		ifFalse: [ self buffer byteAt: i - 1 ]\r		ifTrue: [ self position: index - 1.\r						self at: index ]\r)",
 "public size ^ <Integer> = (\r	^self descriptor size\r)",
 "writeIfNeededBeforePositionChange = (\r	(* This is a hook for mutable subclasses to do any buffer flushing necessary before\r	 the buffer is repositioned.  By default, do nothing *)\r)",
 "public onDescriptor: d <DESCRIPTOR> ^ <Instance> = (\r	^self new initDescriptor: d\r)",
 "public class ExternalReadWriteStream = EIOStream (\r(* Implements positionable streams of bytes from an external source.  Currently, this class is used both\rfor read-only streams and read-write streams, with different creation messages. *)\r)",
 "EIOStream",
 "EIOStream",
 "public contents ^ <List[Integer]> = (\r	(* Obsolete: this method is included purely for BlueBook compatibility.  If possible, use\r	 #contentsRemaining and #contentsWritten, which will work when a ReadWriteStream\r	 is substituted for a ReadStream or a WriteStream, unlike this method *)\r\r	^self collection\r)",
 "contentsWritten ^ <List[Integer]> = (\r	(* %copied (substituting for E) from BasicReadWriteStream *)\r	| cltn <VarSeqCltn[Integer]> origPos <Integer> |\r	cltn:: self newCollectionOfSize: self position.\r	origPos:: self position.\r	self position: 0.\r	1 to: origPos do: [:i <Integer> |\r	cltn at: i put: self next. ].\r	self position: origPos.\r	^cltn\r)",
 "public size ^ <Integer> = (\r	(* Make sure we flush our buffer if needed to ensure that\r	 the buffer contents are taken into account *)\r\r	self flush.\r	^super size\r)",
 "public updateBufferLocationAfterFlush = (\r	#ACCESSBOGUS.\r	(* We don't advance the buffer here because we need to preserve the read semantics *)\r)",
 "writeIfNeededBeforePositionChange = (\r	self dirty\r	ifTrue: [ self writeBuffer; dirty: false. ].\r)",
 "public onDescriptor: d <DESCRIPTOR> ^ <Instance> = (\r	^self new initDescriptor: d\r)",
 "class ExternalStream = Object (\r(* This is the abstract superclass for all external stream classes.  It\rprovides buffer management for subclasses.   Library users don't normally directly instantiate ExternalStreams,\rsince that exposes you to genericity and raw ExternalDescriptors; instead, more appropriate entry points\rsuch as readStream/writeStream/readWriteStream are implemented for the various kinds of external objects\rthat can be streamed over, such as File.\r\rInvariant: the buffer position is always less than the index of the last buffer element.   This is accomplished by proactively filling/flushing the buffer when the end is reached.\r\r%responsibility #arrangeForFinalization\r	Subclasses should reimplement this appropriately to do any finalization registration\r	to ensure that the stream is closed when it is garbage collected. *)\r|\rdescriptor <DESCRIPTOR> (* = d. *)\rbuffer <ExternalProxy> (* I/O buffer, cached from descriptor for speed (0 indexed) *)\rbufferSize <Integer> (* I/O buffer size, cached from descriptor for speed *)\rbufferOrigin <Integer> (* the offset between position and buffer coordinates *)\rpublic nextBufferPosition <Integer> (* The actual position, in buffer coordinates, of the next element (i.e. position + 1 in buffer coords) *)\rpublic bufferNumElements <Integer> (* The number of valid data bytes in the buffer *)\r|)",
 "Object",
 "Object",
 "advanceBuffer = (\r	(* advance the buffer, and fill it if the receiver is readable.  Assumption: the last advanceBuffer completely\r	filled the buffer *)\r	self bufferOrigin: self bufferOrigin + self bufferSize.\r	self fillBuffer.\r	self nextBufferPosition: 0.\r)",
 "arrangeForFinalization = (\r	(* Subclasses should reimplement this appropriately to do any finalization registration\r	  to ensure that the stream is closed when it is garbage collected. *)\r\r	self subclassResponsibility\r)",
 "public close = (\r	self doClose\r)",
 "doClose = (\r	(* This is factored out from close so that subclasses that mixin BasicInputStream can reimplement close to call this *)\r	self descriptor close.\r	buffer:: nil.\r)",
 "fillBuffer = (\r	(* fill the buffer if needed (this default implementation works for noninput streams) *)\r\r	self bufferNumElements: 0\r)",
 "initBuffer = (\r	buffer:: descriptor buffer.\r	bufferSize:: descriptor bufferSize.\r	self arrangeForFinalization.\r)",
 "initDescriptor: d <DESCRIPTOR> = (\r	self descriptor: d.\r	self initBuffer.\r\r	self bufferOrigin: 0.\r	self bufferNumElements: 0.\r	self nextBufferPosition: 0.\r)",
 "postCopy = (\r	super postCopy.\r	self descriptor: self descriptor copy.\r	self initBuffer.\r)",
 "onDescriptor: d <DESCRIPTOR> ^ <Instance> = (\r	^self new initDescriptor: d\r)",
 "public class SeqCltnReadStream = BasicReadStream (\r(* This is the standard concrete class used for creating ReadStreams on lists. *)\r| collection <List[E]> (* = sc. *) |)",
 "BasicReadStream",
 "BasicReadStream",
 "accumulateUntil: predicate <[Boolean]> ^ <List[E]> = (\r	| start <Integer> |\r\r	start:: self position.\r	[ predicate value ]\r		whileFalse: [ self position: self position + 1 ].\r	^self collection copyFrom: start + 1 to: self position\r)",
 "public actualNext ^<E> = (\r	| pos <Integer> |\r	pos:: self actualPosition.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ self error: 'Attempt to read past the end of a stream' ].\r	self actualPosition: pos.\r	^self collection at: pos\r)",
 "at: index <Integer> ^ <E> = (\r	^self collection at: index\r)",
 "public atEnd ^<Boolean> = (\r	(* %optimization: we can ensure that atEnd and actualAtEnd are identical, since we reimplement peek to avoid the superclass\r	  peek buffer, because we can look ahead quickly in a seqcltn *)\r	^self actualAtEnd\r)",
 "public initCollection: sc <List[E]> = (\r	collection:: sc.\r)",
 "public next ^<E> = (\r	(* %optimization: we can ensure that next and actualNext are identical, since we reimplement peek to avoid the superclass\r	  peek buffer, since we can look ahead quickly in a seqcltn *)\r	^self actualNext\r)",
 "nextFromPeek ^ <E> = (\r	(* If this happens, you should have overridden the calling method *)\r	self shouldNotHappen\r)",
 "public nextIfAbsent: f <[X def]> ^ <E | X> = (\r	| pos <Integer> |\r	pos:: self actualPosition.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ ^f value ].\r	self actualPosition: pos.\r	^self collection at: pos\r)",
 "public peek ^<E> = (\r	| pos <Integer> |\r	pos:: self position.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ self error: 'Attempt to read past the end of a stream' ].\r	^self collection at: pos\r)",
 "peekIfAbsent: f <[X def]> ^ <E | X> = (\r	| pos <Integer> |\r	pos:: self position.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ ^f value ].\r	^self collection at: pos\r)",
 "peekVal ^ <E> = (\r	self shouldNotHappen\r)",
 "public position: p <Integer> = (\r	self actualPosition: p.\r	(* Don't have to unset the peekVal *)\r)",
 "public printOn: strm <CharOutputStream> = (\r	strm nextPutAll: self class name;\r			nextPutAll: '(position='; 	print: self position;\r			nextPutAll: ' collection=';  print: self collection;\r			nextPut: \")\"\r)",
 "public size ^<Integer> = (\r	^self collection size\r)",
 "public on: sc <List[E]> ^<ReadStream[E]> = (\r	^self over: sc\r)",
 "over: sc <List[E]> ^ <Instance> = (\r	(* This is like on: except it returns type Instance.   on: for streams may return a non-instance type. *)\r\r	^self new initCollection: sc\r)",
 "public class SeqCltnReadWriteStream = BasicReadWriteStream (\r(* This is the standard concrete class used for creating WriteStreams or ReadWriteStreams on lists. *)\r| buffer <MutableList[E]> (* = sc *) |)",
 "BasicReadWriteStream",
 "BasicReadWriteStream",
 "accumulateUntil: predicate <[Boolean]> ^ <List[E]> = (\r	| start <Integer> |\r\r	start:: self position.\r	[ predicate value ]\r		whileFalse: [ self position: self position + 1 ].\r	^self buffer copyFrom: start + 1 to: self position\r)",
 "actualNext ^ <E> = (\r	| pos <Integer> |\r	pos:: self actualPosition.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ self error: 'Attempt to read past the end of a stream' ].\r	self actualPosition: pos.\r	^self buffer at: pos\r)",
 "at: index <Integer> ^ <E> = (\r	self assert: [ index <= self size ].\r	^self buffer at: index\r)",
 "public atEnd ^ <Boolean> = (\r	(* %optimization: we can ensure that atEnd and actualAtEnd are identical, since we reimplement peek to avoid the superclass\r	  peek buffer, because we can look ahead quickly in a seqcltn *)\r	^self actualAtEnd\r)",
 "collection ^ <MutableList[E]> = (\r	^self buffer copyFrom: 1 to: self size\r)",
 "public contents ^ <List[E]> = (\r	(* Obsolete: this method is included purely for BlueBook compatibility.  If possible, use\r	 #contentsRemaining and #contentsWritten, which will work when a ReadWriteStream\r	 is substituted for a ReadStream or a WriteStream, unlike this method *)\r\r	(* This originally referred to contentsWritten. The result of 'contents' should not depend on how much of a stream has already been read, see Blue Book - Protocol for Streams *)\r\r	^self collection\r)",
 "public initBuffer: sc <MutableList[E]> = (\r	buffer:: sc.\r)",
 "next ^ <E> = (\r	(* %optimization: we can ensure that next and actualNext are identical, since we reimplement peek to avoid the superclass\r	  peek buffer, since we can look ahead quickly in a seqcltn *)\r	^self actualNext\r)",
 "nextFromPeek ^ <E> = (\r	(* If this happens, you should have overridden the calling method *)\r	self shouldNotHappen\r)",
 "public nextIfAbsent: f <[X def]> ^ <E | X> = (\r	| pos <Integer> |\r	pos:: self actualPosition.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ ^f value ].\r	self actualPosition: pos.\r	^self buffer at: pos\r)",
 "nextPut: el <E> ^ <E> = (\r	| pos <Integer> |\r	super nextPut: el.\r	(pos:: self position) > self buffer size\r		ifTrue: [ self initBuffer: (self buffer copyWithSize: (self buffer size * 2 max: 8)) ].\r	self buffer at: pos put: el.\r	^el\r)",
 "peek ^ <E> = (\r	| pos <Integer> |\r	pos:: self position.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ self error: 'Attempt to read past the end of a stream' ].\r	^self buffer at: pos\r)",
 "peekIfAbsent: f <[X def]> ^ <E | X> = (\r	| pos <Integer> |\r	pos:: self position.\r	pos:: pos + 1.\r	pos > self size\r		ifTrue: [ ^f value ].\r	^self buffer at: pos\r)",
 "peekVal ^ <E> = (\r	self shouldNotHappen\r)",
 "position: p <Integer> = (\r	self actualPosition: p.\r	(* Don't have to unset the peekVal *)\r)",
 "public printOn: strm <CharOutputStream> = (\r	strm nextPutAll: self class name;\r			nextPutAll: '(position='; 	print: self position;\r			nextPutAll: ' buffer=';  print: self buffer;\r			nextPut: \")\"\r)",
 "on: sc <MutableList[E]> ^ <ReadWriteStream[E]> = (\r	^self over: sc\r)",
 "on: sc <MutableList[E]> numElements: n <Integer> ^ <ReadWriteStream[E]> = (\r	^(self over: sc) size: n\r)",
 "over: sc <MutableList[E]> ^ <Instance> = (\r	(* This is like on: except it returns type Instance.   on: for streams may return a non-instance type. *)\r\r	^self new initBuffer: sc\r)",
 "public class TempTranscript = CharacterOStream (\r(* This probably doesn't belong here.  *)\r)",
 "CharacterOStream",
 "CharacterOStream",
 "public cr = (\r	(* self nextPut: Character cr. *)\r	self nextPut: Character lf.\r)",
 "public nextPut: c <Character> ^ <Character> = (\r	c unicodeValue printCharacter.\r	c == Character cr\r		ifTrue: [ Character lf unicodeValue printCharacter. ].\r)",
 "public show: s <Collection[Character]> ^ <Collection[Object]> = (\r	self nextPutAll: s.\r	^s\r)",
 "class CombinatorialParsing usingPlatform: platform = (\r(* The Newspeak parser combinator library.\r\rCopyright 2008 Cadence Design Systems, Inc.\rCopyright 2012 Cadence Design Systems, Inc.\rCopyright 2013 Ryan Macnak\r\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)\r|\r\rprivate List = platform collections List.\rprivate Map = platform collections Map.\rprivate ObjectMirror = platform mirrors ObjectMirror.\r|)",
 " ",
 " ",
 "class AlternatingParser either: p_ or: q_ = CombinatorialParser (\r(* A parser that parses either P or Q. *)\r|\rp <CombinatorialParser> = p_.\rq <CombinatorialParser> = q_.\r|)",
 "CombinatorialParser",
 "CombinatorialParser",
 "combineErrors: e1 <String> and: e2 <String> at: pos <Integer> with: blk <[:String :Integer]> = (\r	| or <String> msg <String> |\r	or:: (e1 = '' or: [e2 = '']) ifTrue: [''] ifFalse: [' or '].\r	msg:: e1 = e2 ifTrue: [e1] ifFalse: [e1, or , e2].\r	^blk value: msg value: pos\r)",
 "public parse: input <ReadStream> inContext: context <ParserContext> ifError: blk <[:String :Integer]> = (\r	| rewindPosition |\r	rewindPosition:: input position.\r  	^p parse: input inContext: context ifError:\r		[:msg1 :pos1 |\r		input position: rewindPosition.\r		context recordFailure: {msg1. pos1}.\r		^q parse: input inContext: context ifError:\r			[:msg2 :pos2 |\r			context recordFailure: {msg2. pos2}.\r			pos1 > pos2 ifTrue: [^blk value: msg1 value: pos1].\r			pos2 > pos1 ifTrue: [^blk value: msg2 value: pos2].\r			^combineErrors: msg1 and: msg2 at: pos1 with: blk]]\r)",
 "class CharacterRangeParser from: startChar <Character> to: endChar <Character> = CombinatorialParser (|\rstartRune <Integer> = startChar runeAt: 1.\rendRune <Integer> = endChar runeAt: 1.\rmessage <String> = startChar asString, '-', endChar asString, ' expected'.\r|)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	| rune |\r	input atEnd ifTrue: [^blk value: message value: input position].\r	rune:: input next.\r	rune < startRune ifTrue: [^blk value: message value: input position].\r	rune > endRune ifTrue: [^blk value: message value: input position].\r	^rune\r)",
 "public class CollectingCommentParser = CommentParser (\r(* A special parser used for inputs that need to be rapidly scanned over. It differs from its superclass in that it actually collects the characters it scans, in case they are needed (e.g., for pretty printers).\r\rIdeally,we should not have to do this, but until we do proper optimization by compiling combinators, this will have to suffice. It provides a marked improvement in performance, By using such parsers for comments, whitespace and strings, the overall performance of the Newqueak parser improved by a factor of 2 or so. *)\r)",
 "CommentParser",
 "CommentParser",
 "public parse: input inContext: context ifError: blk = (\r	| comment char onFail |\r	onFail:: [blk value: 'Premature end of input' value: input position - 1].\r	comment: List new.\r	[termBlock value: input] whileFalse:\r		[input atEnd ifTrue: [^onFail].\r		comment add: input next].\r	^comment\r)",
 "public class CombinatorialParser = (\r(* This class is intended to implement Parser\rCombinators. A CombinatorialParser[T]\rreturns a value of type T after successful\rparsing.\r\rThe class is abstract. It does not implement\r the parsing routine parse:ifError:.\r\rIf parsing fails, parse:ifError: should call the error handling block\rpassed to it.\r\rConcrete subclasses should implement specific grammars.\r\rParsing is initiated by calling parse:ifError:. This routine takes a ReadStream[Object] as input.\rIf parsing fails, it is the caller''s responsibility to set the input stream back to its original position\r(Q: is this a good idea?).\rIf an error occurs, the error block passed in is called. *)\r| public name |)",
 " ",
 " ",
 "public & p <CombinatorialParser> ^<SequentialParser> = (\r	(* The sequencing combinator (implicit in BNF). *)\r	^SequentialParser withSubparsers: {self. p}\r)",
 "public , p <CombinatorialParser> ^<SequentialParser> = (\r	(* The flattening sequencing combinator. *)\r\r(* This is what one should typically use in a grammar.\r It differs from '&' in its specification.  '&' is not intended to\rflatten the resulting parser tree, while ',' is; this achieved by overriding ',' in SequentialParser to do the flattening.\r\rWhy would one want to flatten the tree? Because, given a production\r\rFoo -> Bam Ban Bar Bat\r\rone doesn't want to build the AST by writing\r\rFoo:: Bam & Ban & Bar & Bat\r   wrapper: [:start :end |\r	            FooNode b1:start first b2: (start at: 2)  b3: (start at: 3) b4: end\r	]\r\rIt is much more convenient to flatten the tree and have a flat list of the correct arity.\r*)\r	^self & p\r)",
 "char: c <Character> ^<CombinatorialParser> = (\r	^CharacterRangeParser from: c to: c\r)",
 "charBetween: c1 <Character> and: c2 <Character> ^<CombinatorialParser> = (\r	^CharacterRangeParser from: c1 to: c2\r)",
 "empty ^<CombinatorialParser> = (\r	^EmptyParser new\r)",
 "eoi ^<CombinatorialParser> = (\r	^tokenFor: EOIParser new\r)",
 "fail ^<CombinatorialParser> = (\r	^FailingParser new\r)",
 "public isKindOfCombinatorialParser = (\r	(* should be auto-generated *)\r	^true\r)",
 "public not ^<CombinatorialParser> = (\r	^NegatingParser withSubparser: self\r)",
 "public opt ^ <CombinatorialParser> = (\r	(* [P] = P | e *)\r	^self | empty\r)",
 "public packratParse: input <ReadStream> ^ <T | ParserError> = (\r ^self parse: (PackratParserStream memoizing: input) \r)",
 "public parse: input <ReadStream> ^ <T | ParserError> = (\r	^self\r		parse: input\r		ifErrorNoContext: [:msg :pos | ^(ParserError message: msg position: pos) signal]\r)",
 "public parse: input <ReadStream> ifError: blk <[:String :Integer | X def]> ^ <T|X> = (\r	#FLAG.\r	^self parse: input ifErrorNoContext: blk\r(* | context |\r\r  context:: ParserContext new.\r	^parse: input\r	inContext: context\r	ifError: [:msg :pos |\r	               context errorPosition = pos\r	                  ifTrue: [\r		                      context recordFailure: ( combineErrors: context errorMessage\r		                                                                 and: msg\r		                                                                 at: pos\r		                                                          )\r		            ]\r	                  ifFalse: [context recordFailure:{msg. pos.}].\r	               blk value: context errorMessage value: context errorPosition.\r	  ] *)\r)",
 "public parse: input <ReadStream> ifErrorNoContext: blk <[:String :Integer | X def]> ^ <T|X> = (\r	(* YK - a context-less protocol for speeding up parsing *)\r	(* Turns out maintaining a context is expensive in runtime and doesn't\r	do much for locating errors. Experimenting with other error localization\r	mechanism. To minimize impact, the parse:inContext:ifError: protocol\r	is maintained, and a bogus reportFailure is implemented on self *)\r	^self parse: input inContext: self ifError: blk\r)",
 "public parse: input <ReadStream> inContext: context ifError: blk = (\r	subclassResponsibility\r)",
 "public parseString: input <String> ^ <T | ParserError> = (\r	^self parse: (ParserStream over: input)\r)",
 "public parseString: input <String> ifError: blk <[:String :Integer | X def]> ^ <T|X> = (\r	^self parse: (ParserStream over: input) ifError: blk\r)",
 "public plus ^<CombinatorialParser> = (\r	(* Return a parser that accepts one or more repetitions of what the receiver accepts. Denoted by the postfix + in BNF *)\r	^PlusParser withSubparser: self.\r)",
 "public plusSeparatedBy: separator <CombinatorialParser> ^<CombinatorialParser> = (\r(* Utility for the common case of a list with separators. The separators are discarded, as they are usually only used to guide parsing and\rhave no semantic value.  If one needs them, one can always build the rule directly *)\r\r^self & (separator value & self wrapper: [:s :v | v]) star\r	wrapper: [:fst :rst |\r	                 | results |\r	                    List new  addFirst: fst; addAll: rst; yourself (* could be optimized to reuse rst *)\r	       ]\r)",
 "public plusSeparatedOrTerminatedBy: separator <CombinatorialParser> ^ <CombinatorialParser> = (\r(* Utility for the common case of a list with separators, allowing for an optional appearance of the separator at the end. The separators are discarded, as they are usually only used to guide parsing and\rhave no semantic value.  If one needs them, one can always build the rule directly *)\r\r^( plusSeparatedBy: separator), separator value opt\r	wrapper: [:lst :end | lst]\r)",
 "public printOn: stream = (\r	name isNil\r		ifTrue: [super printOn: stream]\r		ifFalse: [stream nextPutAll: name]\r)",
 "public recordFailure: f = (\r	(* YK- do nothing, save time *)\r)",
 "public star ^<CombinatorialParser> = (\r	(* Return a parser that accepts zero or more repetitions of what the receiver accepts. Denoted by the postfix * in BNF *)\r	(* P* = [P+] *)\r	(* We tweak the classic formulation by wrapping it in a parser that takes care to avoid returning nil. In the ordinary case, if the input is empty, the empty parser will return nil as the result. However, we'd rather not  have to check for nil every time we get a result from a starred production; it is verbose and error prone. In the case of star, it is better to return an empty list for empty input. *)\r	^StarParser withSubparser: self.\r)",
 "public starSeparatedBy: separator <CombinatorialParser> ^<CombinatorialParser> = (\r	(* See analogous plus methods. Must wrap to prevent returning nil in empty case *)\r	^(plusSeparatedBy: separator) opt\r		wrap: [:rs | rs isNil ifTrue: [List new] ifFalse: [rs]]\r)",
 "public starSeparatedOrTerminatedBy: separator <CombinatorialParser> ^<CombinatorialParser> = (\r 	(* See analogous plus methods. Must wrap to prevent returning nil in empty case *)\r	^(plusSeparatedOrTerminatedBy: separator) opt\r		wrap: [:rs | rs isNil ifTrue: [List new] ifFalse: [rs]]\r)",
 "public ultimateParser = (\r	(* Used to bypass 0 .. n ForwardReferenceParsers to get to the real parser. Usually, this is self. Only ForwardReferenceParsers forward the request to their forwardee. *)\r	^self\r)",
 "public value = (\r	^self\r)",
 "public wrap: blk = (\r	^WrappingParser new wrapParser: self withWrapper: blk\r)",
 "public wrap: blk name: msg = (\r	^(NamedWrappingParser new wrapParser: self withWrapper: blk) name: msg\r)",
 "public wrapper: blk = (\r	^wrap: [:result | blk valueWithArguments: result asArray]\r)",
 "public wrapper: blk name: msg = (\r	^wrap: [:result | blk valueWithArguments: result asArray]\r	name: msg\r)",
 "public | p <CombinatorialParser> ^<CombinatorialParser> = (\r	(* The alternation combinator - denoted by | in BNF *)\r	^AlternatingParser either: self or: p\r)",
 "public class CommentParser = CombinatorialParser (|\r	public termBlock\r|)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	[termBlock value: input] whileFalse: [\r		input nextIfAbsent: [blk value: 'Premature end of input' value: input position-1]\r	].\r)",
 "class EOIParser = CombinatorialParser (\r(* A parser that only succeeds at the end of the input. This addresses a common problem with combinator parsers. If there is garbage at the end of the input, no production matches it. Consequently, the parsers backtrack to the point where the legal input was consumed, without giving an error message about the junk at the end. *)\r)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	input atEnd\r		ifTrue: [^true]\r		ifFalse: [blk value: 'Unexpected input' value: input position+1]\r)",
 "class EmptyParser = CombinatorialParser (\r(* The parser that parses the empty input. It always succeeds. *)\r)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	^nil\r)",
 "public class ExecutableGrammar = CombinatorialParser (\r(* This class is intended to implement Parser\rCombinators. A ExecutableGrammar[T]\rreturns a value of type T after successful\rparsing.\r\rThe class is abstract. It does not implement\r the parsing routine parse:ifError:.\r\rIf parsing fails, parse:ifError: should call the error handling block\rpassed to it.\r\rConcrete subclasses should implement specific grammars.\r\rParsing is initiated by calling parse:ifError:. This routine takes a ReadStream[Object] as input.\rIf parsing fails, it is the caller''s responsibility to set the input stream back to its original position\r(Q: is this a good idea?).\rIf an error occurs, the error block passed in is called. *)\r|\r	forwardReferenceTable ::= Map new.\r	protected selfMirror <ObjectMirror> = ObjectMirror reflecting: self.\r|self setupForwardReferences.\r  self bindForwardReferences)",
 "CombinatorialParser",
 "CombinatorialParser",
 "bindForwardReferences = (\r	forwardReferenceTable keysAndValuesDo:\r		[:k :v | v bindingRoutine: [finalBindForwardReferences]].\r)",
 "comment ^<CombinatorialParser> = (\r	^fail\r)",
 "finalBindForwardReferences = (\r	forwardReferenceTable keysAndValuesDo:\r		[:k :v | | p |\r		p:: (selfMirror getSlot: k asSymbol) reflectee.\r		(p isKindOfCombinatorialParser) ifTrue: [\r			v bind: p.\r			p name: k (* a good place to name the productions *)]]\r)",
 "public nameProductions = (\r	selfMirror getClass slots do:\r		[:slot <SlotMirror> |\r		| parser |\r		parser:: (selfMirror getSlot: slot simpleName) reflectee.\r		parser isKindOfCombinatorialParser ifTrue: [parser name: slot name]].\r)",
 "setupForwardReferences = (\r	(* Go through all non-nil instance variables and set them to a fresh forward reference. If these do not correspond to productions, they will be overridden by the subclass. *)\r	selfMirror getClass slots do:\r		[:slot <SlotMirror> |\r		| fref iv |\r		iv:: slot name.\r		fref:: ForwardReferenceParser new.\r		(selfMirror getSlot: iv) reflectee isNil ifTrue:\r			[forwardReferenceTable at: iv put: fref.\r			selfMirror setSlot: iv to: fref]]\r)",
 "tokenFor: p <CombinatorialParser> ^ <CombinatorialParser> = (\r(* Tokenizing involves throwing away leading whitespace and comments.\rIn addition, it involves associating the token with a starting position within the input stream;\rWe do the latter first by wrapping p in a TokenizingParser; then we prefix it with a parser\rthat deals with whitespace and comments, and return the result. *)\r\r^(whitespace | comment) star, (TokenizingParser withSubparser: p)\r	wrapper: [:discardWhitespace :t | t].\r\r	(* type safety note: wrapper is only defined on SequentialParser. The call is always\r	 statically unsafe but checked dynamically   (see its definition). One could use\r	 guaranteed to cast to a SequentialParser, but that would not be enough to silence\r	 the typechecker anyway *)\r(* Design note: It seems tempting to define a combinator, 'token', that returns a tokenized version of its receiver.  Alas, this doesn't work out, since tokenization relies on concepts of whitespace and comment, which are often specific to a given grammar. Hence, the combinator needs to be aan operation of the grammar, not of a specific production. *)\r)",
 "tokenFromChar: c <Character> ^<CombinatorialParser> = (\r 	^tokenFor: (char: c)\r)",
 "tokenFromSymbol: string <Symbol> ^<CombinatorialParser> = (\r	^tokenFor: (StringParser for: string)\r)",
 "public whitespace ^<CombinatorialParser> = (\r(* It's rare that anyone will need to change this definition *)\r (* ^ aWhitespaceChar plus. *)\r(* As an optimization, we process whitespace with a dedicated scanning parser. Of course, this regrettable, and Perhaps Squeak specific, but it is a significant win. *)\r	^WhitespaceParser new\r)",
 "class FailingParser = CombinatorialParser (\r(* The parser that always fails. It never parses anything. *)\r)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	^blk value: 'Failing Parser invoked' value: input position\r)",
 "class ForwardReferenceParser = CombinatorialParser (|\r	forwardee\r	public bindingRoutine\r|)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public & p <CombinatorialParser> ^ <CombinatorialParser> = (\r	^forwardee isNil\r		ifTrue: [super & p]\r		ifFalse: [forwardee & p]\r)",
 "public bind: p <CombinatorialParser> = (\r	(* as a precaution, only bind if p is a parser *)\r	(p isKindOfCombinatorialParser) ifTrue: [forwardee: p]\r)",
 "public opt = (\r	^forwardee isNil\r		ifTrue: [super opt]\r		ifFalse: [forwardee opt]\r)",
 "public parse: input inContext: context  ifError: blk = (\r	^parserToForwardTo parse: input inContext: context  ifError: blk.\r)",
 "public parserToForwardTo ^<CombinatorialParser> = (\r	forwardee isNil ifTrue: [bindingRoutine value].\r	^forwardee\r)",
 "public ultimateParser ^<CombinatorialParser> = (\r	^parserToForwardTo ultimateParser\r)",
 "public wrapper: blk ^<CombinatorialParser> = (\r	(* see comments in ForwardingWrappingParser *)\r	^ForwardingWrappingParser new wrapParser: self withWrapper: blk\r)",
 "public | p = (\r	^forwardee isNil\r		ifTrue: [super | p]\r		ifFalse: [forwardee | p]\r)",
 "class ForwardingWrappingParser = WrappingParser (\r(* When a ForwardingReferenceParser is wrapped using the wrapper: combinator, we don't know what the  arity the wrapping block should have - it will depend on the arity of the parser we forward to.  We cannot determine whether to use the implementation of wrapper: given in ordinary parsers, which forwards to the wrap: combinator (designed for block with arity 1) or the implementation used in SequentialParsers, (designed for n-ary blocks, where n is the length of the list of parsers the SequentialParser sequences). Instead, we must defer the decision on how to handle the situation until the parser tree is complete. This is accomplished by using this class as the result of the wrapper: combinator for ForwardReferenceParser.\r\rInstances of this class determiine how to act when asked to parse. At that time, the parse tree must be complete, and they can ask the ultimate parser for a wrappin parser that is suitable configured, and forward requests to it. *)\r|\r	wrappingParser\r|)",
 "WrappingParser",
 "WrappingParser",
 "public parse: input inContext: context ifError: blk = (\r	^trueWrappingParser parse: input inContext: context ifError: blk\r)",
 "trueWrappingParser ^<WrappingParser> = (\r	wrappingParser isNil ifTrue:\r		[wrappingParser:: parser ultimateParser wrapper: wrapperBlock].\r	^wrappingParser\r)",
 "class NamedWrappingParser = WrappingParser (\r(* This is exactly the same as a WrappingParser, but it passes itself down\rin the context parameter, to provide more meaningful error messages. *)\r)",
 "WrappingParser",
 "WrappingParser",
 "public parse: input inContext: context ifError: blk = (\r	^wrapperBlock value: (parser parse: input inContext: self ifError: blk )\r)",
 "class NegatingParser withSubparser: p = CombinatorialParser (\r(* A parser that implements the 'not' combinator, as in Ford's PEGs. It contains a parser p, and succeeds if p fails and vice versa. It does not move the input forward if it succeeds. *)\r| subparser <CombinatorialParser> = p. |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: ctxt ifError: blk = (\r	| rewindPosition |\r	rewindPosition:: input position.\r	subparser parse: input inContext: ctxt ifError: [:msg :pos | input position: rewindPosition. ^true].\r	blk value: 'not combinator failed' value: rewindPosition.\r)",
 "class PackratParserStream memoizing: s <ReadStream> = (\r(*\r\rA stream wrapper designed to support memoization for packrat parsers.\rSince the cache for a packrat parser is indexed by input position (as well as production), it is specific not only to a given grammar,\rbut a given input.  One approach is to create the cache when the grammar is first invoked. This speeds up a given parse, but will\rredo work if applied multiple times to the same contents (as often happens in an IDE like Newspeak's). \r\rIt is, however, tricky to do better given that the contents of a given source unit (expression, method, class, file) change frequently.\rAlex Warth's incremental packrat parsing work partially addresses this  - but in practice, we would need to track diffs, and suffer a large ongoing memory penalty to use that here.  Therefore, we focus on conventional packrat-style caching here.\r\rArguably, it's ugly to attach the cache to the stream, as it has nothing to do with the stream per se. The alternative is to have a parsing context that bundles the stream and the cache and pass that around instead of the stream. Or maybe it's just a matter of naming this class propewrly.\r\r\r*)\r|\rpublic contents <ReadStream> = s.\rpublic position <Integer> ::= 0.\rcache <Map[{Integer. Symbol}, T ]> = Map new. (* where T is the return type of the parser *)\r|)",
 " ",
 " ",
 "public atEnd ^ <Boolean> = (\r	^contents atEnd\r)",
 "public next = (\r	^contents next\r)",
 "public peek = (\r	^contents peek\r)",
 "public resultAt: key <{Integer. Symbol}> ifAbsent: blk <[T]> ^ <T> = (\r  ^cache at: key ifAbsentPut: blk\r)",
 "class ParserContext = (\r(* This class defines a context that is shared among a set of combinatorial parsers during a parse. The context can be used to manage information on parsing errors: rather than always report the latest failure that occurred, we can report the one that occurred deepest in the input stream, or implement some other policy - as long as we can record what failures took place.\r\rIn addition, this class could be used to support context-sensitive parsing.\r*)\r| failures ::= List new. |)",
 " ",
 " ",
 "errorMessage = (\rfailures isEmpty ifTrue: [^''].\r^failures last first\r)",
 "errorPosition = (\rfailures isEmpty ifTrue: [^-1].\r^failures last last\r)",
 "recordFailure: f = (\r(failures isEmpty or: [ failures last last <= f last ])\r		ifTrue: [ failures addLast: f]\r)",
 "public class ParserError message: m position: p = Error (|\r	public message <String> = m.\r	public position <Integer> = p.\r|)",
 "Error",
 "Error",
 "public description = (\r	^'ParserError: ', message\r)",
 "public printString = (\r	^'ParserError: ', message, ' (', position printString, ')'\r)",
 "class ParserStream over: string = (\r(* A wrapper for strings, presenting the minimal stream interface required by combinatorial parsers. \r*)\r|\rpublic contents = string.\rpublic position ::= 0.\r|)",
 " ",
 " ",
 "public atEnd = (\r	^position >= contents size\r)",
 "public next = (\r	position >= contents size ifTrue: [^nil].\r	position:: 1 + position.\r	^contents runeAt: position\r)",
 "public peek = (\r	position >= contents size ifTrue: [^nil].\r	^contents runeAt: 1 + position\r)",
 "class PlusParser withSubparser: p = CombinatorialParser (\r(* An attempt to optimize the + operator by having a dedicated parser for it. *)\r| subparser = p. |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	| rewindPosition results nextResult |\r	results:: List new.\r	results add: (subparser parse: input inContext: context ifError: blk).\r	[\r		rewindPosition: input position.\r		nextResult:: subparser\r			parse: input\r			inContext: context\r			ifError: [:msg :pos |\r				input position: rewindPosition.\r				^results].\r		results add: nextResult.\r	] repeat.\r)",
 "class SequentialParser withSubparsers: s = CombinatorialParser (\r(* A parser that activates a sequence of subparsers (P1, ,Pn).\r\rOne might think that it would be sufficient to define a class that\rcombined two parsers in sequence, corresponding to the &\roperator, just like AlternatingParser corresponds to the | operator.\rHowever, grammar productions typically involve several elements, so\rthe typical sequencing operation is n-ary *)\r| subparsers <Array[CombinatorialParser]> = s. |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public , p <CombinatorialParser> ^<SequentialParser> = (\r	^SequentialParser withSubparsers: (subparsers copyWith: p)\r)",
 "public parse: input inContext: context ifError: blk = (\r	^subparsers\r		collect: [:p | p parse: input inContext: context ifError: blk]\r)",
 "public wrapper: block = (\r	(* Untypesafe, but convenient. We can dynamically ensure that the arity of the incoming block matches that of this parser. Given that this routine is only called during parser construction, dynamic failure of the asserts is sufficient. We cannot ensure type correctness of the arguments to the block using this interface. One can use the more verbose followedBy: combinators if that is deemed essential. *)\r	assert: [block numArgs = subparsers size]\r		message: 'Block arity does not match production arity'.\r	^self wrap: [:results | block valueWithArguments: results asArray]\r)",
 "class StarParser withSubparser: p = CombinatorialParser (\r(* An attempt to optimize the * operator by having a dedicated parser for it. *)\r| subparser = p. |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	| rewindPosition results nextResult |\r	results:: List new.\r	[\r		rewindPosition: input position.\r		nextResult:: subparser\r			parse: input\r			inContext: context\r			ifError: [:msg :pos |\r				input position: rewindPosition.\r				^results].\r		results add: nextResult.\r	] repeat.\r)",
 "class StringParser for: s <String> = CombinatorialParser (\r	(* Parses a given symbol.  One could derive this as an alternation of character parsers, but the derivation is more verbose than defining it directly, and less efficient, so why bother? *)\r| string = s. |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	| pos |\r	pos:: input position.\r	1 to: string size do: [:index |\r		input atEnd ifTrue:\r			[^blk value: (string, ' expected') value: pos].\r		(string runeAt: index) = input next ifFalse:\r			[^blk value: (string, ' expected') value: pos]].\r	^string\r)",
 "public class Token value: v start: s end: e = (\r(* Represents a token of input. Basically, it attaches a start position\rto the token's value. Indeally, we'd use a tuple for this, which is why this class\rimplements the tuple protocol. We could use an array, but that would not be\rtypesafe. Until we have tuples, we'll use this class.\r\rIt's not yet clear if we should bother adding token codes or values here. *)\r|\r	public value = v.\r	public start = s.\r	public end = e.\r|)",
 " ",
 " ",
 "public class TokenizingParser withSubparser: p = CombinatorialParser (| subparser = p. |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	| pos res |\r	pos:: input position + 1.\r	res:: subparser parse: input inContext: context ifError: blk.\r	^Token value: res start: pos end: input position\r)",
 "class WhitespaceParser = CombinatorialParser (\r(* A simple scanner to optimize the handling of whitespace. Should be equivalent to'\r aWhitespaceChar plus\rEventually, the framework should optimize well enough that this will be unnecessary. *)\r)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	| rewindPosition |\r	rewindPosition:: input position.\r	[input atEnd ifTrue: [false] ifFalse: [input peek <= 32]] whileTrue: [input next].\r	input position = rewindPosition ifTrue:\r		[input position: rewindPosition.\r		blk value: 'Whitespace expected' value: rewindPosition].\r	^Token value: #whitespace start: rewindPosition + 1 end: input position\r)",
 "class WrappingParser = CombinatorialParser (\r(* Used to transform the output of another parser. A wrapping parser accepts exactly the same input as the wrapped\rparser does, and performs the same error handling. The only differenceis that it takes the output of the wrapped\rparser and passes it on to a wrapper block which uses it to produce a new result, which is the output of the wrapping\rparser. A typical use is to build nodes of an abstract syntax tree.\r\rThe output type of the wrapped parser, S, is also the input to the wrapper. The output type of the wrapper is the output of this\r(the wrapping) parser. *)\r| parser wrapperBlock |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	^wrapperBlock value: (parser parse: input inContext: context ifError: blk )\r)",
 "public wrapParser: p withWrapper: blk = (\r	parser:: p.\r	wrapperBlock:: blk\r)",
 "class NewspeakGrammar usingPlatform: p parsers: parsers = (\r(* The Newspeak grammar, both with and without type declarations.\r\rCopyright 2008 Cadence Design Systems, Inc.\rCopyright 2010 Felix Geller and Ryan Macnak\rCopyright 2012 Ryan Macnak\r\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)\r|\r\rprivate List = p collections List.\r\rprivate ExecutableGrammar = parsers ExecutableGrammar.\rprivate CollectingCommentParser = parsers CollectingCommentParser.\rprivate CombinatorialParser = parsers CombinatorialParser.\rprivate Token = parsers Token.\rpublic ParserError = parsers ParserError.\r|)",
 " ",
 " ",
 "class NS3Grammar = ExecutableGrammar (\r(* Grammar for Newspeak3 (without types). *)\r|\r	whitespace = super whitespace. (* cache whitespace parser *)\r	colon = tokenFromChar: \":\".\r	comma = tokenFromChar: \",\".\r	dollar = tokenFromChar: \"$\".\r	dot = tokenFromChar: \".\".\r	equalSign = tokenFromChar: \"=\".\r	hat = tokenFromChar: \"^\".\r	lbracket = tokenFromChar: \"[\".\r	lcurly = tokenFromChar: \"{\".\r	lparen = tokenFromChar: \"(\".\r	langleBracket = tokenFromChar: \"<\".\r	pound = tokenFromChar: \"#\".\r	rangleBracket = tokenFromChar: \">\".\r	rbracket = tokenFromChar: \"]\".\r	rcurly = tokenFromChar: \"}\".\r	rparen = tokenFromChar: \")\".\r	semicolon = tokenFromChar: \";\".\r	slash = tokenFromChar: \"/\".\r	vbar = tokenFromChar: \"|\".\r	mixinOperator = tokenFromSymbol: ':>'.\r	inverseMixinOperator = tokenFromSymbol: '<:'.\r	eventualSendOperator = tokenFromSymbol: '<-:'.\r	digit = charBetween: \"0\" and: \"9\".\r	digits = digit plus.\r	uppercaseLetter = charBetween: \"A\" and: \"Z\".\r	extendedDigits = (digit | uppercaseLetter) plus.\r	radix = digits, (char: \"r\").\r	fraction = (char: \".\"), digits.\r	extendedFraction = (char: \".\"), extendedDigits.\r	exponent = (char: \"e\"), (char: \"-\" ) opt, digits.\r	decimalNum = (char: \"-\") opt, digits, fraction opt, exponent opt.\r	radixNum = radix, (char: \"-\") opt, extendedDigits, extendedFraction opt, exponent opt.\r	num = radixNum | decimalNum.\r	(* must distinguish internal use of productions from use as tokens *)\r	number = tokenFor: num.\r	letter = uppercaseLetter | (charBetween: \"a\" and: \"z\").\r	specialCharacter = (char: \"+\") | (char: \"/\") | (char: \"\\\") | (char: \"*\")\r		| (char: \"~\") | (char: \"<\") | (char: \">\") | (char: \"=\")\r		| (char: \"@\") | (char: \"%\") | (char: \"|\") | (char: \"&\")\r		| (char: \"?\" ) | (char: \"!\") | (char: \",\").\r\r	character = digit | letter | specialCharacter\r		| (char: \"[\"  ) | (char: \"]\"  ) | (char: \"{\" ) | (char: \"}\" )\r		| (char: \"(\"  ) | (char: \")\" ) | (char: \"^\" ) | (char: \";\" )\r		| (char: \"$\" ) | (char: \"#\"  ) | (char: \":\" ) | (char: \".\" )\r		| (char: \"-\") | (char: \"_\") | (char: \"`\") (* the Smalltalk grammar neglects to add - to characters, or to comments. It does add | [self char: $' ], but these are both bugs. We also support underscores, which Squeak insists on turning into assignment arrows. However, we do not support these as assignments. *).\r\r	id = (letter | _), ((letter | digit | _)) star wrapper:\r		[:first :second | String fromRunes: {first}, second asArray].\r\r	public identifier = tokenFor: id.\r\r	charIncludingQuotesAndSpace = character | (char: \"'\" ) | (char: \"\"\" ) | (char: \" \").\r	characterConstant = tokenFor: (char: \"\"\"), charIncludingQuotesAndSpace, (char: \"\"\").\r\r	str = (char: \"'\"), stringBody, (char: \"'\") wrapper:\r		[:oq :es :eq | String fromRunes: es].\r\r	string = tokenFor: str.\r\r	kw = id, (char: \":\") wrapper:\r		[:i :c | i, ':'].\r\r	kwds = kw plus\r		wrap: [:c | c inject: '' into: [:s :e | s, e]].\r\r	public keyword = tokenFor: kw.\r\r	setterKw = kw, (char: \":\")\r		wrapper: [:i :c | i, ':'].\r\r	setterKeyword = tokenFor: setterKw.\r\r	sym = str | kwds | binSel | id.\r	symbol = tokenFor: sym.\r\r	comment = NSCommentParser new.\r\r	binSel = (specialCharacter | (char: \"-\")), specialCharacter star\r		wrapper: [:c1 :c2 |\r		(* probably delay interning as symbol until later phase *)\r		(String fromRunes: {c1}, c2) asSymbol].\r\r	binarySelector = tokenFor: binSel. (* maybe intern as symbol here *)\r\r\r	(* syntactic productions *)\r	symbolConstant = pound, symbol.\r	tuple = lcurly, (expression starSeparatedOrTerminatedBy: dot), rcurly.\r\r	(* patterns *)\r\r	(* adding literals for patterns *)\r	literal = pattern | number | symbolConstant | characterConstant | string | tuple.\r\r	pattern = (tokenFromChar: \"<\"), patternLiteral, (tokenFromChar: \">\").\r	patternLiteral = wildcardPattern | literalPattern | keywordPattern.\r\r	wildcardPattern = tokenFromChar: \"_\".\r\r	(* values which are comparable by means of #= *)\r	literalPattern = tokenFor: number | symbolConstant | characterConstant | string | tuple.\r\r	(* keyword patterns *)\r	keywordPattern = kwPatternPair plus.\r	kwPatternPair = keyword, kwPatternValue opt.\r	kwPatternValue = wildcardPattern | literalPattern | variablePattern | nestedPatternLiteral.\r	variablePattern = tokenFor: ((char: \"?\"), id).\r	nestedPatternLiteral = tokenFor: pattern.\r\r	slotName = identifier.\r	unarySelector = UnarySelectorParser new on: self. (* the one hack/flaw. See UnarySelectorParser for details *)\r\r	parenthesizedExpression = lparen, expression, rparen.\r\r	primary = slotName | literal | block | parenthesizedExpression.\r\r	unaryMsg = eventualSendOperator opt, unarySelector.\r	unaryExpression = primary, unaryMsg star.\r\r	binaryMsg = eventualSendOperator opt, binarySelector, unaryExpression.\r	binaryExpression = unaryExpression, binaryMsg star.\r\r	keywordMsg = eventualSendOperator opt, (keyword, binaryExpression) plus.\r\r	message = keywordMsg | binaryMsg | unaryMsg.\r\r	nontrivialUnaryMessages = unaryMsg plus, binaryMsg star, keywordMsg opt.\r	nontrivialBinaryMessages = binaryMsg plus, keywordMsg opt.\r	keywordMessages = keywordMsg.\r	nonEmptyMessages = nontrivialUnaryMessages | nontrivialBinaryMessages | keywordMessages.\r\r	keywordExpression = binaryExpression, keywordMsg opt.\r\r	keywordHereSend = keywordMsg.\r	cascadeMsg = semicolon, (keywordMsg | binaryMsg | unaryMsg).\r\r	msgCascade = nonEmptyMessages, cascadeMsg star.\r\r	cascadedMessageExpression = primary, msgCascade opt.\r\r	sendExpression = keywordHereSend | cascadedMessageExpression.\r\r	expression = setterKeyword star, sendExpression.\r\r	returnStatement = hat, expression, dot opt.\r\r	furtherStatements = dot, statements.\r	statementSequence = expression, furtherStatements  opt.\r 	statements = returnStatement | statementSequence | empty.\r\r	blockParameter = colon, slotDecl.\r	blockParameters = blockParameter plus, vbar.\r\r	slotDefs = slotDef star.\r	seqSlotDecls = vbar, slotDefs, vbar.\r	simSlotDecls = vbar, vbar, slotDefs, vbar, vbar.\r	slotDecls = simSlotDecls | seqSlotDecls.\r\r	temporaries = slotDecls.\r\r	beginNSComment = (char: \"(\"), (char: \"*\").\r	endNSComment = (char: \"*\"), (char: \")\").\r	keywordAndLiteral = keyword, literal.\r	literalMessage = unaryMsg | keywordAndLiteral plus.\r	literalMessageComment = beginNSComment, (tokenFromSymbol: #':literalmessage:'), whitespace opt, literalMessage, whitespace opt, endNSComment.\r\r	codeBody = (literalMessageComment | comment | whitespace) star, temporaries opt, statements.\r\r	block = lbracket, blockParameters opt, codeBody, rbracket.\r\r	slotDecl = identifier.\r\r	accessModifier =\r		((tokenFromSymbol: #private) |\r		 (tokenFromSymbol: #public) |\r		 (tokenFromSymbol: #protected)), whitespace.\r\r	slotDef = accessModifier opt, slotDecl,\r		(((tokenFromSymbol: #=) | (tokenFromSymbol: #'::=')), expression, dot) opt.\r\r	initExprs = expression starSeparatedOrTerminatedBy: dot.\r\r	unaryMsgPattern = unarySelector.\r	binaryMsgPattern = binarySelector, slotDecl.\r	keywordMsgPattern = (keyword, slotDecl) plus.\r	messagePattern = unaryMsgPattern | binaryMsgPattern | keywordMsgPattern.\r\r	(* Top level productions for classes *)\r	transientModifier = (tokenFromSymbol: #transient), whitespace.\r\r	public transientSlotDecl = accessModifier opt, transientModifier, slotDecl,\r	          ((tokenFromSymbol: #=) |\r	            (tokenFromSymbol: #'::=')\r	           ), expression, dot.\r\r\r      public methodHeader = accessModifier opt, messagePattern.\r	public methodDecl = accessModifier opt, messagePattern, equalSign, lparen, codeBody, rparen.\r\r	optionalFactorySection = messagePattern opt, equalSign.\r\r(* Binding the message pattern for the primary factory to the following equal sign is an odd factoring of the grammar designed to work around some ugly problems.\r\rThe two would naturally be separated in classPrefix below, e.g.,\r\r classPrefix = (tokenFromSymbol: #class), identifier, messagePattern opt, equalSign\r	              superclassClause opt.\r\rAlas, this doesn't work. If the primary factory signature is omitted, the equal sign and following superclass clause is matched. This eventually fails.  Unlike BNF,  the '|' operator  'cuts' at the first successful branch  rather than evaluating all branches in parallel or backtracking, so the message opt is not retried. We'd have to use a more general and expensive BNF style combinator.\r\rOriginally, we split this into two branches - one using a mandatory messagePattern and one with empty (the messagePattern could not simply be dropped, because the arity of the wrapper for each branch would differ).\r\rThis solution seems cleaner.\rAS YET UNTESTED.\r*)\r\r      classReservedWord = tokenFromSymbol: #class.\r\r      classId = identifier.\r\r	classPrefix = classReservedWord, classId, optionalFactorySection, superclassClause opt.\r\r	mixinApplication = classPrefix, inverseMixinOperator, sendExpression.\r\r	classComment = whitespace opt, comment. (* A hack, to preserve comments from a complete class declaration *)\r	sideDecl = lparen, classDecl star, transientSlotDecl star, methodDecl star, rparen.\r	classSideDecl = colon, lparen, methodDecl star, rparen.\r	languageId = identifier.\r	classCategory = string opt.\r\r	superclassClause = superclassPrefix opt, unaryMsg, message opt. (* unaryMsg should be identifier. Parser needs refactoring. *)\r\r	outerReceiver = (tokenFromSymbol: #outer), identifier.\r	superclassPrefix = outerReceiver |\r		(tokenFromSymbol: #self) |\r		(tokenFromSymbol: #super).\r\r	public classHeader =\r		(accessModifier opt, classReservedWord, classId, messagePattern, equalSign,\r		superclassClause opt, lparen, classComment opt,\r		slotDecls opt, initExprs,  rparen) |\r		(accessModifier opt, classReservedWord, classId, empty, equalSign,\r		superclassClause opt, lparen, classComment opt,\r		slotDecls opt,  initExprs, rparen).\r(* A gross hack to allow for a default constructor pattern.  This should at least be refactored (note the awful use of empty to keep the arity the same for the wrappearr in the parser. Ugh).\rIt would be nice to just say messagePattern opt]. Alas, because the '|' operator  'cuts' at the first successful branch  rather than evaluating all branches in parallel or backtracking, this won't work. *)\r\r	public classDeclaration = classHeader, sideDecl, classSideDecl opt.\r\r	inheritanceClause = superclassClause.\r\r	instanceInitializer = lparen, classComment opt, slotDecls opt, initExprs, rparen.\r\r	classBody = instanceInitializer, sideDecl, classSideDecl opt.\r\r	mixinAppSuffix = ((tokenFromSymbol: '<:'), inheritanceClause) plus, (dot | classBody).\r\r	mixinSpec = classBody | mixinAppSuffix.\r\r	explicitInheritanceListAndOrBody = inheritanceClause, mixinSpec.\r\r	defaultSuperclassAndBody = classBody.\r\r	inheritanceListAndOrBody = defaultSuperclassAndBody | explicitInheritanceListAndOrBody.\r\r	public classDecl =\r		(accessModifier opt, classReservedWord, classId, messagePattern, equalSign, inheritanceListAndOrBody) |\r		(accessModifier opt, classReservedWord, classId, empty, equalSign, inheritanceListAndOrBody).\r\r	toplevelClass = classCategory, classDecl.\r	compilationUnit = languageId, toplevelClass, eoi.\r\r	public doItExpression = codeBody, eoi.\r|)",
 "ExecutableGrammar",
 "ExecutableGrammar",
 "_ = (\r	^char: \"_\"\r)",
 "stringBody = (\r(* As an optimization, we process the body of a string with a dedicated scanning parser.\rIt should be equivalent to:\r\r	^(self character | self aWhitespaceChar | (self char: \"\"\" ) | self twoQuotes) star *)\r\r	^CollectingCommentParser new  termBlock:\r		[:input |\r		| c = input peek. |\r		c isNil\r			ifTrue: [false (* let main routine handle end of input *)]\r			ifFalse: [c = 39 (* $' asInteger *)\r				ifFalse: [false]\r				ifTrue: [\r					| pos |\r					pos: input position.\r					input next.\r					input peek = 39\r						ifTrue: [false]\r						ifFalse: [input position: pos. true]]]]\r)",
 "class NSCommentParser = CombinatorialParser (\r(* As an optimization, we handle comments with a dedicated parser. It should be equivalent to:\r\rbeginComment = (char: \"(\"), (char: \"*\" ).\rendComment = (char: \"*\" ), (char: \")\").\rmetadataTag = (char: $:), id, (char: $:).\rany = charBetween: (Character value: 0) and: (Character value: 16r10FFFF).\rcomment = beginComment,\r	metadataTag opt,\r	((endComment not, any) | comment) star,\r	endComment.\r\r*)\r)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input <ReadStream> inContext: context ifError: blk = (\r	| pos = input position. body = List new. |\r	(input atEnd not and: [input next = 40 (* ( *) and: [input atEnd not and: [input next = 42 (* * *)]]]) ifFalse:\r		[input position: pos.\r		^blk value: '(* expected' value: pos].\r\r	[ | c |\r	input atEnd ifTrue:\r		[input position: pos.\r		^blk value: '(* expected' value: pos].\r	c:: input next.\r	body add: c.\r	c = 40 (* ( *) ifTrue:\r		[ | d |\r		input atEnd ifTrue:\r			[input position: pos.\r			^blk value: '(* expected' value: pos].\r		d:: input next.\r		d = 42 (* * *) ifTrue: [\r			| res |\r			body removeLast. (* not part of comment body *)\r			input position: input position - 2.\r			res:: self parse: input inContext: context ifError:\r				[:msg :pos2 |\r				input position: pos.\r				^blk value: '(* expected 2' value: pos].\r			1 to: res value size do:\r				[:index | body add: (res value runeAt: index)].\r		] ifFalse: [\r			body add: d.\r		]].\r	c = 42 (* * *) ifTrue:\r		[ | d |\r		input atEnd ifTrue:\r			[input position: pos.\r			^blk value: '(* expected' value: pos].\r		d:: input next.\r		d = 41 (* \")\" *) ifTrue: [\r			body removeLast. (* not part of comment body *)\r			^Token\r				value: (String fromRunes: body)\r				start: pos end: input position]\r		ifFalse: [\r			input position: input position - 1. (* Consider next char as possible end star-paren *)\r		]].\r	c = nil ifTrue:\r		[input position: pos.\r		^blk value: '(* expected' value: pos].\r	] repeat.\r)",
 "public class TypedNS3Grammar = NS3Grammar (\r(* A parser for Strongtalk syntax. Adds productions for the Strongtalk type expression sublanguage, and the changes needed to use types in Newsqueak code. *)\r|\r\r	arg = tokenFromSymbol: #arg.\r	for = tokenFromSymbol: #for.\r	generic = tokenFromSymbol: #generic.\r	inheritedTypeOf = tokenFromSymbol: #inheritedTypeOf.\r	is = tokenFromSymbol: #is.\r	mssg = tokenFromSymbol: #message.\r	of = tokenFromSymbol: #of.\r\r	receiverType = tokenFromSymbol: #receiverType.\r	subtypeOf = tokenFromSymbol: #subtypeOf.\r	typeArg = tokenFromSymbol: #typeArg.\r	where = tokenFromSymbol: #where.\r	returnType = hat, type.\r\r	(* Type Grammar *)\r\r	type = langleBracket, typeExpr, rangleBracket.\r	typePrimary = identifier, typeArguments opt.\r	typeFactor = typePrimary | blockType | tupleType | parenthesizedTypeExpression.\r	parenthesizedTypeExpression = lparen, typeExpr, rparen.\r	typeTerm = typeFactor, identifier star.\r	typeExpr = typeTerm, ((vbar | semicolon | slash), typeExpr) opt.\r	typeArguments = lbracket, (typeExpr plusSeparatedBy: comma), rbracket.\r	tupleType = lcurly, (typeExpr starSeparatedBy: dot), rcurly.\r\r 	blockArgType = colon, typeTerm.\r	blockReturnType = typeExpr.\r	nonEmptyBlockArgList = blockArgType plus, (vbar, blockReturnType) opt.\r	blockType = lbracket, (nonEmptyBlockArgList | blockReturnType opt), rbracket.\r\r	(* Type inference *)\r\r	typePattern = langleBracket, typeFormal, (semicolon, typeFormal) star, rangleBracket. (* changed from {} to <> brackets to avoid conflict with tuples *)\r	typeFormal = where, identifier, typeParamConstraint opt, is, inferenceClause.\r	typeParamConstraint = langleBracket, typeBoundQualifier opt, typeExpr, rangleBracket.\r	typeBoundQualifier = subtypeOf | inheritedTypeOf.\r	inferenceClause = receiverType\r		| (returnType, returnTypeInferenceClause)\r		| typeArgInferenceClause\r		| (arg, number, (of, msgSelector) opt).\r	returnTypeInferenceClause = of, msgSelector.\r	msgSelector = symbolConstant, mssg, of, inferenceClause.\r	typeArgInferenceClause = typeArg, number, for, generic, symbolConstant, of, inferenceClause.\r |)",
 "NS3Grammar",
 "NS3Grammar",
 "messagePattern = (\r	^super messagePattern, returnType opt, typePattern opt. (* Type annotations *)\r)",
 "slotDecl = (\r	^super slotDecl , type opt.\r)",
 "class UnarySelectorParser = CombinatorialParser (\r(* In the absence of a separate lexer, an ambiguity arises, which this parser deals with.\r The problem is that when parsing a unary expression that is an argument to a keyword\r message, one expects a unary selector, which is an identifer.  However, it may be that the next\r token is actually a keyword, part of the surrounding message. If we aren't actually tokenizing,\r the prefix of the keyword will be misinterpreted as an identifier and hence as another unary\r message being sent to the argument.\r\r Using a lexer solves this but introduces a subtlety around the assignment operator :=. In that case\r if there is no whitespace between a variable name and the assignment, the variable name will\r be tokenized as a keyword rather than as an identifier. The Strongtalk parser, DeltaParser, deals\r with this specially. In the longterm, that is probably the way to go. *)\r| p |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public on: s = (\r	p: s.\r)",
 "public parse: input inContext: context ifError: blk = (\r	| pos |\r	pos:: input position.\r	p keyword\r		parse: input inContext: context\r		ifError: [:msg :position |\r			input position: pos.\r			^p identifier parse: input inContext: context ifError: blk].\r	input position: pos.\r	blk value: 'should not print' value: pos\r)",
 "class NewspeakASTs usingLib: platform = (\r(* Abstract syntax tree node classes for Newspeak.\r\rIssues:\rThe abbreviations in class and slot names should be replaced with proper identifiers.\rPossibly ASTs for self/super/outer/implicitReceiver should be defined here.\rThe factory selector should be changed to #usingPlatform:.\r\rCopyright 2008 Cadence Design Systems, Inc.\rCopyright 2010 Felix Geller and Ryan Macnak\r\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)\r|\r	private List = platform collections List.\r|)",
 " ",
 " ",
 "public class AST = (\r(* An abstract syntax tree. An AST knows where in the source code the corresponding construct is. The slots start and end are indices into the source code marking that position. *)\r|\rpublic start <Integer> ::= 0. (* Note that 0 is out-of-bounds in a Newspeak string. *)\rpublic end <Integer> ::= 0.\r|)",
 " ",
 " ",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^self subclassResponsibility\r)",
 "assert: block = (\r	self assert: block message: 'Assert failed'\r)",
 "public copyPositionFrom: other <AST> = (\r	self start: other start.\r	self end: other end.\r)",
 "public isKindOfAST ^<Boolean> = (\r	^true\r)",
 "public class ASTTool = ()",
 " ",
 " ",
 "public blockNode: aNode <BlockAST> = (\r	self subclassResponsibility\r)",
 "public cascadedSendNode: aNode <CascadedSendAST> = (\r	self subclassResponsibility\r)",
 "public characterNode: aNode <CharacterAST> = (\r	self subclassResponsibility\r)",
 "public classNode: aNode <ClassAST> = (\r	self subclassResponsibility\r)",
 "public codeBodyNode: aNode <CodeBodyAST> = (\r	self subclassResponsibility\r)",
 "public messageNode: aNode <MessageAST> = (\r	self subclassResponsibility\r)",
 "public messagePatternNode: aNode <MessagePatternAST> = (\r	self subclassResponsibility\r)",
 "public methodNode: aNode <MethodAST> = (\r	self subclassResponsibility\r)",
 "public mixinApplication: node <MixinApplicationAST> = (\r	self subclassResponsibility\r)",
 "public mixinApplicationClass: node <MixinApplicationClassAST> = (\r	self subclassResponsibility\r)",
 "public numberNode: aNode <NumberAST> = (\r	self subclassResponsibility\r)",
 "public returnStatNode: aNode <ReturnStatAST> = (\r	self subclassResponsibility\r)",
 "public setterSendNode: aNode <SetterSendAST> = (\r	self subclassResponsibility\r)",
 "public sideNode: aNode <SideAST> = (\r	self subclassResponsibility\r)",
 "public stringNode: aNode <StringAST> = (\r	self subclassResponsibility\r)",
 "public symbolNode: aNode <SymbolAST> = (\r	self subclassResponsibility\r)",
 "public tupleNode: aNode <TupleAST> = (\r	self subclassResponsibility\r)",
 "public unresolvedSendNode: aNode <UnresolvedSendAST> = (\r	self subclassResponsibility\r)",
 "public varDeclNode: aNode <VarDeclAST> = (\r	self subclassResponsibility\r)",
 "public variableNode: aNode <VariableAST> = (\r	(* can only be a pseudo variable : self or _here *)\r	self subclassResponsibility\r)",
 "public class BinaryTypeOpAST = AST (|\r	public leftOperand <TypeAST>\r	public rightOperand <TypeAST>\r	public operator <Symbol>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool binaryTypeOpNode: self\r)",
 "public class BlockAST = AST (|\r	public body <CodeBodyAST>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool blockNode: self\r)",
 "public isKindOfBlockNode ^<Boolean> = ( ^true )",
 "public parameters ^ <List[ParameterAST]> = (\r	^body parameters\r)",
 "public class BlockTypeAST formals: f return: r = AST (|\r	public formals = f.\r	public return = r.\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool blockTypeNode: self\r)",
 "public class CascadedSendAST = SendAST (|\r	public previousSend <SendAST>\r|)",
 "SendAST",
 "SendAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool cascadedSendNode: self\r)",
 "public end = (\r	(* Currently the parser doesn't set start or end positions for\r	cascades, so compute from the receiver's elements.  But\r	if the parser ever does set the position, take it directly. *)\r	^super end = 0\r		ifFalse: [super end]\r		ifTrue: [message end]\r)",
 "public isKindOfCascadedSendNode ^<Boolean> = ( ^true )",
 "public receiver ^ <ExpressionAST> = (\r	^self previousSend receiver\r)",
 "public start = (\r	(* Currently the parser doesn't set start or end positions for\r	cascades, so compute from the receiver's elements.  But\r	if the parser ever does set the position, take it directly. *)\r	^super start = 0\r		ifFalse: [super start]\r		ifTrue: [previousSend start]\r)",
 "public to: aSend <SendAST> cascade: aMessage <MessageAST> = (\r	self assert: [aSend isKindOfSendNode].\r	self assert: [aMessage isKindOfMessageNode].\r	self previousSend: aSend; message: aMessage.\r)",
 "public class CharacterAST = LiteralAST ()",
 "LiteralAST",
 "LiteralAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool characterNode: self\r)",
 "public class ClassBodyAST initializer: init <InitializerAST> instanceSide: iSide <SideAST> classSide: cSide <SideAST> = AST (\r(* AST for a class body. *)\r|\r	public instanceInitializer <InitializerAST> = init.\r	public instanceSide <SideAST> = iSide.\r	public classSide <SideAST> = cSide.\r|start:: instanceInitializer start.\rend:: classSide end max: instanceSide end)",
 "AST",
 "AST",
 "public class ClassDeclarationAST = AST (|\r	public header <ClassHeaderAST>\r	public instanceSide <SideAST>\r	public classSide <SideAST>\r|)",
 "AST",
 "AST",
 "public accessModifier ^<Symbol> = (\r	^header accessModifier\r)",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool classNode: self\r)",
 "public category ^ <CategoryAST> = (\r	^header category\r)",
 "public category: cat <CategoryAST> = (\r	header category: cat\r)",
 "public classComment ^ <String> = (\r	^header classComment\r)",
 "public isKindOfClassDeclarationNode ^<Boolean> = (\r	^true\r)",
 "public name ^ <Symbol> = (\r	^header name\r)",
 "public selector ^<Symbol> = (\r	^header name\r)",
 "public superclassName ^ <Symbol> = (\r	^header superclassName\r)",
 "public makeMixinNamed: klassName <Token> factoryMsg: cons <MessagePatternAST> inheriting: iList <List[SendAST]> body: body <ClassBodyAST>\r ^ <ClassDeclarationAST> = (\r(* adaptor factory method for transition. Using this method, we can create an AST compatible with the unmodified compiler based on the revised parser. *)\r	|\r	superCall <SendAST> = iList first.\r	instanceInitializer <InitializerAST> = body instanceInitializer.\r	header = ClassHeaderAST new\r				name: klassName value asSymbol;\r				constructor: cons;\r				superclassName: superCall receiver message selector;\r				superclassCall: superCall receiver;\r				superConstructorCall: superCall message;\r				slots: instanceInitializer slots;\r				isSeq: instanceInitializer isSeq;\r				initExprs: instanceInitializer initializationExpressions;\r				inheritanceChain: iList;\r				classComment: body instanceInitializer classComment;\r				start: klassName start; end: instanceInitializer end.\r	|\r	^new\r		header: header;\r		instanceSide: body instanceSide;\r		classSide: body classSide\r)",
 "public named: klassName <Token> factoryMsg: cons <MessagePatternAST> inheriting: iList <List[SendAST]> body: body <ClassBodyAST>\r ^ <ClassDeclarationAST> = (\r	^body isNil\r		ifTrue: [MixinApplicationClassAST named: klassName value factoryMsg: cons inheriting: iList]\r		ifFalse: [makeMixinNamed: klassName factoryMsg: cons inheriting: iList body: body]\r)",
 "public class ClassHeaderAST = AST (|\r	public accessModifier\r	public name <Symbol>\r	public constructor <MessagePatternAST>\r	public superclassName <Symbol>\r	public superclassCall <NormalSendAST>\r	public superConstructorCall <MessageAST>\r	public slots <List[SlotDefAST]>\r	public isSeq <Boolean>\r	public classComment <String>\r	public category <CategoryAST>\r	public initExprs <List[ExpressionAST]>\r	public inheritanceChain <List[SendAST]>\r |)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool classHeaderNode: self\r)",
 "public isKindOfClassHeaderAST = (\r	^true\r)",
 "public superCall ^ <SendAST> = (\r	^inheritanceChain first\r)",
 "public class ClassPrefixAST name: n\r	constructor: k\r	superclassName: sn\r	superclassCall: scc\r	superConstructorCall: sk = AST (\r(* A class prefix defines everything about a class except for its mixin.\rIt is intended to serve as a common component between ordinary class declarations and mixin applications.\r\rFor Squeak compatibility, we maintain a category as well (ugh).\r*)\r|\r	public name <Symbol> = n.\r	public constructor <MessagePatternAST> = k.\r	public superclassName <Symbol> = sn.\r	public superclassCall <NormalSendAST> = scc.\r	public superConstructorCall <MessageAST> = sk.\r	public category <CategoryAST>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool classPrefix: self\r)",
 "public class CodeBodyAST = AST (|\r	public parameters <List[ParameterAST]>\r	public temporaries <List[TemporaryAST]>\r	public statements <List[StatementAST]>\r	public isSeq <Boolean> ::=true.\r	public literalMessages <List[MessageAST]>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool codeBodyNode: self\r)",
 "public isKindOfCodeBodyNode ^<Boolean> = (^true)",
 "public parameters: pars <List[ParameterAST]> temporaries: temps <List[TemporaryAST]> statements: stats <List[StatementAST]> = (\r	self parameters: pars; temporaries: temps; statements: stats\r)",
 "public temporaries: temps <List[TemporaryAST]> statements: stats <List[StatementAST]> = (\r	self parameters: List new; temporaries: temps; statements: stats\r)",
 "public class ImmutableSlotDefAST = SlotDefAST ()",
 "SlotDefAST",
 "SlotDefAST",
 "public isMutable ^<Boolean> = (\r	^false\r)",
 "public class InitializerAST slots: s initializerExpressions: es comment: c slotsAreSequential: seq = AST (\r(* AST for an instance initializer clause. *)\r|\r	public slots = s.\r	public initializationExpressions <List[ExpressionAST]> = es.\r	public classComment = c.\r	public isSeq <Boolean> = seq.\r|)",
 "AST",
 "AST",
 "public class KeywordPatternAST = PatternAST (|\r	public keywords <TupleAST>\r	public patterns <TupleAST>\r|)",
 "PatternAST",
 "PatternAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool keywordPatternNode: self\r)",
 "public class KeywordPatternPairAST = AST (|\r	keyword <Symbol>\r	pattern\r|)",
 "AST",
 "AST",
 "public class LiteralAST = AST (|\r	public value <Object>\r|)",
 "AST",
 "AST",
 "public isKindOfLiteralNode ^<Boolean> = (^true)",
 "public printOn: stream = (\r	stream nextPutAll: class simpleName.\r	stream nextPutAll: ': '.\r	value printOn: stream.\r)",
 "public class LiteralPatternAST = PatternAST (|\r	public literal <LiteralAST>\r|)",
 "PatternAST",
 "PatternAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool literalPatternNode: self\r)",
 "public class MessageAST = AST (|\r	public selector <Symbol>\r	public arguments <List[ExpressionAST]>\r	public isEventual <Boolean> ::= false.\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool messageNode: self\r)",
 "public isKindOfMessageNode ^<Boolean> = (^true)",
 "public send: sel <Symbol> with: args <List[ExpressionAST]> = (\r	self selector: sel; arguments: args\r)",
 "public class MessagePatternAST = AST (\r|\r	public accessModifier <Symbol>\r	public selector <Symbol>\r	public parameters <List[ParameterAST]>\r	public returnType <TypeAST>\r	public typePattern <TypePatternAST>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool messagePatternNode: self\r)",
 "public selector: s <Symbol> parameters: p <List[ParameterAST]> = (\r  self selector: s; parameters: p\r)",
 "public selector: s <Symbol> parameters: p <List[ParameterAST]> returnType: t <TypeAST> = (\r  self selector: s; parameters: p; returnType: t\r)",
 "public selector: s <Symbol> parameters: p <List[ParameterAST]> returnType: t <TypeAST> typePattern: tp <TypePatternAST> = (\r  self selector: s; parameters: p; returnType: t; typePattern: tp\r)",
 "public selector: s <Symbol> returnType: t <TypeAST> = (\r  self selector: s; returnType: t\r)",
 "public class MethodAST = AST (|\r	public pattern <MessagePatternAST>\r	public body <CodeBodyAST>\r|)",
 "AST",
 "AST",
 "public accessModifier ^ <Symbol> = (\r	^pattern accessModifier\r)",
 "public accessModifier: am <Symbol> = (\r	pattern accessModifier: am\r)",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool methodNode: self\r)",
 "public pattern: p <MessagePatternAST> body: b <CodeBodyAST> accessModifier: am <Symbol> = (\r	pattern: p.\r	body: b.\r	accessModifier: am.\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'MethodAST: '.\r	stream nextPutAll: selector\r)",
 "public selector ^<Symbol> = (\r	^pattern selector\r)",
 "public class MixinApplicationAST = AST (\r(* Represents a literal mixin application. *)\r|\r	public mixinExpression <NormalSendAST>\r	public superclassExpression <NormalSendAST> (* should eventually go away *)\r	public classPrefix <ClassPrefixAST>\r |)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool mixinApplication: self\r)",
 "public prefix: cp mixin: me = (\r(* ultimately should be a primary factory *)\r	^new classPrefix: cp; mixinExpr: me; superclassExpr: cp superclassCall; yourself\r)",
 "public class MixinApplicationClassAST named: klassName factoryMsg: cons inheriting: iList = AST (\r(* This class represents a class defined via a mixin application - that is, a class that does not provide a class body. *)\r|\r	public accessModifier <Symbol>\r	public name <Symbol> = klassName asSymbol.\r	public constructor <MessagePatternAST> = cons.\r	public inheritanceChain <List[SendAST]> = iList.\r	public category <CategoryAST>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool mixinApplicationClass: self\r)",
 "public isKindOfMixinApplicationClassAST ^<Boolean> = (\r	^true\r)",
 "public class MutableSlotDefAST = SlotDefAST ()",
 "SlotDefAST",
 "SlotDefAST",
 "public isMutable ^ <Boolean> = (^true)",
 "public class NumberAST = LiteralAST ()",
 "LiteralAST",
 "LiteralAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool numberNode: self\r)",
 "public isKindOfNumberNode ^<Boolean> = ( ^true )",
 "public class ParameterizedTypeAST = AST (|\r	public generic <TypeIdAST>\r	public arguments <List[TypeAST]>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool genericInvocationNode: self\r)",
 "public class PatternAST = LiteralAST (\r)",
 "LiteralAST",
 "LiteralAST",
 "public class ReturnStatAST = AST (|\r	public expression <ExpressionAST>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool returnStatNode: self\r)",
 "public isKindOfReturnStatNode ^<Boolean> = ( ^true )",
 "public class SendAST send: aMsg = AST (|\r	public message <MessageAST> ::= aMsg.\r|)",
 "AST",
 "AST",
 "public isKindOfSendNode ^<Boolean> = ( ^true )",
 "public receiver = (\r	^self subclassResponsibility\r)",
 "public class SetterSendAST to: r <ExpressionAST> send: m <MessageAST> start: s <integer> end: e <Integer> = SendAST send: m (|\r	public receiver <ExpressionAST> ::= r.\r|\r	start: s.\r	end: e.\r)",
 "send: m",
 "send: m",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool setterSendNode: self\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'SetterSendAST: '.\r	stream nextPutAll: message selector.\r)",
 "public class SideAST = AST (\r(* An AST for one side of a class *)\r|\r	public nestedClasses <Collection[ClassDeclarationAST]>\r	public methods <Collection[MethodAST]>\r	public transientSlots <List[SlotDefAST]>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool sideNode: self\r)",
 "public class SlotDefAST = AST (|\r	public slotDecl <VariableAST>\r	public initializer <ExpressionAST>\r	public accessModifier\r	public isTransient ::= false.\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool slotDefNode: self\r)",
 "public isMutable ^ <Boolean> = (self subclassResponsibility)",
 "public name ^ <Symbol> = (\r	^slotDecl name\r)",
 "public type ^ <TypeAST> = (\r	^slotDecl type\r)",
 "public class StringAST = LiteralAST ()",
 "LiteralAST",
 "LiteralAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool stringNode: self\r)",
 "public class SymbolAST = LiteralAST ()",
 "LiteralAST",
 "LiteralAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool symbolNode: self\r)",
 "public class TupleAST = AST (|\r	public elements <List[ExpressionAST]>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool tupleNode: self\r)",
 "public isKindOfTupleNode ^<Boolean> = ( ^true )",
 "public class TypeIdAST = AST (|\r	public name <Symbol>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool typeIdNode: self\r)",
 "public class UnaryTypeOpAST = AST (| public operand <TypeAST> public operator <Symbol> |)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool unaryTypeOpNode: self\r)",
 "public class UnresolvedSendAST = SendAST (|\r	public receiver <ExpressionAST>\r|)",
 "SendAST",
 "SendAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool unresolvedSendNode: self\r)",
 "public isKindOfUnresolvedSendNode ^<Boolean> = (\r	^true\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'NormalSendAST: '.\r	stream nextPutAll: message selector.\r)",
 "public to: anExpression <ExpressionAST> send: aMessage <MessageAST> = (\r	self receiver: anExpression; message: aMessage\r)",
 "public to: anExpression <ExpressionAST> send: selector with: arguments = (\r	to: anExpression send: (MessageAST new send: selector with: arguments)\r)",
 "public class VarDeclAST name: aName type: aType = AST (|\r	public name <Symbol> = aName.\r	public type <TypeAST> = aType.\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool varDeclNode: self\r)",
 "public class VariableAST = AST (|\r	public name <Symbol>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool variableNode: self.\r)",
 "public isKindOfVariableNode ^<Boolean> = (^true)",
 "public printOn: stream = (\r	stream nextPutAll: class simpleName.\r	stream nextPutAll: ': '.\r	stream nextPutAll: name.\r)",
 "public class VariablePatternAST = PatternAST (|\r	variableName <Symbol>\r|)",
 "PatternAST",
 "PatternAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool variablePatternNode: self\r)",
 "public variableName: vn start: s end: e = (\r	^self new variableName: vn; start: s; end: e; yourself\r)",
 "public class WildcardPatternAST = PatternAST (\r)",
 "PatternAST",
 "PatternAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool wildcardPatternNode: self\r)",
 "public start: s end: e = (\r	^self new start: s; end: e; yourself\r)",
 "class NewspeakParsing usingPlatform: platform grammar: grammar asts: asts = (\r(* The Newspeak parser.\r\rCopyright 2008 Cadence Design Systems, Inc.\rCopyright 2010 Felix Geller and Ryan Macnak\r\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)\r|\r	private List = platform collections List.\r\r	private TypedGrammar = grammar TypedNS3Grammar.\r\r	private BinaryTypeOpAST = asts BinaryTypeOpAST.\r	private BlockAST = asts BlockAST.\r	private BlockTypeAST = asts BlockTypeAST.\r	private CascadedSendAST = asts CascadedSendAST.\r	private CharacterAST = asts CharacterAST.\r	private ClassBodyAST = asts ClassBodyAST.\r	private ClassDeclarationAST = asts ClassDeclarationAST.\r	private ClassHeaderAST = asts ClassHeaderAST.\r	private ClassPrefixAST = asts ClassPrefixAST.\r	private CodeBodyAST = asts CodeBodyAST.\r	private ImmutableSlotDefAST = asts ImmutableSlotDefAST.\r	private InitializerAST = asts InitializerAST.\r	private ParameterizedTypeAST = asts ParameterizedTypeAST.\r	private MessageAST = asts MessageAST.\r	private MessagePatternAST = asts MessagePatternAST.\r	private MethodAST = asts MethodAST.\r	private MixinApplicationClassAST = asts MixinApplicationClassAST.\r	private MutableSlotDefAST = asts MutableSlotDefAST.\r	private UnresolvedSendAST = asts UnresolvedSendAST.\r	private NumberAST = asts NumberAST.\r	private ReturnStatAST = asts ReturnStatAST.\r	private SetterSendAST = asts SetterSendAST.\r	private SideAST = asts SideAST.\r	private StringAST = asts StringAST.\r	private SymbolAST = asts SymbolAST.\r	private TupleAST = asts TupleAST.\r	private TypeIdAST = asts TypeIdAST.\r	private UnaryTypeOpAST = asts UnaryTypeOpAST.\r	private VarDeclAST = asts VarDeclAST.\r	private VariableAST = asts VariableAST.\r\r	private MixinApplicationAST = asts MixinApplicationAST.\r\r	(* patterns *)\r	private KeywordPatternAST = asts KeywordPatternAST.\r	private KeywordPatternPairAST = asts KeywordPatternPairAST.\r	private WildcardPatternAST = asts WildcardPatternAST.\r	private LiteralPatternAST = asts LiteralPatternAST.\r	private VariablePatternAST = asts VariablePatternAST.\r|)",
 " ",
 " ",
 "public class CommonParser = (\r|\r	protected parser = Parser new.\r|\r)",
 " ",
 " ",
 "public parseClassDeclaration: input <String> = (\r	^parser classDecl parseString: input\r)",
 "public parseCompilationUnit: input <String> = (\r	^parser compilationUnit parseString: input\r)",
 "public parseExpression: input <String> = (\r	^parser doItExpression parseString: input\r)",
 "public parseMessagePattern: input <String> = (\r	^parser messagePattern parseString: input\r)",
 "public parseMethodDeclaration: input <String> = (\r	^parser methodDecl parseString: input\r)",
 "public parseMethodHeader: input <String> ^ <MessagePatternAST>= (\r(* Hack to work around the fact that messagePattern production does not parse access modifier *)\r  | hdr <{Symbol. MessagePatternAST}> result <MessagePatternAST> |\r	hdr:: parser methodHeader parseString: input.\r	result:: hdr at: 2.\r	result accessModifier: (hdr at: 1).\r	^result\r)",
 "public parseSlotDefinition: input <String> = (\r	^parser slotDef parseString: input\r)",
 "public parseTransientSlotDeclaration: input <String> = (\r	^parser transientSlotDecl parseString: input\r)",
 "public parseTypeId: input  ^ <TypeIdAST> =  (\r  ^parser typePrimary parseString: input\r)",
 "public class Parser = TypedGrammar (\r(* Parser for Newpeak. Produces a Newspeak AST. This tree represents syntax only. No attribution information such as scopes/symbol tables, types etc. is present in the tree. The tree  only gives its structure and the source code positions of the nodes.\r\rThe parser works by overridding the accessors for most grammar productions in its superclasses. The superclass methods deal with the grammar alone; each production defines a parser that will parse the syntax and return the corresponding set of tokens. The methods here process the output of the superclass methods to yield parsers that will construct ASTs. Hence, the typical method for a production foo is something like\r\rfoo\r\r^super foo wrapper: [:w :x :y :z | FooAST new from: x and: y; start: w start; end: z end]\r\rThis example assumes that the semantic content of foo is given by x and y. Typically, x and y will be the results of  productions that have also been overridden, to provide  ASTs that will be subtrees of the Foo node. In contarst, w and z are likely to be tokens used in the concrete syntax to delimit the Foo construct. They may (or may not) be used to extract source code position information, and then discarded. *)\r)",
 "TypedGrammar",
 "TypedGrammar",
 "public accessModifier = (\r	^super accessModifier wrapper: [:am :ws | am]\r)",
 "public binaryExpression = (\r	^super binaryExpression wrapper:\r		[:ue :bmsgs | (* unaryExpression binaryMsg* *)\r		 bmsgs inject: ue into:\r			[:receiverExpr :b <MessageAST> |\r			 UnresolvedSendAST new\r				to: receiverExpr send: b;\r				start: receiverExpr start;\r				end: b end]]\r)",
 "public binaryMsg ^ <CombinatorialParser[MessageAST]> = (\r	^super binaryMsg wrapper:\r		[:esend :b :e |\r		| args = {e}. |\r		MessageAST new\r			send: b value with: args;\r			isEventual: (nil = esend) not;\r			start: b start;\r			end: e end].\r)",
 "public binaryMsgPattern = (\r	^super binaryMsgPattern wrapper:\r		[:sel :p | | params |\r		 params:: List new add: p; yourself.\r		 MessagePatternAST new\r			selector: sel value parameters: params;\r			start: sel start;\r			end: p end].\r)",
 "public block ^ <CombinatorialParser[BlockAST]> = (\r	^super block wrapper:\r		[:lb :params :cb :rb |\r		| ps |\r		ps:: params isNil ifTrue: [List new] ifFalse: [params].\r		cb parameters: ps.\r		BlockAST new\r			body: cb;\r			start: lb start; end: rb end]\r)",
 "public blockArgType = (\r	^super blockArgType wrapper:\r		[:c :rt | rt]\r)",
 "public blockParameter = (\r	^super blockParameter wrapper:\r		[:c :v | v]\r)",
 "public blockParameters = (\r	^super blockParameters wrapper:\r		[:params :vb | params]\r)",
 "public blockType = (\r	^super blockType wrapper:\r		[:lb :tas :rb |\r		(nil = tas\r			ifTrue:\r				[BlockTypeAST\r					formals: {}\r					return: (TypeIdAST new name: #Object)]\r			ifFalse:\r				[ | fs r |\r				tas isCollection\r					ifTrue: [fs:: tas. r:: fs removeLast]\r					ifFalse: [fs:: {}. r:: tas].\r				BlockTypeAST\r					formals: fs\r					return: r])\r		start: lb start;\r		end: rb end].\r)",
 "public blockTypeArgList = (\r	^super blockTypeArgList wrapper:\r		[:tas :rt |\r		| targs |\r		targs:: tas collect: [:p | p last].\r		nil = rt\r			ifTrue: [targs addLast: (TypeIdAST new name: #Object)]\r			ifFalse: [targs add: rt].\r		targs]\r)",
 "public cascadeMsg = (\r^super cascadeMsg\r	wrapper: [:sm :msg | msg].\r)",
 "public cascadedMessageExpression ^ <CombinatorialParser[CascadedSendAST]> = (\r	^super cascadedMessageExpression wrapper:\r		[:p <ExpressionAST>\r		 :msgs <Tuple[Tuple[List[MessageAST], List[MessageAST], MessageAST], List[MessageAST]]> |\r		|\r		se <SendAST>\r		unaries <List[MessageAST]>\r		binaries <List[MessageAST]>\r		kwMsg <MessageAST>\r		cascade <List[MessageAST]>\r		unarySend <ExpressionAST>\r		binarySend <ExpressionST>\r		|\r		(* primary [msgCascade] *)\r		msgs isNil\r			ifTrue: [p]\r			ifFalse:\r				[unaries:: msgs first first.\r				 binaries:: msgs first at: 2.\r				 kwMsg:: msgs first last.\r				 cascade:: msgs last.\r				 unarySend:: sendMessages: unaries to: p.\r				 binarySend:: sendMessages: binaries to: unarySend.\r				 se:: kwMsg isNil\r					ifTrue: [binarySend]\r					ifFalse: [sendMessages: {kwMsg} to: binarySend].\r	             	cascade inject: se into:\r					[:e <SendAST> :m <MessageASAT> |\r					 CascadedSendAST new\r						to: e cascade: m;\r						start: e start; end: m end]]]\r)",
 "public characterConstant = (\r	^super characterConstant wrap:\r		[:t |\r		| v ::= (Character fromRune: (t value at: 2)). |\r		v isString ifTrue: [v:: v asSymbol].\r		CharacterAST new value: v; start: t start; end: t end].\r)",
 "public classBody ^ <CombinatorialParser[ClassBodyAST]> = (\r	^super classBody wrapper:\r		[:instInit <InitializerAST> :instanceSide <SideAST> :classSide <SideAST> |\r		|\r		klassSide <SideAST> = classSide isNil\r			ifTrue: [emptySide]\r			ifFalse: [classSide].\r		|\r		ClassBodyAST initializer: instInit instanceSide: instanceSide classSide: klassSide].\r)",
 "public classComment = (\r	^super classComment wrapper: [:ws :c | c value]\r)",
 "public classDecl ^ <CombinatorialParser[ClassDeclarationAST]> = (\r 	^super classDecl wrapper:\r		[:am :ckw :klassName <Token> :cons :eq :listAndBody <{List[SendAST]. ClassBodyAST}> |\r		|\r		start = nil = am ifTrue: [ckw start] ifFalse: [am start].\r		konstruktor = nil = cons\r			ifTrue: [defaultConstructorPattern start: klassName end + 1; end: klassName end]\r			ifFalse: [cons].\r		bodyOrDot <ClassBodyAST> = listAndBody last.\r		iList <List[SendAST]> = listAndBody first.\r		end <Integer> = bodyOrDot end.\r		|\r		bodyOrDot isKindOfAST ifTrue: [\r			| c |\r			c:: (ClassDeclarationAST\r				named: klassName\r				factoryMsg: konstruktor\r				inheriting: iList body: bodyOrDot)\r			start: start;\r			end: end.\r			c header accessModifier: (nil = am ifTrue: [#protected] ifFalse: [am value]).\r			c header start: start.\r			c\r	 ] ifFalse: [\r			(MixinApplicationClassAST\r				named: klassName value factoryMsg: konstruktor inheriting: iList)\r				accessModifier: (nil = am ifTrue: [#protected] ifFalse: [am value])]\r		].\r)",
 "public classDeclaration ^ <CombinatorialParser[ClassDeclarationAST]> = (\r	^super classDeclaration wrapper:\r		[:hdr :instSide :classSide |\r		| klassSide kat |\r		klassSide:: classSide isNil\r			ifTrue: [emptySide]\r			ifFalse: [classSide].\r		ClassDeclarationAST new\r			header: hdr;\r			instanceSide: instSide;\r			classSide: klassSide;\r			start: hdr start;\r			end: (classSide isNil ifTrue: [instSide end] ifFalse: [classSide end])]\r)",
 "classDefinition = (\rhalt.\r(* %Cleanup when NS1 and NS0  are gone *)\r(* Retained for compatibility with older Newsqueak versions. We renamed classDefinition to ClassDeclaration in the grammar, but there is code that needs to use older parsers, and hence uses the old protocol *)\r^compilationUnit\r)",
 "public classHeader ^ <CombinatorialParser[ClassHeaderAST]> = (\r	^super classHeader wrapper:\r		[:am :ckw :klassName :cons :eq :superClause :lp :cmnt :instVars :inits :rp |\r		| vs kat start konstruktor superCall isSeq |\r		isSeq:: true.\r		kat:: nil.\r		start:: am isNil ifTrue: [ckw start] ifFalse: [am start].\r		konstruktor:: cons isNil\r			ifTrue: [defaultConstructorPattern start: klassName end + 1; end: klassName end]\r			ifFalse: [cons].\r		superCall:: superClause isNil\r			ifTrue: [defaultSuperCallAt: eq end + 1 ending: eq end]\r			ifFalse: [superClause].\r		vs:: instVars isNil\r			ifTrue: [List new]\r			ifFalse: [isSeq:: instVars first. instVars last].\r		ClassHeaderAST new\r			name: klassName value asSymbol;\r			constructor: konstruktor;\r			superclassName: superCall receiver message selector;\r			superclassCall: superCall receiver;\r			superConstructorCall: superCall message;\r			slots: vs; isSeq: isSeq; initExprs: inits; category: kat;\r			classComment: cmnt;\r			inheritanceChain: {superCall};\r			accessModifier: (am isNil ifTrue: [#protected] ifFalse: [am value]);\r			start: start; end: rp end].\r)",
 "public classPrefix ^ <CombinatorialParser[ClassHeaderAST]> = (\r^super classPrefix\r	wrapper: [:klassName :cons :eq :superClause |\r	     | start  konstruktor superCall |\r\r	        start:: klassName start.\r	        konstruktor:: cons isNil\r	             ifTrue: [defaultConstructorPattern start: klassName end + 1; end: klassName end]\r	             ifFalse: [cons].\r	        superCall:: superClause isNil\r	                           ifTrue: [defaultSuperCallAt: eq end + 1 ending: eq end]\r	                           ifFalse: [superClause].\r\r	        (ClassPrefixAST\r				name: klassName value asSymbol\r	              constructor: konstruktor\r				superclassName: superCall receiver message selector\r				superclassCall: superCall receiver\r				superConstructorCall: superCall message)\r	              start: start; end: superCall end\r	 ].\r)",
 "public classSideDecl ^ <CombinatorialParser[SideAST]> = (\r	^super classSideDecl wrapper:\r		[:cn :lp :methods :rp |\r		 SideAST new\r			nestedClasses: {};\r			methods: methods;\r			start: cn start; end: rp end]\r)",
 "public codeBody ^ <CombinatorialParser[CodeBodyAST]> = (\r	^super codeBody wrapper:\r		[:litMsgs :tmps :stmts |\r		| ts ss start end isSeq |\r		isSeq:: true.\r		end:: nil.\r		start:: end.\r		ts:: tmps isNil ifTrue: [List new] ifFalse: [isSeq:: tmps first. tmps last].\r		ss:: stmts isNil ifTrue: [List new] ifFalse: [stmts].\r		ts isEmpty ifFalse:\r			[start:: ts first start.\r			end:: ts last end].\r		ss isEmpty ifFalse:\r			[start isNil ifTrue: [start:: ss first start].\r			 end:: ss last end].\r		CodeBodyAST new\r			temporaries: ts statements: ss;\r			literalMessages: (litMsgs select: [:e | e isKindOfMessageNode]);\r			isSeq: isSeq;\r			start: start;\r			end: end]\r)",
 "public compilationUnit = (\r	^super compilationUnit wrapper: [:lid :u :e | u] (* throw out end-of-input indicator *)\r)",
 "computeDigits: ds <List[Character]> ^ <Integer> = (\r	| s ::= 0. |\r	ds do: [:d | s:: (10 * s) + (d - 48)].\r	^s\r)",
 "computeDigits: digitCharCodes <List[Integer]> radix: radixValue <Integer> ^<Integer> = (\r	| sum ::= 0. |\r	digitCharCodes do:\r		[:digitCharCode | | digitValue |\r		(digitCharCode > 47 and: [digitCharCode < 58])\r			ifTrue:\r				[digitValue:: digitCharCode - 48]\r			ifFalse:\r				[(digitCharCode > 64 and: [digitCharCode < 71])\r					ifTrue:\r						[digitValue:: digitCharCode - 55]\r					ifFalse:\r						[assert: [digitCharCode > 96 and: [digitCharCode < 123]]\r						message: 'Internal error - illegal character in radix number'.\r						digitValue:: digitCharCode - 87]].\r		assert: [digitValue < radixValue] message: 'Malformed number: digit exceeds radix'.\r		sum:: (radixValue * sum) + (digitValue)].\r	^sum\r)",
 "computeFraction: ds <List[Character]> ^ <Number> = (\r	|\r	numerator ::= 0.\r	denominator ::= 1.\r	|\r	ds do: [:d |\r		numerator:: (10 * numerator) + (d - 48).\r		denominator:: 10 * denominator].\r	^numerator / denominator\r)",
 "computeFraction: digitCharCodes <List[Integer]> radix: radixValue <Integer> ^<Integer> = (\r	|\r	numerator ::= 0.\r	denominator ::= 1.\r	|\r	digitCharCodes do:\r		[:digitCharCode | | digitValue |\r		(digitCharCode > 47 and: [digitCharCode < 58])\r			ifTrue:\r				[digitValue:: digitCharCode - 48]\r			ifFalse:\r				[(digitCharCode > 64 and: [digitCharCode < 71])\r					ifTrue:\r						[digitValue:: digitCharCode - 55]\r					ifFalse:\r						[assert: [digitCharCode > 96 and: [digitCharCode < 123]]\r						message: 'Internal error - illegal character in radix number'.\r						digitValue:: digitCharCode - 87]].\r		assert: [digitValue < radixValue] message: 'Malformed number: digit exceeds radix'.\r		numerator:: (radixValue * numerator) + (digitValue).\r		denominator:: radixValue * denominator].\r	^numerator / denominator\r)",
 "public decimalNum ^ <Number> = (\r	^super decimalNum wrapper:\r		[:sgn :ip <List[Character]> :fp <Number> :ep <Integer> |\r		| sum <Number> |\r		sum:: computeDigits: ip.\r		nil = fp ifFalse: [sum:: sum + fp].\r		nil = sgn ifFalse: [sum:: -1 * sum].\r		nil = ep ifFalse: [sum:: sum * (10 ** ep)].\r		sum]\r)",
 "defaultConstructorCall ^ <MessageAST> = (\r(* default constructor is 'new' *)\r^MessageAST new send: defaultConstructorSelector with: {}\r)",
 "defaultConstructorPattern ^ <MessagePatternAST> = (\r(* default constructor is 'new' *)\r^MessagePatternAST new selector: defaultConstructorSelector parameters: {}\r)",
 "defaultConstructorSelector ^ <Symbol> = (\r(* default constructor is 'new' *)\r^#new\r)",
 "defaultSuperCallAt: start <Integer> ending: end <Integer> ^ <NormalSendAST> = (\r	| objId |\r	objId:: hereSendFromMsg: (MessageAST new send: #Object with: {}; start: start; end: end).\r	^UnresolvedSendAST new receiver: objId; message: (defaultConstructorCall start: start; end: end)\r)",
 "public defaultSuperclassAndBody ^ <{List[SendAST]. ClassBodyAST}> = (\r	^super defaultSuperclassAndBody wrap:\r		[:body <ClassBodyAST> |\r		{{defaultSuperCallAt: body start -1 ending: body start - 1}. body}]\r)",
 "public doItExpression = (\r	(* throw out end-of-input indicator *)\r	^super doItExpression wrapper: [:cb :end | cb]\r)",
 "emptySide = (\r	^SideAST new nestedClasses: {}; methods: {}\r)",
 "public explicitInheritanceListAndOrBody ^ <CombinatorialParser[{List[SendAST]. ClassBodyAST}]> = (\r	^super explicitInheritanceListAndOrBody\r		wrapper: [:ic <SendAST> :ms <{List[{Token. SendAST}]. ClassBodyAST} | ClassBodyAST> |\r			ms isCollection\r				ifFalse: [{{ic}. ms}]\r				ifTrue: [\r					| iList <List[SendAST]> = (ms first collect: [:p | p last]) addFirst: ic; yourself. |\r					{iList. ms last}\r					]\r			]\r)",
 "public exponent ^ <Integer> = (\r	^super exponent wrapper:\r		[:e :sgn :ds <List[Character]> |\r		| exp <Integer> |\r		exp:: computeDigits: ds.\r		sgn isNil ifTrue: [exp] ifFalse: [-1*exp]].\r)",
 "public expression = (\r	^super expression wrapper:\r		[:setters :msg |\r		| e setSend args setSelector |\r		e:: msg.\r		setters isNil ifFalse:\r			[setters size to: 1 by: -1 do:\r				[:index |\r				| setter = setters at: index. |\r				args:: List new add: e; yourself.\r				setSelector:: setter value asString.\r				setSend:: MessageAST new\r					send: (setSelector copyFrom: 1 to: setSelector size - 1) asSymbol with: args;\r					start: setter start; end: e end.\r				e:: self hereSetterSendFromMsg: setSend]].\r		e].\r)",
 "public extendedFraction ^ <List[Character]> = (\r	^super extendedFraction wrapper: [:period :ds | ds]\r)",
 "public fraction ^ <Number> = (\r	^super fraction wrapper: [:period :ds | computeFraction: ds]\r)",
 "public furtherStatements = (\r^super furtherStatements\r	wrapper: [:d :stmts | stmts].\r)",
 "hereNode ^<VariableAST> = (\r	(* Generates an AST representing the implicit receiver. We use a string so that we can represent a name that is not a legal identier *)\r\r	^VariableAST new name: #'@here'; start: 0; end: 0.\r)",
 "hereSendFromMsg: msg = (\r	(* Build an implicit here send with the message msg *)\r	^UnresolvedSendAST new\r		to: hereNode send: msg;\r		start: msg start; end: msg end\r)",
 "hereSetterSendFromMsg: msg = (\r	(* Build an implicit here send with the message msg *)\r\r	^SetterSendAST to: self hereNode\r	                	send: msg\r		                      	start: msg start\r					end: msg end\r)",
 "public instanceInitializer ^ <CombinatorialParser[InitializerAST]> = (\r	^super instanceInitializer\r		wrapper: [:lp <Token> :cmnt :instVars :inits <List[ExpressionAST]> :rp <Token> |\r			| vs isSeq |\r			isSeq:: true.\r			vs:: instVars isNil ifTrue: [List new] ifFalse: [isSeq:: instVars first. instVars last].\r			(InitializerAST  slots: vs initializerExpressions: inits comment: cmnt slotsAreSequential: isSeq)\r				start: lp start; end: rp end\r			]\r)",
 "public keywordExpression ^ <CombinatorialParser[NormalSendAST]> = (\r	^super keywordExpression wrapper:\r		[:bo :msg <MessageAST> |\r		msg isNil\r			ifTrue: [bo]\r			ifFalse: [UnresolvedSendAST new to: bo send: msg; start: bo start; end: msg end]]\r)",
 "public keywordHereSend = (\r^super keywordHereSend\r	wrap: [:msg |\r	        self hereSendFromMsg: msg\r	 ].\r)",
 "public keywordMessages ^<CombinatorialParser[Tuple[List[MessageAST], List[MessageAST], MessageAST]]> = (\r	^super keywordMessages wrap:\r		[:kwMsg <MessageAST> |\r		{{}. {}. kwMsg}]\r)",
 "public keywordMsg ^ <CombinatorialParser[MessageAST]> = (\r	^super keywordMsg wrapper:\r		[:esend :kws |\r		| sel <String> args <List[Expression]> |\r		args:: List new.\r		sel:: kws inject: '' into:\r			[:s <String> :kwd |\r			args add: (kwd at:2).\r			s, (kwd at:1) value].\r		MessageAST new\r			send: sel asSymbol with: args;\r			isEventual: (nil = esend) not;\r			start: kws first first start;\r			end: args last end].\r)",
 "public keywordMsgPattern ^ <CombinatorialParser[MessagePatternAST]> = (\r	^super keywordMsgPattern wrap:\r		[:kws | | sel params |\r		 params:: List new.\r		 sel:: kws inject: '' into:\r			[:s :kwp |\r			 params add: kwp last.\r			 s, kwp first value].\r	    MessagePatternAST new\r			selector: sel asSymbol parameters: params;\r			start: kws first first start;\r			end: params last end]\r)",
 "public keywordPattern ^ <CombinatorialParser[KeywordPatternAST]> = (\r^super keywordPattern\r	wrap: [:pairs | |kws kwsAST pats patsAST st ed |\r		st:: pairs first start.\r		ed:: pairs last end.\r\r		kws:: List new.\r		pats:: pairs inject: List new\r					into: [:m :p | |kwAST|\r							kwAST:: SymbolAST new\r										val: p keyword value asSymbol;\r										start: p keyword start;\r										end: p keyword end.\r							kws add: kwAST.\r							m add: p pattern; yourself].\r\r		kwsAST:: TupleAST new\r					elements: kws;\r					start: st; end: ed.\r		patsAST:: TupleAST new\r					elements: pats;\r					start: st; end: ed.\r\r		KeywordPatternAST new\r			keywords: kwsAST;\r			patterns: patsAST;\r			start: st;\r			end: ed.\r	].\r)",
 "public kwPatternPair = (\r^super kwPatternPair\r	wrapper: [:keyw :val |\r		KeywordPatternPairAST new\r			keyword: keyw;\r			pattern: (val isNil\r						ifTrue: [WildcardPatternAST\r									start: keyw end end: keyw end]\r						ifFalse: [val]);\r			start: keyw start;\r			end: (val isNil ifTrue: [keyw end] ifFalse: [val end])\r	].\r)",
 "public literalMessage = (\r	^super literalMessage wrap:\r		[:kwsOrMsg |\r		kwsOrMsg isCollection\r			ifTrue:\r				[ | sel args |\r				args:: List new.\r				sel:: kwsOrMsg inject: '' into:\r						[:s :kwd |\r						args add: (kwd at: 2).\r						s, (kwd at: 1) value].\r				MessageAST new send: sel asSymbol with: args;\r					start: kwsOrMsg first first start;\r					end: args last end]\r			ifFalse:\r				[kwsOrMsg]]\r)",
 "public literalMessageComment = (\r	^super literalMessageComment wrap:\r		[:tokens| (* beginNSComment :literalmessage: wsp literalMessage endNSComment *)\r		tokens at: 5]\r)",
 "public literalPattern ^ <CombinatorialParser[LiteralPatternAST]> = (\r^super literalPattern\r	wrap: [:litTok |\r		LiteralPatternAST new\r			literal: litTok value;\r			start: litTok start; end: litTok end.\r	].\r)",
 "public messagePattern ^ <CombinatorialParser[MessagePattern]> = (\r	^super messagePattern wrapper:\r		[:pt :rt :tp |\r		 tp isNil\r			ifTrue: [rt isNil ifFalse: [pt end: rt end]]\r			ifFalse: [pt end: tp end].\r		pt returnType: rt; typePattern: tp].\r)",
 "public methodDecl ^ <CombinatorialParser[MethodAST]> = (\r	^super methodDecl wrapper:\r		[:am :msg :eq :lp :cb :rp |\r		cb parameters: msg parameters.\r		MethodAST new\r			pattern: msg\r			body: cb\r			accessModifier: (nil = am ifTrue: [#protected] ifFalse: [am value]);\r			start: (nil = am ifTrue: [msg start] ifFalse: [am start]);\r			end: rp end]\r)",
 "public mixinApplication ^ <CombinatorialParser[MixinApplicationAST]> = (\r	^super mixinApplication wrapper:\r		[:cp <ClassPrefixAST> :mixinOp <Token> :me <Expression> |\r		 (MixinApplicationAST prefix: cp mixin: me)\r			start: cp start;\r			end: me end]\r)",
 "nestedClassDecl = (\r	halt.\r^super nestedClassDecl\r   wrapper: [:accessModifier :classDeclaration |\r	accessModifier ifNil: [\r			(* According to the language spec the accessModifier is #protected if not otherwise specified. *)\r			classDeclaration accessModifier: #protected\r		] ifNotNil: [\r			classDeclaration accessModifier: accessModifier first value ].\r	classDeclaration ]\r)",
 "public nestedPatternLiteral = (\r ^super nestedPatternLiteral wrap: [:nestedTok | nestedTok value ]\r)",
 "public nonEmptyBlockArgList = (\r	^super nonEmptyBlockArgList wrapper:\r		[:ats :vbarreturnt |\r		| targs |\r		targs:: List new addAll: ats; yourself.\r	  nil = vbarreturnt\r			ifTrue: [targs addLast: (TypeIdAST new name: #Object)]\r	        ifFalse: [targs add: (vbarreturnt at: 2)].\r		targs]\r)",
 "public nonEmptyBlockTypeArgList = (\r	^super nonEmptyBlockTypeArgList wrapper:\r		[:tas :rt |\r		| targs |\r		targs:: List new addAll:tas; yourself.\r		nil = rt\r			ifTrue: [targs addLast: (TypeIdAST new name: #Object)]\r			ifFalse: [targs add: rt last].\r		targs]\r)",
 "public nontrivialBinaryMessages ^ <CombinatorialParser[Tuple[List[MessageAST], List[MessageAST], MessageAST]]> = (\r	^super nontrivialBinaryMessages wrapper:\r		[:bmsgs <List[MessageAST]> :kwMsg <MessageAST> |\r		{{}. bmsgs. kwMsg}]\r)",
 "public number ^ <CombinatorialParser[NumberAST]> = (\r	^super number wrap: [:t | NumberAST new value: t value; start: t start; end: t end].\r)",
 "public outerReceiver ^ <CombinatorialParser[NormalSendAST]> = (\r	^super outerReceiver wrapper:\r		[:okw :idn | | osend |\r		osend:: (pseudoVariableNode: okw value asSymbol)\r			start: okw start; end: okw end.\r		UnresolvedSendAST new\r			receiver: osend;\r			message: (MessageAST new send: idn value asSymbol with: {});\r			start: osend start; end: idn end]\r)",
 "public parenthesizedExpression = (\r	^super parenthesizedExpression wrapper:\r		[:l :e :r | e].\r)",
 "public parenthesizedTypeExpression = (\r	^super parenthesizedTypeExpression wrapper:\r		[:lp :te :rp | te].\r)",
 "public parse: input inContext: context ifError: blk = (\r	[ super parse: input inContext: context ifError: blk ]\r		on: ParserError\r		do: [:ex | ^blk value: ex message with: ex position ]\r)",
 "public pattern ^ <CombinatorialParser[PatternAST]> = (\r^super pattern\r	wrapper: [:del1 :pat :del2 | pat]\r)",
 "pseudoVariableNode: psvName = (\r	(* generate a an AST representing self; used for implicit self sends *)\r	self assert: [{#self. #super. #outer.} includes: psvName] message: 'Assert failed'.\r	^VariableAST new name: psvName asSymbol; start: 0; end: 0.\r)",
 "public radix ^<Integer> = (\r	^super radix wrapper: [:ds :r | computeDigits: ds]\r)",
 "public radixNum = (\r	^super radixNum wrapper:\r		[:r <Integer> :sgn :ip <List[Character]> :fp <List[Character]> :ep <Integer> |\r		| sum <Number> |\r		assert: [ip isEmpty not] message: 'internal error: integer part is empty'.\r		sum:: computeDigits: ip radix: r.\r		nil = fp ifFalse: [sum:: sum + (computeFraction: fp radix: r)].\r		nil = sgn ifFalse: [sum:: -1 * sum].\r		nil = ep ifFalse: [sum:: sum * (10 ** ep)].\r		sum]\r)",
 "public returnStatement ^<CombinatorialParser[ReturnStatAST]> = (\r	^super returnStatement wrapper:\r		[:r :e :od |\r		 List new\r			add: (ReturnStatAST new expression: e; start: r start; end: e end);\r			yourself]\r)",
 "public returnType = (\r	^super returnType wrapper:\r		[:h :rt | rt].\r)",
 "sendMessages: msgs <List[MessageAST]> to: receiver <ExpressionAST> ^ <ExpressionAST> = (\r	(* if msgs is non-empty, the return type will always be NormalSendAST *)\r	^msgs inject: receiver into:\r		[:recv :msg |\r		 UnresolvedSendAST new\r			to: recv send: msg;\r			start: recv start; end: msg end]\r)",
 "public seqSlotDecls = (\r	^super seqSlotDecls wrapper:\r		[:vb1 :sds :vb2 | {true. sds} ].\r)",
 "public sideDecl ^ <CombinatorialParser[SideAST]> = (\r	^super sideDecl wrapper:\r		[:lp :nestedClasses :transientSlots :methods :rp |\r		 SideAST new\r			nestedClasses: nestedClasses;\r			transientSlots: transientSlots;\r			methods: methods;\r			start: lp start; end: rp end]\r)",
 "public simSlotDecls = (\r	^super simSlotDecls wrapper:\r		[:vb1 :vb2 :sds :vb3 :vb4 | {false. sds} ].\r)",
 "public slotDecl ^ <VarDeclAST> = (\r	^super slotDecl wrapper:\r		[:n :t | | end |\r		 end:: t isNil ifTrue: [n end] ifFalse: [t end].\r		 (VarDeclAST name: n value asSymbol type: t)\r			start: n start; end: end]\r)",
 "public slotDef = (\r	^super slotDef wrapper:\r		[:am :sd :init |\r		| start end slotClass expr msg |\r		start:: am isNil ifTrue: [sd start] ifFalse: [am start].\r		init isNil\r			ifTrue:\r				[end:: sd end.\r				slotClass:: MutableSlotDefAST]\r			ifFalse:\r				[end:: init last end.\r				expr:: init at: 2.\r				slotClass:: (init at: 1) value = #'::='\r					ifTrue: [MutableSlotDefAST]\r					ifFalse: [ImmutableSlotDefAST]].\r		slotClass new\r			accessModifier: (am isNil ifTrue: [#protected] ifFalse: [am value]);\r			slotDecl: sd;\r			initializer: expr;\r			start: start;\r			end: end].\r)",
 "public slotName = (\r	(* change to create a here send *)\r	^super slotName wrap:\r		[:n | | msg sn |\r		sn:: n value asSymbol.\r		(sn = #self or: [sn = #super or: [sn = #outer]])\r			ifTrue: [(pseudoVariableNode: sn) start: n start; end: n end]\r			ifFalse:\r				[msg:: MessageAST new\r					send: sn with: List new;\r					start: n start; end: n end.\r				hereSendFromMsg: msg]].\r)",
 "public statementSequence = (\r^super statementSequence\r	wrapper: [:e :rst |\r	        rst isNil\r	          ifTrue: [List new add:e; yourself]\r	          ifFalse: [List new add:e; addAll: rst; yourself]\r	 ].\r)",
 "public string ^ <CombinatorialParser[StringAST]> = (\r	^super string wrap: [:t | StringAST new value: t value; start: t start; end: t end].\r)",
 "public superclassClause = (\r	^super superclassClause wrapper:\r		[:sp :sn :msg | | constructorCall  sc |\r		 sc:: sp isNil\r			ifTrue: [hereSendFromMsg: sn]\r			ifFalse:\r				[UnresolvedSendAST new\r					receiver: sp;\r					message: (MessageAST new send: sn selector with: {});\r					start: sp start; end: sn end].\r		constructorCall:: msg isNil (* default constructor is 'new' *)\r			ifTrue: [defaultConstructorCall start: sn start; end: sn end]\r			ifFalse: [msg].\r		UnresolvedSendAST new\r			receiver: sc;\r			message: constructorCall;\r			start: sc start; end: constructorCall end]\r)",
 "public superclassPrefix = (\r	^super superclassPrefix wrap:\r		[:p | | sp |\r		sp:: p isKindOfUnresolvedSendNode\r			ifTrue: [p] (* an outer receiver *)\r			ifFalse:\r				[(pseudoVariableNode: p value asSymbol)\r					start: p start; end: p end (* a #self or #super token *)].\r		sp]\r)",
 "public symbol ^ <CombinatorialParser[SymbolAST]> = (\r	^super symbol wrap: [:t | SymbolAST new value: t value asSymbol; start: t start; end: t end].\r)",
 "public symbolConstant = (\r^super symbolConstant\r	wrapper: [:h :s | s start: h start].\r)",
 "public toplevelClass = (\r	^super toplevelClass wrapper:\r		[:cat :cd |\r		| kat |\r		cat isNil ifFalse:\r			[cd isKindOfClassDeclarationNode \r			   ifTrue: [cd header category: cat value]\r			   ifFalse: [cd category: cat value].\r			cd start: cat start].\r		cd]\r)",
 "public transientSlotDecl = (\r	^super transientSlotDecl  wrapper:\r		[:am :tm :sd :mt :expr :t |\r		| start end slotClass msg |\r\r		start:: am isNil ifTrue: [tm first start] ifFalse: [am start].\r		end:: t end.\r\r		slotClass:: mt value = #'::='\r				ifTrue: [MutableSlotDefAST]\r				ifFalse: [ImmutableSlotDefAST].\r		slotClass new\r			accessModifier: (am isNil ifTrue: [#protected] ifFalse: [am value]);\r			slotDecl: sd;\r			initializer: expr;\r			start: start;\r			end: end;\r			isTransient: true;\r			yourself.\r			].\r)",
 "public tuple = (\r^super tuple\r   wrapper: [:lc :es :rc |\r	     TupleAST new elements: es; start: lc start; end: rc end\r	 ].\r)",
 "public tupleType = (\r^super tupleType\r   wrapper: [:lc :es :rc |\r	     ParameterizedTypeAST new generic: (TypeIdAST new name: #Tuple);\r	                                     arguments: es;\r	                                     start: lc start;\r	                                     end: rc end\r	 ].\r)",
 "public type = (\r	^super type wrapper: [:lb :te :rb | te]\r)",
 "public typeArguments ^ <CombinatorialParser[{List[TypeExpr]. Token}]> = (\r^super typeArguments\r   wrapper: [:lb <Token> :tas <List[TypeExpr]> :rb <Token> |\r	       {tas. rb}\r	 ]\r)",
 "public typeExpr = (\r^super typeExpr\r   wrapper: [:lOperand :msg |\r	    | operator rOperand |\r	       msg isNil ifTrue: [ lOperand]\r	                  ifFalse: [BinaryTypeOpAST new leftOperand: lOperand;\r	                                                       operator: msg first value;\r	                                                       rightOperand: msg last;\r	                                                       start: lOperand start;\r	                                                       end: msg last end\r	                 ]\r	 ]\r)",
 "public typePrimary ^ <CombinatorialParser[TypeIdAST | GenericInvocationAST]> = (\r^super typePrimary\r   wrapper: [:g <Token> :tas <{List[TypeExpr]. Token}> |\r	    | tid <TypeIdAST> |\r	      tid:: TypeIdAST new name: g value; start: g start; end: g end.\r	      tas isNil ifTrue: [tid]\r	                ifFalse: [ParameterizedTypeAST new generic: tid;\r	                                                         arguments: tas first;\r	                                                         start: g start;\r	                                                         end: tas last end\r	               ]\r	 ]\r)",
 "public typeTerm ^ <CombinatorialParser[TypeExpression]> = (\r^super typeTerm\r   wrapper: [:operand :operators |\r	     operators inject: operand into: [:te <TypeExpression> :op |\r	                                          UnaryTypeOpAST new operand: te; operator: op value;\r	                                                                     start: te start; end: op end\r	                              ]\r	 ]\r)",
 "public unaryExpression ^ <CombinatorialParser[ExpressionAST]> = (\r	^super unaryExpression wrapper:\r		[:o <ExpressionAST> :s <List[MessageAST]> |\r		self assert: [s isNil not] message: 'Assert failed'.\r		s inject: o into:\r			[:e <ExpressionAST> :umsg <MessageAST> |\r			UnresolvedSendAST new\r				to: e send: umsg;\r				start: e start; end: umsg end]]\r)",
 "public unaryMsg ^ <CombinatorialParser[MessageAST]> = (\r	^super unaryMsg wrapper:\r		[:esend :u |\r		MessageAST new\r			send: u value asSymbol with: List new;\r			isEventual: (nil = esend) not;\r			start: u start;\r			end: u end].\r)",
 "public unaryMsgPattern ^ <MessagePatternAST> = (\r^super unaryMsgPattern\r	wrap: [:sel <Symbol> |\r	         MessagePatternAST new selector: sel value asSymbol parameters: List new;\r	                                     start: sel start; end: sel end\r	 ].\r)",
 "public variablePattern ^ <CombinatorialParser[VariablePatternAST]> = (\r^super variablePattern\r	wrapper: [:varTok | VariablePatternAST\r					variableName: (varTok value at: 2)\r					start: varTok start end: varTok end ].\r)",
 "public wildcardPattern ^ <CombinatorialParser[WildcardPatternAST]> = (\r^super wildcardPattern\r	wrap: [:wcTok | WildcardPatternAST start: wcTok start end: wcTok end ].\r)",
 "class JavascriptGeneration usingPlatform: platform = (\r(* Building blocks of Javascript syntax trees and a tree writer. The nodes are intended to represent Javascript code to be generated rather than the result of parsing an arbitrary Javascript program, so there is no provision for some ungood things such as the with statement.\r\rCopyright 2012 SAP AG.\rCopyright 2013 Ryan Macnak\r\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0\r*)\r|\r	private List = platform collections List.\r	private Map = platform collections Map.\r\r	syntax = Syntax new.\r	public factory = Factory new.\r|)",
 " ",
 " ",
 "isLegalIdentifier: id <String> ^<Boolean> = (\r	(* This is more conservative than the actual rule. *)\r	id size > 0 ifFalse: [^false].\r	id do: [:char | ('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_' includes: char) ifFalse: [^false]].\r	^id first isNumber not\r)",
 "class Factory = (\r(* Provides a set of methods to build Javascript ASTs by writing expressions more readable than those that instantiate AST classes directly. An instance is held onto by the containing module as the slot named 'factory'. It's convenient to bind that instance in a user module to a slot with a short name such as 'js', to create Javascript ASTs with expressions like\r\rjs block: {js return: (js ident: 'self')} *)\r)",
 " ",
 " ",
 "public array: elements <List[Node]> ^<ArrayExpression> = (\r	elements do: [:each | assert: [each isJsNode] message: 'JS node expected'].\r	^syntax ArrayExpression elements: elements\r)",
 "public assign: lhs <Node> toBe: rhs <Node> ^<Node> = (\r	assert: [lhs isJsNode] message: 'JS node expected on left'.\r	assert: [rhs isJsNode] message: 'JS node expected on right'.\r	^syntax AssignmentExpression leftHandSide: lhs rightHandSide: rhs\r)",
 "public block: statements <List[Node]> ^<Node> = (\r	statements do: [:each | assert: [each isJsNode] message:'Malformed statement tree'].\r	^syntax Block statements: statements\r)",
 "public call: expression <Node> with: arguments <List[Node]> = (\r	^syntax CallExpression function: expression arguments: arguments\r)",
 "public for: varName <String> in: expr <Node> do: bodyStmt <Node> = (\r	| canonicalVarName |\r	canonicalVarName:: varName isNil\r		ifTrue: [varName]\r		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].\r	^syntax ForInStatement\r		varName: canonicalVarName\r		expression: expr\r		body: bodyStmt\r)",
 "public for: initExpr while: testExpr step: incExpr do: bodyStmt = (\r	^syntax ForStatement\r		initExpression: initExpr\r		test: testExpr\r		increment: incExpr\r		body: bodyStmt\r)",
 "public function: name <String> of: params body: body <Block> = (\r	| canonicalName canonicalParams |\r	canonicalName:: name isNil\r		ifTrue: [name]\r		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].\r	canonicalParams:: params collect: [:each | each isString ifTrue: [ident: each]  ifFalse: [each]].\r	^syntax FunctionStatement name: canonicalName parameters: canonicalParams body: body\r)",
 "public functionOf: params body: body <Block> = (\r	| paramIds |\r	paramIds:: params collect: [:each | each isString ifTrue: [ident: each]  ifFalse: [each]].\r	^syntax FunctionExpression name: nil parameters: paramIds body: body\r)",
 "public ident: name <String> ^<Node> = (\r	assert: [name isString] message: 'name must be a string'.\r	^syntax IdentifierExpression name: name\r)",
 "public if: expression <Node> then: then <Node> ^<Node> = (\r	^syntax IfStatement expression: expression then: then else: nil\r)",
 "public if: expression <Node> then: then <Node> else: else <Node> ^<Node> = (\r	^syntax IfStatement expression: expression then: then else: else\r)",
 "public literal: value <Boolean | Integer | String> ^<Node> = (\r	value isString ifTrue: [^syntax StringLiteral value: value].\r	value isNumber ifTrue: [^syntax NumberLiteral value: value].\r	(true = value or: [false = value]) ifTrue: [^syntax BooleanLiteral value: value].\r	error: 'this value cannot be a Javascript literal'\r)",
 "public new: expression <Node> with: args <List[Node]> ^<Node> = (\r	^syntax NewExpression expression: expression arguments: args\r)",
 "public objectLiteral = (\r	^syntax ObjectLiteral new\r)",
 "public objectLiteral: slots <List> = (\r	slots keysAndValuesDo:\r		[:index : element |\r		assert: (index odd\r			ifTrue: [[element isString]]\r			ifFalse: [[element isJsNode]]) message: 'JS node or string expected'].\r	^syntax ObjectLiteral slots: slots\r)",
 "public objectLiteralSlotNames: names <List[String]> values: values <List[Node]> = (\r	^syntax ObjectLiteral slotNames: names values: values\r)",
 "public operator: name <String> with: left <Node> and: right <Node> = (\r	| canonicalName |\r	canonicalName:: name isNil\r		ifTrue: [name]\r		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].\r	assert: [left isJsNode] message: 'JS node expected on left'.\r	assert: [right isJsNode] message: 'JS node expected on right'.\r	^syntax OperatorExpression operator: canonicalName with: left and: right\r)",
 "public postfixOperator: name <String> on: operand <Node> = (\r	| canonicalName |\r	canonicalName:: name isNil\r		ifTrue: [name]\r		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].\r	^syntax UnaryOperatorExpression operator: canonicalName postfix: true on: operand\r)",
 "public prefixOperator: name <String> on: operand <Node> = (\r	| canonicalName |\r	canonicalName:: name isNil\r		ifTrue: [name]\r		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].\r	^syntax UnaryOperatorExpression operator: canonicalName postfix: false on: operand\r)",
 "public propertyOf: expression <Node> at: indexExpr <Node> = (\r	assert: [expression isJsNode] message: 'JS node expected'.\r	assert: [indexExpr isJsNode] message: 'JS node expected for index expression'.\r	^syntax MemberExpression primary: expression property: indexExpr\r)",
 "public propertyOf: expression <Node> atPath: path <List[Node]> = (\r	assert: [expression isJsNode] message: 'JS node expected'.\r	^path isEmpty\r		ifTrue: [expression]\r		ifFalse:\r			[propertyOf: (propertyOf: expression at: path first)\r				atPath: (path copyFrom: 2 to: path size)]\r)",
 "public return = (\r	^syntax ReturnStatement expression: nil\r)",
 "public return: expression <Node | nil> = (\r	^syntax ReturnStatement expression: expression\r)",
 "public script: statements <List[Node]> = (\r	^syntax Script statements: statements\r)",
 "public ternaryIf: condition then: then else: else = (\r	^syntax TernaryOperatorExpression\r		if: condition\r		then: then\r		else: else\r)",
 "public throw: expression <Node> ^<Node> = (\r	^syntax ThrowStatement expression: expression\r)",
 "public try: block <Block> catch: varName <String> with: catchBlock <Block> = (\r	| canonicalVarName |\r	canonicalVarName:: varName isNil\r		ifTrue: [varName]\r		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].\r	^syntax TryStatement block: block catch: canonicalVarName with: catchBlock finally: nil\r)",
 "public try: block <Block> catch: varName <String> with: catchBlock <Block> finally: finallyBlock <Block> = (\r	| canonicalVarName |\r	canonicalVarName:: varName isNil\r		ifTrue: [varName]\r		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].\r	^syntax TryStatement block: block catch: canonicalVarName with: catchBlock finally: finallyBlock\r)",
 "public try: block <Block> finally: finallyBlock <Block> = (\r	^syntax TryStatement block: block catch: nil with: nil finally: finallyBlock\r)",
 "public var: name <String> ^<VariableStatement> = (\r	| canonicalName |\r	canonicalName:: name isNil\r		ifTrue: [name]\r		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].\r	^syntax VariableStatement name: canonicalName initializer: nil\r)",
 "public var: name <String> value: expr <Node> ^<VariableStatement> = (\r	| canonicalName |\r	canonicalName:: name isNil\r		ifTrue: [name]\r		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].\r	^syntax VariableStatement name: canonicalName initializer: expr\r)",
 "public verbatim: text <String> = (\r	 assert: [text isString] message: 'String expected'.\r	^syntax VerbatimNode text: text\r)",
 "class Syntax = (\r(* The AST nodes. The preferred way to construct instances is to use the factory object (an instance of Factory, a sibling of this class) held onto by the module. *)\r)",
 " ",
 " ",
 "public class ArrayExpression elements: elements = Node (\r(* An array constructor expression. *)\r|\r	protected elements_ = elements.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and: [elements = anotherNode elements]\r)",
 "public elements = (\r	^elements_\r)",
 "public visitBy: visitor = (\r	^visitor visitArrayExpression: self\r)",
 "public class AssignmentExpression leftHandSide: lhs rightHandSide: rhs = Node (|\r	public leftHandSide <Expression> = lhs.\r	public rightHandSide <Expression> = rhs.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode\r		and: [leftHandSide = anotherNode leftHandSide\r			and: [rightHandSide = anotherNode rightHandSide]]\r)",
 "public isOperatorExpression = (\r	^true\r)",
 "public printOn: stream = (\r	super printOn: stream.\r	stream nextPutAll: ' ('.\r	leftHandSide printOn: stream.\r	stream nextPutAll: ', '.\r	rightHandSide printOn: stream.\r	stream nextPutAll: ')'\r)",
 "public visitBy: visitor = (\r	^visitor visitAssignmentExpression: self\r)",
 "public class Block statements: s = Node (\r(* Block; ECMA-262 p. 220. *)\r|\r	statementsS <List[Statement | Expression]> = s.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and: [statements = anotherNode statements]\r)",
 "public asBlock = (\r	^self\r)",
 "public statements = (\r	^statementsS\r)",
 "public visitBy: visitor = (\r	^visitor visitBlock: self\r)",
 "public empty = (\r	^Block statements: {}\r)",
 "public class BooleanLiteral value: b <Boolean> = Node (|\r	valueS = b.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and: [value = anotherNode value]\r)",
 "public printOn: stream = (\r	super printOn: stream.\r	stream nextPutAll: ' ('.\r	value printOn: stream.\r	stream nextPutAll: ')'\r)",
 "public value = (\r	^valueS\r)",
 "public visitBy: visitor = (\r	^visitor visitBooleanLiteral: self\r)",
 "public class CallExpression function: f arguments: args = Node (\r(* expression ( arguments ) *)\r|\r	public function <Expression> = f.\r	public arguments <List[Expression]> = args.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[function = anotherNode function and: [arguments = anotherNode arguments]]\r)",
 "public visitBy: visitor = (\r	^visitor visitCallExpression: self\r)",
 "public class DeleteExpression memberExpression: m = Node (\r(* AST node for the delete operator. *)\r|\r	public memberExpression <MemberExpression> = m.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[memberExpression = anotherNode memberExpression]\r)",
 "public visitBy: visitor = (\r	^visitor visitDeleteExpression: self\r)",
 "public class ForInStatement varName: name <IdentifierExpression> expression: expr body: body = Node (|\r	public varName = name.\r	public expression = expr.\r	public body = body.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[varName = anotherNode varName and:\r		[expression = anotherNode expression and:\r		[body = anotherNode body]]]\r)",
 "public visitBy: visitor = (\r	^visitor visitForInStatement: self\r)",
 "public class ForStatement initExpression: initExpr test: testExpr increment: incExpr body: body = Node (|\r	public initExpression = initExpr.\r	public testExpression = testExpr.\r	public incrementExpression = incExpr.\r	public body = body.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[initExpression = anotherNode initExpression and:\r		[testExpression = anotherNode testExpression and:\r		[incrementExpression = anotherNode incrementExpression and:\r		[body = anotherNode body]]]]\r)",
 "public visitBy: visitor = (\r	^visitor visitForStatement: self\r)",
 "public class FunctionExpression name: s <IdentifierExpression | nil> parameters: names <List[IdentifierExpression]> body: b = Node (\r(* FunctionExpression. ECMA-262, p. 262. *)\r|\r	public name <IdentifierExpression | nil> = s.\r	public parameters <List[IdentifierExpression]> = names.\r	public body <Block> = b asBlock.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[name = anotherNode name and:\r		[parameters = anotherNode parameters and:\r		[body = anotherNode body]]]\r)",
 "public isFunctionExpression = (\r	^true\r)",
 "public visitBy: visitor = (\r	^visitor visitFunctionExpression: self\r)",
 "public parameters: names <List[IdentifierExpression]> body: b <Node> = (\r	^FunctionExpression name: nil parameters: names body: b\r)",
 "public class FunctionStatement name: s parameters: names body: b = FunctionExpression name: s parameters: names body: b (\r(* A function statement. Essentially the same thing as a function expression, but needs to be written out differently. Note that unlike in a function expression, the name argument is not optional. TODO: should we move name up to this class and make function expressions anonymous? What does the standard say? *)\r)",
 "name: s parameters: names body: b",
 "name: s parameters: names body: b",
 "public visitBy: visitor = (\r	^visitor visitFunctionStatement: self\r)",
 "public class IdentifierExpression name: s <String> = Node (\r(* a case of PrimaryExpression *)\r|\r	nameS = s.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and: [name = anotherNode name]\r)",
 "public name = (\r	^nameS\r)",
 "public printOn: stream = (\r	super printOn: stream.\r	stream nextPutAll: ' ('.\r	stream nextPutAll: name.\r	stream nextPutAll: ')'\r)",
 "public visitBy: visitor = (\r	^visitor visitIdentifierExpression: self\r)",
 "public class IfStatement expression: expr then: then else: else = Node (\r(* if ( expression ) thenStatement else elseStatement *)\r|\r	public expression = expr.\r	public thenStatement = then.\r	public elseStatement = else.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[expression = anotherNode expression and:\r		[thenStatement = anotherNode thenStatement and:\r		[elseStatement = anotherNode elseStatement]]]\r)",
 "public visitBy: visitor = (\r	^visitor visitIfStatement: self\r)",
 "public expression: expr then: then = (\r	^IfStatement expression: expr then: then else: nil\r)",
 "public class MemberExpression primary: expr <Expression> property: p <Node> = Node (\r(* primary[property] *)\r|\r	public primary = expr.\r	public property = p.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[primary = anotherNode primary and:\r		[property = anotherNode property]]\r)",
 "public visitBy: visitor = (\r	^visitor visitMemberExpression: self\r)",
 "public class NewExpression expression: expr arguments: args = Node (\r(* new expr ( arg, .... ) *)\r|\r	public expression = expr.\r	public arguments = args.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[expression = anotherNode expression and:\r		[arguments = anotherNode arguments]]\r)",
 "public visitBy: visitor = (\r	^visitor visitNewExpression: self\r)",
 "class Node = (\r(* The superclass of all other nodes, both statements and expressions. *)\r|\r	public comment <String>\r|)",
 " ",
 " ",
 "public = anotherNode = (\r	^class = anotherNode class\r)",
 "public asBlock = (\r	^Block statements: {self}\r)",
 "public isFunctionExpression = (\r	^false\r)",
 "public isJsNode = (\r	^true\r)",
 "public isNumberLiteral ^<Boolean> = (\r	^false\r)",
 "public isOperatorExpression = (\r	^false\r)",
 "public class NumberLiteral value: v <Number> = Node (|\r	valueS = v.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[value = anotherNode value]\r)",
 "public isNumberLiteral ^<Boolean> = (\r	^true\r)",
 "public printOn: stream = (\r	super printOn: stream.\r	stream nextPutAll: ' ('.\r	value printOn: stream.\r	stream nextPutAll: ')'\r)",
 "public value = (\r	^valueS\r)",
 "public visitBy: visitor = (\r	^visitor visitNumberLiteral: self\r)",
 "public class ObjectLiteral = Node (\r(* Object literal. ECMA-262, p. 216. *)\r|\r	public slotNames = List new.\r	public slotValues = List new.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[slotNames = anotherNode slotNames and:\r		[slotValues = anotherNode slotValues]]\r)",
 "public addSlot: name <String> value: object = (\r	slotNames addLast: name.\r	slotValues addLast: object\r)",
 "public slotCount = (\r	^slotNames size\r)",
 "public slotsDo: aBlock = (\r	(* Invoke a two-argument aBlock with the name and the value of each slot in this literal. *)\r	^slotNames with: slotValues do: aBlock\r)",
 "public slotsDo: aBlock betweenDo: betweenBlock = (\r	(* Invoke a two-argument aBlock with the name and the value of each slot in this literal. Between the invocations (but not after the last one), invoke the betweenBlock. *)\r	| lastIndex |\r	lastIndex:: slotNames size.\r	1 to: lastIndex do:\r		[:index |\r		aBlock value: (slotNames at: index) value: (slotValues at: index).\r		index = lastIndex ifFalse: [betweenBlock value]]\r)",
 "public visitBy: visitor = (\r	^visitor visitObjectLiteral: self\r)",
 "public slotNames: names values: values = (\r	| instance |\r	instance:: ObjectLiteral new.	\r	1 to: names size do: \r		[:index | instance addSlot: (names at: index) value: (values at: index)].\r	^instance\r)",
 "public slots: namesAndValues = (\r	| instance |\r	namesAndValues size odd ifTrue: [error: 'invalid slot initialization data'].\r	instance:: ObjectLiteral new.\r	1 to: namesAndValues size by: 2 do:\r		[:i |\r		instance addSlot: (namesAndValues at: i) value: (namesAndValues at: i + 1)].\r	^instance\r)",
 "public class OperatorExpression operator: name <String> with: left <Node> and: right <Node> = Node (|\r	public operatorName = name.\r	public left = left.\r	public right = right.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[operatorName = anotherNode operatorName and:\r		[left = anotherNode left and:\r		[right = anotherNode right]]]\r)",
 "public isOperatorExpression = (\r	^true\r)",
 "public visitBy: visitor = (\r	^visitor visitOperatorExpression: self\r)",
 "public class ReturnStatement expression: expr = Node (\r(* return expression/opt. *)\r|\r	expressionS = expr.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and: [expression = anotherNode expression]\r)",
 "public expression = (\r	^expressionS\r)",
 "public printOn: stream = (\r	super printOn: stream.\r	stream nextPutAll: ' ('.\r	expression printOn: stream.\r	stream nextPutAll: ')'\r)",
 "public visitBy: visitor = (\r	^visitor visitReturnStatement: self\r)",
 "public class Script statements: statements <List[Node]> = Node (\r(* A series of statements, a top-level node to hold them together. *)\r|\r	statements_ = statements.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and: [statements = anotherNode statements]\r)",
 "public statements ^<List[Node]> = (\r	^statements_\r)",
 "public visitBy: visitor = (\r	^visitor visitScript: self\r)",
 "public class StringLiteral value: string <String> = Node (|\r	valueS = string.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[value = anotherNode value]\r)",
 "public isStringLiteral ^<Boolean> = (\r	^true\r)",
 "public printOn: stream = (\r	super printOn: stream.\r	stream nextPutAll: ' ('.\r	value printOn: stream.\r	stream nextPutAll: ')'\r)",
 "public value = (\r	^valueS\r)",
 "public visitBy: visitor = (\r	^visitor visitStringLiteral: self\r)",
 "public class TernaryOperatorExpression if: condExpr then: thenExpr else: elseExpr = Node (|\r	public condition = condExpr.\r	public then = thenExpr.\r	public else = elseExpr.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[condition = anotherNode condition and:\r		[then = anotherNode then and:\r		[else = anotherNode else]]]\r)",
 "public visitBy: visitor = (\r	^visitor visitTernaryOperatorExpression: self\r)",
 "public class ThrowStatement expression: expr = Node (|\r	expressionS = expr.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and: [expression = anotherNode expression]\r)",
 "public expression = (\r	^expressionS\r)",
 "public visitBy: visitor = (\r	^visitor visitThrowStatement: self\r)",
 "public class TryStatement block: pb <Block> catch: cvar <IdentifierExpression | nil> with: cb <Block | nil> finally: fb <Block | nil> = Node (\r(* ECMA-262 p. 222 *)\r|\r	public protectedBlock = pb.\r	public catchVar = cvar.\r	public catchBlock = cb.\r	public finallyBlock = fb.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[protectedBlock = anotherNode protectedBlock and:\r		[catchVar = anotherNode catchVar and:\r		[catchBlock = anotherNode catchBlock and:\r		[finallyBlock = anotherNode finallyBlock]]]]\r)",
 "public visitBy: visitor = (\r	^visitor visitTryStatement: self\r)",
 "public class UnaryOperatorExpression operator: name <String> postfix: postfix <Boolean> on: node <Node> = Node (\r(* A unary operator application, either prefix or postfix. *)\r|\r	public operatorName <String> = name.\r	public isPostfix <Boolean> = postfix.\r	public operand <Node> = node.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[operatorName = anotherNode operatorName and:\r		[isPostfix = anotherNode isPostfix and:\r		[operand = anotherNode operand]]]\r)",
 "public visitBy: visitor = (\r	^visitor visitUnaryOperatorExpression: self\r)",
 "public class VariableStatement name: n <IdentifierExpression> initializer: expr <Expression> = Node (\r(* var name [= expression] *)\r|\r	public name = n.\r	public initializer = expr.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and:\r		[name = anotherNode name and:\r		[initializer = anotherNode initializer]]\r)",
 "public printOn: stream = (\r	super printOn: stream.\r	stream nextPutAll: ' ('.\r	name printOn: stream.\r	stream nextPutAll: ', '.\r	initializer printOn: stream.\r	stream nextPutAll: ')'\r)",
 "public visitBy: visitor = (\r	^visitor visitVariableStatement: self\r)",
 "public name: s = (\r	^VariableStatement name: s initializer: nil\r)",
 "public class VerbatimNode text: s <String> = Node (\r(* A node holding onto arbitrary text, to be emitted verbatim into the generated Javascript source. Nothing but the text is emitted, however the context may insert additional tokens before or after the text. For example if a verbatim node appears as a statement in a block, it will have a terminating semicolon. *)\r|\r	public text = s.\r|)",
 "Node",
 "Node",
 "public = anotherNode = (\r	^super = anotherNode and: [text = anotherNode text]\r)",
 "public visitBy: visitor = (\r	^visitor visitVerbatimNode: self\r)",
 "public class Writer = (\r(* Writes out a tree of Javascript syntax elements. *)\r|\r	private output <StringBuilder>\r	private tabLevel <Integer>\r	private stringTranslation = Map new.\r|stringTranslation at: \"\\\" put: '\\\\'.\r	stringTranslation at: Character cr put: '\\r'.\r	stringTranslation at: Character lf put: '\\n'.\r	stringTranslation at: \"\"\" put: '\\\"')",
 " ",
 " ",
 "beginNewWriteCycleUsing: sb <StringBuilder> = (\r	output:: sb.\r	tabLevel:: 0.\r)",
 "contents ^<String> = (\r	(* Answer the Javascript source generated last. *)\r	^output asString\r)",
 "cr = (\r	(* Write a newline and the next line's indentation. *)\r	output add: String lf.\r	tabLevel timesRepeat: [output add: ' ']\r)",
 "public generateSourceFor: node <Node> on: sb <StringBuilder> = (\r	(* Generate Javascript source to represent the node, writing it out to the stream. *)\r	beginNewWriteCycleUsing: sb.\r	node visitBy: self.\r)",
 "inIndentedBlock: closure = (\r	write: '{'.\r	indentCr.\r	^closure ensure:\r		[unindentCr.\r		write: '}']\r)",
 "indentCr = (\r	tabLevel: tabLevel + 1.\r	cr\r)",
 "unindentCr = (\r	tabLevel:: 0 max: tabLevel - 1.\r	cr\r)",
 "public visitArrayExpression: node <ArrayExpression> = (\r	| elements |\r	elements: node elements.\r	elements isEmpty ifTrue:\r		[^write: '[]'].\r	elements size = 1 ifTrue:\r		[write: '['.\r		elements first visitBy: self.\r		^write: ']'].\r	write: '['.\r	indentCr.\r	elements\r		do:\r			[:each | each visitBy: self]\r		separatedBy:\r			[write: ','.\r			cr].\r	unindentCr.\r	write: ']'\r)",
 "public visitAssignmentExpression: node <AssignmentExpression> = (\r	node leftHandSide visitBy: self.\r	write: ' = '.\r	node rightHandSide visitBy: self.\r)",
 "public visitBlock: node <Block> = (\r	| statements |\r	statements: node statements.\r	statements isEmpty ifTrue:\r		[^write: '{}'].\r	write: '{'.\r	indentCr.\r	statements\r		do:\r			[:each |\r			each visitBy: self.\r			write: ';']\r		separatedBy:\r			[cr].\r	unindentCr.\r	write: '}'\r)",
 "public visitBooleanLiteral: node <BooleanLiteral> = (\r	write:: node value ifTrue: ['true'] ifFalse: ['false']\r)",
 "public visitCallExpression: node <CallExpression> = (\r	| parenthesize |\r	parenthesize:: node function isFunctionExpression.\r	parenthesize ifTrue: [write: '('].\r	node function visitBy: self.\r	parenthesize ifTrue: [write: ')'].\r	write: '('.\r	node arguments\r		do:\r			[:arg |\r			arg visitBy: self]\r		separatedBy:\r			[write: ', '].\r	write: ')'\r)",
 "public visitDeleteExpression: node <DeleteExpression> = (\r	write: 'delete '.\r	node memberExpression visitBy: self.\r)",
 "public visitForInStatement: node = (\r	write: 'for ('.\r	node varName visitBy: self.\r	write: ' in '.\r	node expression visitBy: self.\r	write: ') '.\r	node body asBlock visitBy: self.\r)",
 "public visitForStatement: node = (\r	write: 'for ('.\r	node initExpression visitBy: self.\r	write: '; '.\r	node testExpression visitBy: self.\r	write: '; '.\r	node incrementExpression visitBy: self.\r	write: ') '.\r	node body asBlock visitBy: self.\r)",
 "public visitFunctionExpression: node <FunctionExpression> = (\r	visitFunctionStatement: node.\r)",
 "public visitFunctionStatement: node <FunctionStatement> = (\r	write: 'function '.\r	node name ifNotNil:\r		[:name |\r		name visitBy: self.\r		write: ' '].\r	write: '('.\r	node parameters\r		do: [:each | each visitBy: self]\r		separatedBy: [write: ', '].\r	write: ') '.\r	writeBlock: node body.\r)",
 "public visitIdentifierExpression: node <IdentifierExpression> = (\r	write: node name\r)",
 "public visitIfStatement: node <IfStatement> = (\r	write: 'if ('.\r	node expression visitBy: self.\r	write: ') '.\r	writeBlock: node thenStatement asBlock.\r	node elseStatement ifNotNil:\r		[:else |\r		write: ' else '.\r		writeBlock: node elseStatement asBlock]\r)",
 "public visitMemberExpression: node <MemberExpression> = (\r	| parenthesize |\r	parenthesize:: (node primary isNumberLiteral\r		or: [node primary isOperatorExpression])\r		or: [node primary isFunctionExpression].\r	parenthesize ifTrue: [write: '('].\r	node primary visitBy: self.\r	parenthesize ifTrue: [write: ')'].\r\r	(node property isStringLiteral and: [isLegalIdentifier: node property value])\r		ifTrue: 	[write: '.'.\r				 write: node property value]\r		ifFalse: [write: '['.\r				 node property visitBy: self.\r				 write: ']']\r)",
 "public visitNewExpression: node <NewExpression> = (\r	write: 'new '.\r	node expression visitBy: self.\r	write: '('.\r	node arguments\r		do:\r			[:arg |\r			arg visitBy: self]\r		separatedBy:\r			[write: ', '].\r	write: ')'\r)",
 "public visitNumberLiteral: node <NumberLiteral> = (\r	write: node value printString\r)",
 "public visitObjectLiteral: node <ObjectLiteral> = (\r	node slotCount = 0 ifTrue:\r		[write: '{}'.\r		^self].\r	write: '{'.\r	indentCr.\r	node\r		slotsDo:\r			[:name :value |\r			name visitBy: self.\r			write: ': '.\r			value visitBy: self]\r		betweenDo:\r			[write: ','.\r			cr].\r	unindentCr.\r	write: '}'\r)",
 "public visitOperatorExpression: node <OperatorExpression> = (\r	| parenthesizeLeft parenthesizeRight |\r	parenthesizeLeft:: node left isOperatorExpression.\r	parenthesizeRight:: node right isOperatorExpression.\r	parenthesizeLeft ifTrue: [write: '('].\r	node left visitBy: self.\r	parenthesizeLeft ifTrue: [write: ') '] ifFalse: [write: ' '].\r	node operatorName visitBy: self.\r	parenthesizeRight ifTrue: [write: ' ('] ifFalse: [write: ' '].\r	node right visitBy: self.\r	parenthesizeRight ifTrue: [write: ')']\r)",
 "public visitReturnStatement: node <ReturnStatement> = (\r	write: 'return'.\r	node expression ifNotNil:\r		[:expr |\r		write: ' '.\r		expr visitBy: self]\r)",
 "public visitScript: node <Script> = (\r	node statements\r		do:\r			[:each |\r			each visitBy: self.\r			write: ';']\r		separatedBy:\r			[cr.\r			cr].\r)",
 "public visitStringLiteral: node <StringLiteral> = (\r	write: '\"'.\r	node value do:\r		[:each | | s |\r		s:: stringTranslation\r			at: each\r			ifAbsent: [{each}].\r		write: s].\r	write: '\"'\r)",
 "public visitTernaryOperatorExpression: node = (\r	write: '('.\r	node condition visitBy: self.\r	write: ' ? '.\r	node then visitBy: self.\r	write: ' : '.\r	node else visitBy: self.\r	write: ')'\r)",
 "public visitThrowStatement: node <ThrowStatement> = (\r	write: 'throw '.\r	node expression visitBy: self\r)",
 "public visitTryStatement: node <TryStatement> = (\r	write: 'try '.\r	writeBlock: node protectedBlock.\r	node catchBlock ifNotNil:\r		[:catch |\r		write: ' catch ('.\r		node catchVar visitBy: self.\r		write: ') '.\r		writeBlock: catch].\r	node finallyBlock ifNotNil:\r		[:finally |\r		write: ' finally '.\r		writeBlock: finally]\r)",
 "public visitUnaryOperatorExpression: node <UnaryOperatorExpression> = (\r	| isPostfix isOnOperator |\r	isPostfix:: node isPostfix.\r	isOnOperator:: node operand isOperatorExpression.\r	isPostfix ifFalse: [node operatorName visitBy: self].\r	isOnOperator ifTrue: [write: '(']. (* not always necessary, but safer *)\r	node operand visitBy: self.\r	isOnOperator ifTrue: [write: ')'].\r	isPostfix ifTrue: [node operatorName visitBy: self].\r)",
 "public visitVariableStatement: node <VariableStatement> = (\r	write: 'var '.\r	node name visitBy: self.\r	node initializer ifNotNil:\r		[:expr |\r		write: ' = '.\r		expr visitBy: self].\r)",
 "public visitVerbatimNode: node = (\r	write: node text\r)",
 "write: text <String> = (\r	output add: text\r)",
 "writeBlock: block = (\r	| statements |\r	statements: block statements.\r	statements isEmpty\r		ifTrue: [write: '{}']\r		ifFalse:\r			[inIndentedBlock:\r				[statements\r					do:\r						[:each |\r						each visitBy: self.\r						write: ';']\r					separatedBy:\r						[cr]]]\r)",
 "class Newspeak2V8Compilation usingPlatform: platform asts: asts parsing: parsing generation: generation = NewspeakCompilation usingPlatform: platform asts: asts (\r(*\rThis module provides a Newspeak-to-Javascript cross-compiler. It is a descendent of Newspeak2Javascript which takes care to generate code that is easier for V8 to optimize and which is easier to maintain because of a simpler bootstrapping story and strategy for including bits that need to be written directly in Javascript.\r\rThe output is not V8-specific and should run in any Javascript implementation that supports apply(), call() and bind().\r\rThe current compilation scheme does not address async sends or reified activation records. It provides only limited support for refection. Also,  it does not provide generalized mixin application.\r\rAt runtime, a Newspeak object O is represented as a Javascript object J with properties that correspond directly to the Newspeak slots. The prototype of J is a runtime-class JRC, whose properties correspond to the instance methods of O's class, including any necessary synthetic methods. The prototype of JRC is another runtime class object corresponding to the superclass of O's class, and so on up to Object. The prototype of the runtime class of Object is ImplementationBase, which is hand-written and contains stub implementations to end the upward recursion in basicNew and the instance initializers.JRC includes synthetic slots that refer to its runtime mixin, its enclosing object chain, and its metaclass or non-metaclass counterpart.\r\rThe main output of the compiler is an object containing all of the runtime mixins corresponding to the top-level class declarations. A runtime mixin has properties containing the definitions of its Newspeak and synthetic methods and its nested mixins. It also has a function that takes a runtime superclass and produces a runtime class that represents the application of the mixin. This function produces either a runtime class or a runtime metaclass, not the pair.\r\rOne synthetic method deserves particular attention: basicNew(). The prototype of basicNew is the runtime class. The body of basicNew calls the basicNew of the superclass using call(), then initializes properties corresponding to each Newspeak slot to nil.\r\rAll mixin applications share the same Newspeak and synthetic functions, except basicNew.\r\r[PERFORMANCE NOTE] It is important that objects have all their slots initialized up front, rather than lazily. This ensures that all instances of the same Newspeak class go through the same transitions in the same order so V8 will give them all the same \"hidden class\" (what Self called a map).\r\r[PERFORMANCE NOTE] It is important that an object's methods are defined in a prototype, rather than in the constructor call. If they were defined in the constructor, they would be different objects with different contexts.\r\r[PERFORMANCE NOTE] The current structure where the functions for methods are defined in other deeply nested functions may produce functions that perform slower than if they had been defined at the top level. This is because of a need to give them contexts, even if they never access their free variables. This used to be an issue in V8, but it was fixed under pressure from dart2js (who wanted to nest all of their code at least one level to avoid polluting the global scope). It may still be the case in other Javascript engines.Object creation follows the same pattern as the Squeak and Dart implementations: basicNew is followed by running a synthetic instance initializer.\r\rMixin application is implemented by a hand-written method on VMMirror. First a pair of runtime class and runtime metaclass are produced by applying the runtime mixin and runtime metamixin to the runtime class of the superclass and the runtime class of Class, respectively. Then an instance of Metaclass is created to represent the Newspeak metaclass, and an instance of the metaclass is created to represent the Newspeak class. Newspeak objects never directly interact with runtime classes or runtime mixins; the objects answered by #class are the Newspeak class or metaclass.\r\rSelf sends and ordinary sends map to Javascript method invocation. Outer sends map to an invocation on an entry in the enclosing objects array at the correct depth. Implicit receiver sends are resolved either as the self sends or outer sends at compile-time. Super sends are implemented as call() applied to the corresponding property of the runtime superclass.\r\rNewspeak selectors are mangled into legal Javascript identifiers. The mangling differs according to the accessibility of the selector. Public selectors are always prefixed with $. In addition,  keyword selectors have each colon replaced with dollar. For binary selectors, they are the concatenation of a mapping for each of the special characters. Examples:\r\ryourself maps to $yourself.\r\rwith:with: maps to $with$with$. +- maps to $$plus$minus.\r\rFor protected selectors, the public mangling is preceded with an underscore. Hence yourself maps to _$yourself.with:with: maps to _$with$with$. +- maps to _$$plus$minus.The selector #doesNotUnderstand: is treated specially and mapped to dnu.\r\rA full description of the access control scheme is available at:\r\rhttps://docs.google.com/document/d/1CHTjsOsamXv9AwGTvkhe871QVY5vpZP9sDfz6I40gaA/\r\r[PERFORMANCE NOTE] It is important that we use legal identifiers for our property names. The earlier NS2JS did not mangle selectors and instead used square bracket notation to access properties. For example, foo at: 1 put: 2 would become foo[\"#at:put:\"](1,2) rather than foo.at$put$(1,2). V8 eagerly transitions objects like these to dictionary mode, which means they do not have fast property access. This is the most important difference between NS2JS and NS2V8.\r\rNon-local return is implemented using exceptions. The body of a method containing an NLR is wrapped in a try-catch block. At the beginning, an object is created to represent the current activation. When there is a non-local return, the return value is assigned to a property of this object and the object is thrown. The catch clause checks if the object thrown corresponds to its NLR object, and if so extracts the value and does a Javascript (local) return. Otherwise the object is re-thrown.\r\r[ENGINEERING NOTE]This is buggy, because if a closure returns after its home context has completed, the exception will not be caught and the entire program will crash (even when debugging in the IDE).  A method that contains an NLR must invalidate its NLR exception object when it exits, and closures must check the validity of the NLR exception before throwing; if it is in valid, a CannotReturn must be signaled. The best way to accomplish all this is to set the variable holding the NLR exception to nil upon home context exit, so that the closure can test for nil when executing an NLR. This will have very minor performance impact.\r\rNewspeak closures map to Javascript functions. Accesses to self do *not* map directly to \"this\". Rather the receiver must be captured in a local at the beginning of a method, and access must be through this local to get proper lexical scope.\r\r[UNIMPLEMENTED] This representation is not suitable for closure mirrors as there is no way in Javascript to get at the closure's free variables. To support closure mirrors, we would have create objects for each closure that took free variables and the enclosing context as arguments and stored them as slots that reflection could later access. dart2js follows this approach (but I believe this is to ensure they cannot be called with the wrong arity).\r\rTo implement #doesNotUnderstand:, for every message sent the compiler emits a DNU catcher that creates a Message object from the arguments and forwards to #doesNotUnderstand:.  At bootstrap, these handlers are all installed into ImplementationBase under both the public and protected manglings of the selector.\r\r[PERFORMANCE NOTE] It is important that these prototypes are all installed up-front, rather than the subset needed at each mixin application, to ensure the prototype chain is stable during the program's execution. Installing these catchers later would trigger deoptimizations.\r\rThe basic types (number, array, block, boolean, string) are represented directly as their Javascript counterparts. Where the Javascript behavior differs from the Newspeak behavior, we monkey patch the Javascript prototypes.\r\r[ENGINEERING NOTE] These patches are all defined in classes of KernelForV8, using the js intrinsic described below. Unlike NS2JS, there is no need to look through several places and bootstrapping phases to find where such behavior is defined. Adding or modifying behavior for the basic types is as easy as adding or changing methods in these classes.\r\r[PERFORMANCE NOTE] It is important that these patches are labelled for strict mode to avoid automatic boxing.\r\r[ENGINEERING NOTE] We simply label the whole program for script mode, but if our output got wrapped in or otherwise mixed with other scripts, it wouldn't run in script mode.\r\r[ENGINEERING NOTE] dart2js does not use this technique because they want to interoperate with other Javascript code. Instead they use a technique called interceptors, and can avoid the cost in the common case through fancy type inference and inlining that make runtime modification very difficult. Newspeak doesn't want to go there and is content to monkey patch.\r\r[ENGINEERING NOTE] Like dart2js, we cave on the semantics of integers by directly representing our numbers as Javascript numbers, which are doubles.\r\rNil is not represented as Javascript's null. We use a singleton instance of the Newspeak class UndefinedObject.\r\rSource code is not stored with the methods. Instead, each runtime class has an associated metadata structure that contains an index into an array of method sources. The metadata is stored in an array accessed via the property 'methods'. Each method has an entry with properties 'name', 'isSynthetic' and 'source'. This array is stored in the Javascript global variable 'sources'.  The deployment tools can place the code for initializing this array in a separate file, so deployments that do not wish to support debugging can easily avoid the space penalty for the source.\r\rBootstrapping: the compiled Javascript starts by hand-initializing the classes of Kernel to deal with the circular references. Then a namespace is populated with the applications of each of the top-level mixins to Object. This namespace is passed to the factory of RuntimeForV8, and the returned object is passed the VMMirror. This causes the platform object to be created and initialized. As part of this process, the DNU catchers and basic type monkey patches are installed. The application configuration is then passed the namespace, and the returned app object is sent #main:args: with the platform.  (Newspeak2Dart follows the same pattern, though without DNU catcher or basic type patches.)\r\r[ENGINEERING NOTE] This is *way* simpler than whatever multi-phase thing NS2JS is doing.\r\rThe js intrinsic: When compiling the platform sources, we evaluate sends to \"js\" at compile-time against a factory for Javascript ASTs (an instance of JavascriptGeneration`Factory). For instance,\r\rat: index = (	^js propertyOf: (js ident: 'this') at: index - 1)\r\rtranslates to\r\rfunction $at$(index) { return this[index - 1]; }\r\rNote that arguments in messages to \"js\" can be arbitrary expressions (index - 1), which will be compiled like any other ordinary expression, allowing one to write implementations partially in the target language and partially in ordinary Newspeak in the same method.\r\rThis scheme allows the implementations of primitives to be written in the methods they are implementing and without special language support like pragmas, externs or native clauses, which I think is pretty cool :)\r\r[UNIMPLEMENTED] Async sends\r\r[UNIMPLEMENTED] Reflective modification\r\rThis brings up several issues.\r\r(1) Because implicit sends are resolved statically to self sends or outer sends, it is not sufficient to just add or remove methods. Potentially, the entire class must be recompiled if the change hides/unhides a method in the surrounding scope.\r\r(2) Adding a new selector requires adding a new DNU catcher in ImplementationBase, which may have very negative effects on performance.  We could try and rely on the ES6 handlers if we only care about new browsers.\r\r[UNIMPLEMENTED] Reified activation records\rThese are needed to provide a proper live debugger.\r\rCopyright 2008 Cadence Design Systems, Inc.\rCopyright 2009-2010 Gilad Bracha.\rCopyright 2012 SAP AG.\rCopyright 2012 Google Inc.\rCopyright 2013 Ryan Macnak\rCopyright 2014-2017 Google Inc.\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0\r*)\r|\r	Collection = platform collections Collection.\r	Map = platform collections Map.\r	List = platform collections List.	Set = platform collections Set.\r	StringBuilder = platform kernel StringBuilder.\r	Parser = parsing Parser.\r	javascriptGeneration = generation.\r	JavascriptWriter = javascriptGeneration Writer.\r	js = javascriptGeneration factory.\r	public names = NameMangler new.\r	ASTTool = asts ASTTool.\r	AST = asts AST.\r	BlockAST = asts BlockAST.\r	CascadedSendAST = asts CascadedSendAST.\r	CodeBodyAST = asts CodeBodyAST.\r	MessageAST = asts MessageAST.\r	MessagePatternAST = asts MessagePatternAST.\r	MethodAST = asts MethodAST.\r	UnresolvedSendAST = asts UnresolvedSendAST.\r	NumberAST = asts NumberAST.\r	ReturnStatAST = asts ReturnStatAST.\r	SendAST = asts SendAST.\r	SymbolAST = asts SymbolAST.\r	TupleAST = asts TupleAST.\r	VarDeclAST = asts VarDeclAST.\r	VariableAST = asts VariableAST.\r	public parser = Parser new.\r	cachedCompilations = Map new.\r	sourcesList ::= List new. (* Ick, should really belong to ProgramBuilder. *)\r|\r)",
 "usingPlatform: platform asts: asts",
 "usingPlatform: platform asts: asts",
 "ClassEntry = (\r	^super ClassEntry\r)",
 "LocalEntry = (\r	^super LocalEntry\r)",
 "MethodEntry = (\r	^super MethodEntry\r)",
 "Scope = (\r	^super Scope\r)",
 "SlotEntry = (\r	^super SlotEntry\r)",
 "assert: block <[Boolean]> = (\r	super assert: block message: 'assertion failed'.\r	(* block value ifFalse: [error: 'assertion failed'] *)\r)",
 "mixinSlotNameFor: nestedName <String> = (\r	^nestedName\r)",
 "namer = (\r	^super namer\r)",
 "split: aString at: aCharacter = (\r	| parts start |\r	parts:: List new.\r	start:: 1.\r	1 to: aString size do:\r		[:index |\r		(aString at: index) = aCharacter ifTrue:\r			[parts add: (aString copyFrom: start to: index - 1).\r			start:: index + 1]].\r	parts add: (aString copyFrom: start to: aString size).\r	^parts\r)",
 "splitFullyQualifiedName: fqn = (\r	(* Make sure we pass only the first character, so that the code works in image and on JS *)\r	^split: fqn at: syntheticNameSeparator first\r)",
 "syntheticNameSeparator ^<String> = (\r	^'`'\r)",
 "class CachedCompilation = (|\r	public source <String>\r	public enableIntrinsics <Boolean>\r	public ir <ClassDeclarationIR>\r	public sentSelectors <Set[Symbol]>\r|)",
 " ",
 " ",
 "public class Compiler = super Compiler (\r(* Compiler reimplementation, with Javascript AST as the output. This makes automated testing easier and provides control over formatting (for example, placing every expression on its own line to allow for precise breakpoint placement in substandard JS debugger implementations). *)\r|\r	protected scopeMap <Map[AST, Scope]> ::= Map new.\r	scopeStack ::= List new.\r	input\r	public sentSelectors ::= Set new.\r\r	rewriter = Rewriter new.\r	translator = Translator new.\r	currentDepth\r	currentMixinUID\r	jsWriter = JavascriptWriter new.\r	public supportDoesNotUnderstand ::= true.\r	public inlineOperators ::= true.\r	public enableIntrinsics ::= true.\r|)",
 "Compiler",
 "Compiler",
 "accessorForNestedClassNamed: simpleName <String> in: mixinName <String> superCall: superAccessor <Node> ^ <String> = (\r(* Build  a method that will lazily create a nested class 'simpleName' with superclass defined by 'superAccessor' via mixin application, and cache it.  Maybe replace null slot with self-replacing function that computes class and stores in its closure? *)\r\r	| nestedName <String> nestedSlotName <String> nestedSlotNode <Node> enclosingObjectsName <String> |\r	nestedName:: names mangleSynthetic: mixinName, '`', simpleName.\r	nestedSlotName:: names mangleSlot: mixinName, '`', simpleName.\r	nestedSlotNode:: js propertyOf: (js ident: 'this') at: (js literal: nestedSlotName).\r	enclosingObjectsName:: names mangleSynthetic: 'enclosingObjects`', mixinName.\r	^js functionOf: {} body: (js block: {\r		js if: (js operator: '===' with: (js ident: 'nil') and: nestedSlotNode)\r			then: (js block: {\r				js var: 'self' value: (js ident: 'this').\r				js var: 'superclass' value: superAccessor.\r				js var: 'enclosingObjects' value:\r					(js call: (js propertyOf: (js array: {js ident: 'this'}) at: (js literal: 'concat'))\r						with: {js propertyOf: (js ident: 'this') at: (js literal: enclosingObjectsName)}).\r				js var: 'mixin' value: (js propertyOf: (js ident: '$') at: (js literal: nestedName)).\r				js assign: nestedSlotNode toBe:\r					(js call: (js propertyOf: (js ident: 'vmmirror') at: (js literal: '$applyMixin$toSuperclass$withEnclosingObjects$'))\r						with: {(js ident: 'mixin'). js ident: 'superclass'. js ident: 'enclosingObjects'}).\r			}).\r		js return: nestedSlotNode.\r		})\r)",
 "accessorForSuperclass: superclassCall <AST> inScope: s <Scope> ^<Node> = (\r	| send |\r	send:: rewriter applyTo: superclassCall withScope: s.\r\r	translator beginNewTranslationCycle.\r	^send apply: translator\r)",
 "checkForDuplicateNames: aNode = (\r	| namesWithDuplicates names duplicateNames |\r\r	namesWithDuplicates:: List new.\r	aNode instanceSide methods do: [:each | namesWithDuplicates add: each selector].\r\r	aNode header slots do: [:each |\r		namesWithDuplicates add: each name.\r		each isMutable ifTrue: [namesWithDuplicates add: each name, ':']].\r\r	namesWithDuplicates\r		addAll: (aNode instanceSide nestedClasses collect: [:each | each name]).\r\r	names:: Set new.\r	duplicateNames:: Set new.\r	namesWithDuplicates do: [:each | | present |\r		present:: true.\r		names include: each ifNew: [present:: false].\r		present ifTrue: [duplicateNames add: each]].\r\r	duplicateNames isEmpty ifFalse: [ | message |\r		message:: String streamContents: [:s |\r			s\r				nextPutAll: 'Class ';\r				nextPutAll: aNode name;\r				nextPutAll: '\" has multiple definitions for '.\r			duplicateNames\r				do: [:each | s nextPutAll: each asString]\r				separatedBy: [ s nextPutAll: ','].\r			s nextPutAll: '.'.].\r		assert: false message: message].\r)",
 "checkForReservedWord: selector = (\r	^super checkForReservedWord: selector\r)",
 "classNode: aNode <ClassDeclarationAST> within: mixinIR ^ <IntermediateClassDeclaration> = (\r	| ir <IntermediateClassDeclaration> priorMixinUID <String> |\r	aNode name = #Newspeak2V8Compilation ifTrue: [\r		#BOGUS. (* The flaw in the js intrinsic scheme. *)\r		enableIntrinsics: false].\r	checkForDuplicateNames: aNode.\r	ir:: computeMixinFrom: aNode header within: mixinIR.\r	ir accessModifier: aNode accessModifier.\r	priorMixinUID:: currentMixinUID.\r	currentMixinUID:: ir qualifiedName.\r	currentDepth:: currentDepth + 1.\r	processInstanceSideOf: aNode ofMixin: ir instanceSide.\r	generateSlotAccessorsFor: ir instanceSide.\r	(* must be called after nested classes are processed, so all synthetic slots have been added *)\r	processClassSideOf: aNode ofMixin: ir classSide.\r	currentDepth:: currentDepth - 1.\r	currentMixinUID:: priorMixinUID.\r	^ir\r)",
 "public compileClassSource: source <String> within: enclosingIR <IntermediateMixin> ^<IntermediateClassDeclaration> = (\r	| tree <AST> intermediate <IntermediateClassDeclaration> enclosingBuilder |\r	tree:: nil = enclosingIR\r		ifTrue: [parser compilationUnit parseString: source ]\r		ifFalse: [\r			enclosingBuilder:: enclosingIR builder.\r			parser classDecl parseString: source.\r			].\r\r	setInput: source.\r	setScopeFor: tree in: enclosingBuilder.\r	(*sentSelectors:: Set new.*)\r	intermediate:: nil = enclosingIR\r		ifTrue: [classNode: tree within: nil]\r		ifFalse: [compileNestedClassAST: tree into: enclosingIR].\r\r	scopeMap:: Map new.\r	^intermediate\r)",
 "public compileExpressionSource: expression <String> inMixin: enclosing <MixinMirror> ^<MethodIR> = (\r	|\r	body <CodeBodyAST>\r	method <MethodAST>\r	result <LowLevelMethodMirror>\r	|\r\r	(* Parse as a code body *)\r	body:: parser doItExpression parseString: expression.\r	input:: expression.\r\r	(* Ensure last statement is a return statement *)\r	body statements isEmpty ifFalse:\r		[body statements last isKindOfReturnStatNode ifFalse:\r			[| last |\r			last:: body statements removeLast.\r			body statements add: (ReturnStatAST new\r				expression: last; start: last start; end: last end)]].\r\r	(* Put into a method *)\r	method:: MethodAST new\r		pattern: (MessagePatternAST new selector: #DoIt parameters: {});\r		body: body;\r		accessModifier: #public.\r\r	(* Build scope *)\r	setScopeFor: method in: enclosing.\r	currentMixinUID: enclosing declaration qualifiedName.\r\r	(* Rewrite and compile *)\r 	result:: methodNode: method.\r	scopeMap:: Map new.\r	^result\r)",
 "public compileMethodSource: source <String> within: enclosing <MixinMirror> ^<IntermediateMethod> = (\r	| tree <AST> jsTree <IntermediateMethod> |\r	tree:: parser methodDecl parseString: source.\r	setInput: source.\r	setScopeFor: tree in: enclosing.\r	currentMixinUID: enclosing declaration qualifiedName.\r	jsTree:: methodNode: tree.\r	scopeMap:: Map new.\r	^jsTree\r)",
 "compileNestedClassAST: tree <ClassDeclarationAST | MixinApplicationClassAST>\r into: enclosingIR <IntermediateMixin> ^<IntermediateClassDeclaration> = (\r	^(compileNestedClasses: {tree} within: enclosingIR) first\r)",
 "compileNestedClasses: nestedClasses <Collection[ClassDeclarationAST]> within: mixinIR <IntermediateMixin> = (\r	nestedClasses do:\r		[:nc <ClassDeclarationAST> |\r		| nSlotName <String> nSlot <InstanceVariableMirror> |\r		nSlotName:: mixinIR declaration qualifiedName, '`', nc name.\r		nSlot:: IntermediateSlotDeclaration named: nSlotName mutable: true accessModifier: #public (* questionable*).\r		nSlot isSynthetic: true.\r		mixinIR slots add: nSlot.\r		mixinIR nestedClasses add: (classNode: nc within: mixinIR).\r		createNestedClassAccessorFrom: nc within: mixinIR].\r)",
 "compileNestedClassesOf: aNode <SideAST> within: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (\r	(* where do we check that nested classes do not conflict with each other, or with methods or slots? *)\r	^compileNestedClasses: aNode nestedClasses within: mixinMirror\r)",
 "computeMethod: aNode <MethodAST> inScope: s <Scope> = (\r	| scopeBuilder <ScopeBuilder> |\r	scopeBuilder:: ScopeBuilder nestedIn: s atLevel: currentDepth.\r	aNode apply: scopeBuilder.\r	(* need to build scope for method before visiting it *)\r	^methodNode: aNode.\r)",
 "computeMixinFrom: aNode <ClassHeaderAST> within: mixinIR <IntermediateMixin> ^<IntermediateClassDeclaration> = (\r	|\r	ir = IntermediateClassDeclaration new.\r	|\r	nil = mixinIR\r		ifTrue: [ir qualifiedName: aNode name]\r		ifFalse: [ir qualifiedName: (mixinIR qualifiedName, '`', aNode name)].\r	aNode slots do: [:s |\r		ir instanceSide slots add:\r			(IntermediateSlotDeclaration\r				named: s name\r				mutable: s isMutable\r				accessModifier: s accessModifier)].\r	ir headerSource: (input copyFrom: aNode start to: aNode end).\r	ir depth: currentDepth.\r	ir factoryName: aNode constructor selector.\r	^ir\r)",
 "createNestedClassAccessorFrom: classDecl <ClassDeclarationAST> within: mixinMirror <LowLevelMixinMirror> = (\r(* Create an accessor method for the nested class represented by the incoming class tree.\rThis accessor will lazily generate the nested class when its enclosing instance is first asked for it. *)\r\r	| n <String> accessorString <String> methodAST hdr <ClassHeaderAST> accessor <MethdMirror> |\r	hdr:: classDecl header.\r	n:: hdr name.\r	methodAST::\r		accessorForNestedClassNamed: n\r		in: mixinMirror qualifiedName\r		superCall: (accessorForSuperclass: hdr superclassCall inScope: (scopeMap at: classDecl instanceSide)).\r	accessor:: IntermediateMethod\r		named: classDecl name\r		accessModifier: classDecl accessModifier\r		function: methodAST\r		source: nil.\r	accessor isSynthetic: true.\r	mixinMirror methods add: accessor.\r)",
 "currentScope ^<Scope> = (\r	^scopeStack last\r)",
 "public dnuHandlers = (\r	(* We used to generate a separate function for each selector. Now we are recycling the same code for each selector and using the JS magic 'arguments' to handle the variable number of arguments in an attempt to reduce the amount of code the must be compiled at start-up (recall DNU handlers must be installed up front). *)\r	|\r	sortedSelectors = sentSelectors asArray sort: [:a :b | string: a compare: b].\r	mangledSelectors = js array: (sortedSelectors collect: [:sel | js literal: (names manglePublic: sel)]).\r	catcher = js call: (js ident: 'dnuCatcher') with: {js ident: 'sel'}.\r	|\r	^js function: 'installDnuHandlersOn' of: {js ident: 'p'} body: (js block: {\r		js call: (js propertyOf: mangledSelectors at: (js literal: 'forEach'))\r		with: {js functionOf: {'sel'} body: (js block: {\r			js assign: (js propertyOf: (js ident: 'p') at: (js operator: '+' with: (js literal: '_') and: (js ident: 'sel'))) toBe: catcher.\r			js assign: (js propertyOf: (js ident: 'p') at: (js ident: 'sel')) toBe: catcher.\r			(* Make DNU handlers non-enumerable.*)\r			(js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'defineProperty')) with: {\r				js ident: 'p'.\r				js operator: '+' with: (js literal: '_') and: (js ident: 'sel').\r				js objectLiteralSlotNames: {js literal: 'enumerable'} values: {js literal: false}.\r			}).\r			(js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'defineProperty')) with: {\r				js ident: 'p'.\r				js ident: 'sel'.\r				js objectLiteralSlotNames: {js literal: 'enumerable'} values: {js literal: false}.\r			}).\r		})}\r	}).\r	(* function() {  this.dnu(kernel.Message().selector$arguments$(selector, arguments) )  } *)\r)",
 "generateSlotAccessorsFor: mixinIR <MixinIR> = (\r	mixinIR slots do:\r		[:slotIR |\r		generateSlotInitializerFor: slotIR in: mixinIR.\r		generateSlotGetterFor: slotIR in: mixinIR.\r		generateSlotSetterFor: slotIR in: mixinIR].\r)",
 "generateSlotGetterFor: slotIR <IntermediateSlot> in: mixinIR <IntermediateMixin> = (\r	|\r	slotName <String> fieldName <String>\r	getter <MethodMirror> getterJS <Node>\r	|\r	slotName:: slotIR name.\r	fieldName:: names mangleSlot: slotName.\r\r	slotIR accessModifier = #private\r		ifTrue:\r			[getterJS:: js functionOf: {'self'} body: (js block: {\r				js return: (js propertyOf: (js ident: 'self') at: (js literal: fieldName))})]\r		ifFalse:\r			[getterJS:: js functionOf: {} body: (js block: {\r				js return: (js propertyOf: (js ident: 'this') at: (js literal: fieldName))})].\r\r	getter:: IntermediateMethod\r		named: slotName\r		accessModifier: slotIR accessModifier\r		function: getterJS\r		source: nil.\r	getter isSynthetic: true.\r	mixinIR methods add: getter.\r)",
 "generateSlotInitializerFor: slotIR <IntermediateSlot> in: mixinIR <IntermediateMixin> = (\r	|\r	slotName <String> fieldName <String>\r	initializer <MethodMirror> initializerJS <Node>\r	|\r	slotName:: slotIR name.\r	fieldName:: names mangleSlot: slotName.\r\r	slotIR accessModifier = #private\r		ifTrue:\r			[initializerJS:: js functionOf: {'self'. 'v'} body: (js block: {\r				(js assign: (js propertyOf: (js ident: 'self') at: (js literal: fieldName))\r					toBe: (js ident: 'v')).\r				js return: (js ident: 'self')})]\r		ifFalse:\r			[initializerJS:: js functionOf: {'v'} body: (js block: {\r				(js assign: (js propertyOf: (js ident: 'this') at: (js literal: fieldName))\r					toBe: (js ident: 'v')).\r				js return: (js ident: 'this')}).].\r\r	initializer:: IntermediateMethod\r		named: (selectorForSlotInitializer: slotIR)\r		accessModifier: slotIR accessModifier (* Should be private. The scope representation needs to be adjusted to allow this to differ from the slot's access modifier. *)\r		function: initializerJS\r		source: nil.\r	initializer isSynthetic: true.\r	mixinIR methods add: initializer.\r)",
 "generateSlotSetterFor: slotIR <IntermediateSlot> in: mixinIR <IntermediateMixin> = (\r	|\r	slotName <String> fieldName <String>\r	setter <MethodMirror> setterJS <JavascriptGeneration Syntax Node>\r	|\r\r	slotIR isMutable ifFalse: [^self].\r\r	slotName:: slotIR name.\r	fieldName:: names mangleSlot: slotName.\r\r	slotIR accessModifier = #private\r		ifTrue:\r			[setterJS:: js functionOf: {'self'. 'v'} body: (js block: {\r				(js assign: (js propertyOf: (js ident: 'self') at: (js literal: fieldName))\r					toBe: (js ident: 'v')).\r				js return: (js ident: 'self')})]\r		ifFalse:\r			[setterJS:: js functionOf: {'v'} body: (js block: {\r				(js assign: (js propertyOf: (js ident: 'this') at: (js literal: fieldName))\r					toBe: (js ident: 'v')).\r				js return: (js ident: 'this')})].\r\r	setter:: IntermediateMethod\r		named: (selectorForSlotSetter: slotIR)\r		accessModifier: slotIR accessModifier\r		function: setterJS\r		source: nil.\r	setter isSynthetic: true.\r	mixinIR methods add: setter.\r)",
 "hereNode ^<VariableAST> = (\r	(* Generates an AST representing the implicit receiver. We use a string so that we can represent a name that is not a legal identier *)\r\r	^VariableAST new name: #'@here'; start: 0; end: 0.\r)",
 "hereSendFrom: arg <VarDeclAST> ^<MessageNode> = (\r	^UnresolvedSendAST new\r		to: hereNode\r		send: (MessageAST new\r			send: arg name\r			with: {};\r			start: arg start; end: arg end);\r		start: arg start; end: arg end\r)",
 "initializerFor: aNode <ClassHeaderAST> ^ <MethodAST> = (\r|\rstmts <Collection[StatementAST]>\rstart <Integer>\rend <Integer>\rinitHdr <MessagePatternAST>\rbody <CodeBodyAST>\rparams <List[VarDeclAST]>\r|\r\r	start:: aNode superConstructorCall start.\r	end:: aNode superConstructorCall end.\r	params:: aNode constructor parameters collect:\r		[:formal | formal].\r	initHdr:: MessagePatternAST new\r		selector: #'instance`initializer' parameters: params;\r		start: start; end: end.\r\r	(* set up scope with constructor parameters *)\r 	stmts:: List new.\r\r	stmts add: (superConstructorCallFor: aNode).\r\r	(aNode slots reject: [:ea | ea initializer isNil])\r		do: [:slot <SlotDefAST> | | aMsg <MessageAST> |\r	aMsg:: MessageAST new send: (selectorForSlotInitializer: slot)\r					   with: {slot initializer};\r					   start: slot start; end: slot end.\r	stmts add: (UnresolvedSendAST new message: aMsg;\r				receiver: hereNode;\r	                start: aMsg start; end: aMsg end).\r	].\r\r stmts addAll: (aNode initExprs collect: [:ie | ie]).\r body:: CodeBodyAST new temporaries: List new\r	                             statements: stmts;\r	                             start: start; end: end.\r ^MethodAST new pattern: initHdr\r	                  body: body\r	                  accessModifier: #public;\r	                  start: start; end: end.\r)",
 "methodNode: aNode <MethodAST> ^ <IntermediateMethod> = (\r	| tree <AST> jsTree |\r	tree:: rewriter methodNode: aNode inScope: (scopeMap at: aNode). (* rewrite ast *)\r	translator beginNewTranslationCycle.\r	jsTree:: tree apply: translator. (* final pass: visit rewritten ast *)\r	(* pop scope? *)\r	^IntermediateMethod\r		named: translator currentSelector\r		accessModifier: aNode accessModifier\r		function: jsTree\r		source: ([sourceForNode: aNode] on: Error do: [nil])\r)",
 "popScope ^<Scope> = (\r	^scopeStack removeLast\r)",
 "processClassSideOf: aNode <ClassAST> ofMixin: mixinMirror <LowLevelMixinMirror> = (\r	(* | primaryFactory <MethodMirror> factoryAST <MethodAST> | *)\r	processFactoryFor: aNode in: mixinMirror.\r	processSide: aNode classSide ofMixin: mixinMirror. (* compile class methods *)\r)",
 "processFactoryFor: aNode <ClassAST> in: mixinIR <MixinIR> = (\r	| accessor <MethdMirror> argNames ast |\r	argNames:: (aNode header constructor parameters collect: [:each | names mangleLocal: each name]) asArray.\r	ast:: js functionOf: argNames body: (js block: {\r		js return:\r			(js call: (js ident: '(new this.nonMeta.basicNew()).$instance$initializer') (* cheat! *)\r				with: (argNames collect: [:each | js ident: each]))\r		}).\r	accessor:: IntermediateMethod\r		named: aNode header constructor selector\r		accessModifier: #public\r		function: ast\r		source: nil.\r	accessor isSynthetic: true.\r	accessor isFactory: true.\r	mixinIR methods add: accessor.\r)",
 "processInitializerFor: aNode <ClassAST> in: mixinIR <MixinIR> = (\r	processMethod: (superConstructorMethodFor: aNode header) inScope: (scopeMap at: aNode instanceSide) in: mixinIR.\r	(*makeCreateSlotsFor: aNode hdr within: mixinIR.*)\r	processMethod: (initializerFor: aNode header) inScope: (scopeMap at: aNode instanceSide) in: mixinIR.\r)",
 "processInstanceSideOf: aNode <ClassAST> ofMixin: mixinIR <MixinIR> ^ <Collection[MixinRep]> = (\r	processInitializerFor: aNode in: mixinIR.\r	processSide: aNode instanceSide ofMixin: mixinIR. (* compile instance methods *)\r	compileNestedClassesOf: aNode instanceSide within: mixinIR. (* gather nested classes *)\r)",
 "processMethod: aNode <MethodAST> inScope: s <Scope> in: mixinIR <MixinIR> = (\r	| method <MethodMirror> |\r	method:: computeMethod: aNode inScope: s.\r	method isSynthetic: true.\r	mixinIR methods add: method.\r)",
 "processSide: side <SideAST> ofMixin: mixinIR <MixinIR> = (\r	side methods do:\r		[:methodNode | mixinIR methods add: (methodNode: methodNode)].\r)",
 "pushScope: scope <Scope> = (\r	scopeStack addLast: scope\r)",
 "selectorForSlotInitializer: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (\r	^('init`', slot name, ':') asSymbol\r)",
 "selectorForSlotSetter: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (\r	slot isMutable ifFalse: [self warnObsolete].\r	^((slot isMutable ifTrue: [ '' ] ifFalse: [ 'setOnce`' ]), slot name, ':') asSymbol.\r)",
 "selfNode ^ <VariableAST> = (\r	(* generate a an AST representing self; used for implicit self sends *)\r	^VariableAST new name: #self; start: 0; end: 0\r)",
 "setInput: source <ReadStream> = (\r	input: source. (* save the input *)\r)",
 "setScopeFor: node <AST> in: enclosing <MixinMirror | nil> = (\r	| scopeBuilder |\r	nil = enclosing\r		ifTrue: [pushScope:: Scope new]\r		ifFalse: [pushScope:: ScopeBuilder new buildScopeFor: enclosing].\r	currentDepth:: currentScope depth + 1.\r	scopeBuilder:: ScopeBuilder nestedIn: currentScope atLevel: currentDepth.\r	node apply: scopeBuilder\r)",
 "sourceForNode: node <AST> ^ <String> = (\r	| savedPos <Integer> pos <Integer> len <Integer> s <String> |\r	^input copyFrom: node start to: node end\r)",
 "string: a compare: b = (\r	1 to: a size do:\r		[:i |\r		i > b size ifTrue: [^false].\r		(a runeAt: i) < (b runeAt: i) ifTrue: [^true].\r		(a runeAt: i) > (b runeAt: i) ifTrue: [^false]].\r	^true\r)",
 "superConstructorCallFor: aNode <ClassHeaderAST> ^<NormalSendAST> = (\r	(* create call to super constructor method *)\r	|\r	var <VariableAST>\r	send <NormalSendAST>\r	start <Integer>\r	end <Integer>\r	superMsg <MessageAST>\r	args <List[VariableAST]>\r	|\r\r	start:: aNode superConstructorCall start.\r	end:: aNode superConstructorCall end.\r	var:: VariableAST new name: #self; start: start; end: end.\r	args:: aNode constructor parameters collect:\r		[:p <VarDeclAST> | hereSendFrom: p].\r	superMsg:: MessageAST new\r		send: (superConstructorNameFor: aNode) with: args;\r		start: start; end: end.\r	send:: UnresolvedSendAST new to: var send: superMsg; start: start; end: end.\r	^send\r)",
 "superConstructorMethodFor: aNode <ClassHeaderAST> ^ <MethodAST> = (\r|\rstart <Integer>\rend <Integer>\rstmts <List[StmtAST]>\rvar <VariableAST>\rinitHdr <MessagePatternAST>\rsuperMsg <MessageAST>\rsend <NormalSendAST>\rbody <CodeBodyAST>\rparams <List[VarDeclAST]>\rargs <List>\r|\r\r	start:: aNode superConstructorCall start.\r	end:: aNode  superConstructorCall end.\r	params:: aNode constructor parameters collect: [:formal | formal].\r	initHdr:: MessagePatternAST new selector: (superConstructorNameFor: aNode) parameters: params;\r				start: start; end: end.\r	(* set up scope with constructor parameters *)\r	(* create call to superclass initializer *)\r	stmts:: List new.\r	var:: VariableAST new name: #super; start: start; end: end.\r	args:: aNode superConstructorCall arguments collect: [:actual | actual].\r	superMsg:: PropertyCallAST new send: 'instance`initializer' with: args;\r				start: start; end: end.\r	(* only copy actual args *)\r	(* send these as a tuple? to super instance initializer? *)\r	send:: UnresolvedSendAST new to: var send: superMsg; start: start; end: end.\r	stmts addFirst: send.\r	body:: CodeBodyAST new temporaries: List new\r	                             	statements: stmts;\r	                            	start: start; end: end.\r	^MethodAST new pattern: initHdr\r	                  body: body\r	                  accessModifier: #protected;\r	                  start: start; end: end\r)",
 "superConstructorNameFor: aNode <ClassHeaderAST> ^ <Symbol> = (\r	#BOGUS. (* Should not rely on this running after currentMixinUID is set. *)\r	^'superInit`', currentMixinUID\r)",
 "class PropertyCallAST = MessageAST (\r(* Sepcialized node to represent applications of JS properties. In some cases (well, at least one) we need to generate ASTs that call javascript methods directly. These calls need to be translated slightly differently (their names must not be mangled). To distinguish these form normal message sends, we use this node. *)\r)",
 "MessageAST",
 "MessageAST",
 "public apply: tool <ASTTool> = (\r	^tool propertyCallNode: self\r)",
 "class Rewriter = super Rewriter (|\r	protected inlinableOperators <Map[String, String]> = Map new.\r	protected inlinableNumericOperators <Map[String, String]> = Map new.\r|inlinableOperators\r		at: #+ put: '+';\r		at: #- put: '-';\r		at: #* put: '*';\r		at: #/ put: '/';\r		at: #'==' put: '==='.\r	inlinableNumericOperators\r		at: #'<' put: '<';\r		at: #'<=' put: '<=';\r		at: #'>' put: '>';\r		at: #'>=' put: '>=')",
 "Rewriter",
 "Rewriter",
 "public applyTo: node withScope: scope = (\r	| result |\r	self pushScope: scope.\r	result:: node apply: self.\r	self popScope.\r	^result\r)",
 "canInlineSeqexps ^<Boolean> = (\r	^false\r)",
 "currentScope = (\r	^super currentScope\r)",
 "inline: node as: sendClass selector: selector rewriteArgsAs: argRewriteBlock = (\r	| receiver message |\r	receiver:: applyForValueTo: node receiver.\r	message:: MessageAST new\r		send: selector\r		with: (node message arguments collect: argRewriteBlock).\r	^sendClass new\r		to: receiver send: message;\r		start: node start;\r		end: node end\r)",
 "isInlinableBooleanOperator: node <NormalSendAST> = (\r	| selector |\r	selector:: node message selector.\r	^(selector = 'or:' or: [selector = 'and:'])\r		and: [node message arguments size = 1\r		and: [node message arguments first isKindOfBlockNode\r		and: [node message arguments first body statements size = 1]]]\r)",
 "isInlinableNumericOperator: node <NormalSendAST> = (\r	| args |\r	args:: node message arguments.\r	args size = 1 ifFalse: [^false].\r	(inlinableNumericOperators includesKey: node message selector) ifFalse: [^false].\r	(node receiver isKindOfLiteralNode and: [node receiver value isNumber]) ifTrue: [^true].\r	(args first isKindOfLiteralNode and: [args first value isNumber]) ifTrue: [^true].\r	^false\r)",
 "isInlinableOperator: node <NormalSendAST> = (\r	^(inlinableOperators includesKey: node message selector)\r		and: [node message arguments size = 1]\r)",
 "processEventualSend: node <NormalSendAST> = (\r	| scheduler receiver selector arguments |\r	scheduler:: SchedulerAST new.\r\r	receiver:: node receiver apply: self.\r	selector:: (SymbolAST new value: node message selector) apply: self.\r	arguments:: (TupleAST new elements: node message arguments) apply: self.\r\r	^(OrdinarySendAST\r		to: scheduler\r		send: ((MessageAST new\r			send: #eventualSendTo:selector:arguments:\r			with: {receiver. selector. arguments})\r				copyPositionFrom: node message))\r		copyPositionFrom: node\r)",
 "public propertyCallNode: node <PropertyCallAST> ^ <PropertyCallAST> = (\r	| args |\r	assert: [node isKindOfMessageNode].\r	args:: List new.\r	node arguments do: [:each | args add: (applyForValueTo: each)].\r	^PropertyCallAST new\r		send: node selector with: args;\r		start: node start;\r		end: node end\r)",
 "setterBlockArgName = (\r	^('setter_arg') asSymbol\r)",
 "public setterSendNode: node <SetterSendAST> ^ <AST> = (\r(* Rewrite a double-colon setter send. The value of the entire expression should be the value of the argument of the send, NOT the value returned by the setter method. This general case is somewhat inefficient, but in most cases the value of the expression is ignored by the parent so we can use a cheaper regular message send. *)\r	| binding block blockArg blockParam blockScope send rewrittenSetterSend |\r	binding:: currentScope at: node message selector ifAbsent: [MessageAST new].\r	binding isLocalBinding ifTrue:\r		(* This is an assignment to a temporary; no special handling is needed\r		as the value of the expression is the value being assigned. *)\r		[^processLocalAccess: node message of: binding].\r	valueExpected ifFalse:\r		(* The parent ignores the expression value; use a plain cheap here message send. *)\r		[^processImplicitReceiverSend: node].\r\r	(* The value is used by the parent; rewrite the whole thing as\r		setter:: expr => [:a | setter: a. a] value: expr *)\r	(* a -- ok to use a constant name as long as it cannot collide with a user's name *)\r	blockArg:: UnresolvedSendAST new\r		to: implicitReceiverNode\r		send: (MessageAST new send: setterBlockArgName with: {}).\r	blockParam:: ParameterAST name: setterBlockArgName type: nil.\r	(* setter: a *)\r	send:: UnresolvedSendAST new to: node receiver send:\r		(MessageAST new selector: node message selector; arguments: {blockArg};\r		start: node message start; end: node message end; yourself);\r		start: node start; end: node end.\r	(* [:a | setter: a. a] *)\r	block:: BlockAST new body:\r		(CodeBodyAST new\r			parameters: {blockParam}\r			temporaries: {}\r			statements: {\r				send.\r				blockArg\r			};\r			start: node start; end: node end);\r			start: node start; end: node end.\r	blockScope:: Scope parent: currentScope.\r	blockScope\r		at: setterBlockArgName put: (LocalEntry forDeclaration: blockParam atDepth: nil).\r	scopeMap at: block put: blockScope.\r	scopeMap at: block body put: blockScope.\r	(* [:a | setter: a. a] value: expr *)\r	rewrittenSetterSend::\r		UnresolvedSendAST new\r			to: block\r			send: (MessageAST new\r				selector: #value:;\r				arguments: {node message arguments first};\r				start: node message start; end: node message end);\r				start: node start; end: node end.\r	^applyForValueTo: rewrittenSetterSend\r)",
 "public unresolvedSendNode: node <UnresolvedSendAST> ^ <AST> = (\r	#BOGUS. (* Eventual sends trump inlining, but we shouldn't need to duplicate the eventual send check. Maybe the inlining should be deferred until we know it is an immediate ordinary send? *)\r	(node message isEventual)\r		ifTrue: [^processEventualSend: node].\r\r	(inlineOperators and: [isInlinableNumericOperator: node]) ifTrue:\r		[^inline: node as: InlinedOperatorAST\r			selector: (inlinableNumericOperators at: node message selector)\r			rewriteArgsAs: [:each | applyForValueTo: each]].\r	(inlineOperators and: [isInlinableOperator: node]) ifTrue:\r		[^inline: node as: InlinedOperatorAST\r			selector: (inlinableOperators at: node message selector)\r			rewriteArgsAs: [:each | applyForValueTo: each]].\r	(inlineOperators and: [isInlinableBooleanOperator: node]) ifTrue:\r		[^inline: node as: InlinedOperatorAST\r			selector: (node message selector = 'and:' ifTrue: ['&&'] ifFalse: ['||']) (* BOGUS *)\r			rewriteArgsAs: [:each <BlockAST> | applyForValueTo: each body statements first]].\r\r	^super unresolvedSendNode: node\r)",
 "class InlinedOperatorAST = SendAST (\r(* When the inlineOperators mode is on, message sends with certain selectors are replaced with this node. Javascript code generated for those nodes uses native Javascript operators instead of real message sends. The selector of the message of this AST is not a real Newspeak selector but rather the Javascript operator such as &&. *)\r|\r	public receiver <ExpressionAST>\r|)",
 "SendAST",
 "SendAST",
 "public apply: aTool <ASTTool> ^ <Self> = (\r	^aTool inlinedOperatorNode: self\r)",
 "public to: anExpression <ExpressionAST> send: aMessage <MessageAST> = (\r	self receiver: anExpression; message: aMessage\r)",
 "public to: receiver send: selector with: arguments = (\r	to: receiver send: (MessageAST new send: selector with: arguments)\r)",
 "class SchedulerAST = AST ()",
 "AST",
 "AST",
 "public apply: visitor <ASTVisitor> = (\r	^visitor schedulerNode: self\r)",
 "class ScopeBuilder nestedIn: initialScope <Scope> atLevel: initialDepth <Integer> = ASTTool (\r(* The scope builder is a visitor on the AST. It computes a tree of scopes that shadows the AST itself. More precisely, it computes a mapping from ASTs to their scopes. This allows us to get to the appropriate scope for an abstract syntax node without polluting the AST with extraneous data like scopes.\r\rWe could associate each node in the AST with the scope in which it is found, but this would be overkill. Instead, only nodes that actually introduce new scopes (such as class sides, message patterns, code bodies and blocks) actually get mapped in this manner. The intent is that later phases of compilation will visit the tree and look up the scopes at the points where they are introduced.\r\rThe builder starts at a given node, in the context of some mixin, described by a mirror. This is because, in an incremental environment, we may not have the complete AST for a module, but instead be asked to process a part of that module, such as a nested class, slot definition or method. The surrounding scope can be computed from the mirror representing the immediately enclosing mixin.\r\rThen we traverse the tree, creating and populating new scopes as needed. We maintain a stack of scopes (scopeStack) that initially contains only the surrounding scope. Scopes get pushed on to the stack when we encounter a node that introduces a scope, and popped when we finish with that node. The scopes are chained to their super scopes (the scope below them on the stack).\r\rA possible optimization is to avoid a traversal of an entire side of a class.\rOne can process only a side without its subtrees (i.e., methods and nested classes). These can be visited later, as long as we ensure that the processing of the subtree begins with a proper super scope on top of the scope stack. *)\r|\rcurrentScope ::= initialScope.\rcurrentDepth <Integer> ::= initialDepth. (* The lexical nesting level of the class declaration currently being visited; top-level classes are level 0. *)\r|\r)",
 "ASTTool",
 "ASTTool",
 "public buildScopeFor: mm <MixinMirror> ^<Scope> = (\r	assert: [mm isKindOfMixinMirror] message: ''.\r	^incrementalScopeFor: mm.\r)",
 "public classNode: aNode <ClassDeclarationAST> = (\r	| thisClass <ClassEntry> instanceSideScope <Scope> classSideScope <Scope> |\r\r	thisClass:: ClassEntry forDeclaration: aNode atDepth: currentDepth.\r	thisClass enclosingClass: (currentScope at: #'@currentClass' ifAbsent: [nil]).\r\r	currentScope at: aNode name put: thisClass.\r\r	currentDepth:: currentDepth + 1.\r\r	instanceSideScope:: Scope parent: currentScope. (* establish instance side scope *)\r	pushScope: instanceSideScope.\r	aNode header slots do: [:v <SlotDeclAST> |\r		| se = SlotEntry forDeclaration: v atDepth: currentDepth. |\r		instanceSideScope at: v name put: se. (* getter *)\r		instanceSideScope at: (namer selectorForSlotInitializer: v) put: se.\r		v isMutable ifTrue: [instanceSideScope at: (namer selectorForSlotSetter: v) put: se]. (* setter *)].\r	instanceSideScope at: #'@currentClass' put: thisClass.\r	aNode instanceSide apply: self.\r	popScope.\r\r	classSideScope:: (Scope parent: currentScope). (* establish class side scope *)\r	pushScope: classSideScope.\r	classSideScope at: #'@currentClass' put: thisClass.\r	aNode classSide apply: self.\r	popScope.\r\r	currentDepth:: currentDepth - 1.\r)",
 "incrementalScopeFor: mm <MixinMirror> ^<Scope> = (\r	|\r	enclosingMixin\r	enclosingScope <Scope>\r	scope <Scope>\r	currentClass <ClassEntry>\r	depth\r	|\r	enclosingMixin:: mm declaration enclosingClass.\r	nil = enclosingMixin\r		ifTrue: [enclosingScope:: Scope new]\r		ifFalse: [enclosingScope:: incrementalScopeFor: enclosingMixin instanceSide].\r	scope:: Scope parent: enclosingScope.\r	depth:: scope depth.\r	currentClass:: ClassEntry\r		forDeclaration: (MessagePatternAST new selector: mm declaration name)\r		atDepth: depth.\r	currentClass enclosingClass: (scope at: #'@currentClass' ifAbsent: [nil]).\r	scope at: #'@currentClass' put: currentClass.\r	depth:: depth + 1.\r	mm slots do: [:s <SlotMirror> |\r		| se = SlotEntry\r			forDeclaration: (MessagePatternAST new selector: s name; accessModifier: s accessModifier)\r			atDepth: depth. |\r		scope at: s name put: se. (* getter *)\r		scope at: (namer selectorForSlotInitializer: s) put: se.\r		s isMutable ifTrue: [scope at: (namer selectorForSlotSetter: s) put: se. (* setter *)]].\r	mm methods do: [:m <MethodMirror> |\r		| me = MethodEntry\r			forDeclaration: (MessagePatternAST new selector: m name; accessModifier: m accessModifier)\r			atDepth: depth. |\r		scope at: m name put: me].\r	mm nestedClasses do: [:c <ClassDeclarationMirror> |\r		| ce = ClassEntry\r			forDeclaration: (MessagePatternAST new selector: c name; accessModifier: c accessModifier)\r			atDepth: depth. |\r		ce enclosingClass: currentClass.\r		scope at: c name put: ce].\r	^scope\r)",
 "public methodNode: node <MethodAST> = (\r	(* register method in current scope *)\r	checkForReservedWord: node selector.\r	currentScope\r		at: node selector\r		put: (MethodEntry forDeclaration: node atDepth: currentDepth).\r\r	node body parameters: node pattern parameters. (* Should the parser do this? *)\r\r	scopeMap at: node put: currentScope. (* BOGUS: Rewriter should start with the right currentScope. *)\r)",
 "public mixinApplication: node <MixinApplicationAST> = (\r	node mixinExpr apply: self.\r	node superclassExpr apply: self\r)",
 "public mixinApplicationClass: node <MixinApplicationClassAST> = (\r	| thisClass <ClassEntry> |\r	#BOGUS yourself. (* WIP *)\r	thisClass:: ClassEntry forDeclaration: node atDepth: node.\r	thisClass enclosingClass: (currentScope at: #'@currentClass' ifAbsent: [nil]).\r\r	currentScope at: node name put: thisClass.\r	scopeMap at: node put: currentScope.\r)",
 "popScope = (\r	currentScope:: currentScope parent\r)",
 "public propertyCallNode: aNode <PropertyCallAST> = (\r	self messageNode: aNode\r)",
 "pushScope: scope <Scope> = (\r	currentScope:: scope\r)",
 "public sideNode: node <SideAST> = (\r	scopeMap at: node put: currentScope.\r	node methods do: [:method <MethodAST> | method apply: self].\r	node nestedClasses do: [:nestedClass <ClassDeclarationAST> | nestedClass apply: self].\r)",
 "public new ^<Instance> = (\r	^self nestedIn: Scope new atLevel: 0\r)",
 "class Translator = ASTTool (\r(* Visits nodes of an NS AST to produce a Javascript AST. The usual translation unit is a method. Translation is initiated by sending the translateMethodNode: message. The argument is the method to translate, the returned value is the translation. *)\r|\r	scopeStack\r	public currentSelector\r	protected containsNonLocalReturn <Boolean> (* Set to false at the beginning of translating a method. The code that emits a non-local return sets this to true. The top-level code checks the value to see whether to emit a try-catch wrapper for an NLR. *)\r	protected methodIsPrivate <Boolean>\r|)",
 "ASTTool",
 "ASTTool",
 "addCascadedSend: node to: statements = (\r	node isKindOfCascadedSendNode ifTrue:\r		[addCascadedSend: node previousSend to: statements].\r	statements add:\r		(js call: (js propertyOf: (js ident: 'cascadeReceiver') at: (publicMessage: node message))\r			with: (node message arguments collect: [:each | each apply: self]) asArray).\r)",
 "public beginNewTranslationCycle = (\r	scopeStack:: List new.\r	containsNonLocalReturn:: false.\r)",
 "public blockLocalReturnNode: node <BlockLocalReturnAST> = (\r	^js return: (node expression apply: self)\r)",
 "public blockNode: node <BlockAST> = (\r	^js functionOf: (node parameters collect: [:each | self parameterDeclNode: each]) asArray\r			body: (node body apply: self).\r)",
 "public boolNode: node <BoolAST> = (\r	^js literal: node value\r)",
 "public cascadedSendNode: node <CascadedSendAST> = (\r	| statements |\r	statements:: List new.\r	addCascadedSend: node to: statements.\r	statements at: statements size put: (js return: statements last).\r	^js call: (js functionOf: {'cascadeReceiver'} body: (js block: statements))\r		with: {node receiver apply: self}\r)",
 "public characterNode: node <CharAST> = (\r	(* Javascript has no characters, only strings. *)\r	^js literal: node value asString\r)",
 "public codeBodyNode: node <CodeBodyAST> = (\r	| locals statements |\r	locals:: node temporaries collect: [:each | self temporaryDeclNode: each].\r	statements:: node statements collect: [:each | each apply: self].\r	^js block: (locals asArray, statements) asArray\r)",
 "public conditionalNode: node <ConditionalAST> = (\r	^inlinableConditionalNode: node\r)",
 "public enclosingObjectNode: node <EnclosingObjectAST> = (\r	^processOuterReceiverAtDepth: node depth\r)",
 "public implicitReceiverSendNode: node <ImplicitReceiverSendAST> = (\r	| receiver = processOuterReceiverAtDepth: node depth. |\r	^processLexicalSend: node message to: receiver binding: node binding\r)",
 "public inlinableAsExpressionConditionalNode: node <InlinableConditionalAST> = (\r	| truePath falsePath condition |\r\r	condition:: (node receiver apply: self).\r\r	node message selector = 'ifTrue:' ifTrue:\r		[truePath:: (node message arguments at: 1) body statements first apply: self.\r		falsePath:: js ident: 'nil'].\r	node message selector = 'ifFalse:' ifTrue:\r		[truePath:: js ident: 'nil'.\r		falsePath:: (node message arguments at: 1) body statements first apply: self].\r	node message selector = 'ifTrue:ifFalse:' ifTrue:\r		[truePath:: (node message arguments at: 1) body statements first apply: self.\r		falsePath:: (node message arguments at: 2) body statements first apply: self].\r	node message selector = 'ifFalse:ifTrue:' ifTrue:\r		[truePath:: (node message arguments at: 2) body statements first apply: self.\r		falsePath:: (node message arguments at: 1) body statements first apply: self].\r\r	^js ternaryIf: condition then: truePath else: falsePath\r)",
 "public inlinableConditionalNode: node <InlinableConditionalAST> = (\r	| inverseCondition hasElseClause condition |\r	inverseCondition:: node ifTrue not.\r	hasElseClause:: node else isNil not.\r	condition:: node condition apply: self.\r	^js if: (inverseCondition ifTrue: [js prefixOperator: '!' on: condition] ifFalse: [condition])\r		then: (node then apply: self)\r		else: (hasElseClause ifTrue: [node else apply: self] ifFalse: [nil])\r)",
 "public inlinedOperatorNode: node <InlinedOperatorAST> = (\r	(* We are not modeling JS operator precedence, so just parenthesize everything. *)\r	^js operator: node message selector\r		with: (node receiver apply: self)\r		and: (node message arguments first apply: self)\r)",
 "public localReadNode: node <LocalReadAST> = (\r	^js ident: (names mangleLocal: node name)\r)",
 "public localWriteNode: node <LocalWriteAST> = (\r	^js assign: (js ident: (names mangleLocal: node name)) toBe: (node value apply: self)\r)",
 "public loopNode: node <LoopAST> = (\r	(* prologue; while(cond==whileTrue) {body}; *)\r\r	|\r	prologue = node prologue ifNil: [js block: {}] ifNotNil: [:it | it apply: self].\r	cond = node condition apply: self.\r	body = node body ifNil: [js block: {}] ifNotNil: [:it | it apply: self].\r\r	(* Split the condition is it isn't a single expression *)\r	condExpression ::= cond statements last.\r	condPrologue = cond statements asOrderedCollection removeLast; yourself.\r	|\r\r	node isWhileTrue ifFalse: [\r		condExpression:: js prefixOperator: '!' on: condExpression].\r\r	(* Flatten prologue so its declarations are in scope for the loop *)\r\r	^js block:\r		prologue statements,\r		condPrologue, {\r		js\r			for: (js verbatim: '')\r			while: condExpression\r			step: (js verbatim: '')\r			do: (js block: body statements, condPrologue)}\r)",
 "maybeCaptureReceiver = (\r	methodIsPrivate\r		ifTrue: [^{}]\r		ifFalse: [^{js var: selfName value: (js ident: 'this')}].\r)",
 "public messageNode: node = (\r	halt.\r	sentSelectors add: node selector.\r	^js literal: (names mangleSelector: node selector)\r)",
 "public messagePatternNode: node <MessagePatternAST> ^<List[String]> = (\r	| jsParameters = List new. |\r	currentSelector:: node selector.\r	methodIsPrivate:: node accessModifier = #private.\r	methodIsPrivate ifTrue: [jsParameters add: selfName].\r	node parameters do: [:each | jsParameters add: (self parameterDeclNode: each)].\r	^jsParameters\r)",
 "public methodLocalReturnNode: node <MethodLocalReturnAST> = (\r	containsNonLocalReturn ifFalse:\r		[^js return: (node expression apply: self)].\r\r	^js block: {\r		js var: 't' value: (node expression apply: self).\r		js assign: (js ident: nlrName) toBe: (js ident: 'null').\r		js return: (js ident: 't')\r	}\r)",
 "public methodNode: node <MethodAST> ^<Node> = (\r	| translatedBody |\r	node body apply: self. (* Translate once to compute containsNonLocalReturn. Method-local returns that appear before the non-local return are incorrectly compiled. *)\r	translatedBody:: node body apply: self.\r	^js functionOf: (node pattern apply: self) asArray\r		body: (containsNonLocalReturn\r			ifTrue: [wrapBodyForNlrHandling: translatedBody]\r			ifFalse: [wrapBodyNoNlrHandling: translatedBody]).\r)",
 "public nilNode: node = (\r	^js ident: 'nil'\r)",
 "nlrName = (\r	^'NLR'\r)",
 "nlrValuePropertyName = (\r	^'value'\r)",
 "public nonLocalReturnNode: node <NonlocalReturnAST> = (\r	^returnStatNode: node\r)",
 "public numberNode: node <NumberAST> = (\r	^js literal: node value\r)",
 "public ordinarySendNode: node <OrdinarySendAST> = (\r	enableIntrinsics ifTrue:\r		[node receiver isKindOfImplicitReceiverSendNode ifTrue:\r			[node receiver message selector = 'js' ifTrue:\r				[^processIntrinsic: node message]]].\r\r	^js\r		call: (js propertyOf: (node receiver apply: self) at: (publicMessage: node message))\r		with: (node message arguments collect: [:each | each apply: self]) asArray\r)",
 "public outerSendNode: node <OuterSendAST> = (\r	| receiver = processOuterReceiverAtDepth: node depth. |\r	^processLexicalSend: node message to: receiver binding: node binding\r)",
 "public parameterDeclNode: node <ParameterAST> = (\r	^names mangleLocal: node name\r)",
 "processIntrinsic: msg <MessageAST> = (\r	^js perform: msg selector\r		withArguments: (msg arguments collect: [:arg | processIntrinsicArg: arg]) asArray.\r)",
 "processIntrinsicArg: arg <AST> = (\r	arg isKindOfTupleNode ifTrue: [^(arg elements collect: [:el | processIntrinsicArg: el]) asArray].\r	arg isKindOfLiteralNode ifTrue: [^arg value].\r	^arg apply: self\r)",
 "processLexicalSend: message to: jsReceiver binding: binding = (\r	(binding notNil and: [binding ast accessModifier = #private]) ifTrue: [\r		(* Do early binding. *)\r		|\r		definingMixinDepth = binding depth - 1.\r		definingMixin = js ident: '$', definingMixinDepth printString.\r		targetMethod = js propertyOf: definingMixin at: (publicMessage: message).\r		|\r		^js call: targetMethod (*(js propertyOf: targetMethod at: (js literal: 'call'))*)\r			with: {jsReceiver}, (message arguments collect: [:each | each apply: self]) asArray\r	].\r\r	^js\r		call: (js propertyOf: jsReceiver at: (protectedMessage: message))\r		with: (message arguments collect: [:each | each apply: self]) asArray\r)",
 "processOuterReceiverAtDepth: depth <Integer> = (\r	| slotName |\r	depth = 0 ifTrue: [^js ident: 'self'].\r	slotName:: names mangleSynthetic: 'enclosingObjects`', currentMixinUID.\r	^js propertyOf: (js propertyOf: (js ident: 'self') at: (js literal: slotName))\r		at: (js literal: depth - 1) (* Adjust for self not being in the enclosing objects array. *)\r)",
 "public propertyCallNode: node <PropertyCallAST> = (\r	^js literal: (names mangleSelector: node selector)\r)",
 "protectedMessage: node = (\r	sentSelectors add: node selector.\r	^js literal: (names mangleProtected: node selector)\r)",
 "publicMessage: node = (\r	sentSelectors add: node selector.\r	^js literal: (names manglePublic: node selector)\r)",
 "public receiverNode: node <ReceiverNode> = (\r	^js ident: selfName\r)",
 "public returnStatNode: node <ReturnAST> = (\r	containsNonLocalReturn:: true.\r	^js block: {\r		js var: 't' value: (node expression apply: self).\r		js if: (js operator: '===' with: (js ident: nlrName) and: (js ident: 'null'))\r			then: (js call: (js propertyOf: (js ident: selfName) at: (js literal: names privateCannotReturn)) with: {js ident: selfName. js ident: 't'}).\r		js assign: (js propertyOf: (js ident: nlrName) at: (js literal: nlrValuePropertyName)) toBe: (js ident: 't').\r		js throw: (js ident: nlrName)\r	}\r)",
 "public schedulerNode: node <SchedulerAST> = (\r	^js ident: 'currentActor'\r)",
 "selfName = (\r	^'self'\r)",
 "public selfSendNode: node <SelfSendAST> = (\r	| receiver = js ident: selfName. |\r	^processLexicalSend: node message to: receiver binding: node binding\r)",
 "public stringNode: node <StringAST> = (\r	^js literal: node value\r)",
 "public superSendNode: node <SuperSendAST> = (\r	| superSlotName args |\r	superSlotName:: names mangleSlot: 'super`', currentMixinUID.\r	args:: List new.\r	args add: (js ident: 'self').\r	node message arguments do: [:each | args add: (each apply: self)].\r	^js call:\r			(js propertyOf:\r				(js propertyOf: (\r					js propertyOf: (js ident: 'self')\r						at: (js literal: superSlotName))\r					at: (protectedMessage: node message))\r				at: (js literal: 'call')) with: args\r)",
 "public symbolNode: node <SymbolAST> = (\r	^js literal: node value\r)",
 "public temporaryDeclNode: node <ParameterAST> ^<String> = (\r	^js var: (names mangleLocal: node name)\r		value: (js ident: 'nil')\r)",
 "public tupleNode: node <TupleAST> = (\r	^js array: (node elements collect: [:ea | ea apply: self])\r)",
 "public varDeclNode: node <VarDeclNode> = (\r	(* Produce the corresponding local decl. *)\r	^js var: (names mangleLocal: node name)\r)",
 "wrapBodyForNlrHandling: body <Block> = (\r	| nlrVarNode nlrParamName nlrParamNode |\r	nlrVarNode:: js ident: nlrName.\r	nlrParamName:: nlrName, '_exception'.\r	nlrParamNode:: js ident: nlrParamName.\r	^js block: maybeCaptureReceiver,\r		{js var: nlrName value: (js new: (js ident: 'Object') with: {}).\r		js try: body catch: nlrParamName with:\r			(js block: {\r				js if: (js operator: '===' with: nlrVarNode and: nlrParamNode)\r					then: (js return: (js propertyOf: nlrParamNode at: (js literal: nlrValuePropertyName)))\r					else: (js throw: nlrParamNode)\r			})\r	}\r)",
 "wrapBodyNoNlrHandling: body <Block> = (\r	^js block: maybeCaptureReceiver, body statements\r)",
 "public class IntermediateClassDeclaration = (|\r	public qualifiedName <String>\r	public headerSource <String>\r	public factoryName <Symbol>\r	public instanceSide <IntermediateMixin> = IntermediateMixin for: self isMeta: false.\r	public classSide <IntermediateMixin> = IntermediateMixin for: self isMeta: true.\r	public depth <Integer>\r	public accessModifier <Symbol>\r|)",
 " ",
 " ",
 "basicNew = (\r	^js functionOf: {} body: (js block: (\r		{\r		js call: (js ident: 'superBasicNew.call') with: {js ident: 'this'}.\r		},\r		(instanceSide slots collect: [:s |\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: s name))) toBe: (js ident: 'nil')])\r	))\r)",
 "basicNewMeta = (\r	^js functionOf: {} body: (js block: (\r		{\r		js call: (js ident: 'superBasicNew.call') with: {js ident: 'this'}.\r		}\r	))\r)",
 "classMethodsMetadata = (\r	^js array: (classSide methods collect:\r		[:method | js new: (js ident: 'MM') with: {\r			js literal: method name.\r			js literal: method isSynthetic.\r			encodeSource: method source.\r		}])\r)",
 "copyMethods: methods = (\r	| stmts = List new. |\r	methods do: [:m |\r		| mixinFunction assignProtected |\r		mixinFunction:: js propertyOf: (js ident: '$') at: (js literal: (names manglePublic: m name)).\r		assignProtected::\r			(js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleProtected: m name)))\r				toBe: mixinFunction).\r\r		m isPublic ifTrue: [\r			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name)))\r					toBe: assignProtected).\r		].\r		m isProtected ifTrue: [\r			stmts add: assignProtected.\r			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name)))\r					toBe: (dnuCatcherFor: (names manglePublic: m name))).\r		].\r		m name = #doesNotUnderstand: ifTrue: [\r			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: names privateDnu)) toBe: mixinFunction).\r		].\r		(qualifiedName = 'KernelForV8`Object' and: [m name = #cannotReturn:]) ifTrue: [\r			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: names privateCannotReturn)) toBe: mixinFunction).\r		].\r	].\r	^stmts\r)",
 "dnuCatcherFor: publicMangling = (\r	^js call: (js ident: 'dnuCatcher') with: {js literal: publicMangling}\r)",
 "encodeSource: source = (\r	source isNil ifTrue: [^js literal: 0].\r	sourcesList add: source.\r	^js literal: sourcesList size.\r)",
 "invoke = (\r	^js functionOf: {js ident: 'runtimeSuperclass'. js ident: 'enclosingObjects'} body: (js block: {\r		js function: 'constructRuntimeClass' of: {js ident: 'superBasicNew'} body: (js block: (\r			{\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime class for ', qualifiedName).\r			},\r			(copyMethods: instanceSide methods),\r			{\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: 'enclosingObjects`',qualifiedName)))\r				toBe: (js ident: 'enclosingObjects').\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: 'super`',qualifiedName)))\r				toBe: (js ident: 'runtimeSuperclass').\r			(* This first assignment causes devtools to use the class's name as the short name for its instances. *)\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: qualifiedName)) toBe: basicNew.\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'basicNew')) toBe: (js propertyOf: (js ident: 'this') at: (js literal: qualifiedName)).\r			js verbatim: 'this.basicNew.prototype = this'.\r			js verbatim: 'this.meta = null'.\r			js verbatim: 'this.newspeakClass = null'.\r			}\r		)).\r		js verbatim: 'constructRuntimeClass.prototype = runtimeSuperclass'.\r		js verbatim: 'return new constructRuntimeClass(runtimeSuperclass.basicNew)'.\r	})\r)",
 "invokeMeta = (\r	^js functionOf: {js ident: 'runtimeSuperclass'. js ident: 'enclosingObjects'.} body: (js block: {\r		js function: 'constructRuntimeClass' of: {js ident: 'superBasicNew'} body: (js block: (\r			{\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime meta class for ', qualifiedName).\r			},\r			(copyMethods: classSide methods),\r			{\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: 'enclosingObjects`',qualifiedName)))\r				toBe: (js ident: 'enclosingObjects').\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: 'super`',qualifiedName)))\r				toBe: (js ident: 'runtimeSuperclass').\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'basicNew')) toBe: basicNewMeta.\r			js verbatim: 'this.basicNew.prototype = this'.\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'nonMeta')) toBe: (js ident: 'null').\r			js verbatim: 'this.newspeakClass = null'.\r			}\r		)).\r		js verbatim: 'constructRuntimeClass.prototype = runtimeSuperclass'.\r		js verbatim: 'return new constructRuntimeClass(runtimeSuperclass.basicNew)'.\r	})\r)",
 "makeMixin: rm = (\r	^js call: (js propertyOf: (js ident: 'Mixin') at: (js literal: 'fromRuntimeMixin')) with: {rm}\r)",
 "methodsMetadata = (\r	^js array: (instanceSide methods collect:\r		[:method | js new: (js ident: 'MM') with: {\r			js literal: method name.\r			js literal: method isSynthetic.\r			encodeSource: method source.\r		}])\r)",
 "nestedClassesMetadata = (\r	^js array: (instanceSide nestedClasses collect: [:nc | js literal: nc qualifiedName])\r)",
 "public printOn: stm = (\r	stm nextPutAll: 'ClassDeclarationIR:'.\r	stm nextPutAll: qualifiedName.\r)",
 "runtimeMetamixin = (\r	^js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'meta')) toBe: (\r	js new: (js functionOf: {} body: (js block: (\r		{\r		js var: '$' value: (js ident: 'this').\r		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime meta mixin for ', qualifiedName).\r		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'slots')) toBe: (js array: {}).\r		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'methods')) toBe: classMethodsMetadata.\r		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'nestedClasses')) toBe: (js array: {}).\r		},\r		(classSide methods collect: [:m |\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name))) toBe: m function]),\r		{\r		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'invoke')) toBe: invokeMeta.\r		}\r	))) with: {})\r)",
 "public runtimeMixin = (\r	^js new: (js functionOf: {} body: (js block: (\r		{\r		js var: '$' value: (js ident: 'this').\r		js var: '$', depth printString value: (js ident: 'this').\r		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime mixin for ', qualifiedName).\r		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'name')) toBe: (js literal: qualifiedName).\r		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'header')) toBe: (encodeSource: headerSource).\r		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'slots')) toBe: slotsMetadata.\r		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'methods')) toBe: methodsMetadata.\r		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'nestedClasses')) toBe: nestedClassesMetadata.\r		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'applications')) toBe: (js array: {}).\r		},\r		(instanceSide methods collect: [:m |\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name))) toBe: m function]),\r		(instanceSide nestedClasses collect: [:ncd |\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: ncd qualifiedName))) toBe: ncd runtimeMixin]),\r		(instanceSide nestedClasses collect: [:ncd |\r			js assign: (js propertyOf: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: ncd qualifiedName))) at: (js literal: 'enclosingMixin')) toBe: (js ident: 'this')]),\r		{\r		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'invoke')) toBe: invoke.\r		runtimeMetamixin.\r		js assign: (js propertyOf: (js propertyOf: (js ident: 'this') at: (js literal: 'meta')) at: (js literal: 'nonMeta')) toBe: (js ident: 'this').\r		}\r	))) with: {}\r)",
 "slotsMetadata = (\r	^js array: (instanceSide slots collect:\r		[:slot | js new: (js ident: 'SM') with: {\r			js literal: slot name.\r			js literal: slot isMutable.\r			js literal: slot isSynthetic\r	}]).\r)",
 "public class IntermediateMethod named: n accessModifier: am function: f source: s = (|\r	public name <Symbol> = n.\r	public function <JavascriptGeneration Syntax Node> = f.\r	public source <String> = s.\r	public isSynthetic ::= false.\r	public isFactory ::= false.\r	public accessModifier <Symbol> = am.\r|)",
 " ",
 " ",
 "public isPrivate ^ <Boolean> = (\r	^#private = accessModifier\r)",
 "public isProtected ^ <Boolean> = (\r	^#protected = accessModifier\r)",
 "public isPublic ^ <Boolean> = (\r	^#public = accessModifier\r)",
 "public printOn: stm = (\r	stm nextPutAll: 'MethodIR:'.\r	stm nextPutAll: name.\r)",
 "public class IntermediateMixin for: d <IntermediateClassDeclaration> isMeta: m <Boolean> = (|\r	public declaration <IntermediateClassDeclaration> = d.\r	public isMeta <Boolean> = m.\r	public slots <List[IntermediateSlotDeclaration]> = List new.\r	public methods <List[IntermediateMethod]> = List new.\r	public nestedClasses <List[IntermediateClassDeclaration]> = List new.\r|)",
 " ",
 " ",
 "public qualifiedName = (\r	^declaration qualifiedName\r)",
 "public class IntermediateSlotDeclaration named: n mutable: m accessModifier: am = (|\r	public name = n.\r	public isMutable = m.\r	public accessModifier = am.\r	public isSynthetic ::= false.\r|)",
 " ",
 " ",
 "public printOn: stm = (\r	stm nextPutAll: 'SlotIR:'.\r	stm nextPutAll: name.\r)",
 "class NameMangler = (|\r	private specialCharacterManglings = Map new.\r|specialCharacterManglings\r		at: \"+\" put: '$plus';\r		at: \"-\" put: '$minus';\r		at: \"*\" put: '$times';\r		at: \"/\" put: '$over';\r		at: \"\\\" put: '$back';\r		at: \"<\" put: '$less';\r		at: \">\" put: '$greater';\r		at: \"~\" put: '$tilde';\r		at: \"=\" put: '$equal';\r		at: \"@\" put: '$at';\r		at: \"%\" put: '$percent';\r		at: \"|\" put: '$pipe';\r		at: \"&\" put: '$amp';\r		at: \"?\" put: '$question';\r		at: \"!\" put: '$bang';\r		at: \",\" put: '$comma')",
 " ",
 " ",
 "protected _mangleSelector: selector <String> ^ <String> = (\r	(* Convert a Newspeak selector into a JS identifer. *)\r\r	(* Binary *)\r	('+-*/\\<>~=@%|&?!,' includes: selector first) ifTrue:\r		[ | sb = StringBuilder new. |\r		sb add: '$'.\r		selector do: [:specialCharacter | sb add: (specialCharacterManglings at: specialCharacter)].\r		^sb asString asSymbol].\r\r	^((('$', selector)\r		replaceAll: \":\" with: \"$\") (* Keyword *)\r		replaceAll: \"`\" with: \"$\") (* Qualified *)\r		replaceAll: \".\" with: \"$\" (* limit temp *)\r)",
 "public fullyQualifiedNameToSimple: fullName <String> = (\r	| parts |\r\r	parts:: splitFullyQualifiedName: fullName.\r	^parts last asSymbol\r)",
 "public mangleLocal: selector <String> ^ <String> = (\r	^_mangleSelector: selector\r)",
 "public mangleProtected: selector = (\r	^'_', (_mangleSelector: selector)\r)",
 "public manglePublic: selector = (\r	^_mangleSelector: selector\r)",
 "public mangleSlot: selector <String> ^ <String> = (\r	^(_mangleSelector: selector), '$slot'\r)",
 "public mangleSynthetic: selector = (\r	^_mangleSelector: selector\r)",
 "public privateCannotReturn = (\r	^'cannotReturn'\r)",
 "public privateDnu = (\r	^'dnu'\r)",
 "public class ProgramBuilder = (|\rprivate compiler = Compiler new.\rprivate mixins <List[ClassDeclarationIR]> = List new.\rprivate sentSelectors = Set new.\rprivate runtimeConfiguration <ClassDeclarationIR>\rprivate applicationConfiguration <ClassDeclarationIR>\rprivate resources <List[Node]> = List new.\r|)",
 " ",
 " ",
 "public addImageResource: relativeUrl under: name = (\r	| r i |\r	i:: js verbatim:\r	'vmmirror.kernel.$Future().$computing$(\r		function(){return vmmirror.platform.$js().$yourself()._$alienate$(\r			function(){ var i = new Image(); i.src =\"', relativeUrl,'\"; return i;}() );})'.\r	r:: js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: name)))\r				toBe: (js functionOf: {} body: (js block: {js return: i})).\r	resources add: r.\r)",
 "public addStringResource: string under: name = (\r	| r |\r	r:: js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: name)))\r				toBe: (js functionOf: {} body: (js block: {js return: (js literal: string)})).\r	resources add: r.\r)",
 "public applicationSources: sources <List[String]> = (\r	| results |\r	results:: sources collect: [:source | compileSource: source enableIntrinsics: false].\r	applicationConfiguration: results first.\r)",
 "compileSource: source <String> enableIntrinsics: flag <Boolean> ^<ClassDeclarationIR> = (\r	| compilation |\r	compilation:: cachedCompilations\r		at: {source. flag}\r		ifAbsentPut:\r			[ | newCompilation = CachedCompilation new. |\r			newCompilation source: source.\r			newCompilation enableIntrinsics: flag.\r			compiler enableIntrinsics: flag.\r			compiler sentSelectors: Set new.\r			newCompilation ir: (compiler compileClassSource: source within: nil).\r			newCompilation sentSelectors: compiler sentSelectors].\r	mixins add: compilation ir.\r	sentSelectors addAll: compilation sentSelectors.\r	^compilation ir\r)",
 "private main = (\r	^js verbatim:\r'var runtime = ns.$',runtimeConfiguration qualifiedName,'().$packageUsing$(ns);\rvmmirror.platform = runtime.$using$(vmmirror);\rvar app = ns.$',applicationConfiguration qualifiedName,'().$packageUsing$(ns);\rapp.$main$args$(vmmirror.platform, [])'\r)",
 "private namespace = (\r	^js var: 'ns' value: (js new: (js functionOf: {} body: (js block: (\r		(mixins asArray collect: [:cd |\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: cd qualifiedName)))\r				toBe: (js call: (js propertyOf: (js ident: 'vmmirror') at: (js literal: 'applyTopLevelMixin'))\r						with: {js propertyOf: (js ident: 'mixins') at: (js literal: (names manglePublic: cd qualifiedName))})]),\r		(mixins asArray collect: [:cd |\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: cd qualifiedName)))\r				toBe: (js functionOf: {} body: (js block: {js return:\r					(js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: cd qualifiedName)))}))]),\r		resources asArray\r	))) with: {})\r)",
 "public outputProgram ^<String> = (\r	| sb = StringBuilder new. |\r	JavascriptWriter new generateSourceFor: script on: sb.\r	^sb asString\r)",
 "public outputSources ^<String> = (\r	| sb = StringBuilder new. |\r	JavascriptWriter new generateSourceFor: sourcesScript on: sb.\r	^sb asString\r)",
 "private runtimeMixinNamespace = (\r	^js new: (js functionOf: {} body: (js block: (\r		mixins collect: [:cd |\r			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: cd qualifiedName))) toBe: cd runtimeMixin]\r	))) with: {}\r)",
 "public runtimeSources: sources <List[String]> = (\r	| results |\r	results:: sources collect: [:source | compileSource: source enableIntrinsics: true].\r	runtimeConfiguration: results first.\r)",
 "private script = (\r	compiler sentSelectors: sentSelectors.\r	sourcesList:: List new.\r	^js script:\r		{js literal: 'use strict'.\r		js var: 'nil' value: (js literal: 'patch me with nil').\r		js var: 'currentActor'.\r		js var: 'theGlobalObject' value: (js ident: 'this').\r		js verbatim: 'function SM(n,m,s){this.name=n; this.isMutable=m; this.isSynthetic=s; }'.\r		js verbatim: 'function MM(n,sy,src){this.name=n; this.isSynthetic=sy; this.source=src; }'.\r		js verbatim: 'function dnuCatcher(s){ return function() {\rreturn this.dnu(vmmirror.kernel.$Message().$mangledSelector$arguments$(s, Array.prototype.slice.call(arguments)));\r} }'.\r		js var: 'mixins' value: runtimeMixinNamespace.\r		vmmirror.\r		namespace.\r		compiler dnuHandlers.\r		main}\r)",
 "private sourcesScript = (\r	| elements = List new. |\r	elements add: (js ident: 'null').\r	sourcesList do: [:source | elements add: (js literal: source)].\r	^js var: 'sources' value: (js array: elements)\r)",
 "private vmmirror = (\r	^js verbatim:\r'\rvar vmmirror = new function(){\r\r	this.ImplementationBase$slot = new function(){\r		this.debug = \"ImplementationBase\";\r		this.$runtimeClass$slot = new function(){\r			this.debug = \"Runtime class for ImplementationBase\";\r			this.basicNew = function(){ this.hashCode = 0; };\r			this.$instance$initializer = function(){};\r			this._$instance$initializer = function(){};\r			this.toString = function(){ return this.$printString(); }\r		};\r	};\r	this.$ImplementationBase = function(){return this.ImplementationBase$slot;};\r	this.$Array = function(){return Array;};\r	this.$String = function(){return String;};\r	this.$printString = function(){return \"VMMirrorForV8\"};\r\r	this.createKernel = function(){\r\r		var enclosingObjects = [\"patch me with kernel\", \"patch me with nil\"];\r		var enclosingObjects2 = [\"patch me with nil\"];\r\r		var Object$runtimeClass = mixins.$KernelForV8.$KernelForV8$Object.invoke(this.$ImplementationBase().$runtimeClass$slot, enclosingObjects);\r		var Class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Class.invoke(Object$runtimeClass, enclosingObjects);\r		var Metaclass$runtimeClass = mixins.$KernelForV8.$KernelForV8$Metaclass.invoke(Object$runtimeClass, enclosingObjects);\r		var Mixin$runtimeClass = mixins.$KernelForV8.$KernelForV8$Mixin.invoke(Object$runtimeClass, enclosingObjects);\r		var UndefinedObject$runtimeClass = mixins.$KernelForV8.$KernelForV8$UndefinedObject.invoke(Object$runtimeClass, enclosingObjects);\r		var Kernel$runtimeClass = mixins.$KernelForV8.invoke(Object$runtimeClass, enclosingObjects2);\r\r		var Object$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Object.meta.invoke(Class$runtimeClass, enclosingObjects);\r		var Class$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Class.meta.invoke(Class$runtimeClass, enclosingObjects);\r		var Metaclass$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Metaclass.meta.invoke(Class$runtimeClass, enclosingObjects);\r		var Mixin$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Mixin.meta.invoke(Class$runtimeClass, enclosingObjects);\r		var UndefinedObject$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$UndefinedObject.meta.invoke(Class$runtimeClass, enclosingObjects);\r		var Kernel$class$runtimeClass = mixins.$KernelForV8.meta.invoke(Class$runtimeClass, enclosingObjects2);\r\r		Object$runtimeClass.meta = Object$class$runtimeClass;\r		Class$runtimeClass.meta = Class$class$runtimeClass;\r		Metaclass$runtimeClass.meta = Metaclass$class$runtimeClass;\r		Mixin$runtimeClass.meta = Mixin$class$runtimeClass;\r		UndefinedObject$runtimeClass.meta = UndefinedObject$class$runtimeClass;\r		Kernel$runtimeClass.meta = Kernel$class$runtimeClass;\r\r		Object$class$runtimeClass.nonMeta = Object$runtimeClass;\r		Class$class$runtimeClass.nonMeta = Class$runtimeClass;\r		Metaclass$class$runtimeClass.nonMeta = Metaclass$runtimeClass;\r		Mixin$class$runtimeClass.nonMeta = Mixin$runtimeClass;\r		UndefinedObject$class$runtimeClass.nonMeta = UndefinedObject$runtimeClass;\r		Kernel$class$runtimeClass.nonMeta = Kernel$runtimeClass;\r\r		nil = new UndefinedObject$runtimeClass.basicNew();\r\r		var Object = new Object$class$runtimeClass.basicNew();\r		var Class = new Class$class$runtimeClass.basicNew();\r		var Metaclass = new Metaclass$class$runtimeClass.basicNew();\r		var Mixin = new Mixin$class$runtimeClass.basicNew();\r		var UndefinedObject = new UndefinedObject$class$runtimeClass.basicNew();\r		var Kernel = new Kernel$class$runtimeClass.basicNew();\r\r		var Object$class = new Metaclass$runtimeClass.basicNew();\r		var Class$class = new Metaclass$runtimeClass.basicNew();\r		var Metaclass$class = new Metaclass$runtimeClass.basicNew();\r		var Mixin$class = new Metaclass$runtimeClass.basicNew();\r		var UndefinedObject$class = new Metaclass$runtimeClass.basicNew();\r		var Kernel$class = new Metaclass$runtimeClass.basicNew();\r\r		Object$class$runtimeClass.newspeakClass = Object$class;\r		Class$class$runtimeClass.newspeakClass = Class$class;\r		Metaclass$class$runtimeClass.newspeakClass = Metaclass$class;\r		Mixin$class$runtimeClass.newspeakClass = Mixin$class;\r		UndefinedObject$class$runtimeClass.newspeakClass = UndefinedObject$class;\r		Kernel$class$runtimeClass.newspeakClass = Kernel$class;\r\r		Object$runtimeClass.newspeakClass = Object;\r		Class$runtimeClass.newspeakClass = Class;\r		Metaclass$runtimeClass.newspeakClass = Metaclass;\r		Mixin$runtimeClass.newspeakClass = Mixin;\r		UndefinedObject$runtimeClass.newspeakClass = UndefinedObject;\r		Kernel$runtimeClass.newspeakClass = Kernel;\r\r		var kernel = Kernel.$usingVmMirror$(this);\r\r		//superclass$slot\r		Object.$superclass$slot = nil;\r		Class.$superclass$slot = Object;\r		Metaclass.$superclass$slot = Object;\r		Mixin.$superclass$slot = Object;\r		UndefinedObject.$superclass$slot = Object;\r		Kernel.$superclass$slot = Object;\r\r		Object$class.$superclass$slot = Class;\r		Class$class.$superclass$slot = Class;\r		Metaclass$class.$superclass$slot = Class;\r		Mixin$class.$superclass$slot = Class;\r		UndefinedObject$class.$superclass$slot = Class;\r		Kernel$class.$superclass$slot = Class;\r\r		//mixin$slot\r		Object.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Object);\r		Class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Class);\r		Metaclass.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Metaclass);\r		Mixin.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Mixin);\r		UndefinedObject.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$UndefinedObject);\r		Kernel.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8);\r\r		Object$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Object.meta);\r		Class$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Class.meta);\r		Metaclass$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Metaclass.meta);\r		Mixin$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Mixin.meta);\r		UndefinedObject$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$UndefinedObject.meta);\r		Kernel$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.meta);\r\r		//enclosingObject$slot\r		Object.$enclosingObject$slot = kernel;\r		Class.$enclosingObject$slot = kernel;\r		Metaclass.$enclosingObject$slot = kernel;\r		Mixin.$enclosingObject$slot = kernel;\r		UndefinedObject.$enclosingObject$slot = kernel;\r		Kernel.$enclosingObject$slot = nil;\r\r		Object$class.$enclosingObject$slot = kernel;\r		Class$class.$enclosingObject$slot = kernel;\r		Metaclass$class.$enclosingObject$slot = kernel;\r		Mixin$class.$enclosingObject$slot = kernel;\r		UndefinedObject$class.$enclosingObject$slot = kernel;\r		Kernel$class.$enclosingObject$slot = nil;\r\r		enclosingObjects[0] = kernel;\r		enclosingObjects[1] = nil;\r		enclosingObjects2[0] = nil;\r\r		//name$slot\r		Object.$name$slot = \"Object\";\r		Class.$name$slot = \"Class\";\r		Metaclass.$name$slot = \"Metaclass\";\r		Mixin.$name$slot = \"Mixin\";\r		Kernel.$name$slot = \"Kernel\";\r\r		Object$class.$name$slot = \"Object class\";\r		Class$class.$name$slot = \"Class class\";\r		Metaclass$class.$name$slot = \"Metaclass class\";\r		Mixin$class.$name$slot = \"Mixin class\";\r		Kernel$class.$name$slot = \"Kernel class\";\r\r		//runtimeClass\r		Object.runtimeClass = Object$runtimeClass;\r		Class.runtimeClass = Class$runtimeClass;\r		Metaclass.runtimeClass = Metaclass$runtimeClass;\r		Mixin.runtimeClass = Mixin$runtimeClass;\r		Kernel.runtimeClass = Kernel$runtimeClass;\r\r		Object$class.runtimeClass = Metaclass$runtimeClass;\r		Class$class.runtimeClass = Metaclass$runtimeClass;\r		Metaclass$class.runtimeClass = Metaclass$runtimeClass;\r		Mixin$class.runtimeClass = Metaclass$runtimeClass;\r		Kernel$class.runtimeClass = Metaclass$runtimeClass;\r\r		//thisClass$slot\r		Object$class.$thisClass$slot = Object;\r		Class$class.$thisClass$slot = Class;\r		Metaclass$class.$thisClass$slot = Metaclass;\r		Mixin$class.$thisClass$slot = Mixin;\r		Kernel$class.$thisClass$slot = Kernel;\r\r		kernel.$KernelForV8$Object$slot = Object;\r		kernel.$KernelForV8$Class$slot = Class;\r		kernel.$KernelForV8$Metaclass$slot = Metaclass;\r		kernel.$KernelForV8$Mixin$slot = Mixin;\r\r		return kernel;\r	};\r	this.kernel = this.createKernel();\r\r	this.applyTopLevelMixin = function(runtimeMixin){\r		return this.$applyMixin$toSuperclass$withEnclosingObjects$(runtimeMixin, this.kernel._$Object(), [nil]);\r	};\r\r	this.$applyMixin$toSuperclass$withEnclosingObjects$ = function(runtimeMixin, newspeakSuperclass, enclosingObjects){\r\r		var Class = this.kernel.$Class();\r		var Metaclass = this.kernel.$Metaclass();\r		var Mixin = this.kernel.$Mixin();\r\r		var runtimeSuperclass = newspeakSuperclass.runtimeClass;\r		var runtimeClass = runtimeMixin.invoke(runtimeSuperclass, enclosingObjects);\r		var runtimeMetaclass = runtimeMixin.meta.invoke(Class.runtimeClass, enclosingObjects);\r		runtimeClass.meta = runtimeMetaclass;\r		runtimeMetaclass.nonMeta = runtimeClass;\r\r		var newspeakMetaclass = Metaclass.$new();\r		var newspeakClass = new runtimeMetaclass.basicNew();\r\r		runtimeClass.newspeakClass = newspeakClass;\r		runtimeMetaclass.newspeakClass = newspeakMetaclass;//Class;\r\r		newspeakMetaclass.$superclass$slot = Class;\r		newspeakMetaclass.$mixin$slot = Mixin.$fromRuntimeMixin$(runtimeMixin.meta);\r		newspeakMetaclass.$enclosingObject$slot = enclosingObjects[0];\r		newspeakMetaclass.$enclosingObjects$slot = enclosingObjects;\r		newspeakMetaclass.$name$slot = runtimeMixin.name + \" class\";\r		newspeakMetaclass.$thisClass$slot = newspeakClass;\r		newspeakMetaclass.runtimeClass = runtimeMetaclass;\r\r		newspeakClass.$superclass$slot = newspeakSuperclass;\r		newspeakClass.$mixin$slot = Mixin.$fromRuntimeMixin$(runtimeMixin);\r		newspeakClass.$enclosingObject$slot = enclosingObjects[0];\r		newspeakClass.$enclosingObjects$slot = enclosingObjects;\r		newspeakClass.$name$slot = runtimeMixin.name;\r		newspeakClass.runtimeClass = runtimeClass;\r\r		runtimeMixin.applications.push(runtimeClass);\r		return newspeakClass;\r	};\r\r	var specialCharacters = new Object();\r	specialCharacters[\"plus\"] = \"+\";\r	specialCharacters[\"minus\"] = \"-\";\r	specialCharacters[\"times\"] = \"*\";\r	specialCharacters[\"over\"] = \"/\";\r	specialCharacters[\"back\"] = \"\\\\\";\r	specialCharacters[\"less\"] = \"<\";\r	specialCharacters[\"greater\"] = \">\";\r	specialCharacters[\"tilde\"] = \"~\";\r	specialCharacters[\"equal\"] = \"=\";\r	specialCharacters[\"at\"] = \"@\";\r	specialCharacters[\"percent\"] = \"%\";\r	specialCharacters[\"pipe\"] = \"|\";\r	specialCharacters[\"amp\"] = \"&\";\r	specialCharacters[\"question\"] = \"?\";\r	specialCharacters[\"bang\"] = \"!\";\r	specialCharacters[\"comma\"] = \",\";\r\r	this.$unmangleSelector$ = function(s) {\r		if(s[0] != \"$\") return \"<jsSelector:\"+s+\">\";\r		if(s[s.length-1] == \"$\")\r			// Keyword\r			return s.substring(1).replace(/\\$/g,\":\");\r		if(s[1] == \"$\")\r			// Binary\r			return s.substring(2).split(\"$\").map(function(x) {return specialCharacters[x];}).join(\"\");\r		// Unary / qualified\r	   	return s.substring(1).replace(/\\$/g,\"`\");\r	};\r\r	this.$mangleSelector$ = function(s) {\r		return \"$\" + s.replace(/\\:/g,\"$\").replace(/\\`/g,\"$\");\r	};\r};\r'\r)",
 "class NewspeakCompilation usingPlatform: p asts: asts = (\r(* Facilities common to each of the Newspeak compilers, such as scopes and the scope builder. A common Rewriter should eventually be located here as well.\r\rIt is intended that module definitions for each compilation target will be mixed-in to this module definition, and so inherit the facilities provided here. Until general mixin application is supported, the target-specific modules must use the same cheat used by BlocklessCombinatorialParsing of declaring a superclass clause matching the factory of the class it will be later mixed-in to.\r\r\rThis module is derived from Newspeak2SqueakCompilation, which is why the pre-2013 copyrights apply.\r\rCopyright 2008 Cadence Design Systems, Inc.\rCopyright 2010 Gilad Bracha, Felix Geller and Ryan Macnak\rCopyright 2011 Matthias Kleine, Ryan Macnak and Cadence Design Systems\rCopyright 2013 Ryan Macnak\r\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 *)\r|\r	private Map = p collections Map.\r	private List = p collections List.\r\r	private AST = asts AST.\r	private ASTTool = asts ASTTool.\r	private BlockAST = asts BlockAST.\r	private CascadedSendAST = asts CascadedSendAST.\r	private CodeBodyAST = asts CodeBodyAST.\r	private MessageAST = asts MessageAST.\r	private MessagePatternAST = asts MessagePatternAST.\r	private MethodAST = asts MethodAST.\r	private UnresolvedSendAST = asts UnresolvedSendAST.\r	private NumberAST = asts NumberAST.\r	private ReturnStatAST = asts ReturnStatAST.\r	private TupleAST = asts TupleAST.\r	private VariableAST = asts VariableAST.\r\r	public namer = Namer new.\r|)",
 " ",
 " ",
 "class ClassEntry forDeclaration: cd atDepth: d = SymbolTableEntry forAST: cd atDepth: d (|\rpublic enclosingClass <ClassEntry>\r|)",
 "forAST: cd atDepth: d",
 "forAST: cd atDepth: d",
 "public name = (\r	^ast selector\r)",
 "class Compiler = ()",
 " ",
 " ",
 "public Scope = (\r	^outer NewspeakCompilation Scope\r)",
 "checkForReservedWord: selector = (\r	(namer isReservedWord: selector) ifTrue:\r		[Error signal: '\"', selector, '\" is a reserved word'].\r)",
 "public compileClassHeader: source <String> within: enclosingIR <IntermediateMixin> = (\r	subclassResponsibility\r)",
 "public compileClassSource: src <String> within: enclosingIR <IntermediateMixin> ^<IntermediateClassDeclaration> = (\r	subclassResponsibility\r)",
 "public compileExpressionSource: src <String> debugMapper: debugMapper <MethodContext> withScope: withScope <Map> inMixin: enclosing <MixinMirror> ^<IntermediateMethod> = (\r	subclassResponsibility\r)",
 "public compileMethodSource: source <String> within: enclosing <IntermediateMixin> ^<IntermediateMethod> = (\r	subclassResponsibility\r)",
 "public compileTransientSlotSource: src <String> within: enclosingIR <IntermediateMixin> ^<IntermediateTransientSlot> = (\r	subclassResponsibility\r)",
 "class Rewriter = ASTTool (\r(* A common rewriter for the Newspeak compilers targeting Squeak and JavaScript.\r\r - Resolves sends to self, super, outer, implicit receiver and ordinary sends, as well as local variable reads and writes.\r - Resolves returns to local and non-local returns.\r - Adds the implicit return self to method bodies without a return statement.\r - Adds the implicit return nil to empty closure bodies.\r - Adds local slot initializers to statement lists.\r - Adds temporaries to turn setter sends into regular implicit receiver sends.\r - Rewrites well-known control messages with closure literal arguments to branches and loops. *)\r|\r	currentScope <Scope>\r	valueExpected <Boolean>\r	closureDepth <Integer>\r|)",
 "ASTTool",
 "ASTTool",
 "applyForEffectTo: node <Node> = (\r	| original result |\r	original:: valueExpected.\r	valueExpected:: false.\r	result:: node apply: self.\r	valueExpected:: original.\r	^result\r)",
 "applyForValueTo: node <Node> = (\r	| original result |\r	original:: valueExpected.\r	valueExpected:: true.\r	result:: node apply: self.\r	valueExpected:: original.\r	^result\r)",
 "public blockNode: node <BlockAST> = (\r	| rewrittenBlock <BlockAST> last <AST> |\r	closureDepth:: closureDepth + 1.\r	rewrittenBlock:: rewriteBlockNode: node forValue: true.\r	last:: rewrittenBlock body statements last.\r	(last isKindOfReturnStatNode or: [last isKindOfBlockLocalReturnAST]) ifFalse:\r		[(* The last expression in a block is returned by it. *)\r		rewrittenBlock body statements removeLast.\r		rewrittenBlock body statements add:\r			((BlockLocalReturnAST expression: last) copyPositionFrom: last)].\r	closureDepth:: closureDepth - 1.\r	^rewrittenBlock\r)",
 "canInlineSeqexps ^<Boolean> = (\r	^true (* No on JS and Dart *)\r)",
 "public cascadedSendNode: node <CascadedSendAST> = (\r	| prevSend msg |\r	prevSend:: node previousSend apply: self.\r	msg:: node message apply: self.\r	^CascadedSendAST new to: prevSend cascade: msg\r)",
 "public characterNode: node <CharacterAST> = (\r	^node\r)",
 "public codeBodyNode: node <CodeBodyAST> = (\r	(* Move slot initializers to statements. Simultaneous slots. *)\r\r	| bodyScope parameters temporaries setterEntry statements result |\r	bodyScope:: Scope parent: currentScope.\r	node parameters do:\r		[:parameter <VarDeclAST> |\r		 checkForReservedWord: parameter name.\r		 (bodyScope includesKeyLocal: parameter name) ifTrue:\r			[Error signal: 'Conflicting slots named ', parameter name].\r		 bodyScope\r			at: parameter name\r			put: (LocalEntry\r				forDeclaration: parameter\r				atDepth: nil)].\r	node temporaries do:\r		[:temporary <SlotDefAST> | | local |\r		 checkForReservedWord: temporary name.\r		 (bodyScope includesKeyLocal: temporary name) ifTrue:\r			[Error signal: 'Conflicting slots named ', temporary name].\r		 local:: LocalEntry forDeclaration: temporary slotDecl atDepth: nil.\r		 bodyScope at: (namer selectorForSlotInitializer: temporary) put: local.\r		 bodyScope at: (namer selectorForSlotGetter: temporary) put: local.\r		 temporary isMutable ifTrue:\r			[bodyScope at: (namer selectorForSlotSetter: temporary) put: local]].\r	pushScope: bodyScope.\r\r	parameters:: node parameters collect:\r		[:varDecl <VarDeclAST> | | p |\r		 p:: currentScope at: varDecl name.\r		 p closureDepth: closureDepth.\r		 p].\r\r	temporaries:: List new.\r	node temporaries do:\r		[:varDecl <VarDeclAST> | | t |\r		 t:: currentScope at: varDecl name.\r		 t closureDepth: closureDepth.\r		 temporaries add: t].\r\r	setterEntry:: LocalEntry forDeclaration: (TemporaryAST name: namer setterTemp type: nil) atDepth: nil.\r	bodyScope at: namer setterTemp put: setterEntry.\r	bodyScope at: (namer setterTemp, ':') asSymbol put: setterEntry.\r	temporaries add: setterEntry.\r\r	statements:: List new.\r	node temporaries do:\r		[:varDecl <VarDeclAST> |\r		| initializer |\r		initializer:: varDecl initializer.\r		nil = initializer ifFalse:\r			[node isSeq ifFalse:\r				[initializer:: futureFor: initializer].\r			statements add: (LocalWriteAST\r				to: (bodyScope at: varDecl name)\r				assign: (self applyForValueTo: initializer))]].\r\r	node statements keysAndValuesDo:\r		[:index :statement |\r		| rewritten |\r		rewritten:: (index = node statements size and: [valueExpected])\r			ifTrue: [applyForValueTo: statement]\r			ifFalse: [applyForEffectTo: statement].\r		statements add: rewritten].\r\r	setterEntry used ifFalse:\r		[bodyScope at: namer setterTemp put: nil.\r		 bodyScope at: (namer setterTemp, ':') asSymbol put: nil.\r		 temporaries remove: setterEntry].\r\r	popScope.\r	result:: CodeBodyAST new\r		parameters: parameters\r		temporaries: temporaries\r		statements: statements.\r	result literalMessages: node literalMessages.\r	^result\r)",
 "depthOfEnclosingClass: name <Symbol> ^<Integer> = (\r	| entry <ClassEntry> |\r	entry:: currentScope at: #'@currentClass'.\r	[entry isNil] whileFalse:\r		[entry name = name ifTrue: [\r			^entry depth].\r		entry:: entry enclosingClass].\r	Error signal: 'No enclosing class named \"', name, '\"'\r)",
 "emptyBody = (\r	| body |\r	#BOGUS. (* Should be able to use immutable collections. *)\r	body:: CodeBodyAST new\r		parameters: List new;\r		temporaries: List new;\r		statements: (List new add: NilAST new; yourself).\r	^body\r)",
 "futureFor: expression <ExpressionAST> ^<ExpressionAST> = (\r	(* @here Future computing: [expression] *)\r	^UnresolvedSendAST new\r		receiver: (UnresolvedSendAST new\r			receiver: implicitReceiverNode;\r			message: (MessageAST new selector: #Future; arguments: {}));\r		message: (MessageAST new selector: #computing:; arguments: {\r			BlockAST new body: (\r				 CodeBodyAST new\r					parameters: List new;\r					temporaries: List new;\r					statements: {expression})})\r)",
 "implicitReceiverNode ^<VariableAST> = (\r	^VariableAST new name: #'@here'\r)",
 "isImplicitReceiverNode: node <AST> ^<Boolean> = (\r	node isKindOfVariableNode ifFalse: [^false].\r	^node name = #'@here'\r)",
 "isInlineableConditional: node <NormalSendAST> ^<Boolean> = (\r	canInlineSeqexps ifFalse: [valueExpected ifTrue: [^false]].\r	node message isEventual ifTrue: [^false].\r	({#ifTrue:. #ifFalse:. #ifTrue:ifFalse:. #ifFalse:ifTrue:} includes: node message selector)\r	     ifFalse: [^false].\r	node message arguments do: [:arg <AST> | (isRemovableBlock: arg withArgs: 0) ifFalse: [^false]].\r	^true\r)",
 "isInlineableLoop: node <NormalSendAST> ^<Boolean> = (\r	| selector <Symbol> args |\r	canInlineSeqexps ifFalse: [valueExpected ifTrue: [^false]].\r	node message isEventual ifTrue: [^false].\r	selector:: node message selector.\r	args:: node message arguments.\r	({#whileTrue. #whileFalse. #whileTrue:. #whileFalse:. #repeat} includes: selector) ifTrue:\r		[args do:\r			[:each |\r			(isRemovableBlock: each withArgs: 0) ifFalse: [^false]].\r		^isRemovableBlock: node receiver withArgs: 0].\r\r	(selector = #timesRepeat:) ifTrue: [^isRemovableBlock: args last withArgs: 0].\r	({#to:do:. #to:by:do:} includes: selector) ifFalse: [^false].\r	(isRemovableBlock: args last withArgs: 1) ifFalse: [^false].\r	(selector = #to:do:) ifTrue: [^true].\r	^args size = 3\r)",
 "isOuterNode: node <AST> ^<Boolean> = (\r	node isKindOfVariableNode ifFalse: [^false].\r	^node name = #outer\r)",
 "isRemovableBlock: block <BlockAST> withArgs: numArgs <Integer> ^<Boolean> = (\r	(* Answers true if block can be removed (inlined) within another block. *)\r	block isKindOfBlockNode ifFalse: [^false].\r	block parameters size = numArgs ifFalse: [^false].\r	^true\r)",
 "isSelfNode: node <AST> ^<Boolean> = (\r	node isKindOfVariableNode ifFalse: [^false].\r	^node name = #self\r)",
 "isSuperNode: node <AST> ^<Boolean> = (\r	node isKindOfVariableNode ifFalse: [^false].\r	^node name = #super\r)",
 "public messageNode: node <MessageAST> ^<MessageAST> = (\r	^MessageAST new\r		send: node selector\r		with: (node arguments collect: [:arg | applyForValueTo: arg]);\r		isEventual: node isEventual;\r		start: node start;\r		end: node end\r)",
 "public methodNode: node <MethodAST> inScope: scope = (\r	(* Need setter temp? Implicit ^self? *)\r	| body accessModifier result |\r	checkForReservedWord: node selector.\r	closureDepth:: 0.\r	currentScope:: scope.\r	node body parameters: node pattern parameters. (* Should the parser do this? *)\r	(* We add the implicit ^self before rewritting the body to ensure the last non-return statment is rewritten for effect. *)\r	(node body statements isEmpty or: [node body statements last isKindOfReturnStatNode not])\r		ifTrue: [node body statements add:\r					(ReturnStatAST new expression: (VariableAST new name: #self))].\r	body:: self applyForEffectTo: node body.\r	result:: MethodAST new\r		pattern: node pattern\r		body: body\r		accessModifier: node accessModifier.\r	currentScope:: nil.\r	^result\r)",
 "public numberNode: node <NumberAST> = (\r	^node\r)",
 "offsetOfEnclosingObjectForClass: name <Symbol> ^<Integer> = (\r	| entry <ClassEntry> |\r	entry:: currentScope at: #'@currentClass'.\r	[entry isNil] whileFalse:\r		[entry name = name ifTrue: [\r			| offset = outer Compiler currentDepth - entry depth - 1. |\r			assert: [offset >= 0] message: 'Invalid enclosing object index'.\r			^offset].\r		entry:: entry enclosingClass].\r	Error signal: 'No enclosing class named \"', name, '\"'\r)",
 "offsetOfImplicitReceiverTarget: binding <SymbolTableEntry> ^<Integer> = (\r	(* Note this calculation differs from the one used by explicit outer sends by a factor of one. This is because an explicit outer send needs the depth of the enclosing object with for a class whose name is a given selector, whereas an implicit receiver send needs the depth of the enclosing object for the class that defined a given selector. *)\r	| depth |\r	depth:: outer Compiler currentDepth - binding depth.\r	assert: [depth >= 0] message: 'Invalid enclosing object index'.\r	^depth\r)",
 "popScope = (\r	currentScope:: currentScope parent.\r)",
 "processEventualSend: node <NormalSendAST> = (\r	subclassResponsibility\r)",
 "processImplicitReceiverSend: node <UnresolvedSendAST> = (\r	|\r	message = node message.\r	selector = message selector.\r	binding <SymbolTableEntry>\r	|\r\r	selector = #self ifTrue:\r		[^ReceiverAST new copyPositionFrom: message].\r	selector = #nil ifTrue:\r		[^NilAST new copyPositionFrom: message].\r	selector = #false ifTrue:\r		[^(BooleanAST withValue: false) copyPositionFrom: message].\r	selector = #true ifTrue:\r		[^(BooleanAST withValue: true) copyPositionFrom: message].\r\r	binding:: currentScope at: selector ifAbsent: [nil].\r\r	(* Nothing is lexically visible. *)\r	binding isNil ifTrue:\r		[^processImplicitReceiverSend: message binding: nil].\r\r	binding isLocalBinding ifTrue:\r		[^processLocalAccess: message of: binding].\r\r	binding isMappedBinding ifTrue:\r		[^processMappedVariable: message decl: binding].\r\r	^processImplicitReceiverSend: message binding: binding\r)",
 "processImplicitReceiverSend: msg <MessageAST> binding: binding <ClassEntry | SlotEntry | MethodEntry> = (\r	| depth = binding isNil ifTrue: [0] ifFalse: [offsetOfImplicitReceiverTarget: binding]. |\r	^(ImplicitReceiverSendAST new\r		depth: depth;\r		binding: binding;\r		message: (msg apply: self))\r		copyPositionFrom: msg\r)",
 "processInlineableConditional: node <NormalSendAST> = (\r	|\r	receiver = node receiver apply: self.\r	selector = node message selector.\r	numArgs = node message arguments size.\r	arg1 = numArgs > 0 ifTrue:\r		[(rewriteInlinedBlockNode: (node message arguments at: 1) forValue: valueExpected) body].\r	arg2 = numArgs > 1 ifTrue:\r		[(rewriteInlinedBlockNode: (node message arguments at: 2) forValue: valueExpected) body].\r	|\r	selector = #ifTrue:\r		ifTrue: [^ConditionalAST if: receiver is: true then: arg1 forValue: valueExpected].\r	selector = #ifFalse:\r		ifTrue: [^ConditionalAST if: receiver is: false then: arg1 forValue: valueExpected].\r	selector = #ifTrue:ifFalse:\r		ifTrue: [^ConditionalAST if: receiver is: true then: arg1 else: arg2].\r	selector = #ifFalse:ifTrue:\r		ifTrue: [^ConditionalAST if: receiver is: false then: arg1 else: arg2].\r	assert: [false] message: 'Unknown conditional selector'\r)",
 "processInlineableLoop: node <NormalSendAST> ^<LoopAST> = (\r	|\r	rcvr = node receiver.\r	msg = node message.\r	sel = msg selector.\r	numArgs = msg arguments size.\r	arg1 = numArgs >= 1 ifTrue: [msg arguments at: 1].\r	arg2 = numArgs >= 2 ifTrue: [msg arguments at: 2].\r	arg3 = numArgs >= 3 ifTrue: [msg arguments at: 3].\r	|\r\r	sel = #whileTrue ifTrue: [^LoopAST new\r		while: true\r		do: (rewriteInlinedBlockNode: rcvr forValue: true) body].\r	sel = #whileFalse ifTrue: [^LoopAST new\r		while: false\r		do: (rewriteInlinedBlockNode: rcvr forValue: true) body].\r	sel = #whileTrue: ifTrue: [^LoopAST new\r		while: (rewriteInlinedBlockNode: rcvr forValue: true) body\r		is: true\r		do: (rewriteInlinedBlockNode: arg1 forValue: false) body].\r	sel = #whileFalse: ifTrue: [^LoopAST new\r		while: (rewriteInlinedBlockNode: rcvr forValue: true) body\r		is: false\r		do: (rewriteInlinedBlockNode: arg1 forValue: false) body].\r\r	sel = #repeat ifTrue: [^LoopAST new\r		repeat: (rewriteInlinedBlockNode: rcvr forValue: false) body].\r\r	sel = #timesRepeat: ifTrue: [^LoopAST new\r		do: (rcvr apply: self)\r		timesRepeat: arg1].\r\r	sel = #to:do: ifTrue: [^LoopAST new\r		from: (rcvr apply: self)\r		to: (arg1 apply: self)\r		do: arg2].\r\r	sel = #to:by:do: ifTrue: [^LoopAST new\r		from: (rcvr apply: self)\r		to: (arg1 apply: self)\r		by: (arg2 apply: self)\r		do: arg3].\r\r	assert: [false] message: 'Unknown loop selector'\r)",
 "processLocalAccess: msg <MessageAST> of: decl <SlotEntry> = (\r	^(msg selector endsWith: ':')\r		ifTrue: [processLocalWrite: msg to: decl]\r		ifFalse: [processLocalRead: msg from: decl]\r)",
 "processLocalRead: message <MessageAST> from: declaration <LocalEntry> = (\r	assert: [message arguments isEmpty] message: ''.\r	assert: [declaration isNil not] message: ''.\r	^(LocalReadAST of: declaration)\r		start: message start;\r		end: message end\r)",
 "processLocalWrite: message <MessageAST> to: declaration <LocalEntry> = (\r	assert: [message arguments size = 1] message: ''.\r	^(LocalWriteAST\r		to: declaration assign: (applyForValueTo: message arguments first))\r		copyPositionFrom: message\r)",
 "processOrdinarySend: node <UnresolvedSendAST> ^<AST> = (\r	(isInlineableConditional: node)\r		ifTrue: [^processInlineableConditional: node].\r	(isInlineableLoop: node)\r		ifTrue: [^processInlineableLoop: node].\r\r	(* And lo, we really have a normal send. *)\r	^(OrdinarySendAST\r		to: (node receiver apply: self) send: (node message apply: self))\r		copyPositionFrom: node\r)",
 "processOuterExpression: node <UnresolvedSendAST> = (\r	^EnclosingObjectAST new\r		depth: (offsetOfEnclosingObjectForClass: node message selector);\r		start: node receiver start;\r		end: node message end\r)",
 "processOuterSend: node <UnresolvedSendAST> = (\r	(* +1 because we're looking for members of the enclosing class, not the siblings of the enclosing class. *)\r	| binding = currentScope\r		at: node message selector\r		depth: (depthOfEnclosingClass: node receiver message selector) + 1. |\r	^OuterSendAST new\r		depth: (offsetOfEnclosingObjectForClass: node receiver message selector);\r		binding: binding;\r		message: (node message apply: self);\r		start: node receiver receiver start;\r		end: node message end\r)",
 "processSelfSend: node <UnresolvedSendAST> = (\r	| binding = currentScope at: node message selector depth: outer Compiler currentDepth. |\r	^SelfSendAST new\r		message: (node message apply: self);\r		binding: binding;\r		copyPositionFrom: node\r)",
 "processSetterSend: node <SetterSendAST> binding: binding ^<AST> = (\r	|\r	setterTempBinding <LocalEntry>\r	setterTempRead\r	setterTempWrite\r	message <MessageAST>\r	send <NormalSendAST>\r	depth\r	body <CodeBodyAST>\r	|\r	valueExpected\r		ifFalse: [^processImplicitReceiverSend: node message binding: binding].\r\r	setterTempBinding:: currentScope at: namer setterTemp.\r	setterTempBinding used: true.\r\r	(* t := exp *)\r	setterTempWrite:: LocalWriteAST\r		to: setterTempBinding\r		assign: (node message arguments first apply: self).\r\r	(* setter: t *)\r	setterTempRead:: LocalReadAST of: setterTempBinding.\r	message:: MessageAST new selector: node message selector; arguments: {setterTempRead}.\r	assert: [isImplicitReceiverNode: node receiver] message: 'Setter send receiver should be implicit'.\r	depth:: binding isNil ifTrue: [0] ifFalse: [offsetOfImplicitReceiverTarget: binding].\r	send:: ImplicitReceiverSendAST new\r		depth: depth;\r		binding: binding;\r		message: message. (* Do not rewrite message twice *)\r\r	(* t:=exp. setter: t. t *)\r	body:: CodeBodyAST new\r		parameters: List new;\r		temporaries: {};\r		statements: {setterTempWrite. send. setterTempRead}.\r	^body\r)",
 "processSuperSend: node <UnresolvedSendAST> = (\r	^SuperSendAST new\r		message: (node message apply: self);\r		copyPositionFrom: node\r)",
 "pushScope: scope <Scope> = (\r	currentScope:: scope\r)",
 "public returnStatNode: node <ReturnStatAST> = (\r	^((closureDepth > 0 ifTrue: [NonlocalReturnAST] ifFalse: [MethodLocalReturnAST])\r		expression: (applyForValueTo: node expression))\r		copyPositionFrom: node\r)",
 "rewriteBlockNode: node <BlockAST> forValue: forValue <Boolean> ^ <BlockAST> = (\r(* An empty block evaluates to nil when called. This method performs the necessary transformation if the block is empty; otherwise it recursively rewrites the block body. This rewrite is done on all blocks, regardless of whether they are inlined. *)\r	|\r	rewrittenNode <BlockAST>\r	|\r	(* this shouldn't be handled here, but I'm not sure where the block / codebody\r	comes from. *)\r	node body start isKindOfNumber\r		ifFalse: [node body start: node start. node body end: node end].\r\r	rewrittenNode:: BlockAST new body:\r		(forValue ifTrue: [applyForValueTo: node body] ifFalse: [applyForEffectTo: node body]).\r	rewrittenNode start: node start; end: node end.\r	node body statements isEmpty ifTrue:\r		[rewrittenNode body statements add: (NilAST new start: node body start; end: node body end)].\r	^rewrittenNode\r)",
 "rewriteInlinedBlockNode: node <BlockAST> forValue: forValue <Boolean> ^ <CodeBodyAST> = (\r(* An empty block evaluates to nil when called. This method performs the necessary transformation if the block is empty; otherwise it recursively rewrites the block body. This rewrite is done on all blocks, regardless of whether they are inlined. *)\r	^rewriteBlockNode: node forValue: forValue\r)",
 "public setterSendNode: node <SetterSendAST> ^<AST> = (\r	|\r	message = node message.\r	selector = message selector.\r	binding <SymbolTableEntry>\r	|\r\r	binding:: currentScope at: selector ifAbsent: [nil].\r\r	(* Nothing is lexically visible. *)\r	binding isNil ifTrue:\r		[^processSetterSend: node binding: nil].\r\r	binding isLocalBinding ifTrue:\r		[^processLocalAccess: message of: binding].\r\r	binding isMappedBinding ifTrue:\r		[^processMappedVariable: message decl: binding].\r\r	^processSetterSend: node binding: binding\r)",
 "public stringNode: node <StringAST> = (\r	^node\r)",
 "public symbolNode: node <SymbolAST> = (\r	^node\r)",
 "public tupleNode: node <TupleAST> = (\r	^TupleAST new elements: (node elements collect: [:element | applyForValueTo: element])\r)",
 "public unresolvedSendNode: node <UnresolvedSendAST> ^<AST> = (\r	(node message isEventual) ifTrue:\r		[^processEventualSend: node].\r	(isImplicitReceiverNode: node receiver) ifTrue:\r		[^processImplicitReceiverSend: node].\r	(isSelfNode: node receiver) ifTrue:\r		[^processSelfSend: node].\r	(isSuperNode: node receiver) ifTrue:\r		[^processSuperSend: node].\r	(isOuterNode: node receiver) ifTrue:\r		[^processOuterExpression: node].\r	(node receiver isKindOfSendNode and: [isOuterNode: node receiver receiver]) ifTrue:\r		[^processOuterSend: node].\r	^processOrdinarySend: node\r)",
 "public variableNode: node <VariableAST> = (\r	node name = #self ifTrue:\r		[^ReceiverAST new copyPositionFrom: node].\r	node name = #nil ifTrue:\r		[^NilAST new copyPositionFrom: node].\r	node name = #true ifTrue:\r		[^(BooleanAST withValue: true) copyPositionFrom: node].\r	node name = #false ifTrue:\r		[^(BooleanAST withValue: false) copyPositionFrom: node].\r	assert: [(node name = #super) not] message: '\"super\" is not a valid expression'.\r	assert: [(node name = #outer) not] message: '\"outer\" is not a valid expression'.\r	halt.\r	^node\r)",
 "public class BlockLocalReturnAST expression: e = ReturnAST expression: e ()",
 "expression: e",
 "expression: e",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool blockLocalReturnNode: self\r)",
 "public isKindOfBlockLocalReturnAST ^<Boolean> = (\r	^true\r)",
 "public class BooleanAST withValue: b = AST (|\r	public value = b.\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool boolNode: self\r)",
 "public isKindOfLiteralNode ^<Boolean> = (^true)",
 "public printOn: stream = (\r	stream nextPutAll: 'BooleanAST: '.\r	value printOn: stream.\r)",
 "public class ConditionalAST if: cond is: ifTrue_ then: t else: e = AST (|\r	public condition <ExpressionAST> = cond.\r	public ifTrue = ifTrue_.\r	public then <CodeBodyAST> = t.\r	public else <CodeBodyAST | nil> = e.\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool conditionalNode: self\r)",
 "public if: cond <ExpressionAST> is: val <Boolean> then: t <BlockAST> forValue: forValue ^<Instance> = (\r	^self if: cond is: val then: t else: (forValue ifTrue: [emptyBody])\r)",
 "class EnclosingObjectAST = AST (\r(* See mailing list for debate over 'outer Foo' as an expression. *)\r|\r	public depth <Integer>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool enclosingObjectNode: self\r)",
 "public isKindOfExplicitRcvrNode ^<Boolean> = (\r	^true\r)",
 "public class ImplicitReceiverSendAST = SendAST (|\rpublic depth <Integer> (* Used on targets that don't have implicit receiver lookup at runtime. *)\rpublic binding <ClassEntry | SlotEntry | MethodEntry>\r|)",
 "SendAST",
 "SendAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool implicitReceiverSendNode: self\r)",
 "public isKindOfImplicitReceiverSendNode ^<Boolean> = (\r	^true\r)",
 "public class LocalReadAST of: var = AST (|\r	public variable = var.\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool localReadNode: self\r)",
 "public name = (\r	^variable ast name\r)",
 "public class LocalWriteAST to: var assign: val = AST (|\r	public variable = var.\r	public value = val.\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool localWriteNode: self\r)",
 "public name = (\r	^variable ast name\r)",
 "public class LoopAST = AST (\r(* This node represents a while loop. The general form of the loop is:\r\rprologue; while (cond = whileTrue) { body}\r\r*)\r|\r	public prologue <CodeBodyAST>\r	public condition <CodeBodyAST>\r	public isWhileTrue <Boolean>\r	public body <CodeBodyAST>\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool loopNode: self\r)",
 "public do: n <Integer> timesRepeat: b <BlockAST> = (\r	| var <ParameterAST> |\r\r	(* introduce counter variable *)\r	var:: (ParameterAST name: #'.i' type: nil) copyPositionFrom: b.\r	assert: [b parameters isEmpty].\r	b parameters add: var. (* BOGUS: Should not mutate AST *)\r\r	(* translate n timesRepeat: [blockBody] into 1 to: n do: [:.i | blockBody] *)\r	from: (NumberAST new value: 1; copyPositionFrom: b) to: n do: b\r)",
 "public from: first <AST> to: last <AST> by: step <AST> do: block <BlockAST> = (\r	|\r	loopScope		<Scope>\r	counterDecl	<VarDecl>\r	counterEntry\r	counter		<TemporaryVariableAST>\r	limitName		<Symbol>\r	limitDecl		<TemporaryAST>\r	limitEntry\r	limit			<LiteralAST | VariableAST>\r	condSel			<Symbol>\r	condExpr		<ExpressionAST>\r	incExpr			<ExpressionAST>\r	incStat			<StatementAST>\r	|\r\r	assert: [ step isKindOfNumberNode and: [step value isKindOfInteger] ] message: 'Loop with non-integer step'.\r	assert: [ block isKindOfBlockNode ] message: 'Loop with block that is not a BlockAST'.\r\r	isWhileTrue:: true.\r	prologue:: emptyBody.\r\r	loopScope:: Scope parent: currentScope.\r	pushScope: loopScope.\r\r	(* Create counter variable from block's parameter. *)\r	counterDecl:: block parameters removeLast. (* BOGUS: Should not mutate AST *)\r	counterEntry:: LocalEntry forDeclaration: counterDecl atDepth: nil.\r	counterEntry induction: true.\r	loopScope at: counterDecl name put: counterEntry.\r	prologue temporaries add: counterEntry.\r	prologue statements add: (LocalWriteAST to: counterEntry assign: first).\r	counter:: (LocalReadAST of: counterEntry) copyPositionFrom: block.\r\r	(* Introduce counter limit variable if needed. *)\r	last isKindOfLiteralNode\r		ifTrue:\r			[(* no limit variable needed - use last directly since there's no side-effect *)\r			limit:: last]\r		ifFalse:\r			[limitName:: #'.limit'.\r			 limitDecl:: TemporaryAST name: limitName type: nil.\r			 limitDecl copyPositionFrom: block.\r			 limitEntry:: LocalEntry forDeclaration: limitDecl atDepth: nil.\r			 loopScope at: limitName put: limitEntry.\r			 prologue temporaries add: limitEntry.\r			 (* initialize limit variable - note that this must be done *after* setting up the counter because of possible side effects *)\r			 prologue statements add: (LocalWriteAST to: limitEntry assign: last). (* .limit := last *)\r			 limit:: (LocalReadAST of: limitEntry) copyPositionFrom: block].\r\r	(* setup loop condition => introduce condition block for whileTrue: loop *)\r	condSel:: step value < 0 ifTrue: [ #<= ] ifFalse: [ #>= ].\r	condExpr:: OrdinarySendAST to: limit send: (MessageAST new send: condSel with: {counter}).\r	(* limit <= counter OR limit >= counter *)\r	condition:: CodeBodyAST new\r		parameters: {};\r		temporaries: {};\r		statements: {condExpr};\r		copyPositionFrom: block.\r\r	(* inlined closure body *)\r	body:: (rewriteInlinedBlockNode: block forValue: false) body.\r\r	(* add counter increment to loop body *)\r	incExpr:: OrdinarySendAST to: step send: (MessageAST new send: #+ with: {counter}).\r	incExpr copyPositionFrom: block.\r	(* step + counter *)\r	incStat:: LocalWriteAST to: counterEntry assign: incExpr.\r	incStat copyPositionFrom: block.\r	(* counter := step + counter *)\r	body statements add: incStat.\r\r	popScope.\r)",
 "public from: first <AST> to: last <AST> do: block <BlockAST> = (\r	from: first to: last by: (NumberAST new value: 1) do: block\r)",
 "public repeat: b <CodyBodyAST> = (\r	condition:: b.\r	condition statements add: ((BooleanAST withValue: true) start: condition end; end: condition end).\r	isWhileTrue:: true.\r)",
 "public while: v <Boolean> do: b <CodeBodyAST> = (\r	condition:: b.\r	isWhileTrue:: v.\r)",
 "public while: b1 <CodyBodyAST> is: v <Boolean> do: b2 <CodyBodyAST> = (\r	condition:: b1.\r	isWhileTrue:: v.\r	body:: b2.\r)",
 "public class MethodLocalReturnAST expression: e = ReturnAST expression: e ()",
 "expression: e",
 "expression: e",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool methodLocalReturnNode: self\r)",
 "public class NilAST = AST ()",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool nilNode: self\r)",
 "public class NonlocalReturnAST expression: e = ReturnAST expression: e ()",
 "expression: e",
 "expression: e",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool nonLocalReturnNode: self\r)",
 "public class OrdinarySendAST to: rcvr send: msg = SendAST (|\r	public receiver = rcvr.\r	public message = msg.\r|)",
 "SendAST",
 "SendAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool ordinarySendNode: self\r)",
 "public isKindOfOrdinarySendNode ^<Boolean> = (\r	^true\r)",
 "public class OuterSendAST = SendAST (|\rpublic depth <Integer>\rpublic binding <ClassEntry | SlotEntry | MethodEntry>\r|)",
 "SendAST",
 "SendAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool outerSendNode: self\r)",
 "public class ParameterAST name: n type: t = AST (|\r	public name = n.\r	public type = t.\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool parameterDeclNode: self\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'ParameterAST('; nextPutAll: name; nextPutAll: ')'.\r)",
 "class ReceiverAST = AST ()",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool receiverNode: self\r)",
 "public isKindOfReceiverNode ^<Boolean> = (\r	^true\r)",
 "class ReturnAST expression: e = AST (|\r	public expression <AST> = e.\r|)",
 "AST",
 "AST",
 "public isKindOfReturnStatNode ^<Boolean> = (\r	^true\r)",
 "public class SelfSendAST = SendAST (|\rpublic binding <ClassEntry | SlotEntry | MethodEntry>\r|)",
 "SendAST",
 "SendAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool selfSendNode: self\r)",
 "public isKindOfSelfSendNode ^<Boolean> = (\r	^true\r)",
 "public receiver = (\r	^ReceiverAST new\r)",
 "class SendAST = AST (|\r	public message <MessageAST>\r|)",
 "AST",
 "AST",
 "public isKindOfSendNode ^<Boolean> = ( ^true )",
 "public class SuperSendAST = SendAST ()",
 "SendAST",
 "SendAST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool superSendNode: self\r)",
 "public isKindOfSuperSendNode ^<Boolean> = (\r	^true\r)",
 "public class TemporaryAST name: n type: t = AST (|\r	public name = n.\r	public type = t.\r|)",
 "AST",
 "AST",
 "public apply: tool <ASTTool[T]> ^<T> = (\r	^tool temporaryDeclNode: self\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'TemporaryAST('; nextPutAll: name; nextPutAll: ')'.\r)",
 "class LocalEntry forDeclaration: decl <VarDeclAST> atDepth: d <Integer> = SymbolTableEntry forAST: decl atDepth: d (\r(* Semantic info for a parameter or temporary. *)\r|\r(* public offset <Integer>\rpublic remote <Boolean> ::= false.\rpublic remoteVector <LocalEntry> *)\r\rpublic closureDepth\rpublic used ::= false.\rpublic induction ::= false.\rpublic captured ::= false.\rpublic remote\rpublic remoteVector2\rpublic remoteOffset\r|)",
 "forAST: decl atDepth: d",
 "forAST: decl atDepth: d",
 "public isLocalBinding ^<Boolean> = (\r	^true\r)",
 "public name = (\r	^ast name\r)",
 "public printOn: stream = (\r	stream nextPutAll: 'LocalEntry('; nextPutAll: name; nextPutAll: '#'; print: hash; nextPutAll: ')'.\r)",
 "class MethodEntry forDeclaration: decl atDepth: d = SymbolTableEntry forAST: decl atDepth: d (\r)",
 "forAST: decl atDepth: d",
 "forAST: decl atDepth: d",
 "public isMethodBinding ^<Boolean> = (\r	^true\r)",
 "class Namer = ()",
 " ",
 " ",
 "public doitContextArgumentName = (\r	^#'@context'\r)",
 "public isReservedWord: selector = (\r	^{#self. #super. #outer. #true. #false. #nil} includes: selector\r)",
 "public mixinSlotNameFor: nestedName = (\r	^(nestedName, '`slot') asSymbol\r)",
 "public scopeArgumentName = (\r	^#'@with'\r)",
 "public selectorForSlotGetter: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (\r	^slot name\r)",
 "public selectorForSlotInitializer: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (\r	^('init`', slot name, ':') asSymbol\r)",
 "public selectorForSlotSetter: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (\r	slot isMutable ifFalse: [Error signal: 'Slot is not mutable'].\r	^(slot name, ':') asSymbol\r)",
 "public setterTemp = (\r	^#'@setterTemp'\r)",
 "public class Scope parent: p = (|\r	public parent <Scope> = p.\r	protected bindings <Map[Symbol, SymbolTableEntry]> = Map new.\r|)",
 " ",
 " ",
 "public at: key <Symbol> ^<SymbolTableEntry> = (\r	(* Answers the value associated with aKey in this or one the super scopes or fails if aKey is absent. *)\r	^self at: key ifAbsent: [Error signal: 'Key ', key, ' not found!']\r)",
 "public at: key depth: d = (\r	depth = d ifFalse: [\r		nil = parent\r			ifTrue: [^nil]\r			ifFalse: [^parent at: key depth: d]].\r	^bindings at: key ifAbsent: [nil]\r)",
 "public at: key <Symbol> ifAbsent: blk <[X def]> ^<SymbolTableEntry | X> = (\r	(* Answers the value associated with aKey in this or one of the superScopes or the value of aBlock if aKey is absent. *)\r	(* Optimization note: This is written using [nil] blocks to avoid passing non-clean blocks dynamically down the scope structure. *)\r\r	| val <T> |\r	val:: self bindings at: key ifAbsent: [nil].\r	nil = val ifFalse: [^val].\r	nil = self parent ifTrue: [^blk value].\r	val:: self parent at: key ifAbsent: [nil].\r	nil = val ifFalse: [^val].\r	^blk value\r)",
 "public at: key <Symbol> put: value <SymbolTableEntry> = (\r	^self bindings at: key put: value\r)",
 "public depth ^<Integer> = (\r	parent isNil ifTrue: [^0].\r	^parent depth + 1.\r)",
 "public includesKeyLocal: key = (\r	^bindings includesKey: key\r)",
 "public printOn: stm = (\r	stm nextPutAll: 'Scope('.\r	bindings keys\r		do: [:key | stm nextPutAll: key]\r		separatedBy: [ stm nextPutAll: ', '].\r	stm nextPutAll: ') in '.\r	parent printOn: stm.\r)",
 "public new = (\r	^self parent: nil\r)",
 "class SlotEntry forDeclaration: decl <VarDeclAST> atDepth: d <Integer> = SymbolTableEntry forAST: decl atDepth: d ()",
 "forAST: decl atDepth: d",
 "forAST: decl atDepth: d",
 "public name = (\r	^ast name\r)",
 "class SymbolTableEntry forAST: tree atDepth: d = (\r(* An entry in a scope. *)\r|\rpublic ast <AST> = tree.\rpublic depth <Integer> = d.\r|)",
 " ",
 " ",
 "public isLocalBinding ^<Boolean> = (\r	^false\r)",
 "public isMappedBinding = (\r	^false\r)",
 "public isMethodBinding ^<Boolean> = (\r	^false\r)",
 "class Ampleforth packageUsing: manifest = (\r(* Ampleforth is designed to support live literate programming. It supports embedding Newspeak code inside the text of a normal web page. Ampleforth is in its infancy, and currently can be used in conjunction with other tools such as Madoko, Lounge or plain old HTML to produce such documents.\r\rAmpleforth is the name of a character in 1984 who worked at the Ministry of Truth. His job was to edit Oldspeak text so it would be goodthinkful.\r\rCopyright 2014-2017 Google Inc. *)\r	|\r	private hopscotchRuntime = manifest HopscotchForHTML5Runtime packageUsing: manifest.\r	Embedder = manifest AmpleforthEmbedder.\r	HopscotchIDE = manifest HopscotchWebIDE packageUsing: manifest.\r	|\r)",
 " ",
 " ",
 "public main: platform args: args = (\r	| namespace embedder ide hopscotchPlatform |\r	\r	hopscotchPlatform:: hopscotchRuntime using: platform.\r	ide:: HopscotchIDE ideUsingPlatform: hopscotchPlatform.\r	namespace:: ide namespacing Root.\r	namespace at: #Ampleforth put: self class.\r	embedder:: Embedder usingPlatform: hopscotchPlatform namespace: namespace browsing: ide browsing.\r	embedder start.\r)",
 "class HopscotchForHTML5Runtime packageUsing: manifest = (\r	|\r	private Graphics = manifest GraphicsForHTML5.\r	private TextModule = manifest TextModule.\r	private Hopscotch = manifest HopscotchForHTML5.\r	private images = Images packageUsing: manifest.\r	|\r)",
 " ",
 " ",
 "public using: platform = (\r	^PlatformWithHopscotch usingPlatform: platform\r)",
 "class Images packageUsing: manifest = (\r|\r	public accept16px = manifest accept16px.\r	public cancel16px = manifest cancel16px.\r	public disclosureClosedImage = manifest disclosureClosedImage.\r	public disclosureTransitionImage = manifest disclosureTransitionImage.\r	public disclosureOpenImage = manifest disclosureOpenImage.\r	public dropDownImage = manifest hsDropdownImage.\r	public dropDownOutImage = manifest hsDropdownOutImage.\r	public dropDownOverImage = manifest hsDropdownOverImage.\r|\r)",
 " ",
 " ",
 "class PlatformWithHopscotch usingPlatform: platform = (\r	|\r	public kernel = platform kernel.\r	public collections = platform collections.\r	public actors = platform actors.\r	public mirrors = platform mirrors.\r	public js = platform js.\r	public graphics = Graphics usingPlatform: self.\r	public text = TextModule usingPlatform: self.\r	public hopscotch = Hopscotch usingPlatform: self images: images.\r	|\r)",
 " ",
 " ",
 "class GraphicsForHTML5 usingPlatform: p = (\r(*\rCore graphics support for Newspeak.\r\rCopyright Google Inc. 2015 - 2017\r*)\r|\rdocument = p js global at: 'document'.\r|)",
 " ",
 " ",
 "public class Canvas width: w height: h = (\r|\r	private alien ::= document createElement: 'canvas'.\r|\r	alien at: 'width' put: w.\r	alien at: 'height' put: h.\r	(alien at: 'style') at: 'position' put: 'relative'.\r)",
 " ",
 " ",
 "public context = (\r	^Context on: (alien getContext: '2d')\r)",
 "public mouseDownAction: onMouseDown <[:Point]> = (\r	alien addEventListener: 'mousedown' action:\r		[:event | onMouseDown value: (Point x: (event at: 'offsetX') y: (event at: 'offsetY')). nil].\r)",
 "public mouseMovedAction: onMouseMoved <[:Point]> = (\r	alien addEventListener: 'mousemove' action:\r		[:event | onMouseMoved value: (Point x: (event at: 'offsetX') y: (event at: 'offsetY')). nil].\r)",
 "public class Color scaledR: r g: g b: b a: a = (|\rpublic red <Integer> = r.\rpublic green <Integer> = g.\rpublic blue <Integer> = b.\rpublic alpha <Integer> = a.\r|)",
 " ",
 " ",
 "public applyToStyle: style = (\r	style setProperty: 'background-color' to: self asCSSString\r)",
 "public asCSSString = (\r	^'rgba(', red printString, ',', green printString, ',', blue printString, ',', alpha printString, ')'\r)",
 "public black = (\r	^self scaledR: 0 g: 0 b: 0 a: 255\r)",
 "public blue = (\r	^self scaledR: 0 g: 0 b: 255 a: 255\r)",
 "public blue: brightness = (\r	^self scaledR: 0 g: 0 b: brightness a: 255\r)",
 "public gray = (\r	^self r: 0.5 g: 0.5 b: 0.5\r)",
 "public gray: brightness = (\r	^self r: brightness g: brightness b: brightness\r)",
 "public h: hue s: saturation v: brightness = (\r	| s v hf i f p q t |\r	s:: (saturation asFloat max: 0.0) min: 1.0.\r	v:: (brightness asFloat max: 0.0) min: 1.0.\r\r	(* zero saturation yields gray with the given brightness *)\r	s = 0.0 ifTrue: [ ^self r: v g: v b: v ].\r\r	hf:: hue asFloat.\r	(hf < 0.0 or: [hf >= 360.0])\r		ifTrue: [hf:: hf \\\\ 360].\r	hf:: hf / 60.0.\r	i:: hf asInteger. (* integer part of hue *)\r	f:: hf - i. (* hf fractionPart. *)  (* fractional part of hue *)\r	p:: (1.0 - s) * v.\r	q:: (1.0 - (s * f)) * v.\r	t:: (1.0 - (s * (1.0 - f))) * v.\r\r	0 = i ifTrue: [ ^self r: v g: t b: p ].\r	1 = i ifTrue: [ ^self r: q g: v b: p ].\r	2 = i ifTrue: [ ^self r: p g: v b: t ].\r	3 = i ifTrue: [ ^self r: p g: q b: v ].\r	4 = i ifTrue: [ ^self r: t g: p b: v ].\r	5 = i ifTrue: [ ^self r: v g: p b: q ].\r\r	Error signal: 'implementation error'.\r)",
 "public magenta = (\r	^self r: 139 g: 0 b: 139 a: 255\r)",
 "public orange = (\r	^self scaledR: 255 g: 165 b: 0 a: 255\r)",
 "public r: r g: g b: b = (\r	^self scaledR: (r * 255) floor g: (g * 255) floor b: (b * 255) floor a: 255\r)",
 "public r: r g: g b: b a: a = (\r	^self scaledR: (r * 255) floor g: (g * 255) floor b: (b * 255) floor a: a\r)",
 "public red = (\r	^self scaledR: 255 g: 0 b: 0 a: 255\r)",
 "public red: brightness = (\r	^self scaledR: brightness g: 0 b: 0 a: 255\r)",
 "public white = (\r	^self scaledR: 255 g: 255 b: 255 a: 255\r)",
 "public class Context on: a = (|\ralien = a.\r|)",
 " ",
 " ",
 "public arcAt: center radius: radius from: startAngle to: stopAngle = (\r	alien arc: center x with: center y with: radius with: startAngle with: stopAngle\r)",
 "public beginPath = (\r	alien beginPath.\r)",
 "public fill = (\r	alien fill.\r)",
 "public fillStyle: c <Color> = (\r	alien at: 'fillStyle' put: c asCSSString.\r)",
 "public fillText: string at: p = (\r	alien fillText: string with: p x with: p y\r)",
 "public lineTo: p = (\r	alien lineTo: p x with: p y\r)",
 "public moveTo: p = (\r	alien moveTo: p x with: p y\r)",
 "public rectangle: r = (\r	alien rect: r origin x with: r origin y with: r extent x with: r extent y\r)",
 "public stroke = (\r	alien stroke.\r)",
 "public strokeStyle: c <Color> = (\r	alien at: 'strokeStyle' put: c asCSSString\r)",
 "public class Point x: xCoord y: yCoord = (|\rpublic x <Number> = xCoord.\rpublic y <Number> = yCoord.\r|)",
 " ",
 " ",
 "public = other <Object> ^<Boolean> = (\r	^other isPoint and: [x = other x and: [y = other y]]\r)",
 "public corner: corner <Point> ^<Rectangle> = (\r	^Rectangle origin: self corner: corner\r)",
 "public extent: extent <Point> ^<Rectangle> = (\r	^Rectangle origin: self extent: extent\r)",
 "public hash ^<Integer> = (\r	^x hash bitXor: y hash\r)",
 "public isPoint ^<Boolean> = (\r	^true\r)",
 "public printString ^<String> = (\r	^x printString, ' @ ', y printString\r)",
 "public r ^<Number> = (\r	^((x*x) + (y*y)) sqrt\r)",
 "public theta ^<Number> = (\r	Error signal: 'Unimplemented'\r)",
 "public r: r <Number> theta: theta <Number> ^<Point> = (\r	^self x: r * theta cos y: r * theta sin\r)",
 "public zero ^<Point> = (\r	^self x: 0 y: 0\r)",
 "public class Rectangle origin: o corner: c = (|\rpublic origin <Point> = o.\rpublic corner <Point> = c.\r|)",
 " ",
 " ",
 "public = other ^<Boolean> = (\r	^other isRectangle and: [origin = other origin and: [corner = other corner]]\r)",
 "public center = (\r	^Point x: origin x + ((corner x - origin x) / 2) y: origin y + ((corner y - origin y) / 2)\r)",
 "public containsPoint: p = (\r	^((origin x <= p x\r		and: [origin y <= p y])\r		and: [corner x >= p x])\r		and: [corner y >= p y]\r)",
 "public extent = (\r	^Point x: corner x - origin x y: corner y - origin y\r)",
 "public hash ^<Integer> = (\r	^origin hash bitXor: corner hash\r)",
 "public insetBy: delta = (\r	^Rectangle\r		origin: (Point x: origin x + delta x y: origin y + delta y)\r		corner: (Point x: corner x - delta x y: corner y - delta y)\r)",
 "public isRectangle ^<Boolean> = (\r	^true\r)",
 "public printString ^<String> = (\r	^'Rectangle origin: ', origin printString, ' corner: ', corner printString\r)",
 "public origin: o <Point> extent: e <Point> ^<Rectangle> = (\r	^self origin: o corner: (Point x: o x + e x y: o y + e y)\r)",
 "class TextModule usingPlatform: p <Platform> = (\r(*\rTop level module for text, HTML version. Experimental.\rCopyright 2016-2017 Google Inc.\r*)\r)",
 " ",
 " ",
 "public class Text properties: tps = (\r(*Abstract supertype of all texts.*)\r|\r	public textProperties <TextProperties> = tps.\r|)",
 " ",
 " ",
 "public isKindOfText ^ <Boolean> = (\r	^true\r)",
 "public textUnits ^ <List[Fragment]> = (\r	^self subclassResponsibility\r)",
 "public class TextBlock units: tus <List[Text]> properties: tps <TextProperties> = Text properties: tps (\r|\r	 public textUnits <List[Text]> = tus.\r|)",
 "properties: tps",
 "properties: tps",
 "public cloneWithDefaultProperties: tps <TextProperties> ^ <Self> = (\r	^self class units: immediateTextUnits properties: (tps supplyDefaultsFor: textProperties)\r)",
 "public elementaryTextUnits ^ <List[Text]> = (\r	^textUnits flatMap: [:u <Text> |\r		u isKindOfText ifTrue: [(u cloneWithDefaultProperties: textProperties) elementaryTextUnits] ifFalse: [u]\r		].\r)",
 "public isKindOfTextBlock ^ <Boolean> = (\r	^true\r)",
 "public string ^ <String> = (\r	^textUnits inject: '' into: [:s1 :s2 | s1, s2 string].\r)",
 "public forString: s <String> ^ <Instance> = (\r	^units: {TextString forString: s}\r)",
 "public units: tus <List[Text]> ^ <Instance> = (\r	^self units: tus properties: TextProperties new\r)",
 "public class TextProperties = (\r(*The properties of text: font, weight, color, size etc.*)\r|\r	public font\r	public weight <Symbol>\r	public style <Symbol>\r	public pointSize <Integer>\r	public color <Color>\r	public strikeThrough <Boolean>\r	public underline <Boolean>\r|)",
 " ",
 " ",
 "public applyTo: element <HTMLElement> = (\r	| styleElement = element at: 'style'. |\r	styleElement setProperty: 'white-space' to: 'pre-wrap'.\r	font isNil ifFalse: [styleElement setProperty: 'font-family' to: font].\r	pointSize isNil ifFalse: [styleElement setProperty: 'font-size' to: pointSize printString, 'pt'].\r	weight isNil ifFalse: [styleElement setProperty: 'font-weight' to: weight].\r	style isNil ifFalse: [styleElement setProperty: 'font-style' to: style].\r	color isNil ifFalse: [\r		styleElement setProperty: 'color' to: 'rgb(', color red printString, ', ', color green printString, ', ', color blue printString, ')'\r		].\r	 strikeThrough isNil ifFalse: [\r		 strikeThrough ifTrue: [styleElement setProperty: 'text-decoration' to: 'line-through']\r		].\r	underline isNil ifFalse: [\r		underline ifTrue: [styleElement setProperty: 'text-decoration' to: 'underline']\r		].\r)",
 "public applyToText: t <Text> = (\r	| tProperties <TextProperties> = t textProperties. |\r	tProperties font isNil ifTrue: [tProperties font: font].\r	tProperties weight isNil ifTrue: [tProperties weight: weight].\r	tProperties pointSize isNil ifTrue: [tProperties pointSize: pointSize].\r	tProperties color isNil ifTrue: [tProperties color: color].\r	tProperties strikeThrough isNil ifTrue: [tProperties strikeThrough: strikeThrough].\r	tProperties underline isNil ifTrue: [tProperties underline: underline].\r)",
 "public clone ^ <Self> = (\r	^self class new\r		font: font;\r	 	weight: weight;\r		pointSize: pointSize;\r		color: color;\r		strikeThrough: strikeThrough;\r		underline: underline;\r		yourself\r)",
 "public supplyDefaultsFor: tps <TextProperties> = (\r	| tProperties <TextProperties> = tps clone. |\r\r	tProperties font isNil ifTrue: [tProperties font: font].\r	tProperties weight isNil ifTrue: [tProperties weight: weight].\r	tProperties pointSize isNil ifTrue: [tProperties pointSize: pointSize].\r	tProperties color isNil ifTrue: [tProperties color: color].\r	tProperties strikeThrough isNil ifTrue: [tProperties strikeThrough: strikeThrough].\r	tProperties underline isNil ifTrue: [tProperties underline: underline].\r)",
 "public class TextString forString: s <String> properties: tps = Text properties: tps (\r|\r	public string <String> = s.\r|)",
 "properties: tps",
 "properties: tps",
 "public cloneWithDefaultProperties: tps <TextProperties> ^ <Self> = (\r	^self class forString: string properties: (tps supplyDefaultsFor: textProperties)\r)",
 "public elementaryTextUnits ^ <List[Fragment]> = (\r	^{self}\r)",
 "public isKindOfTextString ^ <Boolean> = (\r	^true\r)",
 "public forString: s <String> ^ <Instance> = (\r	^forString: s properties: TextProperties new\r)",
 "class HopscotchForHTML5 usingPlatform: p images: images = (\r(* Hopscotch is Newspeak's UI framework. This version is implemented on top of HTML and CSS.\r\rCopyright Google Inc. 2012 -2017\r*)\r|\r	private Color = p graphics Color.\r	private Context = p graphics Context.\r	private Timer = p actors Timer.\r	private List = p collections List.\r	private Map = p collections Map.\r	private Set = p collections Set.\r	private TextBlock = p text TextBlock.\r	private TextProperties = p text TextProperties.\r	private TextString = p text TextString.\r	private window = p js global.\r	private document = window at: 'document'.\r	JSObject = p js global at: 'Object'.\r	private body = document at: 'body'.\r	private history = window at: 'history'.\r	sharedNavigationHistory\r	embeddedWindowMap = Map new.\r	sharedBackButtonListener\r	currentHopscotchWindow\r\r	private accept16px = images accept16px.\r	private cancel16px = images cancel16px.\r	private disclosureClosedImage = images disclosureClosedImage.\r	private disclosureTransitionImage = images disclosureTransitionImage.\r	private disclosureOpenImage = images disclosureOpenImage.\r	public dropDownImage = images dropDownImage.\r	public dropDownOutImage = images dropDownOutImage.\r	public dropDownOverImage = images dropDownOverImage.\r\r	private deferredContentQueue = List new.\r	public core = self. (* Polymorphic with HopscotchForBrazil *)\r	public fragments = self. (* Polymorphic with HopscotchForBrazil *)\r	|)",
 " ",
 " ",
 "public CodeMirror = (\r  ^window at: 'CodeMirror'.\r)",
 "computeContentForMenu: menuSupplier <[Menu]> ^ <Alien[Div]> = (\r	| dropDownContent = document createElement: 'div'. |\r	(dropDownContent at: 'style')\r		at: 'color' put: 'black';\r		at: 'backgroundColor' put: 'lightgray';\r		at: 'position' put: 'absolute';\r		at: 'z-index' put: 1;\r		at: 'padding-left' put: '6px';\r		at: 'padding-right' put: '10px';\r		at: 'border-radius' put: '5px';\r		at: 'box-shadow' put: '5px 5px 5px darkgrey';\r		at: 'display' put: 'none'.\r	menuSupplier value do: \r		[:menuItem <MenuItem | Symbol> |\r		 | itemContent <Alien[Element]> |\r		 itemContent:: contentFor: menuItem within: dropDownContent.\r		 dropDownContent appendChild: itemContent].\r	^dropDownContent\r)",
 "contentFor: menuItem < MenuItem | Symbol> within: dropDownContent ^ <Alien[Element]> = (\r	| entry |\r	menuItem = #separator ifTrue:\r		[^document createElement: 'hr'].\r	entry:: document createElement: 'div'.\r	entry at: 'textContent' put: menuItem first.\r	entry\r		addEventListener: 'mouseover' action:\r			[:event | (entry at: 'style') at: 'background-color' put: 'darkgrey'. nil];\r	      addEventListener: 'mouseout' action:\r			[:event | (entry at: 'style') at: 'background-color' put: 'lightgrey'. nil];\r		addEventListener: 'click' action:\r			[:event | menuItem last value. nil].\r	^entry\r)",
 "deferAction: action = (\r	deferredContentQueue add: action.\r	deferredContentQueue size = 1 ifTrue:\r		[nextFrameDo: [nextDeferredAction]].\r)",
 "nextDeferredAction = (\r	| action = deferredContentQueue removeFirst. |\r	deferredContentQueue size > 0 ifTrue:\r		[nextFrameDo: [nextDeferredAction]].\r	action value.\r)",
 "nextFrameDo: action <[]> = (\r	(* Our goal is to run the argument after images have been loaded and rendered. window.requestAnimationFrame runs the callback *before* the next frame. We register another callback in the callback so the first deferred action runs *after* the next frame. We register *that* callback in another RAF callback to let new images added from a deferred block load and render before the next deferred block runs. RAF is also a relative new feature, so simply schedule a timer if it is not available. *)\r	(window at: 'requestAnimationFrame') isUndefined ifTrue:\r		[Timer after: 200 do: action. ^self].\r\r	window requestAnimationFrame:\r		[:time1 <Float> | window requestAnimationFrame:\r			[:time2 <Float> | window requestAnimationFrame:\r				[:time3 <Float> | action value. nil]]].\r)",
 "sharedNavigator ^ <NavigationHistory> = (\r	nil = sharedNavigationHistory ifTrue:\r		[sharedNavigationHistory:: NavigationHistory new].\r	^sharedNavigationHistory\r)",
 "class BlankFragment = LeafFragment (\r)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	^document createElement: 'div'\r)",
 "class ButtonFragment label: l action: a = LeafFragment (|\r	label = l.\r	action = a.\r	public enabled ::= true.\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	^(document createElement: 'button')\r		appendChild: (document createTextNode: label);\r		at: 'onclick' put: [:event | action value. false];\r		at: 'disabled' put: enabled not;\r		yourself\r)",
 "class CanvasFragment withExtent: e = LeafFragment (\r	|\r	private alien = document createElement: 'canvas'.\r	|\r	alien at: 'width' put: e x.\r	alien at: 'height' put: e y.\r	(alien at: 'style') at: 'position' put: 'relative'.\r)",
 "LeafFragment",
 "LeafFragment",
 "public context = (\r	^Context on: (alien getContext: '2d')\r)",
 "createVisual = (\r	^alien\r)",
 "public keyDownAction: onKeyPressed <[:String]> = (\r	(* The canvas element itself doesn't seem to get key events. *)\r	body addEventListener: 'keydown' action: \r		[:event | onKeyPressed value: (String fromCharCode: (event at: 'keyCode')). nil].\r)",
 "public mouseDownAction: onMouseDown <[:Point]> = (\r	alien addEventListener: 'mousedown' action: \r		[:event | onMouseDown value: (event at: 'offsetX') @ (event at: 'offsetY'). nil].\r)",
 "public mouseMovedAction: onMouseMoved <[:Point]> = (\r	alien addEventListener: 'mousemove' action:\r		[:event | onMouseMoved value: (event at: 'offsetX') @ (event at: 'offsetY'). nil].\r)",
 "public class CodeMirrorFragment onText: t <String>  = LeafFragment (\r(* An experiment to see how to integrate CodeMirror as editor. *)\r|\r      public editor <Alien[CodeMIrror]>\r	textSlot <TextFragment | String> ::= t.\r	counterfactualBar <Alien[Span]>\r	isInEditState ::= false.\r	public changeResponse <[TextEditorFragment]>\r	public acceptResponse <[TextEditorFragment]>\r	public cancelResponse <[TextEditorFragment]>\r	styles ::= List new.\r|\r)",
 "LeafFragment",
 "LeafFragment",
 "applyStyle: style <{Integer. Integer. Alien[JSObject]}> = (\r	| s <Alien[CodeMirrorPosition]> e <Alien[CodeMirrorPosition]> |\r	(* Newspeak intervals are 1-origin and [start, stop]. JS intervals are 0-origin and [start, stop). *)\r	s:: editor posFromIndex: (style at: 1) - 1.\r	e:: editor posFromIndex: (style at: 2).\r	editor markText: s to: e style: (style at: 3).\r)",
 "applyStyles = (\r    nil = editor ifFalse: [\r	styles do: [: s <{Integer. Integer. Alien[JSObject]}> |\r	applyStyle: s\r	].\r     styles:: List new.\r     editor refresh.\r   ]\r)",
 "controlBarColor = (\r	^Color r: 0.95 g: 0.792 b: 0.475\r)",
 "createVisual = (\r	| frame  <Alien[Div]> accept  <Alien[Img]> cancel <Alien[Img]> textArea <Alien[Span]> options <Alien[JSObject]> |\r	\r	frame:: document createElement: 'div'.\r	(frame at: 'style')\r		at: 'display' put: 'flex';\r		at: 'opacity' put: 1.\r	counterfactualBar:: document createElement: 'span'.\r	(counterfactualBar at: 'style')\r		at: 'backgroundColor' put: controlBarColor asCSSString;\r		at: 'flex' put: 'none'.\r	accept:: document createElement: 'img'.\r	accept at: 'src' put: (accept16px yourself at: 'src').\r	(accept at: 'style') at: 'margin' put: '3px'.\r	accept at: 'onclick' put:\r		[:event | respondToAccept: event. nil].\r	cancel:: document createElement: 'img'.\r	cancel at: 'src' put: (cancel16px yourself at: 'src').\r	(cancel at: 'style') at: 'margin' put: '3px'.\r	cancel at: 'onclick' put:\r		[:event | respondToCancel. nil].\r	counterfactualBar appendChild: accept.\r	counterfactualBar appendChild: cancel.\r	textArea:: document createElement: 'textarea'.\r	textArea\r		at: 'value' put:  textSlot;\r		at: 'resize' put: true.\r	frame appendChild: textArea.\r	options:: JSObject new.\r	options at: 'lineWrapping' put: true.\r	editor:: CodeMirror fromTextArea: textArea with: options.\r      editor on: 'change' respondToChange:\r		[:codeMirror :change | respondToChange: codeMirror. nil].\r	((textArea at: 'nextSibling') at: 'style') \r		at: 'height' put: 'unset';\r		at: 'width' put: '100%';\r		at: 'fontFamily' put: 'TimesNewRoman';\r		at: 'borderStyle' put: 'solid';\r		at: 'borderWidth' put: '1px';\r		at: 'borderColor' put: 'gray'.\r	^frame\r)",
 "public defaultAcceptResponse = (\r      textSlot:: editor getValue.\r	leaveEditState\r)",
 "defaultCancelResponse = (\r	editor setValue: textSlot.\r	leaveEditState\r)",
 "defaultChangeResponse = (\r	enterEditState\r)",
 "public enterEditState = (\r	isInEditState ifFalse:\r		[visual appendChild: counterfactualBar.\r		isInEditState:: true].\r	visual scrollIntoView: true (* alignWithTop *).\r)",
 "public leaveEditState = (\r	isInEditState ifTrue:\r		[visualX removeChild: counterfactualBar.\r		isInEditState:: false.\r		(*removeMessages*)]\r)",
 "public noticeExposure = (\r  refresh\r)",
 "public refresh = (\r  applyStyles\r)",
 "respondToAccept: event <Alien[Event]> = (\r	nil = acceptResponse\r		ifTrue: [defaultAcceptResponse]\r		ifFalse: [acceptResponse cull: self cull: event]\r)",
 "respondToCancel = (\r	(*confirm: 'Confirm Cancel' ifConfirmed:\r		[*)nil = cancelResponse\r			ifTrue: [defaultCancelResponse]\r			ifFalse: [cancelResponse cull: self](*]*)\r)",
 "respondToChange: event <Alien[Event]> = (\r	nil = changeResponse\r		ifTrue: [defaultChangeResponse]\r		ifFalse: [changeResponse cull: self cull: event]\r)",
 "public showMessage: message <String> = (\r	message out.\r)",
 "public style: style <Alien[JSObject]> from: start <Integer> to: end <Integer>  = (\r	styles add: {start. end. style}.\r	applyStyles\r)",
 "public text: t = (\r      textSlot:: t.\r	hasVisual ifTrue: [editor setValue: t].\r)",
 "public textBeingAccepted ^ <String> = (\r  ^editor getValue\r)",
 "class ColorDecorator color: c <Color> = Decorator (\r| color <Color> = c. |)",
 "Decorator",
 "Decorator",
 "public decorate: aVisual = (\r	color applyToStyle: (aVisual at: 'style').\r	^aVisual\r)",
 "class ColumnComposer definitions: fs <List[Fragment]> = SequenceComposer definitions: fs (\r	crossAxisStretch\r)",
 "definitions: fs",
 "definitions: fs",
 "flexDirection ^ <String> = (\r	^'column'\r)",
 "class Composer = Fragment ()",
 "Fragment",
 "Fragment",
 "public class Decorator = (\r(* A Decorator is attached to a fragment and is called by the fragment to change the various attributes of the Brazil visual created by the fragment itself. *)\r)",
 " ",
 " ",
 "public decorate: aVisual = (\r	(* Change properties of aVisual or wrap it into a new visual that applies whatever decorating we represent to aVisual. Answer aVisual or the new visual. *)\r	subclassResponsibility\r)",
 "class DeferredContentComposer initialContent: ic contentSource: cs = Composer (|\r	initialContent <Fragment> = ic.\r	contentSource <[Fragment]> = cs.\r	contentFragment <Fragment>\r|)",
 "Composer",
 "Composer",
 "public childrenDo: aBlock = (\r	nil = contentFragment \r	  ifFalse: [aBlock value: contentFragment]\r	  ifTrue: [aBlock value: initialContent]\r)",
 "createVisual = (\r	| div initialVisual |\r	div:: document createElement: 'div'.\r	(div at: 'style') at: 'align-self' put: 'center'.\r	initialVisual:: initialContent visual.\r	div appendChild: initialVisual.\r	deferAction: [\r		| deferredFragment = contentSource value. |\r		deferredFragment parent: self.\r		contentFragment:: deferredFragment.\r		(* replace: new with: old due to stupid DOM argument ordering *)\r		div replaceChild: deferredFragment visual with: initialVisual].\r	^div\r)",
 "class DropDownMenuFragment menu: ms images: ims <Array[Image]> alignment: side <Symbol> = ImageButtonFragment images: ims (\r(*\rCreate a drop down menu based on dynamic content. This means that the menu contents may vary every time the menu button\ris clicked.  The contents are computed by a closure provided by the ms argument to the factory, and stored in the\rmenuSupplier slot.  The images to use for the menu button are provided by the ims argument.  Menus may be aligned to the right\ror the left; ideally, the system would figure the best alignment dynamically, but for now it must be specified via the side argument. Usually the presenter has a good idea what side the menu should be aligned to, so this is not a high priority item to address.\r\rClass methods that provide convenient defaults for the button images and the alignment are provided as well.\r*)\r	|\r	menuSupplier <[Tuple[Symbol | Tuple[String, []]]]> = ms. (* Skip formal menu structure for now*)\r	menuActive <Boolean> ::= false.\r	alignment <String>  = side asString.\r	|\r	action:: [].\r)",
 "images: ims",
 "images: ims",
 "createVisual ^ <Alien[Element]> = (\r	| column = super createVisual. |\r	column addEventListener: 'click' action: [:event | toggleContent. nil].\r	(column at: 'style')\r		at: 'cursor' put: 'pointer'.\r	^column\r)",
 "removeContent ^ <Alien[Element]> = (\r	^visual removeChild: (visual at: 'lastChild')\r)",
 "toggleContent = (\r	menuActive ifTrue: [removeContent] ifFalse: [updateContent].\r	menuActive:: menuActive not.\r)",
 "updateContent ^ <Alien[Element]> = (\r	| menuContent <Alien[Div]> |\r	menuContent:: computeContentForMenu: menuSupplier.\r	(menuContent at: 'style') \r	   at: alignment put: 0;\r	   at: 'display' put: 'block'.\r	visual appendChild: menuContent.\r	^menuContent\r)",
 "public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> ^ <Instance> = (\r   ^menu: ms images: {dropDownImage. dropDownOverImage. dropDownOutImage} alignment: #right\r)",
 "public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> alignment: side <Symbol> ^ <Instance> = (\r   ^menu: ms images: {dropDownImage. dropDownOverImage. dropDownOutImage} alignment: side\r)",
 "public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> images: ims <Array[Image]> ^ <Instance> = (\r   ^menu: ms images: ims alignment: #right\r)",
 "public class EmbeddedHopscotchWindow into: container openSubject: s = HopscotchShell (\r	|\r	localNavigator = LocalNavigationHistory new.\r	|\r	container appendChild: contentHolder.\r	enterSubject: s.\r)",
 "HopscotchShell",
 "HopscotchShell",
 "public displayPresenter: p <Presenter> = (\r	super displayPresenter: p.\r	(* Not a full-page app: don't update document title. *)\r)",
 "public enterPresenter: p <Presenter> = (\r	currentHopscotchWindow:: self.\r	embeddedWindowMap at: p ifAbsentPut: [self].\r	localNavigator visit: p.\r	super enterPresenter: p\r)",
 "public enterSubject: s <Subject> fromSnippet: snippet <SnippetSubject> = (\r	embeddedWindowMap at: snippet presenter ifAbsentPut: [self].\r	enterSubject: s.\r)",
 "public goBack = (\r	localNavigator goBack.\r	displayPresenter: localNavigator current.\r)",
 "listenForBackButton = (\r	nil = sharedBackButtonListener ifFalse: [^self. (* Already listening. *)].\r	sharedBackButtonListener::\r		[:event <Alien[Event]> |\r		| p <Presenter> = navigator presenterFor: (event at: 'state').\r		priorWindow = embeddedWindowMap at: p. |\r		currentHopscotchWindow goBack. (* might be better to enterPresenter:? *)\r		currentHopscotchWindow:: priorWindow].\r	window at: 'onpopstate' put: sharedBackButtonListener.\r)",
 "navigationHistory = (\r	^sharedNavigator\r)",
 "public openSubject: s = (\r	^into: body openSubject: s\r)",
 "class Fragment = (|\r	visualX\r	public parent\r	public size ::= nil.\r	public expansibility ::= 0.\r	public compressibility ::= 0.\r	decorators\r	|)",
 " ",
 " ",
 "public addDecorator: newDecorator <Decorator> = (\r	(* The argument is added last to the collection of our decorators, meaning it will be applied after all the other decorators we might have. *)\r	nil = decorators ifTrue: [decorators:: List new].\r	decorators addLast: newDecorator.\r)",
 "createVisual = (\r	subclassResponsibility\r)",
 "public decorate: aVisual = (\r	(* The argument is a visual freshly created by the #createVisual or #createViewportWithVisual method. If we have any decorators attached, apply them now to arrive at the final decorated visual. *)\r	| decorated |\r	decorated:: aVisual.\r	nil = decorators ifFalse:\r		[decorators do: [:each | decorated:: each decorate: decorated]].\r	^decorated\r)",
 "public elasticity: x = (\r	expansibility: x.\r	compressibility: x.\r)",
 "public hasVisual = (\r	^visualX isNil not\r)",
 "public noticeExposure = (\r	(* Propagated down the fragment hierarchy just after the hierarchy has been made visible. A fragment may receive this message multiple times over its life. *)\r\r	childrenDo: [:each | each noticeExposure]\r)",
 "public refresh = (\r	(* Fragments that dynamically retrieve their information should reimplement this to update their visuals accordingly. *)\r\r	childrenDo: [:each | each refresh]\r)",
 "public shell = (\r	^parent isNil\r		ifTrue: [Error signal: 'hierarchy not installed in a shell :',  printString]\r		ifFalse: [parent shell]\r)",
 "public value = (\r	^self\r)",
 "public visual = (\r	visualX isNil ifTrue: [visualX:: decorate: createVisual].\r	^visualX\r)",
 "public width: w elasticity: e = (\r	size: w.\r	expansibility: e.\r	compressibility: e.\r)",
 "public class Gradient from: a to: b = (|\r	topColor = a.\r	bottomColor = b.\r|)",
 " ",
 " ",
 "public applyToStyle: style = (\r	| value |\r	value:: '(top,', topColor asCSSString, ',', bottomColor asCSSString, ')'.\r	style setProperty: 'background-image' to: '-webkit-linear-gradient', value.\r	style setProperty: 'background-image' to: '-moz-linear-gradient', value.\r)",
 "class HolderComposer withContent: definition <Fragment | [Fragment]> = Composer (|\r	contentSource <Fragment | [Fragment]> ::= definition.\r	actualContent <Fragment>\r|)",
 "Composer",
 "Composer",
 "public childrenDo: aBlock <[:Fragment]> = (\r	nil = actualContent ifFalse: [aBlock value: actualContent].\r)",
 "public content ^<Fragment> = (\r	nil = actualContent ifTrue:\r		[actualContent:: contentSource value.\r		actualContent parent: self].\r	^actualContent\r)",
 "public content: fragment = (\r	fragment parent: self.\r	hasVisual ifTrue:\r		[ | oldContent newContent |\r		oldContent:: actualContent.\r		newContent:: actualContent:: fragment.\r		(* replace: new with: old due to stupid DOM argument ordering *)\r		visual replaceChild: newContent visual with: oldContent visual]\r	ifFalse: [actualContent:: fragment]\r)",
 "createVisual = (\r	| div |\r	div:: document createElement: 'div'.\r	div appendChild: content visual.\r	^div\r)",
 "public noticeExposure = (\r  refresh\r)",
 "public refresh = (\r	(contentSource isKindOfClosure and: [hasVisual])\r		ifTrue:\r			[ | oldContent newContent |\r			oldContent:: actualContent.\r			actualContent:: nil.\r			newContent:: content.\r			(* replace: new with: old due to stupid DOM argument ordering *)\r			visual replaceChild: newContent visual with: oldContent visual]\r		ifFalse:\r			[actualContent refresh].\r)",
 "class HopscotchShell = (\r	|\r	navigator = navigationHistory.\r	currentPresenterX\r	contentHolder = document createElement: 'div'.\r	|\r	listenForBackButton.\r)",
 " ",
 " ",
 "public childrenDo: aBlock = (\r	aBlock value: currentPresenter\r)",
 "public currentPresenter = (\r	^currentPresenterX\r)",
 "public displayPresenter: p = (\r	(* TODO: noticeX events *)\r	currentPresenterX:: p.\r	p parent: self.\r	contentHolder hasChildNodes\r		ifTrue: [contentHolder replaceChild: p visual from: (contentHolder at: 'firstChild')]\r		ifFalse: [contentHolder appendChild: p visual].\r	p noticeExposure.\r)",
 "public enterPresenter: presenter = (\r	presenter isTransient ifFalse:\r		[nil = currentPresenterX\r			ifTrue: [navigator recordFirst: presenter]\r			ifFalse: [history pushState: (navigator idFor: presenter) title: presenter title]].\r	displayPresenter: presenter.\r)",
 "public enterSubject: s <Subject> = (\r	self enterPresenter: s presenter\r)",
 "listenForBackButton = (\r	window at: 'onpopstate' put: [:event | userBack: event. nil]\r)",
 "navigationHistory = (\r	^NavigationHistory new\r)",
 "public refresh = (\r	(* Since refreshing forces a new copy of the current presenter into the browser, we need to massage it into the history as well. *)\r\r	| newSubject |\r	newSubject:: currentPresenter subject refreshmentSubject.\r	displayPresenter: newSubject presenter.\r	(* navigator replaceCurrentWith: newSubject presenter. *)\r)",
 "public shell = (\r	^self\r)",
 "userBack: event = (\r	displayPresenter: (navigator presenterFor: (event at: 'state'))\r)",
 "public class HopscotchWindow into: container openSubject: s = HopscotchShell (\r	container appendChild: contentHolder.\r	enterSubject: s.\r)",
 "HopscotchShell",
 "HopscotchShell",
 "public displayPresenter: p = (\r	super displayPresenter: p.\r	document at: 'title' put: p title.\r)",
 "public openSubject: s = (\r	^into: body openSubject: s\r)",
 "class HyperlinkFragment label: l action: a = LeafFragment (|\r	label = l.\r	action = a.\r	public color ::= Color r: 0 g: 0 b: 1.\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	| anchor |\r	anchor:: document createElement: 'a'.\r	anchor at: 'href' put: '#'.\r	anchor appendChild: (document createTextNode: label).\r	anchor at: 'onclick' put: [:event | action value. false].\r	(anchor at: 'style')\r		at: 'textDecoration' put: 'none'; (* No underline *)\r		at: 'overflow' put: 'hidden';\r		setProperty: 'white-space' to: 'nowrap'.\r	color isNil ifFalse:\r		[(anchor at: 'style') setProperty: 'color' to: color asCSSString].\r	^anchor\r)",
 "public smallFont = (\r	(visual at: 'style') at: 'font-size' put: 'smaller'\r)",
 "class HyperlinkImageFragment image: i action: a = LeafFragment (|\r	image = i.\r	action = a.\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	| img |\r	img:: image cloneNode: false (* Not deep *).\r	img at: 'onclick' put: [:event | action value. false].\r	^img\r)",
 "class ImageButtonFragment images: imageArray <Array[Image]> = LeafFragment (\r(* A button displayed as an image; or an image that acts as a button. *)\r|\r	public action <[]>\r	stateImages <Array[Image]> = imageArray, (Array new: 3).\r	(* Appending three nils so that we can always send #at: with an index between 1 and 4 and expect it not to fail. *)\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual ^ <Visual> = (\r	| div img |\r	div:: document createElement: 'div'.\r	(div at: 'style')\r		at: 'display' put: 'flex';\r		at: 'flex-direction' put: 'flex-column';\r		at: 'align-items' put: 'center'.\r	img:: (stateImages at: 1) cloneNode: false (* Not deep *).\r	img at: 'onclick' put: [:event | action value. false].\r	div appendChild: img.\r	^div\r)",
 "class LeafFragment = Fragment ()",
 "Fragment",
 "Fragment",
 "public childrenDo: aBlock = (\r	(* No children. *)\r)",
 "class LocalNavigationHistory = (\r(* LocalNavigationHistory is a richly structured collection that maintains a web browser-like history of ''visits''. Visits are arbitrary objects. NavigationHistory makes no assumptions about visits other than that they can be compared using #=.\r\rThe important attributes of a history are: the ''current'' visit, the ''past'', the ''future'' and ''allVisits''. A history starts off empty. To visit an object, send the #visit: message to the history with the object as the argument. This makes the object the ''current'' object of the history.\r\rThe ''past'' is a queue of visits that used to be the current (most recently current object last). Sending the #goBack message makes the most recently current object from the past the current again, while the current object becomes the first member of the ''future'' queue. Sending the #goForward message reverses the process. Visiting an object other than the first element of the ''future'' queue erases the future queue.\r\rAll visits visited by a history are remembered in the ''allVisits'' set. This set is never emptied, other than on an explicit request.\r\rA history can optionally be configured with a transientTestBlock. The test block is applied to visits to determine whether they are transient or not. Transient visits are not recorded in the ''past'' and ''future'' queues and in the ''allVisits'' set. By default all visits are considered to be non-transient.\r*)\r	|\r	currentVisitSlot\r	public allVisits <List>\r	public past <List>\r	public future <List>\r	public transientTestBlock <[:Object | Boolean]> ::= [:element | false].\r	|\r	erase.\r)",
 " ",
 " ",
 "public current ^ <Object> = (\r	^currentVisitSlot\r)",
 "public do: aBlock = (\r	(* Do the current visit separately if transient because it's not among allVisits. *)\r	(isTransient: currentVisitSlot) ifTrue:\r		[aBlock value: currentVisitSlot].\r	allVisits do: aBlock\r)",
 "public equalVisitOr: anObject ^ <Object> = (\r	(* Return a visit from the history equal to the argument, or the argument itself if there is no equal visit in the history. *)\r	^allVisits detect: [:some | some = anObject] ifNone: [anObject]\r)",
 "public erase = (\r	currentVisitSlot:: nil.\r	allVisits:: List new.\r	erasePast.\r	eraseFuture.\r)",
 "public eraseEntry: anObject = (\r	allVisits remove: anObject.\r	past remove: anObject ifAbsent: [].\r	future remove: anObject ifAbsent: []. (* can it ever be in the future list? *)\r)",
 "eraseFuture = (\r	future:: List new.\r)",
 "erasePast = (\r	past:: List new.\r)",
 "public goBack = (\r	isPastEmpty ifFalse:\r		[(isTransient: currentVisitSlot) ifFalse:\r			[future addFirst: currentVisitSlot].\r		currentVisitSlot:: past removeLast]\r)",
 "public goForward = (\r	isFutureEmpty ifFalse:\r		[(isTransient: currentVisitSlot) ifFalse:\r			[past addLast: currentVisitSlot].\r		currentVisitSlot:: future removeFirst]\r)",
 "public goToFutureItem: anObject = (\r	[currentVisitSlot = anObject or: [isFutureEmpty]]\r		whileFalse: [goForward]\r)",
 "public goToPastItem: anObject = (\r	[currentVisitSlot = anObject or: [isPastEmpty]]\r		whileFalse: [goBack]\r)",
 "includesVisit: anObject ^ <Boolean> = (\r	^allVisits includes: anObject\r)",
 "isEmpty ^ <Boolean> = (\r	^allVisits isEmpty\r)",
 "public isFutureEmpty ^ <Boolean> = (\r	^future isEmpty\r)",
 "public isPastEmpty ^ <Boolean> = (\r	^past isEmpty\r)",
 "isTransient: anObject ^ <Boolean> = (\r	^transientTestBlock value: anObject\r)",
 "next ^ <Object> = (\r	(* Answer the closest visit from the future. Fail if the future is empty. *)\r	^future first\r)",
 "previous ^ <Object> = (\r	(* Answer the most recent visit from the past. Fail if the past is empty. *)\r	^past last\r)",
 "replace: anObject with: replacement = (\r	(* Replace all references to anObject that we have with references to 'replacement'. *)\r	allVisits remove: anObject ifAbsent: [].\r	(isTransient: replacement) ifFalse: [allVisits add: replacement].\r	currentVisitSlot = anObject ifTrue: [currentVisitSlot:: replacement].\r	past keysAndValuesDo:\r		[:index :each | each = anObject ifTrue: [past at: index put: replacement]].\r	future keysAndValuesDo:\r		[:index :each | each = anObject ifTrue: [future at: index put: replacement]]\r)",
 "public replaceCurrentWith: anObject = (\r	self replace: currentVisitSlot with: anObject\r)",
 "public visit: anObject = (\r	(* Make the argument the current object of the history. The prior current object becomes the last object of the 'past' queue. The 'future' queue is erased, unless the visit is equal to the first element of the future. *)\r	currentVisitSlot = anObject ifTrue: [^self].\r	((nil = currentVisitSlot) not and: [(isTransient: currentVisitSlot) not]) ifTrue:\r		[past addLast: currentVisitSlot].\r	currentVisitSlot:: anObject.\r	(isTransient: anObject) ifFalse:\r		[allVisits\r			remove: anObject ifAbsent: [];\r			add: anObject].\r	future isEmpty not ifTrue:\r		[future first = currentVisitSlot\r			ifTrue: [future removeFirst]\r			ifFalse: [eraseFuture]].\r)",
 "class NavigationHistory = (| nextId ::= 1. ids <Map[Presenter, Integer]> = Map new. |)",
 " ",
 " ",
 "public idFor: presenter <Presenter> ^ <Integer> = (\r	^ids at: presenter ifAbsentPut: [nextId:: nextId + 1]\r)",
 "public presenterFor: id <Integer> ^ <Presenter> = (\r	ids keysAndValuesDo:\r		[:key :value | value = id ifTrue: [^key]].\r	^nil\r)",
 "public recordFirst: presenter = (\r	(* The popstate event has a null id when navigating all the way back. *)\r	ids at: presenter put: nil.\r)",
 "class PaddedFrameComposer content: c offsets: o = Composer (|\r	content = c.\r	offsets = o.\r	public color\r|)",
 "Composer",
 "Composer",
 "public childrenDo: aBlock = (\r	nil = content ifFalse: [aBlock value: content]\r)",
 "createVisual = (\r	| div = document createElement: 'div'. |\r	(div at: 'style')\r		at: 'paddingLeft' put: (offsets at: 1) printString, 'px';\r		at: 'paddingTop' put: (offsets at: 2) printString, 'px';\r		at: 'paddingRight' put: (offsets at: 3) printString, 'px';\r		at: 'paddingBottom' put: (offsets at: 4) printString, 'px'.\r	color isNil ifFalse: [color applyToStyle: (div at: 'style')].\r	content parent: self.\r	div appendChild: content visual.\r	^div\r)",
 "public class Presenter onSubject: aSubject <Subject> = Fragment (|\rpublic subject <Subject> ::= aSubject.\rsubstanceSlot <Fragment>\r|)",
 "Fragment",
 "Fragment",
 "alert: text = (\r	window alert: text\r)",
 "blank: size = (\r	^BlankFragment new size: size\r)",
 "button: label <String> action: block <[]> = (\r	^ButtonFragment label: label action: block\r)",
 "canvas: extent <Point> = (\r	^CanvasFragment withExtent: extent\r)",
 "public childrenDo: aBlock = (\r	nil = substanceSlot ifFalse: [aBlock value: substanceSlot]\r)",
 "codeMirror: t <Text | String> = (\r	^CodeMirrorFragment onText: t\r)",
 "collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> ^<Fragment> = (\r	^collapsed: collapsed expanded: expanded initiallyExpanded: false\r)",
 "collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> initiallyExpanded: flag <Boolean>\r^<Fragment> = (\r	^ToggleComposer\r		collapsedDefinition: collapsed\r		expandedDefinition: expanded\r		initiallyExpanded: flag\r)",
 "column: definitions <List[Fragment]> ^ <ColumnComposer> = (\r	^ColumnComposer definitions: definitions\r)",
 "createVisual ^ <Alien[HTMLElement]> = (\r(*	| substance = definition. |\r	substance parent: self.\r	^substance visual *)\r	ensureSubstance.\r	^substanceSlot visual\r)",
 "deferred: contentSource <[Fragment]> ^<Fragment> = (\r	^DeferredContentComposer initialContent: nothing contentSource: contentSource\r)",
 "public definition ^<Fragment> = (\r	subclassResponsibility\r)",
 "dropDownMenu: menu <[Menu]> ^ <DropDownMenuFragment> = (\r	^DropDownMenuFragment menu: menu\r)",
 "dropDownMenu: menu <[Menu]> alignment: side <Symbol> ^ <DropDownMenuFragment> = (\r	^DropDownMenuFragment menu: menu alignment: side\r)",
 "dropDownMenu: menu <[Menu]> images: ims <Array[Image]>  ^ <DropDownMenuFragment> = (\r	^DropDownMenuFragment menu: menu images: ims\r)",
 "dropDownMenu: menu <[Menu]> images: ims <Array[Image]> alignment: side <Symbol> ^ <DropDownMenuFragment> = (\r	^DropDownMenuFragment menu: menu images: ims alignment: side\r)",
 "elastic: aFragment = (\r	aFragment elasticity: 1.\r	^aFragment\r)",
 "ensureSubstance = (\r	nil = substanceSlot ifTrue:\r		[substanceSlot:: self definition.\r		substanceSlot parent: self.\r		noticeSubstanceCreation]\r)",
 "enterSubject: s = (\r	(* TODO: use sendUp and open a new window if undelivered *)\r	^shell enterSubject: s\r)",
 "enterSubject: s <Subject> fromSnippet: snippet <SnippetSubject> = (\r	(* TODO: use sendUp and open a new window if undelivered *)\r	^shell enterSubject: s fromSnippet: snippet\r)",
 "expanded: expanded <[Fragment]> collapsed: collapsed <[Fragment]> ^<Fragment> = (\r	^collapsed: collapsed expanded: expanded initiallyExpanded: true\r)",
 "filler = (\r	^BlankFragment new expansibility: 1; compressibility: 1\r)",
 "holder: def <Fragment | [Fragment]> = (\r	^HolderComposer withContent: def\r)",
 "image: image = (\r	^StaticImageFragment image: image\r)",
 "imageButton: images <Array[Image]> action: block <[]> = (\r	^(ImageButtonFragment images: images)\r		action: block\r)",
 "initially: initialContent <Fragment> deferred: contentSource <[Fragment]> ^<Fragment> = (\r	^DeferredContentComposer initialContent: initialContent contentSource: contentSource\r)",
 "public isTransient = (\r	(* Should visits of this presenter be omitted from the navigation history? *)\r	^false\r)",
 "label: label <String> = (\r	^StaticLabelFragment text: label\r)",
 "link: label <String> action: block <[]> = (\r	^HyperlinkFragment label: label action: block\r)",
 "linkImage: image action: block = (\r	^HyperlinkImageFragment image: image action: block\r)",
 "list ^ <PresenterList> = (\r	^PresenterList new\r)",
 "list: presenterSource <Sequence[Presenter] | [Sequence[Presenter]]> ^ <PresenterList> = (\r	^PresenterList new presenterSource: presenterSource\r)",
 "mediumBlank = (\r	^blank: 10\r)",
 "menuWithLabelsAndActions: labelsAndActions <Tuple[Symbol | Tuple[String, []]]> ^ <Menu> = (\r	| menu |\r	^labelsAndActions\r\r(*	menu:: Menu forVisual: visual.\r	labelsAndActions do:\r		[:each |\r		menu add: (#separator = each\r			ifTrue: [SeparatorItem new]\r			ifFalse: [MenuItem key: nil label: each key action: each value])].\r	^menun*)\r)",
 "nothing = (\r	^BlankFragment new\r)",
 "noticeSubstanceCreation = (\r	(* Received after the #definition method of the receiver has been invoked and the result remembered as its substance. The substance hasn't been asked to create a visual yet. *)\r)",
 "openMenu: aMenu <Menu> ^ <Alien[Div]> = (\r	| menuContent <Alien[Div]> |\r	menuContent:: computeContentForMenu: [aMenu].\r	(menuContent at: 'style') at: 'display' put: 'block'.\r	visual appendChild: menuContent.\r	menuContent addEventListener: 'click' action:\r		[:event | visual removeChild: menuContent. nil].\r	^menuContent\r(* so the issue here is to actually open a menu that was not in the tree before? And how to close it*)\r)",
 "openMenuWithLabelsAndActions: labelsAndActions = (\r	openMenu: (menuWithLabelsAndActions: labelsAndActions)\r)",
 "padded: def with: offsets = (\r	^PaddedFrameComposer content: def offsets: offsets\r)",
 "row: definitions = (\r	^RowComposer definitions: definitions\r)",
 "schedule: action <[]> = (\r	window setTimeout: [action value. nil] with: 0.\r)",
 "substance ^ <Fragment> = (\r	ensureSubstance.\r	^substanceSlot\r)",
 "text: t <Text> = (\r	| subfragments <Collection[Fragment]> |\r	t isKindOfTextString ifTrue: [^TextStringFragment onText: t].\r	subfragments:: t textUnits collect: [:u <Text> | text: u].\r	^TextBlockFragment onText: t subfragments: subfragments\r)",
 "textDisplay: string = (\r	^TextDisplayFragment text: string\r)",
 "textField: initialText onAccept: blk = (\r(* experimental *)\r	 ^fragments TextEditorFragment new\r	  text: initialText;\r	  acceptResponse: blk (*[:editor | blk valueWithPossibleArgument: editor. editor defaultAcceptResponse] *)\r)",
 "textString: string <String> = (\r	^TextStringFragment forString: string\r)",
 "textString: string <String> properties: tps <TextProperties> = (\r	^TextStringFragment forString: string properties: tps\r)",
 "public title ^<String> = (\r	^subject title\r)",
 "zebra: sequence <Sequence[Fragment]> ^ <Sequence[Fragment]> = (\r	sequence addDecorator: ZebraDecorator lighterColorFirst.\r	^sequence\r)",
 "class PresenterList = Fragment (\r(* PresenterList is a fragment that manages a sequence of Presenters, displaying them as a column. The interesting functionality it provides beyond that is updating itself intelligently when receiving a new sequence of presenters to display. New presenters equal (as determined by #=) to those currently displayed remain displayed as before, with any state they had unaffected even if their order in the list has changed.\r\rThe presenters can be given to the list either as a collection or as a niladic block that evaluates to a collection. In the latter case, a PresenterList will re-evaluate the block and update itself from the result each time it receives the #refresh message.\r\rSlots:\r\rpresenterSourceX. The presenters to display or the block providing them, as given to this instance when it was created.\r\rpresentersX. If presenterSourceX is a collection, this slot holds the same object as presenterSourceX. It it is the block, it holds the last result produced by the block.\r*)\r|\r	presenterSourceX <Sequence[Presenter] | [Sequence[Presenter]]> ::= List new.\r	presentersX <Sequence[Presenter]>\r|)",
 "Fragment",
 "Fragment",
 "public add: aPresenter <Presenter> = (\r	(* Append the argument to the end of the list of displayed presenters. If there is an equal presenter already displayed, remove it. *)\r	\r	| newPresenters |\r	newPresenters:: List withAll: presenters.\r	(newPresenters includes: aPresenter) ifTrue:\r		[newPresenters remove: aPresenter].\r	newPresenters add: aPresenter.\r	setPresenters: newPresenters.\r)",
 "public add: aPresenter <Presenter> afterIndex: index <Integer> = (\r	| newList |\r	newList:: presenters copy.\r	newList add: aPresenter afterIndex: index.\r	presenters: newList.\r)",
 "public addAll: additionalPresenters <{Presenter}> = (\r	| newPresenters |\r	newPresenters:: List withAll: presenters.\r	newPresenters addAll: additionalPresenters.\r	setPresenters: newPresenters.\r)",
 "public addFirst: aPresenter <Presenter> = (\r	(* Add the argument at the beginning of the end of the list of displayed presenters. If there is an equal presenter already displayed, remove it. *)\r	| newPresenters |\r	newPresenters:: List withAll: presenters.\r	(newPresenters includes: aPresenter) ifTrue:\r		[newPresenters remove: aPresenter].\r	newPresenters addFirst: aPresenter.\r	setPresenters: newPresenters.\r)",
 "public childrenDo: aBlock = (\r	nil = presentersX ifFalse: [presentersX do: aBlock].\r)",
 "public color: aColor = (\r	addDecorator::\r		ColorDecorator new color: aColor\r)",
 "createVisual = (\r	| column = ColumnComposer definitions: presenters. |\r	column parent: self.\r	^column visual\r)",
 "public detectPresenter: aBlock = (\r	^presentersX detect: aBlock\r)",
 "public detectPresenter: aBlock ifNone: noneBlock = (\r	^presentersX detect: aBlock ifNone: noneBlock\r)",
 "findFirst: aBlock = (\r	(* Answer the index of my first element for which aBlock evaluates as true. *)\r	^presentersX findFirst: aBlock\r)",
 "findLast: aBlock = (\r	(* Answer the index of my last element for which aBlock evaluates as true. *)\r	^presentersX findLast: aBlock\r)",
 "public presenterSource: niladicValuable <Sequence[Presenter] | [Sequence[Presenter]]> = (\r	presenterSourceX:: niladicValuable.\r	nil = presentersX ifFalse: [refreshPresenterList].\r)",
 "public presenters ^ <Sequence[Presenter]> = (\r	(* Return the presenters we are currently showing, pulling them from the source if needed. *)\r\r	nil = presentersX ifTrue:\r		[setPresenters: (presenterSourceX isKindOfClosure\r			ifTrue: [presenterSourceX value]\r			ifFalse: [presenterSourceX])].\r	^presentersX\r)",
 "public presenters: newPresenterList <Sequence[Presenter]> = (\r	self presenterSource: newPresenterList\r)",
 "public refresh = (\r	| newPresenters |\r	newPresenters:: Set withAll: refreshPresenterList.\r	presenters do:\r		[:each | (newPresenters includes: each) ifFalse: [each refresh]]\r)",
 "refreshPresenterList = (\r	(* Make it so that the displayed presenters match those provided by the source. For a list initialized with a presenter collection, this only does anything non-trivial when the instance is brand new. For a list initialized with a block, this re-evaluates the block and updates the list. *)\r	| newPresenters |\r	newPresenters:: presenterSourceX isKindOfClosure\r		ifTrue: [presenterSourceX value]\r		ifFalse: [presenterSourceX].\r	^setPresenters: newPresenters\r)",
 "refreshPresenters = (\r	presenters do: [:each | each refresh]\r)",
 "public remove: aPresenter = (\r	| newPresenters |\r	newPresenters:: List withAll: presenters.\r	newPresenters remove: aPresenter.\r	setPresenters:: newPresenters.\r)",
 "public removeAt: index <Integer> = (\r	| copy |\r	copy:: presenters copy.\r	copy removeAt: index.\r	presenters:: copy.\r)",
 "replaceChild: aFragment with: anotherFragment = (\r	| index newPresenters |\r	(presentersX includes: aFragment) ifTrue:\r		[index:: presenters indexOf: aFragment.\r		newPresenters:: presenters copy.\r		newPresenters at: index put: anotherFragment.\r		^presenters: newPresenters].\r	error: 'the fragment is not a child'\r)",
 "public setPresenters: newPresenterList <Sequence[Presenter]> = (\r	(* This is the workhorse of intelligent updates: massage the argument presenters into the currently displayed list, making sure that if there is an element of newPresenterList equal to a currently displayed presenter, we continue using the current presenter. *)\r\r	| currentPresenters oldPresentersAndIndices removedPresenters removedIndices addedPresenters newFinalList |\r	currentPresenters:: nil = presentersX ifTrue: [List new] ifFalse: [presentersX].\r	oldPresentersAndIndices:: Map new: currentPresenters size.\r	currentPresenters keysAndValuesDo:\r		[:index :each | oldPresentersAndIndices at: each put: index].\r	addedPresenters:: List new: newPresenterList size.\r	newFinalList:: List new: newPresenterList size.\r\r	newPresenterList do:\r		[:each | | oldIndex |\r		oldIndex:: oldPresentersAndIndices at: each ifAbsent: [nil].\r		nil = oldIndex\r			ifFalse: (* reusing a presenter we already have for this subject *)\r				[newFinalList add: (presenters at: oldIndex).\r				oldPresentersAndIndices removeKey: each]\r			ifTrue:\r				[newFinalList add: each.\r				addedPresenters add: each]].\r\r	removedPresenters:: oldPresentersAndIndices keys.\r	(* removedIndices:: (1 to: currentPresenters size) select:\r		[:index | removedPresenters includes: (currentPresenters at: index)]. *)\r\r	presentersX:: newFinalList.\r	presenterSourceX:: newFinalList.\r	addedPresenters do: [:each <Presenter> | each parent: self].\r	hasVisual ifTrue: [updateColumn].\r	(*	[updateColumn: visualX\r		 removingIndices: removedIndices\r		 addingPresenters: addedPresenters].*)\r	^addedPresenters\r)",
 "updateColumn = (\r	| newVisual = createVisual. |\r  (visual at: 'parentElement') replaceChild: newVisual with: visual.\r(* Note: this really means replace visual with newVisual; JS takes the args in wrong order *)\r  visualX: newVisual\r)",
 "updateColumn: column removingIndices: indices addingPresenters: newPresenters = (\r	indices asSortedList reverseDo:\r		[:each | column removeAt: each].\r	newPresenters do:\r		[:each | column add: each visual].\r	column reorder:\r		(presenters collect: [:each | each visual])\r)",
 "class RowComposer definitions: fs <List[Fragment]> = SequenceComposer definitions: fs (\r)",
 "definitions: fs",
 "definitions: fs",
 "flexDirection = (\r	^'row'\r)",
 "class SequenceComposer definitions: fs <List[Fragment]> = Composer (|\r	definitions <List[Fragment]> = fs.\r	public color <Color>\r	protected alignItems ::= 'center'.\r	protected childAlignSelf ::= 'center'.\r	protected justifyContent ::= 'flex-start'.\r|)",
 "Composer",
 "Composer",
 "public childrenDo: aBlock = (\r	definitions do: aBlock\r)",
 "createVisual ^ <Alien[HTMLElement]> = (\r	| container <Alien[HTMLElement]> |\r	container:: document createElement: 'div'.\r	(container at: 'style')\r		at: 'overflow' put: 'hidden';\r		at: 'display' put: 'flex';\r		at: 'flex-direction' put: flexDirection;\r		at: 'align-content' put: alignItems;\r		at: 'justify-content' put: justifyContent.\r	nil = color ifFalse:\r		[color applyToStyle: (container at: 'style')].\r	definitions do: [:fragment <Fragment> |\r		| cell <Alien[HTMLElement]> |\r		fragment parent: self.\r		cell:: fragment visual.\r		(cell at: 'style')\r			at: 'overflow' put: 'hidden';\r			at: 'align-self' put: childAlignSelf;\r			at: 'flex-grow' put: fragment expansibility;\r			at: 'flex-shrink' put: fragment compressibility.\r		nil = fragment size ifFalse:\r			[(cell at: 'style')\r				at: 'flex-basis' put: fragment size printString, 'px'].\r		container appendChild: cell].\r	^container\r)",
 "public crossAxisAlignToCenter = (\r	alignItems:: 'center'.\r	childAlignSelf:: 'center'.\r)",
 "public crossAxisAlignToEnd = (\r	alignItems:: 'flex-end'.\r	childAlignSelf:: nil.\r)",
 "public crossAxisAlignToStart = (\r	alignItems:: 'flex-start'.\r	childAlignSelf:: nil.\r)",
 "public crossAxisStretch = (\r	alignItems:: 'stretch'.\r	childAlignSelf:: nil.\r)",
 "public mainAxisAlignToCenter = (\r	justifyContent:: 'center'.\r)",
 "public mainAxisAlignToEnd = (\r	justifyContent:: 'flex-end'.\r)",
 "public mainAxisAlignToStart = (\r	justifyContent:: 'flex-start'.\r)",
 "class StaticImageFragment image: i = LeafFragment (|\r	image = i.\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	| div img |\r	div:: document createElement: 'div'.\r	(div at: 'style')\r		at: 'display' put: 'flex';\r		at: 'flex-direction' put: 'flex-column';\r		at: 'align-items' put: 'center'.\r	img:: image cloneNode: false. (* Not deep *)\r	div appendChild: img.\r	^div\r)",
 "class StaticLabelFragment text: t = LeafFragment (|\r	textX ::= t.\r	public color\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	| div = document createElement: 'div'. |\r	(div at: 'style')\r		at: 'overflow' put: 'hidden';\r		at: 'white-space' put: 'pre'.\r	div at: 'textContent' put: text.\r	nil = color ifFalse:\r		[(div at: 'style') setProperty: 'color' to: color asCSSString].\r	^div\r)",
 "public smallFont = (\r	(visual at: 'style') at: 'font-size' put: 'smaller'\r)",
 "public text = (\r	^textX\r)",
 "public text: newText = (\r	textX: newText.\r	hasVisual ifTrue: [visual at: 'textContent' put: textX]\r)",
 "public class Subject onModel: aModel = (|\r	protected model ::= aModel.\r	protected presenterX <Presenter>\r|)",
 " ",
 " ",
 "public createPresenter ^<Presenter> = (\r	subclassResponsibility\r)",
 "public presenter ^<Presenter> = (\r	presenterX isNil ifTrue: [presenterX:: createPresenter].\r	^presenterX\r)",
 "public refreshmentSubject ^<Subject> = (\r	(* Answer a new subject representing the same thing as the receiver. *)\r	^self class onModel: model\r)",
 "public title ^<String> = (\r	^self printString\r)",
 "class TextBlockFragment onText: t <Text> subfragments: sfs <List[Fragment]> = TextFragment onText: t (\r(* A fragment representing a compound text . *)\r| subfragments <List[Fragment]> = sfs. |)",
 "onText: t",
 "onText: t",
 "createVisual = (\r	| span = document createElement: 'span'. |\r	text textProperties applyTo: span.\r	subfragments do: [:u |\r		span insertAdjacentElement: 'beforeEnd' into: u visual\r		].\r	^span\r)",
 "public cursorPosition ^ <Integer> = (\r |\r  ca\r  sel = window getSelection.\r  focusNode\r  sum <Integer> ::= 0.\r |\r  sel isNil ifFalse: [ (*BOGUS: assumes the block is a flat collection of TextStringFragments*)\r	focusNode:: sel at: 'focusNode'.\r	ca:: (sel getRangeAt: 0) at: 'commonAncestorContainer'.\r	subfragments do: [:sf <Fragment> |\r		(sf visual at: 'firstChild') = focusNode ifTrue: [^sum + sf cursorPosition].\r	  sum:: sum + (sf visual at: 'textContent') size.\r		].\r	].\r	^nil\r)",
 "public cursorPosition: position <Integer> = (\r	| sum <Integer> ::= 0. |\r(*BOGUS: assumes the block is a flat collection of TextStringFragments*)\r	subfragments do: [:subfragment <Fragment> | | index <Integer> |\r		index:: position  - sum.\r		sum:: sum + (subfragment visual at: 'textContent') size.\r		position <= sum ifTrue: [subfragment cursorPosition: index. ^self].\r		].\r)",
 "public isKindOfTextBlockFragment ^ <Boolean> = (\r	^true\r)",
 "class TextDisplayFragment text: t = LeafFragment (|\r	textX ::= t.\r|)",
 "LeafFragment",
 "LeafFragment",
 "createVisual = (\r	| div = document createElement: 'div'. |\r	(div at: 'style') setProperty: 'white-space' to: 'pre-wrap'.\r	div at: 'textContent' put: textX.\r	^div\r)",
 "public smallFont = (\r  (visual at: 'style') at: 'font-size' put: 'smaller'\r)",
 "public text = (\r	^textX\r)",
 "public text: newText = (\r	textX: newText.\r	hasVisual ifTrue: [visual at: 'textContent' put: textX]\r)",
 "public class TextEditorFragment = LeafFragment (|\r	textX <TextFragment | String> ::= ''.\r	counterfactualBarX\r	editorX <Div>\r	public textBeingAccepted <String>\r	isInEditState ::= false.\r	public changeResponse <[TextEditorFragment]>\r	public acceptResponse <[TextEditorFragment]>\r	public cancelResponse <[TextEditorFragment]>\r	public oldText <TextFragment | String>\r|)",
 "LeafFragment",
 "LeafFragment",
 "controlBarColor = (\r	^Color r: 0.95 g: 0.792 b: 0.475\r)",
 "createVisual = (\r	| frame editorWrapper accept cancel |\r	frame:: document createElement: 'div'.\r	(frame at: 'style')\r		at: 'display' put: 'flex'.\r	editorX:: document createElement: 'div'.\r	editorX at: 'contentEditable' put: 'true'.\r	(editorX at: 'style')\r		at: 'borderStyle' put: 'solid';\r		at: 'borderWidth' put: '1px';\r		at: 'borderColor' put: 'gray';\r		setProperty: 'background-color' to: 'white';\r		at: 'flex' put: 1;\r		setProperty: 'white-space' to: 'pre-wrap';\r		at: 'display' put: 'block'.\r		setText: textX.\r	(* editorX at: 'textContent' put: textX.*)\r	editorX addEventListener: 'input' action: [:event | respondToChange: event. nil].\r	counterfactualBarX:: document createElement: 'span'.\r	(counterfactualBarX at: 'style')\r		at: 'backgroundColor' put: controlBarColor asCSSString;\r		at: 'flex' put: 'none'.\r	accept:: document createElement: 'img'.\r	accept at: 'src' put: (accept16px yourself at: 'src').\r	(accept at: 'style') at: 'margin' put: '3px'.\r	accept at: 'onclick' put: [:event | respondToAccept: event. nil].\r	cancel:: document createElement: 'img'.\r	cancel at: 'src' put: (cancel16px yourself at: 'src').\r	(cancel at: 'style') at: 'margin' put: '3px'.\r	cancel at: 'onclick' put: [:event | respondToCancel. nil].\r	counterfactualBarX appendChild: accept.\r	counterfactualBarX appendChild: cancel.\r	frame appendChild: editorX.\r	(* frame appendChild: counterfactualBarX. *)\r	^frame\r)",
 "public cursorPosition ^ <Integer> = (\r(* BOGUS. This leads to quirks when cutting and pasting. We really need to get the selection from the browser and identify\rthe cursor position based on that. But so far that hasn't worked. And we have issues with inserting newlines.\r*)\r	|\r	oldString <String>\r	newString <String>\r	bound <Integer>\r	offset <Integer> ::= 0.\r	|\r	oldString:: textX text string.\r	newString:: textBeingAccepted.\r	bound:: newString size min: oldString size.\r	offset:: -1 max: (newString size - oldString size - 1).\r	1 to: bound do: [:i <Integer> |\r		(oldString at: i) = (newString at: i) ifFalse: [^i + offset]\r		].\r	^newString size\r)",
 "public defaultAcceptResponse = (\r	setVisualText: textBeingAccepted.\r	leaveEditState\r)",
 "defaultCancelResponse = (\r	setVisualText: textX.\r	leaveEditState\r)",
 "defaultChangeResponse = (\r	enterEditState\r)",
 "public enterEditState = (\r	isInEditState ifFalse:\r		[visual appendChild: counterfactualBarX.\r		isInEditState:: true].\r	visual scrollIntoView: true (* alignWithTop *).\r)",
 "public leaveEditState = (\r	isInEditState ifTrue:\r		[visualX removeChild: counterfactualBarX.\r		isInEditState:: false.\r		(*removeMessages*)]\r)",
 "reconstructText ^ <String> = (\r  (* compute the text string from the DOM. This is necessary since the textContent attribute does not accurately reflect\r	newlines, as these are sometimes implied by div and br nodes. *)\r |\r  children <Alien[HTMLCollection]> = editorX at: 'children'.\r  numberOfChildren = children at: 'length'.\r  result <String>\r |\r	numberOfChildren = 0 ifTrue: [^textBeingAccepted:: editorX at: 'textContent'].\r	result:: ''.\r	0 to: numberOfChildren - 1 do: [:i <Integer> | result:: result, (reconstructTextForNode: (children item: i))].\r	^result\r)",
 "reconstructTextForNode: n <Alien[Node]> ^ <String> = (\r  (* compute the text string from the DOM. This is necessary since the textContent attribute does not accurately reflect\r	newlines, as these are sometimes implied by div and br nodes. *)\r |\r  children <Alien[HTMLCollection]> = n at: 'children'.\r  numberOfChildren = children at: 'length'.\r  result <String>\r |\r	result:: ''.\r	numberOfChildren = 0  ifTrue: [result:: n at: 'textContent'].\r	0 to: numberOfChildren - 1 do: [:i <Integer> | result:: result, (reconstructTextForNode: (children item: i))].\r	({'P'. 'BR'. 'DIV'} includes: (n at: 'tagName') ) ifTrue: [(n at: 'tagName') out. result:: result, String cr].\r	^result.\r)",
 "respondToAccept: event <Alien[Event]> = (\r	textBeingAccepted:: reconstructText (*editorX at: 'textContent'.*)(*withSqueakLineEndings*).\r	nil = acceptResponse\r		ifTrue: [defaultAcceptResponse]\r		ifFalse: [acceptResponse cull: self cull: event]\r)",
 "respondToCancel = (\r	(*confirm: 'Confirm Cancel' ifConfirmed:\r		[*)nil = cancelResponse\r			ifTrue: [defaultCancelResponse]\r			ifFalse: [cancelResponse cull: self](*]*)\r)",
 "respondToChange: event <Alien[Event]> = (\r	textBeingAccepted:: reconstructText (*editorX at: 'textContent'.*).\r	nil = changeResponse\r		ifTrue: [defaultChangeResponse]\r		ifFalse: [changeResponse cull: self cull: event]\r)",
 "public setCursor = (\r	| sum <Integer> ::= 0. cp <Integer> = cursorPosition. |\r	textX cursorPosition: 5.\r	(* textX elementaryTextUnits do: [:u <TextString> | (*textX is a fragment or a string, has no elementary text units*)\r		sum:: sum + u string size.\r		cp < sum ifTrue: [^setCursor: u to: cp]\r		]*)\r)",
 "public setCursor: position <Integer> = (\r	| sum <Integer> ::= 0. |\r	textX cursorPosition: position.\r)",
 "setText: t <TextFragment | String> = (\r   t isKindOfString\r	ifTrue: [editorX at: 'textContent' put: t]\r	ifFalse: [ | children = List new. |\r		oldText isKindOfString ifFalse: [\r			(editorX at: 'childNodes') forEach: [:n | children add: n].\r			children do: [:n | editorX removeChild: n].\r			].\r		editorX appendChild: t visual\r		]\r)",
 "setVisualText: aText = (\r	hasVisual ifTrue: [setText: aText]\r)",
 "public showMessage: m = (\r#BOGUS.\r	m out\r)",
 "public text = (\r	^textX\r)",
 "public text: t = (\r	oldText:: textX.\r	textX: t.\r	setVisualText: textX.\r)",
 "public updateCursor = (\r	| sum <Integer> ::= 0. cp <Integer> = textX cursorPosition. |\r	textX cursorPosition: cp.\r)",
 "class TextFragment onText: t <Text> = Fragment (\r(*Abstract supertype of all texts.*)\r|\r	public text <Text> = t.\r|)",
 "Fragment",
 "Fragment",
 "public cursorPosition: position <Integer> = (\r	subclassResponsibility\r)",
 "public isKindOfTextFragment ^ <Boolean> = (\r	^true\r)",
 "class TextStringFragment onText: t <Text> = TextFragment onText: t (\r(*A formatted string.*)\r)",
 "onText: t",
 "onText: t",
 "public createVisual = (\r	| span = document createElement: 'span'. |\r	text textProperties applyTo: span.\r	span at: 'textContent' put: text string.\r	^span\r)",
 "public cursorPosition ^ <Integer> = (\r | sel = window getSelection. |\r  sel isNil ifFalse: [\r	(*(visual at: 'firstChild') = (sel at: 'focusNode') ifTrue: [*)\r		^(sel getRangeAt: 0) at: 'endOffset'\r		(*]*)\r	].\r	^nil\r)",
 "public cursorPosition: position <Integer> = (\r | textNode = visual at: 'firstChild'. range = document createRange. |\r\r  range setStart: textNode to: position;\r	  setEnd: textNode to: position.\r  window getSelection removeAllRanges; addRange: range\r)",
 "public isKindOfTextStringFragment ^ <Boolean> = (\r	^true\r)",
 "public forString: s <String> ^ <Instance> = (\r	^onText: (TextString forString: s properties: TextProperties new)\r)",
 "public forString: s <String> properties: tps <TextProperties> ^<Instance> = (\r	^onText: (TextString forString: s properties: tps)\r)",
 "class ToggleComposer collapsedDefinition: collapsed <[Fragment]>\r expandedDefinition: expanded <[Fragment]>\r initiallyExpanded: flag <Boolean> = Composer (|\rexpandedDefinition <[Fragment]> = expanded.\rcollapsedDefinition <[Fragment]> = collapsed.\risExpanded <Boolean> ::= flag.\rexpandedPresenter <Fragment>\rcollapsedPresenter <Fragment>\rcontentHolder\rtoggleWidget\r|)",
 "Composer",
 "Composer",
 "public childrenDo: aBlock = (\r	nil = collapsedPresenter ifFalse:\r		[aBlock value: collapsedPresenter].\r	nil = expandedPresenter ifFalse:\r		[aBlock value: expandedPresenter].\r)",
 "public collapse = (\r	isExpanded:: false.\r	installCollapsedPresenter\r)",
 "createVisual = (\r	| toggleDiv div |\r	contentHolder:: document createElement: 'div'.\r\r	toggleDiv:: document createElement: 'div'.\r	toggleWidget:: document createElement: 'img'.\r	toggleWidget at: 'onclick' put: [:event | toggle. nil].\r	toggleDiv appendChild: toggleWidget.\r\r	(contentHolder at: 'style')\r		setProperty: 'flex-grow' to: 1;\r		setProperty: 'flex-shrink' to: 1.\r	(toggleDiv at: 'style')\r		setProperty: 'flex-grow' to: 0;\r		setProperty: 'flex-shrink' to: 0;\r		at: 'paddingTop' put: '2px';\r		at: 'paddingRight' put: '3px'.\r	toggleWidget at: 'align' put: 'top'.\r\r	isExpanded\r		ifTrue: [installExpandedPresenter]\r		ifFalse: [installCollapsedPresenter].\r\r	div:: document createElement: 'div'.\r	(div at: 'style')\r		at: 'display' put: 'flex';\r		setProperty: 'flex-direction' to: 'row'.\r	div appendChild: toggleDiv.\r	div appendChild: contentHolder.\r	^div\r)",
 "public expand = (\r	isExpanded:: true.\r	installExpandedPresenter\r)",
 "installCollapsedPresenter = (\r	nil = collapsedPresenter ifTrue:\r		[collapsedPresenter:: collapsedDefinition value.\r		collapsedPresenter parent: self].\r	installContentVisual: collapsedPresenter visual.\r	toggleWidget at: 'src' put: (disclosureClosedImage at: 'src').\r)",
 "installContentVisual: newVisual = (\r	contentHolder hasChildNodes\r		ifTrue:\r			[ | oldVisual = contentHolder at: 'firstChild'. |\r			contentHolder replaceChild: newVisual with: oldVisual]\r		ifFalse: [contentHolder appendChild: newVisual].\r)",
 "installExpandedPresenter = (\r	expandedPresenter isNil ifTrue:\r		[expandedPresenter:: expandedDefinition value.\r		expandedPresenter parent: self].\r	installContentVisual: expandedPresenter visual.\r	expandedPresenter noticeExposure.\r	toggleWidget at: 'src' put: (disclosureOpenImage at: 'src').\r)",
 "public toggle = (\r	isExpanded:: isExpanded not.\r	isExpanded\r		ifTrue: [installExpandedPresenter]\r		ifFalse: [installCollapsedPresenter].\r)",
 "public class ZebraDecorator firstColor: color1 secondColor: color2 = Decorator (|\r	firstColor ::= color1.\r	secondColor ::= color2.\r	sequenceDefinition\r|)",
 "Decorator",
 "Decorator",
 "public decorate: aVisual = (\r| odd <Boolean> ::= false.  children = (aVisual at: 'children'). |\r	0 to: (children at: 'length') - 1 do:\r		[:index | | each = children item: index. c <Color> |\r		c:: odd ifTrue: [firstColor] ifFalse: [secondColor].\r		assert: [c isNil not] message: ['nil color!'].\r		c applyToStyle: (each at: 'style').\r		odd:: odd not.\r		].\r	^aVisual\r)",
 "public darkerColorFirst = (\r	^self firstColor: (Color gray: 0.97) secondColor: Color white\r)",
 "public lighterColorFirst = (\r	^self firstColor: Color white secondColor: (Color gray: 0.97)\r)",
 "class AmpleforthEmbedder usingPlatform: p namespace: ns browsing: b = (\r(*\rAmpleforth is designed to support live literate programming. It supports embedding Newspeak code inside the text of a normal web page. Ampleforth is in its infancy, and currently can be used in conjunction with Madoko to produce such documents.\r\rAmpleforth is the name of a character in 1984 who worked at the Ministry of Truth. His job was to edit Oldspeak text so it would be goodthinkful.\r\rCopyright 2014-2017 Google Inc.\r*)\r|\r	List = p collections List.\r	Color = p graphics Color.\r	ObjectMirror = p mirrors ObjectMirror.\r	ClassMirror = p mirrors ClassMirror.\r	Subject = p hopscotch core Subject.\r	Presenter = p hopscotch core Presenter.\r	TextEditorFragment = p hopscotch fragments TextEditorFragment.\r	Gradient = p hopscotch Gradient.\r	EmbeddedHopscotchWindow = p hopscotch core EmbeddedHopscotchWindow.\r\r	ObjectSubject = b ObjectSubject.\r\r	namespace = ns.\r	browsing = b.\r	document = p js global at: 'document'.\r	platformMirror = ObjectMirror reflecting: p.\r |namespace at: #AmpleforthEmbedder put: self class)",
 " ",
 " ",
 "domElementsWithClass: klass <String> do: action <[:Alien[Element]]> = (\r	| elements = document getElementsByClassName: klass. |\r	0 to: (elements at: 'length') - 1 do:\r		[:index | action value: (elements at: index)].\r)",
 "evaluateSubject: se <String> ^ <Subject> = (\r(* Takes a string representing a unary block and evaluates it with\r	browsing as its argument.  The result should be a Subject, which gets\r	returned. In other words, the string should contain an expression of type\r   [:BrowsingForHTML | Subject]\r*)\r	| blk |\r	blk:: platformMirror\r		evaluate: (withoutNbsp: se)\r		ifCompilerError: [:e | ^ErrorSubject onModel: 'compile-time error: ', e printString]\r		ifError: [:e | ^ErrorSubject onModel: 'runtime error: ', e printString].\r		^blk value: browsing\r)",
 "populateNamespace = (\r | platformClass <ClassMirror> = topLevelClassOf: platformMirror. |\r	namespace at: #SimpleBrowsing put: (ClassMirror reflecting: self Browsing) mixin declaration.\r	namespace at: platformClass name put: platformClass.\r	platformClass slots do: [:s <SlotMirror> | | klass <ClassMIrror> o <ObjectMirror> |\r		o:: platformMirror getSlot: s name.\r		klass:: topLevelClassOf: o.\r		namespace at: klass name put: klass.\r		].\r)",
 "public processClassPresenters = (\r	domElementsWithClass: 'classPresenter' do: [:element |\r		|\r		errorBlock =\r			[:errorMessage <String> |\r			^EmbeddedHopscotchWindow\r				into: element\r				openSubject: (ErrorSubject onModel: errorMessage)].\r		className <String> = element getAttribute: 'className'.\r		klass <Class>\r		cm <ClassDeclarationMirror>\r		|\r		klass:: namespace at: className ifAbsent: [nil].\r		klass isKindOfBehavior ifFalse: [errorBlock value: className, ' is not a class'].\r		(* isKindOfClass should be defined but isn't. *)\r		cm:: (ClassMirror reflecting: klass) mixin declaration.\r		EmbeddedHopscotchWindow\r			into: element\r			openSubject: (browsing ClassSubject onModel: cm)\r	].\r)",
 "public processEvaluators = (\r	domElementsWithClass: 'evaluator' do:\r		[:element |\r		| expression = element getAttribute: 'expression'. |\r		EmbeddedHopscotchWindow\r			into: element\r			openSubject: (SnippetSubject onModel: expression)].\r)",
 "public processMinibrowsers = (\r	domElementsWithClass: 'minibrowser' do:\r		[:element |\r		EmbeddedHopscotchWindow\r			into: element\r			openSubject: browsing HomeSubject new].\r)",
 "public start = (\r	processEvaluators.\r	processMinibrowsers.\r	processClassPresenters.\r)",
 "topLevelClassOf: om <ObjectMirror> ^ <ClassDeclarationMirror> = (\r	| klass ::= om getClass mixin declaration. |\r	[klass mixin enclosingClass isNil] whileFalse: [klass:: klass enclosingClass].\r	^klass\r)",
 "withoutNbsp: string = (\r	('a' at: 1) isKindOfInteger\r		ifTrue:\r			[ | bytes = ByteArray withAll: string. |\r			1 to: bytes size do: [:index | (bytes at: index) = 160 ifTrue: [bytes at: index put: 32]].\r			^bytes asString]\r		ifFalse:\r			[ | nonbreakingSpace = String fromRune: 160.\r			space = String fromRune: 32. |\r			^string replaceAll: nonbreakingSpace with: space]\r)",
 "class ErrorPresenter onSubject: s = Presenter onSubject: s (\r)",
 "onSubject: s",
 "onSubject: s",
 "public definition ^ <Fragment> = (\r	^label: subject errorMessage\r)",
 "class ErrorSubject onModel: s <String> = Subject onModel: s (\r|\r	public errorMessage = s.\r|)",
 "onModel: s",
 "onModel: s",
 "public createPresenter ^ <ErrorPresenter> = (\r	^ErrorPresenter onSubject: self\r)",
 "class SnippetPresenter onSubject: s = Presenter onSubject: s ()",
 "onSubject: s",
 "onSubject: s",
 "definition = (\r	| result |\r	^column: {\r		TextEditorFragment new\r			text: subject snippet;\r			changeResponse: [:editor | result content: (evaluate: editor textBeingAccepted asString)].\r		result:: holder: [deferred: [evaluate: subject snippet]].\r	}\r)",
 "evaluate: expression <String> ^<Fragment> = (	\r	| thread <ThreadMirror> |\r	[thread:: platformMirror evaluate: (withoutNbsp: expression)]\r		on: Error do: [:e | ^linkForError: e].\r	thread isFulfilled ifTrue: [^linkForResult: thread result].\r	thread isBroken ifTrue: [^linkForError: thread result].\r	^nothing\r)",
 "linkForError: exception = (\r	^(link: exception printString\r	action: [enterSubject: (ObjectSubject onModel: (ObjectMirror reflecting: exception)) fromSnippet: subject])\r		color: (Color r: 1 g: 0 b: 0)\r)",
 "linkForResult: objectMirror = (\r	^link: objectMirror reflectee printString\r	action: [enterSubject: (ObjectSubject onModel: objectMirror) fromSnippet: subject]\r)",
 "public class SnippetSubject onModel: m = Subject onModel: m ()",
 "onModel: m",
 "onModel: m",
 "createPresenter = (\r	^SnippetPresenter onSubject: self\r)",
 "public snippet = (\r	^model\r)",
 "class HopscotchWebIDE packageUsing: manifest = (\r	(* The Newspeak IDE in the web browser. *)\r	|\r	private hopscotchRuntime = manifest HopscotchForHTML5Runtime packageUsing: manifest.\r	private Browsing = manifest SimpleBrowsing.\r	private CombinatorialParsing = manifest CombinatorialParsing.\r	private Debugging = manifest Debugging2.\r	private Minitest = manifest Minitest.\r	private MinitestUI = manifest MinitestUI2.\r	private Namespacing = manifest NamespacingForV8.\r	private NewspeakColorization = manifest NewspeakColorization2.\r	private NewspeakGrammar = manifest NewspeakGrammar.\r	private WorkspaceManager = manifest WorkspaceManagerForV8.\r	\r	private testModules = {\r		manifest AccessModifierTesting.\r		manifest AccessModifierTestingConfiguration.\r		manifest KernelTests.\r		manifest KernelTestsConfiguration.\r		manifest MinitestTests.\r		manifest MinitestTestsConfiguration.\r		manifest MirrorTesting.\r		manifest MirrorTestingConfiguration.\r		manifest MirrorTestingModel.\r		manifest MirrorBuilderTesting.\r		manifest MirrorBuilderTestingConfiguration.\r		manifest ActivationMirrorTesting.\r		manifest ActivationMirrorTestingConfiguration.\r	}.\r	\r	private imagesOuter = HopscotchImages packageUsing: manifest. (* Should be `images` but there appears to be an outer send bug in NS2V8. *)\r	|\r	(* manifest codemirror.*)\r)",
 " ",
 " ",
 "augmentIDE: ide withPlatform: p = (\r	|\r	platformMirror <ObjectMirror> = p mirrors ObjectMirror reflecting: p.\r	platformClass <ClassMirror> = platformMirror getClass.\r	runtimeMirror<ObjectMirror> = platformClass enclosingObject.\r	runtimeClass <ClassMirror> = topLevelClassOf: platformMirror.\r	namespace <Namespace> = ide namespacing Root.\r	|\r\r	runtimeClass slots do:\r		[:s <SlotMirror> | | klass <ClassMIrror> o <Object> |\r		o:: (runtimeMirror getSlot: s name) reflectee.\r		o isKindOfBehavior ifTrue:\r			[namespace at: o name put: o]].\r)",
 "public ideUsingPlatform: p = (\r	^HopscotchWebIDE usingPlatform: p\r)",
 "public main: platform <Platform> args: args <Tuple[String]> = (\r	| hopscotchPlatform ide |\r	hopscotchPlatform:: hopscotchRuntime using: platform.\r	ide:: ideUsingPlatform: hopscotchPlatform.\r      augmentIDE: ide withPlatform: platform.\r	hopscotchPlatform hopscotch core HopscotchWindow openSubject: ide browsing HomeSubject new.\r)",
 "topLevelClassOf: om <ObjectMirror> ^ <ClassMirror> = (\r	| klass <ClassMirror> ::= om getClass. |\r	[klass enclosingObject reflectee isNil] whileFalse: [klass:: klass enclosingObject getClass].\r	^klass\r)",
 "class HopscotchImages packageUsing: manifest = (\r	|\r	public publicAccessImage = manifest publicImage.\r	public protectedAccessImage = manifest protectedImage.\r	public privateAccessImage = manifest privateImage.\r	public addImage = manifest hsAddImage.\r	public addOutImage = manifest hsAddOutImage.\r	public addOverImage = manifest hsAddOverImage.\r	public dropDownImage = manifest hsDropdownImage.\r	public dropDownOutImage = manifest hsDropdownOutImage.\r	public dropDownOverImage = manifest hsDropdownOverImage.\r	public expandImage = manifest hsExpandImage.\r	public expandOverImage = manifest hsExpandOverImage.\r	public expandDownImage = manifest hsExpandDownImage.\r	public collapseImage = manifest hsCollapseImage.\r	public collapseOverImage = manifest hsCollapseOverImage.\r	public collapseDownImage = manifest hsCollapseDownImage.\r	public homeImage = manifest hsHomeImage.\r	public homeOverImage = manifest hsHomeOverImage.\r	public homeOutImage = manifest hsHomeOutImage.\r	public homeDownImage = manifest hsHomeDownImage.\r	public refreshImage = manifest hsRefreshImage.\r	public refreshOverImage = manifest hsRefreshOverImage.\r	public refreshOutImage = manifest hsRefreshOutImage.\r	public refreshDownImage = manifest hsRefreshDownImage.\r	public classPresenterIcon = manifest classPresenterImage.\r	public classUnknownIcon = manifest classUnknownImage.\r	public classIcon = manifest languageNewspeak3.\r|)",
 " ",
 " ",
 "class HopscotchWebIDE usingPlatform: p = (\r	|\r	public images = imagesOuter.\r	public browsing = Browsing usingPlatform: p ide: self.\r	public debugging = Debugging usingPlatform: p ide: self.\r	public namespacing = Namespacing usingPlatform: p.\r	public theWorkspaceManager = WorkspaceManager usingPlatform: p ide: self.\r	public minitest = Minitest usingPlatform: p.\r	public minitestUI = MinitestUI usingPlatform: p minitest: minitest ide: self.\r	public parserLib = CombinatorialParsing usingPlatform: p.\r	public grammar = NewspeakGrammar usingPlatform: p parsers: parserLib.\r	public colorizer = (NewspeakColorization usingPlatform: p grammar: grammar) NS3BrowserColorizer new.\r	|\r	populateNamespaceUsingPlatform: p.\r)",
 " ",
 " ",
 "populateIconNamespace: ns <HopscotchImages> ^ <Namespace> = (\r	^ns\r		at: 'publicAccessImage' put: images publicAccessImage;\r		at: 'protectedAccessImage' put: images protectedAccessImage;\r		at: 'privateAccessImage' put: images privateAccessImage;\r		at: 'addImage' put: images addImage;\r		at: 'addOutImage' put: images addOutImage;\r		at: 'addOverImage' put: images addOverImage;\r		at: 'dropDownImage' put: images dropDownImage;\r		at: 'dropDownOutImage' put: images dropDownOutImage;\r		at: 'dropDownOverImage' put: images dropDownOverImage;\r		at: 'expandImage' put: images expandImage;\r		at: 'expandOverImage' put: images expandOverImage;\r		at: 'expandDownImage' put: images expandDownImage;\r		at: 'collapseImage' put: images collapseImage;\r		at: 'collapseOverImage' put: images collapseOverImage;\r		at: 'collapseDownImage' put: images collapseDownImage;\r		at: 'classPresenterIcon' put: images classPresenterIcon;\r		at: 'classUnknownIcon' put: images classUnknownIcon;\r		at: 'classIcon' put: images classIcon;\r		yourself\r)",
 "populateNamespaceUsingPlatform: p <Platform> ^ <Namespace> = (\r	|\r	platformMirror <ObjectMirror> = p mirrors ObjectMirror reflecting: p.\r	platformClass <ClassMirror> = platformMirror getClass.\r	runtimeMirror<ObjectMirror> = platformClass enclosingObject.\r	runtimeClass <ClassMirror> = topLevelClassOf: platformMirror.\r	namespace <Namespace> = namespacing Root.\r	|\r	namespace\r		at: 'Icons' put: (populateIconNamespace: namespacing freshNamespace);\r		at: runtimeClass mixin name put: runtimeClass reflectee;\r		at: 'SimpleBrowsing' put: Browsing;\r		at: 'Minitest' put: Minitest;\r		at: 'MinitestUI' put: MinitestUI;\r		at: 'NamespacingForV8' put: Namespacing;\r		at: 'NewspeakColorization2' put: NewspeakColorization;\r		at: 'HopscotchWebIDE' put: (topLevelClassOf: (p mirrors ObjectMirror reflecting: self)) reflectee;\r		at: 'CombinatorialParsing' put: CombinatorialParsing;\r		at: 'NewspeakGrammar' put: NewspeakGrammar;\r		at: 'Debugging2' put: Debugging;\r		at: 'WorkspaceManagerForV8' put: WorkspaceManager.\r\r	testModules do: [:testModule | namespace at: testModule name put: testModule].\r\r	runtimeClass slots do:\r		[:s <SlotMirror> | | klass <ClassMirror> o <Object> |\r		o:: (runtimeMirror getSlot: s name) reflectee.\r		o isKindOfBehavior ifTrue:\r			[namespace at: o name put: o]].\r\r	^namespace\r)",
 "class SimpleBrowsing usingPlatform: p ide: webIde = (\r(* An IDE for Newspeak on the web.\r    Copyright 2016-2017 Google Inc.\r*)\r|	(* imports *)\r	StringBuilder = p kernel StringBuilder.\r	Subject = p hopscotch core Subject.\r	Presenter = p hopscotch core Presenter.\r	TextEditorFragment = p hopscotch fragments TextEditorFragment.\r	Color = p graphics Color.\r	Gradient = p hopscotch Gradient.\r	List = p collections List.\r	Map = p collections Map.\r	ClassMirror = p mirrors ClassMirror.\r	ObjectMirror = p mirrors ObjectMirror.\r	ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.\r	JSObject = p js global at: 'Object'.\r	JSMath = p js global at: 'Math'.\r		(* module variables *)\r	cachedPlatform = p.\r	ide = webIde.\r	detailAreaRatio = 3 asFloat.\r	captionColor = Color h: 240 s: 0.05 asFloat v: 0.9 asFloat.\r	cssConverter = cssConversionTable.\r|\r)",
 " ",
 " ",
 "colorizingBlockFor: cm <CodeMirrorFragment> = (\r	^[:r | | style <Alien[JSObject]> = JSObject new. |\r	style at: 'css' put: (cssFor: r kind).\r	cm style: style from: r start to: r end]\r)",
 "crToLf: string = (\r	('a' at: 1) isKindOfInteger\r		ifTrue:\r			[ | bytes = ByteArray withAll: string. |\r			1 to: bytes size do: [:index | (bytes at: index) = 13 ifTrue: [bytes at: index put: 10]].\r			^bytes asString]\r		ifFalse:\r			[ | cr = String fromRune: 13. lf = String fromRune: 10. |\r			^string replaceAll: cr with: lf]\r)",
 "cssConversionTable ^ <Map[Symbol, String]> = (\r(* compute a mapping from 'kinds', which are symbols denoting logical categories of code, to CSS properties used to colorize them*)\r	|\r	redBoldUnderlined <String> = 'color:Red; font-weight:bold; text-decoration: underline'.\r	redUnderlined <String> = 'color:Red; text-decoration: underline'.\r	orangeBoldUnderlined <String> = 'color:Orange; font-weight:bold; text-decoration: underline'.\r	underlined <String> = 'text-decoration: underline'.\r	gray <String> = 'color:Gray'.\r	blue <String> = 'color:Blue'.\r	grayBold <String> = 'color:Gray; font-weight:bold'.\r	blackBold <String> = 'color:Black; font-weight:bold'.\r	blueBold <String> = 'color:Blue; font-weight:bold'.\r	magentaBold <String> = 'color:Magenta; font-weight:bold'.\r	bold <String> = 'font-weight:bold'.\r	|\r      ^Map new\r		at: #error put: redBoldUnderlined;\r		at: #undefinedUnary put: redUnderlined;\r		at: #undefinedBinary put: redUnderlined;\r		at: #undefinedKeyword put: redUnderlined;\r		at: #shadowingTempVar put: orangeBoldUnderlined;\r		at: #obsoleteMessage put: orangeBoldUnderlined;\r		at: #whitespaceWarning put: orangeBoldUnderlined;\r		at: #incompleteUnary put: underlined;\r		at: #incompleteBinary put: underlined;\r		at: #incompleteKeyword put: underlined;\r		at: #self put: gray;\r		at: #super put: gray;\r		at: #outer put: gray;\r		at: #true put: gray;\r		at: #false put: gray;\r		at: #nil put: gray;\r		at: #string put: gray;\r		at: #symbol put: gray;\r		at: #number put: gray;\r		at: #character put: gray;\r		at: #public put: gray;\r		at: #protected put: gray;\r		at: #private put: gray;\r		at: #tempVar put: grayBold;\r		at: #blockTempVar put: grayBold;\r		at: #blockPatternArg put: grayBold;\r		at: #patternArg put: grayBold;\r		at: #slotDecl put: grayBold;\r		at: #patternTempVar put: grayBold;\r		at: #methodTempBar put: blackBold;\r		at: #leftParenthesis put: blackBold;\r		at: #rightParenthesis put: blackBold;\r		at: #leftParenthesis3 put: blackBold;\r		at: #rightParenthesis3 put: blackBold;\r		at: #leftParenthesis6 put: blackBold;\r		at: #rightParenthesis6 put: blackBold;\r		at: #blockStart put: blackBold;\r		at: #blockEnd put: blackBold;\r		at: #blockStart3 put: blackBold;\r		at: #blockEnd3 put: blackBold;\r		at: #blockStart6 put: blackBold;\r		at: #blockEnd6 put: blackBold;\r		at: #leftBrace put: blackBold;\r		at: #rightBrace put: blackBold;\r		at: #leftBrace3 put: blackBold;\r		at: #rightBrace3 put: blackBold;\r		at: #leftBrace6 put: blackBold;\r		at: #rightBrace6 put: blackBold;\r		at: #messagePatternDecl put: bold;\r		at: #class put: gray;\r		at: #className put: bold;\r		at: #comment put: blue;\r		at: #type put: blueBold;\r		at: #return put: blueBold;\r		at: #leftParenthesis1 put: blueBold;\r		at: #rightParenthesis1 put: blueBold;\r		at: #leftParenthesis4 put: blueBold;\r		at: #rightParenthesis4 put: blueBold;\r		at: #leftParenthesis7 put: blueBold;\r		at: #rightParenthesis7 put: blueBold;\r		at: #blockStart1 put: blueBold;\r		at: #blockEnd1 put: blueBold;\r		at: #blockStart4 put: blueBold;\r		at: #blockEnd4 put: blueBold;\r		at: #blockStart7 put: blueBold;\r		at: #blockEnd7 put: blueBold;\r		at: #leftBrace1 put: blueBold;\r		at: #rightBrace1 put: blueBold;\r		at: #leftBrace4 put: blueBold;\r		at: #rightBrace4 put: blueBold;\r		at: #leftBrace7 put: blueBold;\r		at: #rightBrace7 put: blueBold;\r		at: #leftParenthesis2 put: magentaBold;\r		at: #rightParenthesis2 put: magentaBold;\r		at: #leftParenthesis5 put: magentaBold;\r		at: #rightParenthesis5 put: magentaBold;\r		at: #blockStart2 put: magentaBold;\r		at: #blockEnd2 put: magentaBold;\r		at: #blockStart5 put: magentaBold;\r		at: #blockEnd5 put: magentaBold;\r		at: #leftBrace2 put: magentaBold;\r		at: #rightBrace2 put: magentaBold;\r		at: #leftBrace5 put: magentaBold;\r		at: #rightBrace5 put: magentaBold;\r		yourself\r)",
 "cssFor: k <Symbol> ^ <String> = (\r        ^cssConverter at: k ifAbsent: [ 'color:Black; font-family: TimesNewRoman']\r)",
 "public class AssortedMethodsPresenter onSubject: s = DefinitionListPresenter onSubject: s (\r(* The subject is a collection of MethodSubjects that can come from diverse sources (in the sense that they do not have to belong to the same class). The presenter displays them as a column of expandable method presenters and takes care of reasonably handling the various creation and deletion requests coming from them.  I group my methods by their containing package.\r\rSlots\r	title	<String>	The title to use for the presenter\r	methodPresenters <List[ExpandableMethodPresenter]> Because the method presenters are grouped by package, if we need to expand or collapse those presenters, we only want to expand or collapse the method presenters.  The group heading is not expandable (or collapsable). *)\r|\r	public title ::= 'Assorted Methods'.\r	methodPresenters ::= List new.\r|)",
 "onSubject: s",
 "onSubject: s",
 "contentPresenters = (\r	^subject methodSubjects collect: [:each | each presenter]\r)",
 "respondToCollapse: presenters = (\r	presenters do: [:each | each collapse].\r)",
 "respondToExpand: presenters = (\r	presenters do: [:each | each expand].\r)",
 "public class BitOfWisdom text: s <String> actionLabel: l <String> actionBlock: b <[]> image: i = (|\r	public text <String> = s.\r	public image = i.\r	public actionLabel <String> = l.\r	public actionBlock <[]> = b.\r|)",
 " ",
 " ",
 "public text: s <String> ^ <BitOfWisdom> = (\r	^text: s actionLabel: nil actionBlock: nil image: nil\r)",
 "public text: s <String> actionLabel: l <String> actionBlock: b <[]> ^ <BitOfWisdom> = (\r	^self\r		text: s\r		actionLabel: l\r		actionBlock: b\r		image: nil\r)",
 "public text: s image: i ^ <BitOfWisdom> = (\r	^text: s actionLabel: nil actionBlock: nil image: i\r)",
 "class ClassActionsPresenter onSubject: s = ProgrammingPresenter onSubject: s ()",
 "onSubject: s",
 "onSubject: s",
 "definition = (\r	^row: {testActions. (*benchmarkActions. applicationActions*) }\r)",
 "testActions = (\r	subject isTestConfiguration ifFalse: [^nothing].\r	^link: '[run tests]' action: [enterSubject:: subject testingSubject].\r)",
 "class ClassCommentPresenter onSubject: s <ClassSubject> = ProgrammingPresenter onSubject: s (\r|\r  editor\r  isEditing ::= false.\r  showPartialIfLong ::= true.\r  showingPartial\r|\r)",
 "onSubject: s",
 "onSubject: s",
 "= anotherPresenter = (\r	^self == anotherPresenter\r)",
 "definition = (\r	^holder:\r		[isEditing\r			ifTrue: [editorDefinition]\r			ifFalse: [viewerDefinition]]\r)",
 "definitionText = (\r	(* In this class, only used by the editor side of the presenter to get the text to show in the editor. *)\r\r	^fullCommentText\r)",
 "editorDefinition = (\r	editor:: TextEditorFragment new.\r	editor\r		text: definitionText;\r		cancelResponse: [respondToCancel];\r		acceptResponse: [respondToAccept];\r		enterEditState.\r	^editor\r)",
 "enterEditState = (\r	isEditing:: true.\r	refresh\r)",
 "fullCommentText = (\r	^subject classCommentText asString\r)",
 "hash = (\r	^self identityHash\r)",
 "public leaveEditState = (\r	isEditing:: false.\r	refresh\r)",
 "maybePartialCommentText ^<String> = (\r  ^fullCommentText size > 500 ifTrue: [\r	showingPartial:: true.\r	subject classCommentSummary\r	] ifFalse: [\r	showingPartial:: false.\r	fullCommentText\r	]\r)",
 "presentationDefinition = (\r	| textToDisplay |\r	textToDisplay:: retrieveComment.\r	textToDisplay isEmpty ifTrue:\r		[textToDisplay:: '(no comment)'].\r	^column:\r		{textDisplay: textToDisplay.\r		showingPartial\r			ifTrue: [(link: 'show full comment' action: [showFullComment])]\r			ifFalse: [(link: 'hide full comment' action: [showLessComment])].\r		}\r)",
 "respondToAccept = (\r	subject classCommentText: editor textBeingAccepted. leaveEditState.\r)",
 "respondToCancel = (\r	leaveEditState\r)",
 "respondToEdit = (\r	enterEditState\r)",
 "retrieveComment ^<String> = (\r	(* Get the text to display--either the whole thing or the first paragraph, depending on the text and the settings--and set the showingPartial slot accordingly. *)\r\r	^showPartialIfLong\r		ifTrue:\r			[maybePartialCommentText]\r		ifFalse:\r			[showingPartial:: false.\r			fullCommentText]\r)",
 "showFullComment = (\r	showPartialIfLong:: false.\r	refresh\r)",
 "showLessComment = (\r	showPartialIfLong:: true.\r	refresh\r)",
 "viewerDefinition = (\r^\r	row: {\r		elastic:\r			presentationDefinition.\r		smallBlank.\r		(* linkImage:  editImage action: [respondToEdit]*)\r		}\r)",
 "class ClassEntryPresenter onSubject: s <ClassSubject> = EntryPresenter onSubject: s ()",
 "onSubject: s",
 "onSubject: s",
 "accessIndicator = (\r	^image: (iconForAccessModifier: subject accessModifier).\r)",
 "classCommentSummary ^ <String> = (\r	|\r	fullComment <String> = subject classCommentText.\r	endOfFirstSentence <Integer> = fullComment indexOf: '.'.\r	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.\r	|\r	^firstSentence\r)",
 "collapsedDefinition = (\r	^row1: {\r		image: ide images classIcon.\r		smallBlank.\r		accessIndicator.\r		smallBlank.\r		link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror].\r	} row2: {\r		(row: {deferred: [(label: subject classCommentSummary)\r			smallFont;\r			color: secondaryTextColor]})\r				compressibility: 1.\r		filler\r			compressibility: 0.\r\r		ClassActionsPresenter onSubject: subject.\r		mediumBlank.\r		entryActionsMenu.\r	}\r)",
 "entryActionsMenu = (\r	^nothing\r)",
 "expandedDefinition = (\r	^subject presenter\r)",
 "class ClassFactoryPresenter onSubject: s <ClassFactorySubject> = MethodPresenter onSubject: s (\r(* WIP. Present the factory method, colorized *)\r)",
 "onSubject: s",
 "onSubject: s",
 "acceptResponse ^ <[:CodeMirrorFragment :Event]> = (\r	^[:ed <CodeMirrorFragment> :event <Event> |\r		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |\r		b addFactoryFromSource: ed textBeingAccepted.\r		b declaration install.\r		colorizeHeaderSource: (crToLf: ed textBeingAccepted).\r		ed leaveEditState.\r		]\r)",
 "colorizeHeaderSource: s <String> withEditor: cm <CodeMirrorFragment> = (\r	ide colorizer colorizeHeader: s fromClass: subject classDeclaration via: (colorizingBlockFor: cm)\r)",
 "colorizeMethodSource: s <String> ^ <TextFragment> = (\r	^text: (ide colorizer parseClassHeader: s fromClass: subject classDeclaration)\r)",
 "class ClassFactorySubject onModel: m <ClassDeclarationMirror> = MethodSubject onModel: m (\r(* WIP. *)\r)",
 "onModel: m",
 "onModel: m",
 "public accessModifier ^ <Symbol> = (\r	^#public\r)",
 "public createPresenter ^ <ClassFactoryPresenter> = (\r	^ClassFactoryPresenter onSubject: self\r)",
 "class ClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (\r|\rdescriptionOrSourceSwitcherHolder\rdescriptionOrSourceHolder\r|\r)",
 "onSubject: s",
 "onSubject: s",
 "acceptResponse ^ <[:CodeMirrorFragment :Event]> = (\r	^[:ed <CodeMirrorFragment> :event <Event> |\r		| b <ClassDeclarationBuilder> = subject classMirror asBuilder. |\r		(*('ed text:', ed textBeingAccepted) out.*)\r		b header source: ed textBeingAccepted.\r		b install.\r		colorizeHeaderSource: (crToLf: ed textBeingAccepted) withEditor: ed.\r		ed leaveEditState.\r		]\r)",
 "accessIndicator = (\r	^image: (iconForAccessModifier: subject accessModifier).\r)",
 "changeResponse ^ <[:CodeMirrorFragment :Event]> = (\r	^[:ed <CodeMirrorFragment> :event <Event>  |  | cp <Integer> |\r		colorizeHeaderSource: (crToLf: ed textBeingAccepted) withEditor: ed.\r		ed enterEditState.\r	  ]\r)",
 "classActionsMenu = (\r	^menuWithLabelsAndActions: {\r		{'Inspect Mirror'. [inspectObject: subject classMirror]}.\r		{'Inspect Presenter'. [respondToInspectPresenter]}.\r		{'Delete'. [respondToDelete]}.\r	}\r)",
 "classCommentSummary ^ <String> = (\r	|\r	fullComment <String> = subject classCommentText.\r	endOfFirstSentence <Integer> = fullComment indexOf: '.'.\r	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.\r	|\r	^firstSentence\r)",
 "classDescriptionDefinition = (\r	| slotList <Fragment> |\r	^column: {\r		ClassCommentPresenter onSubject: subject.\r		mediumBlank.\r           (slotList:: subject classMirror instanceSide slots) size > 0\r		   ifTrue: [\r			column: {\r				label: 'Slots'.\r				row: {\r					mediumBlank.\r					column: (slotList collect: [:ea | label: ea name]).\r				}\r			}.\r		] ifFalse: [nothing].\r		initializerDefinition.\r		}\r)",
 "classNameAndContainmentDefinition ^ <Fragment> = (\r	| parts <List[Fragment]> |\r	parts:: List new.\r	subject enclosingClassSubjects\r		do: [:ecs | parts add: (link: ecs name action: [enterSubject:: ecs])]\r		separatedBy: [parts add: ( label: ' in ')].\r	^column: {\r		row: {\r			blank: 5.\r			image: ide images classIcon.\r			blank: 5.\r			row: parts.\r			filler.\r			ClassActionsPresenter onSubject: subject.\r			smallBlank.\r			dropDownMenu: [classActionsMenu].\r			largeBlank.\r			homeButton.\r			smallBlank.\r			refreshButton.\r			smallBlank.\r		}.\r		preambleLine.\r		label: subject classCommentSummary.\r	}\r)",
 "classSourceDefinition = (\r	| src = crToLf: subject classHeaderSource. editor =  codeMirror: src. |\r	editor changeResponse: changeResponse;\r		acceptResponse: acceptResponse.\r	colorizeHeaderSource: src withEditor: editor.\r	^editor\r)",
 "collapsedHeadingDefinition = (\r	^row: {\r		blank: 5.\r		image: ide images classIcon.\r		blank: 5.\r		link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror (* Why do we need a copy? *)]\r		}.\r)",
 "colorizeHeaderSource: s <String> withEditor: cm <CodeMirrorFragment> = (\r	ide colorizer colorizeHeader: s fromClass: subject classMirror via: (colorizingBlockFor: cm)\r)",
 "public definition ^ <Fragment> = (\r	^column: {\r		headingDefinition.\r		sectionLabelled: 'Classes' presenting: subject nestedClassesSubject.\r		sectionLabelled: 'Methods' presenting: subject methodsSubject.\r		sectionLabelled: 'Class Methods' presenting: subject classMethodsSubject.\r	}\r)",
 "expandedHeadingDefinition ^ <Fragment> = (\r	|  slotList <Fragment> |\r	^(column: {\r		blank: 5.\r		classNameAndContainmentDefinition.\r		blank: 15.\r		descriptionOrSourceSwitcherHolder:: holder: (switcherShowingSource: false).\r		(row: {}) color: (Color gray: 0.8).\r		mediumBlank.\r		descriptionOrSourceHolder:: holder: (classDescriptionDefinition)\r	})\r)",
 "headingDefinition ^ <Fragment> = (\r	^(column: {\r		expanded: [expandedHeadingDefinition]\r		collapsed: [collapsedHeadingDefinition].\r	}) color: (Color h: 240 s: 0.05 v: 0.9).\r)",
 "initializerDefinition ^ <Fragment> = (\r	^nothing\r)",
 "inspectSelf ^ <Fragment> = (\r	^row: {filler. link: 'Inspect Presenter' action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)]}\r)",
 "minorClassHeadingBlock: body = (\r	^(padded: body with: {10. 5. 10. 5.})\r		color: minorClassHeadingColor\r)",
 "minorClassHeadingColor = (\r	^Gradient\r		from: (Color h: 240 s: 0.02 v: 0.94)\r		to: (Color h: 240 s: 0.02 v: 0.9)\r)",
 "nestedClass: cdm = (\r	^collapsed: [row: {\r					image: (iconForAccessModifier: cdm accessModifier).\r					blank: 3.\r					link: cdm simpleName action: [enterSubject:: ClassSubject onModel: cdm]\r					}\r				]\r	expanded: [(ClassSubject onModel: cdm) presenter]\r)",
 "preambleLine = (\r	(* The line showing the class constructor syntax, e.g. 'Foo foo: x = Bar'. The superclass clause, if present, becomes a link to browse the superclass. *)\r\r	| preamble <String> equalIndex <Integer> prefix <String> suffix <String> |\r	preamble:: subject classMirror header preamble.\r	equalIndex:: preamble indexOf: \"=\".\r	equalIndex = 0\r		ifTrue:\r			[prefix:: preamble.\r			suffix:: '']\r		ifFalse:\r			[prefix:: (preamble copyFrom: 1 to: equalIndex - 1).\r			suffix:: (preamble copyFrom: equalIndex + 1 to: preamble size)].\r	^suffix isEmpty\r		ifTrue:\r			[label: prefix]\r		ifFalse:\r			[row: {\r				label: prefix, ' = '.\r				link: suffix action: [respondToBrowseSuperclass]\r				}]\r)",
 "respondToDelete = (\r	| enclosing = subject enclosingClassSubject. |\r	subject deleteClass.\r	enterSubject: enclosing.\r)",
 "sectionLabelled: title <String> presenting: groupSubject <MirrorGroupSubject> = (\r	| groupPresenter |\r^\r	column: {\r		minorClassHeadingBlock: (\r			row: {\r				label: title.\r				largeBlank.\r				addButtonWithAction: [groupPresenter addNewItemTemplate].\r				filler.\r				expandButtonWithAction: [groupPresenter expandAll].\r				blank: 3.\r				collapseButtonWithAction: [groupPresenter collapseAll].\r				}\r			).\r		groupPresenter:: groupSubject presenter.\r		}\r)",
 "switchToDescription = (\r	descriptionOrSourceSwitcherHolder content: (switcherShowingSource: false).\r	descriptionOrSourceHolder content: classDescriptionDefinition.\r)",
 "switchToSource = (\r	descriptionOrSourceSwitcherHolder content: (switcherShowingSource: true).\r	descriptionOrSourceHolder content: classSourceDefinition.\r	descriptionOrSourceHolder refresh.\r)",
 "switcherShowingSource: showingSourceNow <Boolean> ^ <Fragment> = (\r	^showingSourceNow\r		ifTrue:\r			[row: {\r				(link: 'Description' action: [switchToDescription]).\r				mediumBlank.\r				(label: 'Source').\r			}]\r		ifFalse:\r			[row: {\r				(label: 'Description').\r				mediumBlank.\r				(link: 'Source' action: [switchToSource]).\r			}]\r)",
 "public class ClassSubject onModel: m <ClassDeclarationMirror> = Subject onModel: m (\r)",
 "onModel: m",
 "onModel: m",
 "public accessModifier = (\r	^classMirror accessModifier\r)",
 "public classCommentSummary ^ <String> = (\r	|\r	fullComment <String> = classCommentText.\r	endOfFirstSentence <Integer> = fullComment indexOf: '.'.\r	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.\r	|\r	^firstSentence\r)",
 "public classCommentText ^<String> = (\r	| comment = model header classComment. |\r	nil = comment ifTrue: [^''].\r	^comment\r)",
 "public classHeaderSource = (\r	^classMirror header source\r)",
 "public classMethodsSubject ^ <MethodGroupSubject> = (\r	^MethodGroupSubject onModel: classMirror classSide methods within: classMirror classSide\r)",
 "public classMirror ^ <ClassDeclarationMirror> = (\r	^model\r)",
 "public createPresenter = (\r	^ClassPresenter onSubject: self\r)",
 "public deleteClass = (\r	| builder |\r	nil = model enclosingClass ifTrue: [halt].\r	builder:: model enclosingClass asBuilder.\r	builder instanceSide nestedClasses removeMirrorNamed: model name.\r	builder install.\r)",
 "public enclosingClassSubject = (\r	^ClassSubject onModel: model enclosingClass\r)",
 "public enclosingClassSubjects = (\r	| them = List new. c |\r	c:: model.\r	[c isNil] whileFalse: [them add: (ClassSubject onModel: c). c:: c enclosingClass].\r	^them\r)",
 "public isTestConfiguration = (\r	(* bogus, but compatible. *)\r	^isTopLevel and: [(model header source indexOf: 'packageTestsUsing:') > 0]\r)",
 "public isTopLevel = (\r	^nil = model enclosingClass\r)",
 "public methodsSubject ^ <MethodGroupSubject> = (\r	^MethodGroupSubject onModel: classMirror instanceSide methods within: classMirror instanceSide\r)",
 "public name = (\r	^model name\r)",
 "public nestedClassesSubject ^ <NestedClassGroupSubject> = (\r	^NestedClassGroupSubject onModel: classMirror instanceSide nestedClasses within: classMirror instanceSide\r)",
 "public testingSubject = (\r	#NAMESPACEBOGUS.\r	^ide minitestUI TestingInProgressSubject\r		onConfiguration: (ide namespacing Root at: name)\r		platform: cachedPlatform\r		minitest: ide minitest\r)",
 "public title = (\r	^name\r)",
 "public class DefinitionListPresenter onSubject: s = ProgrammingPresenter onSubject: s (\r(* DefinitionListPresenter is an abstract superclass of presenters that displays helper ''transient'' presenters that visually appear to belong to the main list of subject presenters. One common example is a method list presenter which can at times include presenters for methods being added or residue presenters of removed methods. *)\r| \rprefixes <PresenterList> \rcontent <PresenterList> \rsuffixes <PresenterList> \r|\r)",
 "onSubject: s",
 "onSubject: s",
 "public collapseAll = (\r	(* Collapse all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)\r\r	(*majorUpdate: [*)\r		content presenters do: [:each | each collapse]\r		(*]*)\r)",
 "contentList ^ <PresenterList> = (\r	^list: [contentPresenters]\r)",
 "contentPresenters ^ <List[Presenter]> = (\r	^List new\r)",
 "definition ^ <Fragment> = (\r	prefixes:: list.\r	content:: contentList.\r	suffixes:: list.\r	^column: {\r		prefixes.\r		content.\r		suffixes.\r	}\r)",
 "public expandAll = (\r	(* Expand all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)\r\r	(*majorUpdate: [*)\r		content presenters do: [:each | each expand]\r		(*]*)\r)",
 "public class DefinitionTemplate\r   caption: c <String>\r   initialText: t <String | Text>\r   colorizerBlock: cb <[:String :CodeMirrorFragment]>\r   acceptResponse: onAccept <[DefinitionTemplate]>\r   cancelResponse: onCancel <[DefinitionTemplate]>\r = ProgrammingPresenter onSubject: nil (|\r	public caption = c.\r	public initialText = t.\r	public initiallyInEditState ::= true.\r	public acceptResponse = onAccept.\r	public cancelResponse = onCancel.\r	public editor\r	public colorizerBlock = cb.\r|)",
 "onSubject: nil",
 "onSubject: nil",
 "definition ^ <Fragment> = (\r	^(row: {\r		mediumBlank.\r		elastic:\r			(column: {\r				smallBlank.\r				label: caption.\r				editorDefinition.\r				mediumBlank.\r 			}).\r		smallBlank.\r		}) color: (Gradient from: (Color h: 100 s: 0.3 v: 0.9) to: (Color h: 100 s: 0.3 v: 0.8))\r)",
 "editorDefinition ^ <Fragment> = (\r	editor:: (codeMirror: initialText)\r	(*	acceptLabelText: 'save';\r		cancelLabelText: 'cancel';*)\r		acceptResponse: [acceptResponse value: self];\r		changeResponse: [:cm <CodeMirrorFragment> :event <Event>  | colorizerBlock value: cm textBeingAccepted value: cm];\r		cancelResponse: [cancelResponse value: self].\r	initiallyInEditState ifTrue: [editor enterEditState].\r	colorizerBlock value: initialText value: editor.\r	^editor\r)",
 "public text = (\r	^editor textBeingAccepted\r)",
 "class EntryPresenter onSubject: s = ProgrammingPresenter onSubject: s ()",
 "onSubject: s",
 "onSubject: s",
 "public collapse = (\r	substance collapse\r)",
 "definition = (\r	^collapsed: [collapsedDefinition] expanded: [expandedDefinition]\r)",
 "public expand = (\r	substance expand\r)",
 "row1: row1 row2: row2 = (\r	^row: {\r		(row: row1) width: 0 elasticity: 1.\r		(row: {mediumBlank}, row2) width: 0 elasticity: 2.\r	}\r)",
 "public class EvaluationPresenter onSubject: s <ObjectSubject | ActivationSubject> = ProgrammingPresenter onSubject: s (\r	|\r	resultHolder\r	|\r)",
 "onSubject: s",
 "onSubject: s",
 "definition = (\r	^column: {\r		editorDefinition.\r		resultHolder:: holder: [nothing].\r	}\r)",
 "editorDefinition ^ <CodeMirrorFragment> = (\r	| initialSource cm <CodeMirrorFragment> |\r	initialSource:: ''.\r	cm:: (codeMirror: initialSource) changeResponse:\r		[:editor <CodeMirrorFragment>  |\r		| src <String> =  editor textBeingAccepted. |\r		resultHolder content: (evaluate: (withoutNbsp: src)).\r		ide colorizer colorizeDoIt: src fromClass: nil via: (colorizingBlockFor: editor)].\r	ide colorizer colorizeDoIt: initialSource fromClass: nil via: (colorizingBlockFor: cm).\r	^cm\r)",
 "evaluate: expression <String> ^<Fragment> = (\r	| thread <ThreadMirror> |\r	expression isEmpty ifTrue: [^nothing].\r	\r	[thread:: subject evaluate: expression]\r		on: Error do: [:e | ^linkForCompileError: e].\r\r	thread isFulfilled ifTrue: [^linkForResult: thread].\r	thread isBroken ifTrue: [^linkForError: thread].\r	^nothing\r)",
 "linkForCompileError: error <Exception> = (\r	^column: {\r		smallBlank.\r		(link: error printString action:\r			[inspectObjectMirror: (ObjectMirror reflecting: error)])\r				color: (Color r: 1 g: 0 b: 0).\r	}\r)",
 "linkForError: thread <ThreadMirror> = (\r	^column: {\r		smallBlank.\r		(link: thread result reflectee printString action:\r			[enterSubject:: ide debugging ThreadSubject onModel: thread])\r				color: (Color r: 1 g: 0 b: 0).\r	}\r)",
 "linkForResult: thread <ThreadMirror> = (\r	^column: {\r		smallBlank.\r		(link: thread result reflectee printString action:\r			[enterSubject:: ObjectSubject onModel: thread result]).\r	}\r)",
 "withoutNbsp: string = (\r	('a' at: 1) isKindOfInteger\r		ifTrue:\r			[ | bytes = ByteArray withAll: string. |\r			1 to: bytes size do: [:index | (bytes at: index) = 160 ifTrue: [bytes at: index put: 32]].\r			^bytes asString]\r		ifFalse:\r			[ | nonbreakingSpace = String fromRune: 160.\r			space = String fromRune: 32. |\r			^string replaceAll: nonbreakingSpace with: space]\r)",
 "class HomePresenter onSubject: s = ProgrammingPresenter onSubject: s (\r| helpHolder |\r)",
 "onSubject: s",
 "onSubject: s",
 "aboutSystemDefinition = (\r	^(link: 'About this system' action: [respondToAboutSystem]) smallFont.\r)",
 "actionsMenu = (\r	^menuWithLabelsAndActions: {\r		{'Inspect Presenter'. [respondToInspectPresenter]}.\r	}\r)",
 "column1: definitions1 column2: definitions2 column3: definitions3 = (\r	^row: {\r		(column: definitions1) width: 0 elasticity: 1.\r		(column: definitions2) width: 0 elasticity: 1.\r		(column: definitions3) width: 0 elasticity: 1.\r	}\r)",
 "definition = (\r      helpHolder:: list.\r	^column: {\r	      helpHolder.\r		majorHeadingBlock: (\r			row: {\r				label: 'Navigation'.\r				filler.\r                        dropDownMenu: [actionsMenu].\r                        mediumBlank.				\r				helpButton.\r			}\r		).\r		mediumBlank.\r\r		indentedBlock:\r			(column1: {\r				link: 'Newspeak Source' action: [navigateToNamespace].\r			}\r			column2: {\r				link: 'Workspaces' action: [navigateToWorkspaces].\r			}\r			column3: {\r			}).\r		mediumBlank.\r\r(*		majorHeadingBlock: (label: 'Recently Visited' asText allBold).\r		mediumBlank.\r		indentedBlock:\r			(holder: [recentStuffDefinition]).\r		largeBlank.*)\r\r		majorHeadingBlock: (label: 'Did you know?').\r		mediumBlank.\r\r		indentedBlock:\r			(holder: [didYouKnow]).\r		mediumBlank.\r		indentedBlock: aboutSystemDefinition.\r	}\r)",
 "didYouKnow = (\r	| wisdom |\r	wisdom:: subject randomBitOfWisdom.\r	nil = wisdom actionLabel ifFalse:\r		[^textAndActionWisdom: wisdom].\r	nil = wisdom image ifFalse:\r		[^textAndImageWisdom: wisdom].\r	^textDisplay: wisdom text\r)",
 "helpButton = (\r^helpText isNil\r	ifTrue: [nothing]\r	ifFalse: [(link: '[?]' action: [respondToHelp]) smallFont]\r)",
 "helpText ^<String | nil> = (\r(* If this method answers a string, a help button will appear on the Home page. Clicking on that button will display the string. *)\r^'This is the home page.\rThe home page includes links to a variety of useful places, like the IDE''s root namespace, which lists all top level classes, and the workspace manager, where you can evaluate code.\rGolden icons represent Newspeak3, which is the currently operational dialect of Newspeak.'\r)",
 "navigateToNamespace = (\r	enterSubject:: NamespaceSubject new.\r)",
 "navigateToWorkspaces = (\r	enterSubject:: ide theWorkspaceManager AllWorkspacesSubject new.\r)",
 "respondToAboutSystem = (\r	alert: 'WebIDEApp version 0.1984'\r)",
 "respondToHelp = (\rhelpHolder setPresenters: {\r	row: {\r		filler.\r		(link: 'close help' action: [helpHolder setPresenters: {}]) smallFont.\r	}.\r	textDisplay: helpText.\r}\r)",
 "textAndActionWisdom: wisdom = (\r	^column: {\r		textDisplay: wisdom text.\r		(link: wisdom actionLabel action: wisdom actionBlock) smallFont\r	}\r)",
 "textAndImageWisdom: wisdom = (\r	^row: {\r		image: wisdom image.\r		mediumBlank.\r		elastic:\r			(textDisplay: wisdom text).\r	}\r)",
 "public class HomeSubject onModel: m = Subject onModel: m ()",
 "onModel: m",
 "onModel: m",
 "public = anotherSubject <Subject> ^ <Boolean> = (\r	(* As there is just one possible logical home of the system, all subjects representing it are considered equal. *)\r	^anotherSubject isKindOfHomeSubject\r)",
 "bitsOfWisdom = (\r	(* This defines the bits of wisdom displayed at the bottom of the Hopscotch home page. Each time a page opens a new element is selected at random. An element may evaluate to nil, which will select another element at random. *)\r	^{\r	[BitOfWisdom\r		text: 'This is the \"expand all\" button which appears in headers of expandable item groups.'\r		image: ide images expandImage].\r\r	[BitOfWisdom\r		text: 'This is the \"collapse all\" button which appears in headers of expandable item groups.'\r		image: ide images collapseImage].\r\r	[BitOfWisdom\r		text: 'This is the \"add\" button which appears in headers of groups of items you can add to, such as methods of a class or classes of a package.'\r		image: ide images addImage].\r\r	[BitOfWisdom\r		text: 'Expressions evaluated in debuggers and inspectors can access a workspace via the name _. This allows you to bypass modularity during development and access values you forgot to import, e.g. _ collections List.'].\r\r	[BitOfWisdom\r		text: 'This icon identifies Newspeak classes.'\r		image: ide images classIcon].\r\r	[BitOfWisdom\r		text: 'This icon identifies namespaces.'\r		image: ide images classPresenterIcon].\r\r	[BitOfWisdom\r		text: 'War is peace. Freedom is slavery. Ignorance is strength.'].\r	}\r)",
 "public createPresenter = (\r	^HomePresenter onSubject: self\r)",
 "public isKindOfHomeSubject ^ <Boolean> = (\r	^true\r)",
 "public randomBitOfWisdom = (\r	| bits = bitsOfWisdom. |\r	^(bits at: (JSMath random * bits size) floor asInteger + 1) value\r)",
 "public title = (\r	^'Home'\r)",
 "public new = (\r	^onModel: nil\r)",
 "class MethodGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (\r(* Presents the subject, an NSMethodGroup, as a column of presenters for the methods in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS methods goes here. *)\r| groupedByCategory <Boolean> ::=false. |\r)",
 "onSubject: s",
 "onSubject: s",
 "public addNewItemTemplate = (\r	(* Handle a user's request to create a new method by displaying a new method template. *)\r	addNewItemTemplate: subject methodTemplateText\r)",
 "addNewItemTemplate: src = (\r	(* Handle a user's request to create a new method by displaying a new method template. *)\r\r	| template |\r	template:: DefinitionTemplate\r		caption: 'Adding new method:'\r		initialText: src\r		colorizerBlock:\r			[:text <String> :cm <CodeMIrrorFragment> | subject colorizeSource: text editor: cm]\r		acceptResponse:\r			[:ed | createNewMethodFromTemplate: template]\r		cancelResponse:\r			[:ed | prefixes remove: template].\r	prefixes add: template.\r	prefixes refresh.\r	^template\r)",
 "createNewMethodFromTemplate: template <DefinitionTemplate> = (\r	subject\r		compileSource: template text\r		ifSuccess:\r			[:newMethod <MethodMirror> |\r			|\r			newSubject <MethodSubject> = MethodSubject onModel: newMethod.\r			newPresenter <MethodPresenter> = createPresenterForSubject: newSubject.\r			|\r			prefixes remove: template.\r			content add: newPresenter.\r			newPresenter expand]\r		ifFailure:\r			[:message | template editor showMessage: message]\r)",
 "public deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (\r	subject deleteMethodWithSubject: presenter subject.\r	successResponse value\r)",
 "elementPresenterClass ^ <ProgrammingPresenter class> = (\r	^MethodPresenter\r)",
 "public class MethodGroupSubject onModel: m <MirrorGroup[MethodMirror]> within: dm <MixinMirror> = MirrorGroupSubject onModel: m within: dm  (\r(* Represents the collection of methods of a Newspeak class. Holds onto the mirror group for the methods. *)\r)",
 "onModel: m within: dm",
 "onModel: m within: dm",
 "public colorizeSource: source <String> editor: cm <CodeMirrorFragment> ^ <TextFragment> = (\r	^ide colorizer\r		colorizeMethod: source\r		fromClass: definingMixin declaration\r		via: (colorizingBlockFor: cm)\r)",
 "public compileSource: source <String> ifSuccess: successBlock <[:MethodMirror]> ifFailure: failureBlock <[:String]> = (\r	[ | builder <MixinBuilder> newBuilder <MethodBuilder> newMirror <MethodMirror> |\r	builder:: definingMixin asBuilder.\r	newBuilder:: builder methods addFromSource: source.\r	builder declaration install.\r	newMirror:: definingMixin methods findMirrorNamed: newBuilder name.\r	successBlock value: newMirror]\r		on: Error\r		do: [:ex <Exception> | failureBlock value: ex printString].\r)",
 "public createPresenter = (\r	^MethodGroupPresenter onSubject: self\r)",
 "public deleteMethodWithSubject: methodSubject <MethodSubject> = (\r	| builder <MixinBuilder> |\r	builder:: definingMixin asBuilder.\r	builder methods removeMirrorNamed: methodSubject selector.\r	builder declaration install.\r)",
 "elementSubjectClass ^ <MethodSubject class> = (\r	^MethodSubject\r)",
 "public methodTemplateText ^ <String> = (\r^\r'messageSelector = (\r)'\r)",
 "modelMirrorCollection ^ <Collection[MethodMirror]> = (\r	^super modelMirrorCollection (*asSortedList: [:a :b | a simpleName < b simpleName]*)\r)",
 "class MethodPresenter onSubject: s <MethodSubject> = ProgrammingPresenter onSubject: s (\r	(* A presenter for a single method. *)\r	|\r	public showClassName ::= false.\r	|\r)",
 "onSubject: s",
 "onSubject: s",
 "acceptResponse ^ <[:CodeMirrorFragment :Event]> = (\r	^[:ed <CodeMirrorFragment> :event <Event> |\r		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |\r		(*('ed text:', ed textBeingAccepted) out.*)\r		b methods addFromSource: ed textBeingAccepted.\r		b declaration install.\r		colorizeMethodSource: (crToLf: ed textBeingAccepted) withEditor: ed.\r		ed leaveEditState.\r		]\r)",
 "changeResponse ^ <[:CodeMirrorFragment :Event]> = (\r	^[:ed <CodeMirrorFragment> :event <Event> | | cp <Integer> |\r		colorizeMethodSource: (crToLf: ed textBeingAccepted) withEditor: ed.\r		ed enterEditState.\r	 ]\r)",
 "public collapse = (\r	^substance collapse\r)",
 "colorizeMethodSource: s <String> withEditor: cm <CodeMirrorFragment> = (\r	ide colorizer colorizeMethod: s fromClass: subject classDeclaration via: (colorizingBlockFor: cm)\r)",
 "public definition ^ <Fragment> = (\r	| toggle |\r	toggle::\r		collapsed: [row: {\r			image: (iconForAccessModifier: subject accessModifier).\r			blank: 3.\r			(link: subject name action: [toggle expand]) color: actionLinkColor.\r	        filler.\r	        dropDownMenu: [methodMenuFor: subject name]\r			}\r		]\r		expanded: [ |  src = crToLf: subject source. cm = codeMirror: src. |\r			cm changeResponse: changeResponse; acceptResponse: acceptResponse.\r			colorizeMethodSource: src withEditor: cm.\r			column: {\r			row: {\r			  image: (iconForAccessModifier: subject accessModifier).\r			  blank: 3.\r			  (link: subject name action: [toggle collapse]) color: actionLinkColor.\r	          filler.\r	          dropDownMenu: [methodMenuFor: subject name]\r			}.\r			cm\r		}].\r	^toggle\r)",
 "public expand = (\r	^substance expand\r)",
 "methodMenuFor: methodName <String> = (\r	^menuWithLabelsAndActions: {\r		{'Delete ', methodName. [subject delete.  refresh]}.\r		{'Inspect Presenter'. [respondToInspectPresenter]}\r	}\r)",
 "public class MethodSubject onModel: mm <MethodMirror> = Subject onModel: mm (\r(* Manages the UI for a method. *)\r)",
 "onModel: mm",
 "onModel: mm",
 "public accessModifier ^ <Symbol> = (\r	^methodMirror accessModifier\r)",
 "public classDeclaration ^ <ClassDeclarationMirror> = (\r	^methodMirror definingMixin declaration\r)",
 "public createPresenter ^ <Presenter> = (\r	^MethodPresenter onSubject: self\r)",
 "public delete = (\r	| b <MixinBuilder> = methodMirror definingMixin asBuilder. |\r	('Deleting ', name) out.\r	b methods removeMirrorNamed: methodMirror name.\r	b declaration install.\r)",
 "public methodMirror ^ <MethodMirror> = (\r	^model\r)",
 "public name ^ <Symbol> = (\r	^methodMirror name\r)",
 "public source ^ <String> = (\r	^methodMirror source\r)",
 "class MirrorGroupPresenter onSubject: s <Subject> = DefinitionListPresenter onSubject: s (\r)",
 "onSubject: s",
 "onSubject: s",
 "public addNewItemTemplate = (\r	(* A subclass must redefine this to show a template for the user to fill out to create a new item in the group. *)\r\r	subclassResponsibility\r)",
 "contentPresenters ^ <Collection[ProgrammingPresenter]> = (\r	^subject elements collect:\r		[:each <ProgrammingPresenter> | createPresenterForSubject: each]\r)",
 "createPresenterForSubject: aSubject <Subject> ^ <ProgrammingPresenter> = (\r	(* Let the subject create its default unless elementPresenterClass is set to specify our preference. *)\r	nil = elementPresenterClass ifTrue: [^aSubject presenter].\r	^elementPresenterClass onSubject: aSubject\r)",
 "elementPresenterClass ^ <ProgrammingPresenter class> = (\r	(* A subclass must redefine this to define the class of presenter it will be using. *)\r	subclassResponsibility\r)",
 "class MirrorGroupSubject onModel: m <MirrorGroup> within: dm <MixinMirror> = Subject onModel: m (\r	|\r	public definingMixin <MixinMirror> = dm.\r	|\r)",
 "onModel: m",
 "onModel: m",
 "elementSubjectClass = (\r	(* Answer the class of the subjects we create on individual elements of our subject group. *)\r	subclassResponsibility\r)",
 "public elements ^<Collection[Subject]> = (\r	(* Answer a collection of subjects on individual elements of the group which is our subject. *)\r	^modelMirrorCollection collect: [:each | elementSubjectClass onModel: each]\r)",
 "public mirrorGroup ^ <MirrorGroup> = (\r	^model\r)",
 "modelMirrorCollection ^<Collection[Mirror]> = (\r	^List withAll: model\r)",
 "class NamespacePresenter onSubject: s = DefinitionListPresenter onSubject: s (\r)",
 "onSubject: s",
 "onSubject: s",
 "acceptNewClassDefinitionFrom: aTemplate = (\r	subject\r		addClassFromDefinition: aTemplate text\r		ifSuccess:\r			[prefixes remove: aTemplate.\r			 content setPresenters: contentPresenters]\r		ifFailure:\r			[:msg | aTemplate editor showMessage: msg]\r)",
 "acceptNewNamespaceDefinitionFrom: aTemplate = (\r	subject\r		addNamespaceFromDefinition: aTemplate text\r		ifSuccess:\r			[prefixes remove: aTemplate.\r			 content setPresenters: contentPresenters]\r		ifFailure:\r			[:msg | aTemplate editor text: msg]\r)",
 "addCategoryMenu = (\r	^ {\r		{'Add Class'. [addClassTemplate]}.\r		{ 'Add Namespace'. [addNamespaceTemplate]}.\r		(*{'Add Image From File'. [respondToAddImage].}.\r		{'Add Text From File'. [respondToAddText]}.\r		 'Add Value' -> [Error signal: 'Unimplemented']. *)\r	}\r)",
 "addClassTemplate = (\r	prefixes add:\r		(DefinitionTemplate\r			caption: 'Defining a new class:'\r			initialText: subject classTemplateText\r			colorizerBlock:\r				[:text <String> :cm <CodeMIrrorFragment> | subject colorizeClassSource: text editor: cm]\r			acceptResponse:\r				[:template | acceptNewClassDefinitionFrom: template]\r			cancelResponse:\r				[:template | prefixes remove: template]).\r	prefixes refresh.\r)",
 "addNamespaceTemplate = (\r	prefixes add:\r		(DefinitionTemplate\r			caption: 'Defining a new namespace:'\r			initialText: 'NewNamespace'\r			colorizerBlock:\r				[:text <String> :cm <CodeMIrrorFragment> | ]\r			acceptResponse:\r				[:template | acceptNewNamespaceDefinitionFrom: template]\r			cancelResponse:\r				[:template | prefixes remove: template]).\r	prefixes refresh.\r)",
 "contentList ^ <PresenterList> = (\r	^zebra: super contentList\r)",
 "contentPresenters ^ <List[Presenter]> = (\r	| lexicalOrder <[:Symbol :Symbol | Boolean]> |\r	lexicalOrder:: [:a <Symbol> :b <Symbol> |\r		lexicallyLessOrEqual: a than: b\r	].\r	^(subject namespace keys asArray sort: lexicalOrder) collect: [:key | presenterForEntryAt: key]\r)",
 "definition ^ <Fragment> = (\r	^column: {\r		minorHeadingBlock: (row: {\r			label: subject key (*asText allBold*).\r			largeBlank.\r			(*subject namespace isKindOfCategoryNamespace\r				ifTrue: [*)addButtonWithMenu: [addCategoryMenu](*]\r				ifFalse: [addButtonWithAction: [respondToAddForRoot]]*).\r			filler.\r			expandButtonWithAction: [expandAll].\r			blank: 3.\r			collapseButtonWithAction: [collapseAll].\r			blank: 3.\r			dropDownMenu: [namespaceMenu].\r			largeBlank.\r			homeButton.\r			smallBlank.\r			refreshButton.\r		}).\r		smallBlank.\r		super definition.\r	}\r)",
 "entryActionsMenuFor: key = (\r	^menuWithLabelsAndActions: {\r		{'Remove ', key. [ide namespacing removeKey: key.  refresh]}.\r	}\r)",
 "lexicallyLessOrEqual: a <String> than: b <String> ^ <Boolean> = (\r	(* BOGUS: This should be a utility somewhere *)\r	| length = a size min: b size. |\r	('a' at: 1) isKindOfInteger ifTrue: \r		[1 to: length do:\r			[:index |\r			 (a at: index) < (b at: index) ifTrue: [^true].\r			 (a at: index) > (b at: index) ifTrue: [^false]].\r		^true].\r\r	1 to: length do:\r		[:index |\r		 (a runeAt: index) < (b runeAt: index) ifTrue: [^true].\r		 (a runeAt: index) > (b runeAt: index) ifTrue: [^false]].\r	^true\r)",
 "namespaceMenu = (\r	^menuWithLabelsAndActions: {\r		{'Inspect Presenter' . [respondToInspectPresenter]}\r	}\r)",
 "presenterForEntryAt: key <Symbol> ^ <EntryPresenter> = (\r	| entry = subject namespace at: key. |\r	entry isKindOfBehavior\r		ifTrue: [^ClassEntryPresenter onSubject: (ClassSubject onModel: (ClassMirror reflecting: entry) mixin declaration)].\r\r	entry isKindOfNamespace\r		ifTrue: [^NamespaceEntryPresenter onSubject: (NamespaceSubject onModel: entry key: key)].\r\r	^(ValueEntryPresenter onSubject: (objectSubjectFor: entry)) key: key\r)",
 "respondToAddForRoot = (\r	openMenuWithLabelsAndActions: {\r		{'Add Namespace'. [addNamespaceTemplate]}.\r	}\r)",
 "respondToAddImage = (\r	| fileRequester |\r	fileRequester:: request File new.\r	fileRequester allowedFileTypes: {'Image files (*.png)' ->'*.png'}.\r	fileRequester initialDirectory: (FileDirectory default fullName).\r	fileRequester openModal ifNotNil: [:fn |\r		| key form |\r		key:: (FileDirectory on: fn) localName allButLast: 4.\r		key:: key select: [:letter | letter isAlphaNumeric].\r		form:: PNGReadWriter formFromFileNamed: fn.\r		subject namespace at: key asSymbol put: form.\r	].\r)",
 "respondToAddText = (\r	| fileRequester |\r	fileRequester:: request File new.\r	fileRequester allowedFileTypes: {'Text files (*.txt)' ->'*.txt'}.\r	fileRequester initialDirectory: (FileDirectory default fullName).\r	fileRequester openModal ifNotNil: [:fn |\r		| key text |\r		key:: (FileDirectory on: fn) localName allButLast: 4.\r		key:: key select: [:letter | letter isAlphaNumeric].\r		text:: ((MultiByteFileStream oldFileNamed: fn)\r			converter: (TextConverter newForEncoding: 'utf8')) contents.\r		subject namespace at: key asSymbol put: text.\r	].\r)",
 "class ClassEntryPresenter onSubject: s <ClassSubject> = outer SimpleBrowsing ClassEntryPresenter onSubject: s ()",
 "onSubject: s",
 "onSubject: s",
 "accessIndicator = (\r	^nothing\r)",
 "entryActionsMenu = (\r	^dropDownMenu: [entryActionsMenuFor: subject name].\r)",
 "class NamespaceEntryPresenter onSubject: s = EntryPresenter onSubject: s ()",
 "onSubject: s",
 "onSubject: s",
 "collapsedDefinition = (\r	^row1: {\r		image: ide images classPresenterIcon.\r		smallBlank.\r		row: {link: subject key action: [\r			(*ide defaultPopularityRecord\r			rememberNamespaceVisit: subject key. (* Should be the namespace itself, but non-strings break the home page. *)*)\r			enterSubject:: subject refreshmentSubject]}.\r	} row2: {\r		(label: subject summaryText)\r				smallFont;\r				compressibility: 1;\r				color: secondaryTextColor.\r		filler\r			compressibility: 0.\r		mediumBlank.\r		dropDownMenu: [entryActionsMenuFor: subject key]\r	}.\r)",
 "expandedDefinition = (\r	^subject presenter\r)",
 "class ValueEntryPresenter onSubject: s = EntryPresenter onSubject: s (|\r	public key\r|)",
 "onSubject: s",
 "onSubject: s",
 "collapsedDefinition = (\r	^row1: {\r		image: ide images classUnknownIcon.\r		smallBlank.\r		link: key action: [enterSubject:: subject].\r	} row2: {\r		(label: subject title)\r			smallFont;\r			compressibility: 1;\r			color: secondaryTextColor.\r		filler\r			compressibility: 0.\r		mediumBlank.\r		dropDownMenu: [entryActionsMenuFor: key]\r	}\r)",
 "definition = (\r	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)\r	^collapsed: [collapsedDefinition]\r	expanded: [subject presenter selfCaption: key]\r)",
 "expandedDefinition = (\r	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)\r	^subject presenter selfCaption: key\r)",
 "public class NamespaceSubject onModel: m <Map[Symbol, Object]> key: k <Symbol> = Subject onModel: m (|\r	public key = k.\r|ide namespacing refreshCategoryNamespaces)",
 "onModel: m",
 "onModel: m",
 "public = other ^<Boolean> = (\r	^class = other class (* class is not public *)\r		and: [namespace = other namespace]\r		and: [key = other key].\r)",
 "public addClassFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (\r	| builder <ClassDeclarationBuilder> klass |\r	[builder:: ClassDeclarationBuilder fromSource: definition]\r		on: Error\r		do: [:ex | ^failureBlock value: ex printString].\r	(namespace includesKey: builder name) ifTrue:\r		[^failureBlock value: 'A class named ', builder name, ' already exists in this namespace'].\r	klass:: builder install applyToObject.\r	namespace at: klass mixin name put: klass reflectee.\r	successBlock value\r)",
 "public addNamespaceFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (\r	| selector <Symbol> = definition asSymbol. |\r	(*model = ide namespacing Categories ifFalse: (* ? *)\r		[Error signal: 'Not supported yet, only categories for now.'].*)\r\r	(*selector isUnary ifFalse:\r		[^failureBlock value: 'Must be a unary selector'].*)\r	(namespace includesKey: selector) ifTrue:\r		[^failureBlock value: 'A class named ', definition, ' already exists in this namespace'].\r	(* ide namespacing categoryNamespace: selector.*)\r	namespace at: selector put: (ide namespacing freshNamespace).\r	successBlock value\r)",
 "public classTemplateText ^ <String> = (\r^\r'class ClassNameHere = (\r	|\r	slot1\r	slot2\r	|\r) ()'\r)",
 "public colorizeClassSource: source <String> editor: cm <CodeMirrorFragment>  = (\r	^ide colorizer\r		colorizeClassDeclaration: source\r		fromClass: nil\r		via: (colorizingBlockFor: cm)\r)",
 "public createPresenter ^ <NamespacePresenter> = (\r	^NamespacePresenter onSubject: self\r)",
 "public hash ^<Integer> = (\r	^model hash bitXor: key hash\r)",
 "public namespace ^ <Map[Symbol, Object]> = (\r	^self model\r)",
 "public refreshmentSubject = (\r	^self class onModel: model key: key\r)",
 "public summaryText = (\r	| sb = StringBuilder new. |\r	namespace keys\r		do: [:k | sb add: k]\r		separatedBy: [sb add: ', '].\r	^sb asString\r)",
 "public title ^<String> = (\r	^key\r)",
 "public new = (\r	#NAMESPACEBOGUS.\r	^self onModel: ide namespacing Root key: 'Root'\r)",
 "class NestedClassGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (\r(* Presents the subject, a NestedClassGroupSubject, as a column of presenters for the nested classes in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS nested classes goes here. *)\r)",
 "onSubject: s",
 "onSubject: s",
 "acceptNewClassDefinitionFrom: aTemplate = (\r	subject\r		addClassFromDefinition: aTemplate text\r		ifSuccess:\r			[:newClass <ClassDeclarationMirror> |\r			|\r			newSubject <ClassSubject> = ClassSubject onModel: newClass.\r			newPresenter <ClassEntryPresenter> = createPresenterForSubject: newSubject.\r			|\r			prefixes remove: aTemplate.\r			content add: newPresenter.\r			newPresenter expand]\r		ifFailure:\r			[:msg | aTemplate editor showMessage: msg]\r)",
 "public addNewItemTemplate = (\r	(* Handle a user's request to create a new nested class by displaying a new class template. *)\r	prefixes add:\r		(DefinitionTemplate\r			caption: 'Defining a new class:'\r			initialText: subject classTemplateText\r			colorizerBlock:\r				[:text <String> :cm <CodeMIrrorFragment> | subject colorizeClassSource: text editor: cm]\r			acceptResponse:\r				[:template | acceptNewClassDefinitionFrom: template]\r			cancelResponse:\r				[:template | prefixes remove: template]).\r	prefixes refresh.\r)",
 "public deleteClassInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (\r	subject deleteClassWithSubject: presenter subject.\r	successResponse value\r)",
 "elementPresenterClass ^ <ProgrammingPresenter class> = (\r	^ClassEntryPresenter\r)",
 "public class NestedClassGroupSubject onModel: m <MirrorGroup[ClassDeclarationMirror]> within: dm <MixinMirror> = MirrorGroupSubject onModel: m within: dm  (\r(* Represents the collection of nested classes of a Newspeak class. Holds onto the mirror group for the classes. *)\r)",
 "onModel: m within: dm",
 "onModel: m within: dm",
 "public addClassFromDefinition: source <String> ifSuccess: successBlock <[:ClassDeclarationMirror]> ifFailure: failureBlock <[:String]> = (\r	[ | builder <MixinBuilder> newBuilder <ClassDeclarationBuilder> newMirror <ClassDeclarationMirror> |\r	builder:: definingMixin asBuilder.\r	newBuilder:: builder nestedClasses addFromSource: source.\r	builder declaration install.\r	newMirror:: definingMixin nestedClasses findMirrorNamed: newBuilder name.\r	successBlock value: newMirror]\r		on: Error\r		do: [:ex <Exception> | failureBlock value: ex printString].\r)",
 "public classTemplateText ^ <String> = (\r^\r'class ClassNameHere = (\r	|\r	slot1\r	slot2\r	|\r) ()'\r)",
 "public colorizeClassSource: source <String> editor: cm <CodeMirrorFragment> = (\r	^ide colorizer\r		colorizeClassDeclaration: source\r		fromClass: definingMixin declaration\r		via: (colorizingBlockFor: cm)\r)",
 "public createPresenter = (\r	^NestedClassGroupPresenter onSubject: self\r)",
 "public deleteClassWithSubject: classSubject <ClassSubject> = (\r	| builder <MixinBuilder> |\r	builder:: definingMixin asBuilder.\r	builder nestedClasses removeMirrorNamed: classSubject name.\r	builder declaration install.\r)",
 "elementSubjectClass ^ <ClassSubject class> = (\r	^ClassSubject\r)",
 "class ObjectPresenter onSubject: s = ProgrammingPresenter onSubject: s (\r	|\r	public selfCaption ::= 'self'.\r	|\r)",
 "onSubject: s",
 "onSubject: s",
 "actionsMenu = (\r	^menuWithLabelsAndActions: {\r		{'Inspect Mirror'. [respondToInspectMirror]}.\r		{'Inspect Presenter'. [respondToInspectPresenter]}.\r	}\r)",
 "captionBar: body = (\r	^(padded: body with: {5. 5. 5. 5}) color: captionColor\r)",
 "classInfoLine = (\r	^row: {\r		(label: 'class')\r			width: 0 elasticity: 1.\r		(link: subject className action: [navigateToClass])\r			width: 0 elasticity: detailAreaRatio.\r	}\r)",
 "public definition = (\r	^column: {\r		captionBar: (column: {\r			selfInfoLine.\r			enclosingInfoLine.\r			classInfoLine.\r			smallBlank.\r			EvaluationPresenter onSubject: subject.\r		}).\r		objectDetails.\r	}\r)",
 "enclosingInfoLine = (\r	^row: {\r		(label: 'enclosingObject')\r			width: 0 elasticity: 1.\r		(link: subject enclosingObjectName action: [navigateToEnclosingObject])\r			width: 0 elasticity: detailAreaRatio.\r	}\r)",
 "navigateToClass = (\r	enterSubject: subject classSubject.\r)",
 "navigateToEnclosingObject = (\r	inspectObjectMirror: subject classMirror enclosingObject\r)",
 "navigateToSelf = (\r	enterSubject: (ObjectSubject onModel: subject objectMirror)\r)",
 "objectDetails = (\r	^column:\r		(subject slots collect:\r			[:slot <SlotSubject> | slot presenter])\r)",
 "respondToInspectMirror = (\r	inspectObject: subject objectMirror.\r)",
 "selfInfoLine = (\r	^row: {\r		(label: selfCaption (*asText allBold*)) width: 0 elasticity: 1.\r		(row: {\r			(link: subject title action: [navigateToSelf]) compressibility: 1.\r			filler compressibility: 0.\r			mediumBlank.\r			dropDownMenu: [actionsMenu].\r			mediumBlank.\r			homeButton.\r		}) width: 0 elasticity: detailAreaRatio.\r	}\r)",
 "public title = (\r	^'Inspector on ', subject title\r)",
 "public class ObjectSubject onModel: m = Subject onModel: m (\r)",
 "onModel: m",
 "onModel: m",
 "public classMirror ^<ClassMirror> = (\r	^model getClass\r)",
 "public className ^<String> = (\r	^classMirror mixin name\r)",
 "public classSubject = (\r	^ClassSubject onModel: classMirror mixin declaration\r)",
 "public createPresenter = (\r	^ObjectPresenter onSubject: self\r)",
 "public enclosingObjectName = (\r	^classMirror enclosingObject reflectee printString\r)",
 "public evaluate: expression <String> ^<ThreadMirror> = (\r	^objectMirror evaluate: expression\r)",
 "public objectMirror ^<ObjectMIrror> = (\r	^model\r)",
 "public slots = (\r	(* Arrays have slots that aren't defined by their class. *)\r	classMirror = (ClassMirror reflecting: Array) ifTrue:\r		[ |\r		array = objectMirror reflectee.\r		variableLengthSlots = Array new: array size.\r		|\r		1 to: array size do:\r			[:index | variableLengthSlots\r				at: index\r				put: (SlotSubject\r					name: 'at: ', index asString\r					value: (ObjectMirror reflecting: (array at: index)))].\r		^variableLengthSlots].\r\r	^classMirror slots collect:\r		[:slot <SlotDeclarationMirror> |\r		 | val <ObjectMirror> = objectMirror getSlot: slot name. |\r		 SlotSubject name: slot name value: val]\r)",
 "public title = (\r	^objectMirror reflectee printString\r)",
 "public class ProgrammingPresenter onSubject: s <Subject> = Presenter onSubject: s (\r(* Common superclass for presenters of programming constructs. *)\r)",
 "onSubject: s",
 "onSubject: s",
 "actionLinkColor = (\r	^Color black\r)",
 "addButtonWithAction: aBlock = (\r	^imageButton:\r		{ide images addImage.\r		ide images addOverImage.\r		ide images addOutImage}\r	action: aBlock\r)",
 "addButtonWithMenu: menu = (\r	^dropDownMenu: menu\r		images: {\r		   ide images addImage.\r		   ide images addOverImage.\r		   ide images addOutImage\r		}\r)",
 "browseClass: klass <Behavior> = (\r	enterSubject:: ClassSubject onModel: (ClassMirror reflecting: klass) mixin declaration.\r)",
 "browseMixinMirror: mixin <MixinMirror> = (\r	enterSubject:: ClassSubject onModel: mixin declaration.\r)",
 "collapseButtonWithAction: aBlock = (\r	^imageButton:\r		{ide images collapseImage.\r		 ide images collapseOverImage.\r		 ide images collapseDownImage}\r	action: aBlock\r)",
 "expandButtonWithAction: aBlock = (\r	^imageButton:\r		{ide images expandImage.\r		 ide images expandOverImage.\r		 ide images expandDownImage}\r	action: aBlock\r)",
 "homeButton = (\r	^imageButton: {\r		ide images homeImage.\r		ide images homeOutImage.\r		ide images homeOverImage.\r		ide images homeDownImage\r		}\r		action: [enterSubject: HomeSubject new].\r)",
 "iconForAccessModifier: am = (\r	#private = am ifTrue: [^ide images privateAccessImage].\r	#protected = am ifTrue: [^ide images protectedAccessImage].\r	^ide images publicAccessImage\r)",
 "indentedBlock: body = (\r	^column: {\r		mediumBlank.\r		row: {\r			mediumBlank.\r			elastic: body\r			}.\r		mediumBlank\r		}\r)",
 "inspectObject: object <Object> = (\r	enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: object).\r)",
 "inspectObjectMirror: object <ObjectMirror> = (\r	enterSubject:: ObjectSubject onModel: object.\r)",
 "largeBlank = (\r	^blank: 20\r)",
 "majorHeadingBlock: body = (\r	^(padded: body with: {10. 10. 10. 10.})\r		color: majorHeadingColor\r)",
 "majorHeadingColor = (\r	(* This color is used for major definitions such as class headings. *)\r	^Gradient\r		from: (Color h: 240 s: 0.05 v: 0.92)\r		to: (Color h: 240 s: 0.05 v: 0.86)\r)",
 "minorHeadingBlock: body = (\r	^(padded: body with: {10. 5. 10. 5.})\r		color: minorHeadingColor\r)",
 "minorHeadingColor = (\r^Gradient\r	from: (Color h: 240 s: 0.02 v: 0.94)\r	to: (Color h: 240 s: 0.02 v: 0.9)\r)",
 "public objectSubjectFor: anObject = (\r	^objectSubjectForMirror: (ObjectMirror reflecting: anObject)\r)",
 "objectSubjectForMirror: objectMirror <ObjectMirror> = (\r	^ObjectSubject onModel: objectMirror\r)",
 "refreshButton = (\r	^imageButton: {\r		ide images refreshImage.\r		ide images refreshOutImage.\r		ide images refreshOverImage.\r		ide images refreshDownImage\r		}\r		action: [shell refresh].\r)",
 "respondToInspectPresenter = (\r	inspectObject: self.\r)",
 "secondaryTextColor ^ <Color> = (\r	^Color gray: 0.6\r)",
 "smallBlank = (\r	^blank: 5\r)",
 "tertiaryTextColor = (\r	^Color gray: 0.8\r)",
 "class SlotPresenter onSubject: s <SlotSubject> = ProgrammingPresenter onSubject: s (\r)",
 "onSubject: s",
 "onSubject: s",
 "caption ^<Fragment> = (\r	^row: {\r		(link: subject name action: [substance toggle])\r			width: 0 elasticity: 1;\r			color: actionLinkColor.\r		smallBlank.\r		(link: subject reflecteePrintString action: [inspectObjectMirror: subject objectMirror])\r			width: 0 elasticity: detailAreaRatio.\r	}\r)",
 "public definition ^<Fragment> = (\r	^collapsed: [caption] expanded: [details]\r)",
 "details ^<Fragment> = (\r	^(objectSubjectForMirror: subject objectMirror) presenter selfCaption: subject name\r)",
 "public class SlotSubject name: n value: v = Subject onModel: v (\r	|\r	public name = n.\r	|\r)",
 "onModel: v",
 "onModel: v",
 "public createPresenter = (\r	^SlotPresenter onSubject: self\r)",
 "public objectMirror ^<ObjectMirror> = (\r	^model\r)",
 "public reflecteePrintString = (\r	^model reflectee printString\r)",
 "class CombinatorialParsing usingPlatform: platform = (\r(* The Newspeak parser combinator library.\r\rCopyright 2008 Cadence Design Systems, Inc.\rCopyright 2012 Cadence Design Systems, Inc.\rCopyright 2013 Ryan Macnak\r\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)\r|\r\rprivate List = platform collections List.\rprivate Map = platform collections Map.\rprivate ObjectMirror = platform mirrors ObjectMirror.\r|)",
 " ",
 " ",
 "class AlternatingParser either: p_ or: q_ = CombinatorialParser (\r(* A parser that parses either P or Q. *)\r|\rp <CombinatorialParser> = p_.\rq <CombinatorialParser> = q_.\r|)",
 "CombinatorialParser",
 "CombinatorialParser",
 "combineErrors: e1 <String> and: e2 <String> at: pos <Integer> with: blk <[:String :Integer]> = (\r	| or <String> msg <String> |\r	or:: (e1 = '' or: [e2 = '']) ifTrue: [''] ifFalse: [' or '].\r	msg:: e1 = e2 ifTrue: [e1] ifFalse: [e1, or , e2].\r	^blk value: msg value: pos\r)",
 "public parse: input <ReadStream> inContext: context <ParserContext> ifError: blk <[:String :Integer]> = (\r	| rewindPosition |\r	rewindPosition:: input position.\r  	^p parse: input inContext: context ifError:\r		[:msg1 :pos1 |\r		input position: rewindPosition.\r		context recordFailure: {msg1. pos1}.\r		^q parse: input inContext: context ifError:\r			[:msg2 :pos2 |\r			context recordFailure: {msg2. pos2}.\r			pos1 > pos2 ifTrue: [^blk value: msg1 value: pos1].\r			pos2 > pos1 ifTrue: [^blk value: msg2 value: pos2].\r			^combineErrors: msg1 and: msg2 at: pos1 with: blk]]\r)",
 "class CharacterRangeParser from: startChar <Character> to: endChar <Character> = CombinatorialParser (|\rstartRune <Integer> = startChar runeAt: 1.\rendRune <Integer> = endChar runeAt: 1.\rmessage <String> = startChar asString, '-', endChar asString, ' expected'.\r|)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	| rune |\r	input atEnd ifTrue: [^blk value: message value: input position].\r	rune:: input next.\r	rune < startRune ifTrue: [^blk value: message value: input position].\r	rune > endRune ifTrue: [^blk value: message value: input position].\r	^rune\r)",
 "public class CollectingCommentParser = CommentParser (\r(* A special parser used for inputs that need to be rapidly scanned over. It differs from its superclass in that it actually collects the characters it scans, in case they are needed (e.g., for pretty printers).\r\rIdeally,we should not have to do this, but until we do proper optimization by compiling combinators, this will have to suffice. It provides a marked improvement in performance, By using such parsers for comments, whitespace and strings, the overall performance of the Newqueak parser improved by a factor of 2 or so. *)\r)",
 "CommentParser",
 "CommentParser",
 "public parse: input inContext: context ifError: blk = (\r	| comment char onFail |\r	onFail:: [blk value: 'Premature end of input' value: input position - 1].\r	comment: List new.\r	[termBlock value: input] whileFalse:\r		[input atEnd ifTrue: [^onFail].\r		comment add: input next].\r	^comment\r)",
 "public class CombinatorialParser = (\r(* This class is intended to implement Parser\rCombinators. A CombinatorialParser[T]\rreturns a value of type T after successful\rparsing.\r\rThe class is abstract. It does not implement\r the parsing routine parse:ifError:.\r\rIf parsing fails, parse:ifError: should call the error handling block\rpassed to it.\r\rConcrete subclasses should implement specific grammars.\r\rParsing is initiated by calling parse:ifError:. This routine takes a ReadStream[Object] as input.\rIf parsing fails, it is the caller''s responsibility to set the input stream back to its original position\r(Q: is this a good idea?).\rIf an error occurs, the error block passed in is called. *)\r| public name |)",
 " ",
 " ",
 "public & p <CombinatorialParser> ^<SequentialParser> = (\r	(* The sequencing combinator (implicit in BNF). *)\r	^SequentialParser withSubparsers: {self. p}\r)",
 "public , p <CombinatorialParser> ^<SequentialParser> = (\r	(* The flattening sequencing combinator. *)\r\r(* This is what one should typically use in a grammar.\r It differs from '&' in its specification.  '&' is not intended to\rflatten the resulting parser tree, while ',' is; this achieved by overriding ',' in SequentialParser to do the flattening.\r\rWhy would one want to flatten the tree? Because, given a production\r\rFoo -> Bam Ban Bar Bat\r\rone doesn't want to build the AST by writing\r\rFoo:: Bam & Ban & Bar & Bat\r   wrapper: [:start :end |\r	            FooNode b1:start first b2: (start at: 2)  b3: (start at: 3) b4: end\r	]\r\rIt is much more convenient to flatten the tree and have a flat list of the correct arity.\r*)\r	^self & p\r)",
 "char: c <Character> ^<CombinatorialParser> = (\r	^CharacterRangeParser from: c to: c\r)",
 "charBetween: c1 <Character> and: c2 <Character> ^<CombinatorialParser> = (\r	^CharacterRangeParser from: c1 to: c2\r)",
 "empty ^<CombinatorialParser> = (\r	^EmptyParser new\r)",
 "eoi ^<CombinatorialParser> = (\r	^tokenFor: EOIParser new\r)",
 "fail ^<CombinatorialParser> = (\r	^FailingParser new\r)",
 "public isKindOfCombinatorialParser = (\r	(* should be auto-generated *)\r	^true\r)",
 "public not ^<CombinatorialParser> = (\r	^NegatingParser withSubparser: self\r)",
 "public opt ^ <CombinatorialParser> = (\r	(* [P] = P | e *)\r	^self | empty\r)",
 "public packratParse: input <ReadStream> ^ <T | ParserError> = (\r ^self parse: (PackratParserStream memoizing: input) \r)",
 "public parse: input <ReadStream> ^ <T | ParserError> = (\r	^self\r		parse: input\r		ifErrorNoContext: [:msg :pos | ^(ParserError message: msg position: pos) signal]\r)",
 "public parse: input <ReadStream> ifError: blk <[:String :Integer | X def]> ^ <T|X> = (\r	#FLAG.\r	^self parse: input ifErrorNoContext: blk\r(* | context |\r\r  context:: ParserContext new.\r	^parse: input\r	inContext: context\r	ifError: [:msg :pos |\r	               context errorPosition = pos\r	                  ifTrue: [\r		                      context recordFailure: ( combineErrors: context errorMessage\r		                                                                 and: msg\r		                                                                 at: pos\r		                                                          )\r		            ]\r	                  ifFalse: [context recordFailure:{msg. pos.}].\r	               blk value: context errorMessage value: context errorPosition.\r	  ] *)\r)",
 "public parse: input <ReadStream> ifErrorNoContext: blk <[:String :Integer | X def]> ^ <T|X> = (\r	(* YK - a context-less protocol for speeding up parsing *)\r	(* Turns out maintaining a context is expensive in runtime and doesn't\r	do much for locating errors. Experimenting with other error localization\r	mechanism. To minimize impact, the parse:inContext:ifError: protocol\r	is maintained, and a bogus reportFailure is implemented on self *)\r	^self parse: input inContext: self ifError: blk\r)",
 "public parse: input <ReadStream> inContext: context ifError: blk = (\r	subclassResponsibility\r)",
 "public parseString: input <String> ^ <T | ParserError> = (\r	^self parse: (ParserStream over: input)\r)",
 "public parseString: input <String> ifError: blk <[:String :Integer | X def]> ^ <T|X> = (\r	^self parse: (ParserStream over: input) ifError: blk\r)",
 "public plus ^<CombinatorialParser> = (\r	(* Return a parser that accepts one or more repetitions of what the receiver accepts. Denoted by the postfix + in BNF *)\r	^PlusParser withSubparser: self.\r)",
 "public plusSeparatedBy: separator <CombinatorialParser> ^<CombinatorialParser> = (\r(* Utility for the common case of a list with separators. The separators are discarded, as they are usually only used to guide parsing and\rhave no semantic value.  If one needs them, one can always build the rule directly *)\r\r^self & (separator value & self wrapper: [:s :v | v]) star\r	wrapper: [:fst :rst |\r	                 | results |\r	                    List new  addFirst: fst; addAll: rst; yourself (* could be optimized to reuse rst *)\r	       ]\r)",
 "public plusSeparatedOrTerminatedBy: separator <CombinatorialParser> ^ <CombinatorialParser> = (\r(* Utility for the common case of a list with separators, allowing for an optional appearance of the separator at the end. The separators are discarded, as they are usually only used to guide parsing and\rhave no semantic value.  If one needs them, one can always build the rule directly *)\r\r^( plusSeparatedBy: separator), separator value opt\r	wrapper: [:lst :end | lst]\r)",
 "public printOn: stream = (\r	name isNil\r		ifTrue: [super printOn: stream]\r		ifFalse: [stream nextPutAll: name]\r)",
 "public recordFailure: f = (\r	(* YK- do nothing, save time *)\r)",
 "public star ^<CombinatorialParser> = (\r	(* Return a parser that accepts zero or more repetitions of what the receiver accepts. Denoted by the postfix * in BNF *)\r	(* P* = [P+] *)\r	(* We tweak the classic formulation by wrapping it in a parser that takes care to avoid returning nil. In the ordinary case, if the input is empty, the empty parser will return nil as the result. However, we'd rather not  have to check for nil every time we get a result from a starred production; it is verbose and error prone. In the case of star, it is better to return an empty list for empty input. *)\r	^StarParser withSubparser: self.\r)",
 "public starSeparatedBy: separator <CombinatorialParser> ^<CombinatorialParser> = (\r	(* See analogous plus methods. Must wrap to prevent returning nil in empty case *)\r	^(plusSeparatedBy: separator) opt\r		wrap: [:rs | rs isNil ifTrue: [List new] ifFalse: [rs]]\r)",
 "public starSeparatedOrTerminatedBy: separator <CombinatorialParser> ^<CombinatorialParser> = (\r 	(* See analogous plus methods. Must wrap to prevent returning nil in empty case *)\r	^(plusSeparatedOrTerminatedBy: separator) opt\r		wrap: [:rs | rs isNil ifTrue: [List new] ifFalse: [rs]]\r)",
 "public ultimateParser = (\r	(* Used to bypass 0 .. n ForwardReferenceParsers to get to the real parser. Usually, this is self. Only ForwardReferenceParsers forward the request to their forwardee. *)\r	^self\r)",
 "public value = (\r	^self\r)",
 "public wrap: blk = (\r	^WrappingParser new wrapParser: self withWrapper: blk\r)",
 "public wrap: blk name: msg = (\r	^(NamedWrappingParser new wrapParser: self withWrapper: blk) name: msg\r)",
 "public wrapper: blk = (\r	^wrap: [:result | blk valueWithArguments: result asArray]\r)",
 "public wrapper: blk name: msg = (\r	^wrap: [:result | blk valueWithArguments: result asArray]\r	name: msg\r)",
 "public | p <CombinatorialParser> ^<CombinatorialParser> = (\r	(* The alternation combinator - denoted by | in BNF *)\r	^AlternatingParser either: self or: p\r)",
 "public class CommentParser = CombinatorialParser (|\r	public termBlock\r|)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	[termBlock value: input] whileFalse: [\r		input nextIfAbsent: [blk value: 'Premature end of input' value: input position-1]\r	].\r)",
 "class EOIParser = CombinatorialParser (\r(* A parser that only succeeds at the end of the input. This addresses a common problem with combinator parsers. If there is garbage at the end of the input, no production matches it. Consequently, the parsers backtrack to the point where the legal input was consumed, without giving an error message about the junk at the end. *)\r)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	input atEnd\r		ifTrue: [^true]\r		ifFalse: [blk value: 'Unexpected input' value: input position+1]\r)",
 "class EmptyParser = CombinatorialParser (\r(* The parser that parses the empty input. It always succeeds. *)\r)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	^nil\r)",
 "public class ExecutableGrammar = CombinatorialParser (\r(* This class is intended to implement Parser\rCombinators. A ExecutableGrammar[T]\rreturns a value of type T after successful\rparsing.\r\rThe class is abstract. It does not implement\r the parsing routine parse:ifError:.\r\rIf parsing fails, parse:ifError: should call the error handling block\rpassed to it.\r\rConcrete subclasses should implement specific grammars.\r\rParsing is initiated by calling parse:ifError:. This routine takes a ReadStream[Object] as input.\rIf parsing fails, it is the caller''s responsibility to set the input stream back to its original position\r(Q: is this a good idea?).\rIf an error occurs, the error block passed in is called. *)\r|\r	forwardReferenceTable ::= Map new.\r	protected selfMirror <ObjectMirror> = ObjectMirror reflecting: self.\r|self setupForwardReferences.\r  self bindForwardReferences)",
 "CombinatorialParser",
 "CombinatorialParser",
 "bindForwardReferences = (\r	forwardReferenceTable keysAndValuesDo:\r		[:k :v | v bindingRoutine: [finalBindForwardReferences]].\r)",
 "comment ^<CombinatorialParser> = (\r	^fail\r)",
 "finalBindForwardReferences = (\r	forwardReferenceTable keysAndValuesDo:\r		[:k :v | | p |\r		p:: (selfMirror getSlot: k asSymbol) reflectee.\r		(p isKindOfCombinatorialParser) ifTrue: [\r			v bind: p.\r			p name: k (* a good place to name the productions *)]]\r)",
 "public nameProductions = (\r	selfMirror getClass slots do:\r		[:slot <SlotMirror> |\r		| parser |\r		parser:: (selfMirror getSlot: slot simpleName) reflectee.\r		parser isKindOfCombinatorialParser ifTrue: [parser name: slot name]].\r)",
 "setupForwardReferences = (\r	(* Go through all non-nil instance variables and set them to a fresh forward reference. If these do not correspond to productions, they will be overridden by the subclass. *)\r	selfMirror getClass slots do:\r		[:slot <SlotMirror> |\r		| fref iv |\r		iv:: slot name.\r		fref:: ForwardReferenceParser new.\r		(selfMirror getSlot: iv) reflectee isNil ifTrue:\r			[forwardReferenceTable at: iv put: fref.\r			selfMirror setSlot: iv to: fref]]\r)",
 "tokenFor: p <CombinatorialParser> ^ <CombinatorialParser> = (\r(* Tokenizing involves throwing away leading whitespace and comments.\rIn addition, it involves associating the token with a starting position within the input stream;\rWe do the latter first by wrapping p in a TokenizingParser; then we prefix it with a parser\rthat deals with whitespace and comments, and return the result. *)\r\r^(whitespace | comment) star, (TokenizingParser withSubparser: p)\r	wrapper: [:discardWhitespace :t | t].\r\r	(* type safety note: wrapper is only defined on SequentialParser. The call is always\r	 statically unsafe but checked dynamically   (see its definition). One could use\r	 guaranteed to cast to a SequentialParser, but that would not be enough to silence\r	 the typechecker anyway *)\r(* Design note: It seems tempting to define a combinator, 'token', that returns a tokenized version of its receiver.  Alas, this doesn't work out, since tokenization relies on concepts of whitespace and comment, which are often specific to a given grammar. Hence, the combinator needs to be aan operation of the grammar, not of a specific production. *)\r)",
 "tokenFromChar: c <Character> ^<CombinatorialParser> = (\r 	^tokenFor: (char: c)\r)",
 "tokenFromSymbol: string <Symbol> ^<CombinatorialParser> = (\r	^tokenFor: (StringParser for: string)\r)",
 "public whitespace ^<CombinatorialParser> = (\r(* It's rare that anyone will need to change this definition *)\r (* ^ aWhitespaceChar plus. *)\r(* As an optimization, we process whitespace with a dedicated scanning parser. Of course, this regrettable, and Perhaps Squeak specific, but it is a significant win. *)\r	^WhitespaceParser new\r)",
 "class FailingParser = CombinatorialParser (\r(* The parser that always fails. It never parses anything. *)\r)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	^blk value: 'Failing Parser invoked' value: input position\r)",
 "class ForwardReferenceParser = CombinatorialParser (|\r	forwardee\r	public bindingRoutine\r|)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public & p <CombinatorialParser> ^ <CombinatorialParser> = (\r	^forwardee isNil\r		ifTrue: [super & p]\r		ifFalse: [forwardee & p]\r)",
 "public bind: p <CombinatorialParser> = (\r	(* as a precaution, only bind if p is a parser *)\r	(p isKindOfCombinatorialParser) ifTrue: [forwardee: p]\r)",
 "public opt = (\r	^forwardee isNil\r		ifTrue: [super opt]\r		ifFalse: [forwardee opt]\r)",
 "public parse: input inContext: context  ifError: blk = (\r	^parserToForwardTo parse: input inContext: context  ifError: blk.\r)",
 "public parserToForwardTo ^<CombinatorialParser> = (\r	forwardee isNil ifTrue: [bindingRoutine value].\r	^forwardee\r)",
 "public ultimateParser ^<CombinatorialParser> = (\r	^parserToForwardTo ultimateParser\r)",
 "public wrapper: blk ^<CombinatorialParser> = (\r	(* see comments in ForwardingWrappingParser *)\r	^ForwardingWrappingParser new wrapParser: self withWrapper: blk\r)",
 "public | p = (\r	^forwardee isNil\r		ifTrue: [super | p]\r		ifFalse: [forwardee | p]\r)",
 "class ForwardingWrappingParser = WrappingParser (\r(* When a ForwardingReferenceParser is wrapped using the wrapper: combinator, we don't know what the  arity the wrapping block should have - it will depend on the arity of the parser we forward to.  We cannot determine whether to use the implementation of wrapper: given in ordinary parsers, which forwards to the wrap: combinator (designed for block with arity 1) or the implementation used in SequentialParsers, (designed for n-ary blocks, where n is the length of the list of parsers the SequentialParser sequences). Instead, we must defer the decision on how to handle the situation until the parser tree is complete. This is accomplished by using this class as the result of the wrapper: combinator for ForwardReferenceParser.\r\rInstances of this class determiine how to act when asked to parse. At that time, the parse tree must be complete, and they can ask the ultimate parser for a wrappin parser that is suitable configured, and forward requests to it. *)\r|\r	wrappingParser\r|)",
 "WrappingParser",
 "WrappingParser",
 "public parse: input inContext: context ifError: blk = (\r	^trueWrappingParser parse: input inContext: context ifError: blk\r)",
 "trueWrappingParser ^<WrappingParser> = (\r	wrappingParser isNil ifTrue:\r		[wrappingParser:: parser ultimateParser wrapper: wrapperBlock].\r	^wrappingParser\r)",
 "class NamedWrappingParser = WrappingParser (\r(* This is exactly the same as a WrappingParser, but it passes itself down\rin the context parameter, to provide more meaningful error messages. *)\r)",
 "WrappingParser",
 "WrappingParser",
 "public parse: input inContext: context ifError: blk = (\r	^wrapperBlock value: (parser parse: input inContext: self ifError: blk )\r)",
 "class NegatingParser withSubparser: p = CombinatorialParser (\r(* A parser that implements the 'not' combinator, as in Ford's PEGs. It contains a parser p, and succeeds if p fails and vice versa. It does not move the input forward if it succeeds. *)\r| subparser <CombinatorialParser> = p. |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: ctxt ifError: blk = (\r	| rewindPosition |\r	rewindPosition:: input position.\r	subparser parse: input inContext: ctxt ifError: [:msg :pos | input position: rewindPosition. ^true].\r	blk value: 'not combinator failed' value: rewindPosition.\r)",
 "class PackratParserStream memoizing: s <ReadStream> = (\r(*\r\rA stream wrapper designed to support memoization for packrat parsers.\rSince the cache for a packrat parser is indexed by input position (as well as production), it is specific not only to a given grammar,\rbut a given input.  One approach is to create the cache when the grammar is first invoked. This speeds up a given parse, but will\rredo work if applied multiple times to the same contents (as often happens in an IDE like Newspeak's). \r\rIt is, however, tricky to do better given that the contents of a given source unit (expression, method, class, file) change frequently.\rAlex Warth's incremental packrat parsing work partially addresses this  - but in practice, we would need to track diffs, and suffer a large ongoing memory penalty to use that here.  Therefore, we focus on conventional packrat-style caching here.\r\rArguably, it's ugly to attach the cache to the stream, as it has nothing to do with the stream per se. The alternative is to have a parsing context that bundles the stream and the cache and pass that around instead of the stream. Or maybe it's just a matter of naming this class propewrly.\r\r\r*)\r|\rpublic contents <ReadStream> = s.\rpublic position <Integer> ::= 0.\rcache <Map[{Integer. Symbol}, T ]> = Map new. (* where T is the return type of the parser *)\r|)",
 " ",
 " ",
 "public atEnd ^ <Boolean> = (\r	^contents atEnd\r)",
 "public next = (\r	^contents next\r)",
 "public peek = (\r	^contents peek\r)",
 "public resultAt: key <{Integer. Symbol}> ifAbsent: blk <[T]> ^ <T> = (\r  ^cache at: key ifAbsentPut: blk\r)",
 "class ParserContext = (\r(* This class defines a context that is shared among a set of combinatorial parsers during a parse. The context can be used to manage information on parsing errors: rather than always report the latest failure that occurred, we can report the one that occurred deepest in the input stream, or implement some other policy - as long as we can record what failures took place.\r\rIn addition, this class could be used to support context-sensitive parsing.\r*)\r| failures ::= List new. |)",
 " ",
 " ",
 "errorMessage = (\rfailures isEmpty ifTrue: [^''].\r^failures last first\r)",
 "errorPosition = (\rfailures isEmpty ifTrue: [^-1].\r^failures last last\r)",
 "recordFailure: f = (\r(failures isEmpty or: [ failures last last <= f last ])\r		ifTrue: [ failures addLast: f]\r)",
 "public class ParserError message: m position: p = Error (|\r	public message <String> = m.\r	public position <Integer> = p.\r|)",
 "Error",
 "Error",
 "public description = (\r	^'ParserError: ', message\r)",
 "public printString = (\r	^'ParserError: ', message, ' (', position printString, ')'\r)",
 "class ParserStream over: string = (\r(* A wrapper for strings, presenting the minimal stream interface required by combinatorial parsers. \r*)\r|\rpublic contents = string.\rpublic position ::= 0.\r|)",
 " ",
 " ",
 "public atEnd = (\r	^position >= contents size\r)",
 "public next = (\r	position >= contents size ifTrue: [^nil].\r	position:: 1 + position.\r	^contents runeAt: position\r)",
 "public peek = (\r	position >= contents size ifTrue: [^nil].\r	^contents runeAt: 1 + position\r)",
 "class PlusParser withSubparser: p = CombinatorialParser (\r(* An attempt to optimize the + operator by having a dedicated parser for it. *)\r| subparser = p. |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	| rewindPosition results nextResult |\r	results:: List new.\r	results add: (subparser parse: input inContext: context ifError: blk).\r	[\r		rewindPosition: input position.\r		nextResult:: subparser\r			parse: input\r			inContext: context\r			ifError: [:msg :pos |\r				input position: rewindPosition.\r				^results].\r		results add: nextResult.\r	] repeat.\r)",
 "class SequentialParser withSubparsers: s = CombinatorialParser (\r(* A parser that activates a sequence of subparsers (P1, ,Pn).\r\rOne might think that it would be sufficient to define a class that\rcombined two parsers in sequence, corresponding to the &\roperator, just like AlternatingParser corresponds to the | operator.\rHowever, grammar productions typically involve several elements, so\rthe typical sequencing operation is n-ary *)\r| subparsers <Array[CombinatorialParser]> = s. |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public , p <CombinatorialParser> ^<SequentialParser> = (\r	^SequentialParser withSubparsers: (subparsers copyWith: p)\r)",
 "public parse: input inContext: context ifError: blk = (\r	^subparsers\r		collect: [:p | p parse: input inContext: context ifError: blk]\r)",
 "public wrapper: block = (\r	(* Untypesafe, but convenient. We can dynamically ensure that the arity of the incoming block matches that of this parser. Given that this routine is only called during parser construction, dynamic failure of the asserts is sufficient. We cannot ensure type correctness of the arguments to the block using this interface. One can use the more verbose followedBy: combinators if that is deemed essential. *)\r	assert: [block numArgs = subparsers size]\r		message: 'Block arity does not match production arity'.\r	^self wrap: [:results | block valueWithArguments: results asArray]\r)",
 "class StarParser withSubparser: p = CombinatorialParser (\r(* An attempt to optimize the * operator by having a dedicated parser for it. *)\r| subparser = p. |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	| rewindPosition results nextResult |\r	results:: List new.\r	[\r		rewindPosition: input position.\r		nextResult:: subparser\r			parse: input\r			inContext: context\r			ifError: [:msg :pos |\r				input position: rewindPosition.\r				^results].\r		results add: nextResult.\r	] repeat.\r)",
 "class StringParser for: s <String> = CombinatorialParser (\r	(* Parses a given symbol.  One could derive this as an alternation of character parsers, but the derivation is more verbose than defining it directly, and less efficient, so why bother? *)\r| string = s. |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	| pos |\r	pos:: input position.\r	1 to: string size do: [:index |\r		input atEnd ifTrue:\r			[^blk value: (string, ' expected') value: pos].\r		(string runeAt: index) = input next ifFalse:\r			[^blk value: (string, ' expected') value: pos]].\r	^string\r)",
 "public class Token value: v start: s end: e = (\r(* Represents a token of input. Basically, it attaches a start position\rto the token's value. Indeally, we'd use a tuple for this, which is why this class\rimplements the tuple protocol. We could use an array, but that would not be\rtypesafe. Until we have tuples, we'll use this class.\r\rIt's not yet clear if we should bother adding token codes or values here. *)\r|\r	public value = v.\r	public start = s.\r	public end = e.\r|)",
 " ",
 " ",
 "public class TokenizingParser withSubparser: p = CombinatorialParser (| subparser = p. |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	| pos res |\r	pos:: input position + 1.\r	res:: subparser parse: input inContext: context ifError: blk.\r	^Token value: res start: pos end: input position\r)",
 "class WhitespaceParser = CombinatorialParser (\r(* A simple scanner to optimize the handling of whitespace. Should be equivalent to'\r aWhitespaceChar plus\rEventually, the framework should optimize well enough that this will be unnecessary. *)\r)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	| rewindPosition |\r	rewindPosition:: input position.\r	[input atEnd ifTrue: [false] ifFalse: [input peek <= 32]] whileTrue: [input next].\r	input position = rewindPosition ifTrue:\r		[input position: rewindPosition.\r		blk value: 'Whitespace expected' value: rewindPosition].\r	^Token value: #whitespace start: rewindPosition + 1 end: input position\r)",
 "class WrappingParser = CombinatorialParser (\r(* Used to transform the output of another parser. A wrapping parser accepts exactly the same input as the wrapped\rparser does, and performs the same error handling. The only differenceis that it takes the output of the wrapped\rparser and passes it on to a wrapper block which uses it to produce a new result, which is the output of the wrapping\rparser. A typical use is to build nodes of an abstract syntax tree.\r\rThe output type of the wrapped parser, S, is also the input to the wrapper. The output type of the wrapper is the output of this\r(the wrapping) parser. *)\r| parser wrapperBlock |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input inContext: context ifError: blk = (\r	^wrapperBlock value: (parser parse: input inContext: context ifError: blk )\r)",
 "public wrapParser: p withWrapper: blk = (\r	parser:: p.\r	wrapperBlock:: blk\r)",
 "class Debugging2 usingPlatform: platform ide: ide = (\r	(* UI for the Web debugger. *)\r	|\r	private List = platform collections List.\r\r	private JSObject = platform js global at: 'Object'.\r\r	private Color = platform graphics Color.\r\r	private Gradient = platform hopscotch Gradient.\r	private Subject = platform hopscotch Subject.\r	private TextEditorFragment = platform hopscotch TextEditorFragment.\r\r	private EvaluationPresenter = ide browsing EvaluationPresenter.\r	private ProgrammingPresenter = ide browsing ProgrammingPresenter.\r	private SlotSubject = ide browsing SlotSubject.\r	|\r)",
 " ",
 " ",
 "class ActivationPresenter onSubject: s <ThreadSubject> = ProgrammingPresenter onSubject: s (\r	|\r	slots <PresenterList>\r	source <CodeMirrorFragment>\r	|\r)",
 "onSubject: s",
 "onSubject: s",
 "actionsMenu = (\r	^menuWithLabelsAndActions: {\r		{'Inspect Mirror'. [respondToInspectMirror]}.\r		{'Inspect Presenter'. [respondToInspectPresenter]}.\r	}\r)",
 "public collapse = (\r	substance collapse.\r)",
 "computeSlotPresenters = (\r	| presenters = List new. |\r	subject slotsDo:\r		[:slot <LocalSubject> | presenters add: slot presenter].\r	^presenters\r)",
 "public definition ^ <Fragment> = (\r	^collapsed: [definitionForHeader] expanded: [column: {\r		definitionForHeader.\r		definitionForControls.\r		(row: {\r			definitionForSource width: 0 elasticity: 1.6 asFloat.\r			smallBlank.\r			definitionForState width: 0 elasticity: 1.\r		}) crossAxisAlignToStart.\r	}]\r)",
 "definitionForControls = (\r	^row: {\r		(button: 'restart' action: [respondToRestart]) enabled: false.\r		smallBlank.\r		button: 'over' action: [respondToStepOver].\r		smallBlank.\r		button: 'into' action: [respondToStepInto].\r		smallBlank.\r		button: 'into closure' action: [respondToStepIntoClosure].\r		smallBlank.\r		button: 'out' action: [respondToStepOut].\r		filler.\r		(button: '^self' action: [respondToReturnSelf]) enabled: false.\r		smallBlank.\r		(button: '^nil' action: [respondToReturnNil]) enabled: false.\r		smallBlank.\r		(button: '^false' action: [respondToReturnFalse]) enabled: false.\r		smallBlank.\r		(button: '^true' action: [respondToReturnTrue]) enabled: false.\r		smallBlank.\r	}\r)",
 "definitionForHeader = (\r	| qualification |\r	qualification:: subject receiverMixin = subject methodMixin\r		ifTrue:\r			[{}]\r		ifFalse:\r			[{\r				(label: ' ( ')\r					color: tertiaryTextColor.\r				(link: subject methodMixin name action: [browseMixinMirror: subject methodMixin])\r					color: secondaryTextColor.\r				(label: ' )')\r					color: tertiaryTextColor.\r			}].\r\r	^row: {\r		(link: subject name action: [substance toggle])\r			color: actionLinkColor.\r		(label: ' in ')\r			color: tertiaryTextColor.\r		(link: subject receiverMixin name action: [browseMixinMirror: subject receiverMixin])\r			color: secondaryTextColor.\r	} , qualification , {\r		filler.\r		dropDownMenu: [actionsMenu].\r	}\r)",
 "definitionForSource = (\r	source:: codeMirror: subject source.\r	highlightSourceRange.\r	^source\r)",
 "definitionForState = (\r	^column: {\r		EvaluationPresenter onSubject: subject.\r		slots:: list: computeSlotPresenters.\r	}\r)",
 "public expand = (\r	substance expand.\r)",
 "highlightSourceRange = (\r	| range style |\r	range:: subject sourceRange.\r	nil = range ifTrue: [^self].\r	style:: JSObject new.\r	style at: 'css' put: 'color:blue; font-weight:bold; text-decoration: underline'.\r	source style: style from: range start to: range stop.\r)",
 "public refresh = (\r	nil = slots ifFalse: \r		[slots setPresenters: computeSlotPresenters].\r	nil = source ifFalse:\r		[highlightSourceRange].\r)",
 "refreshThreadPresenter = (\r	| ancestor ::= parent. |\r	[nil = ancestor] whileFalse:\r		[ancestor isKindOfThreadPresenter ifTrue:\r			[^ancestor refresh].\r		 ancestor:: ancestor parent].\r)",
 "respondToInspectMirror = (\r	inspectObject: subject activationMirror.\r)",
 "respondToRestart = (\r	subject restart.\r	refreshThreadPresenter.\r)",
 "respondToReturnFalse = (\r)",
 "respondToReturnNil = (\r)",
 "respondToReturnSelf = (\r)",
 "respondToReturnTrue = (\r)",
 "respondToStepInto = (\r	subject stepInto.\r	refreshThreadPresenter.\r)",
 "respondToStepIntoClosure = (\r	subject stepThrough.\r	refreshThreadPresenter.\r)",
 "respondToStepOut = (\r	subject stepOut.\r	refreshThreadPresenter.\r)",
 "respondToStepOver = (\r	subject stepOver.\r	refreshThreadPresenter.\r)",
 "class ActivationSubject onModel: m <ActivationMirror> in: t <ThreadSubject> = Subject onModel: m (\r|\r	protected threadSubject <ThreadSubject> = t.\r|\r)",
 "onModel: m",
 "onModel: m",
 "public = other <Object> ^<Boolean> = (\r	other isKindOfActivationSubject ifFalse: [^false].\r	^activationMirror = other activationMirror\r)",
 "public activationMirror ^<ActivationMirror> = (\r	^model\r)",
 "public className = (\r	^nil\r)",
 "public createPresenter = (\r	^ActivationPresenter onSubject: self\r)",
 "public evaluate: expression <String> ^<ThreadMirror> = (\r	^model evaluate: expression\r)",
 "public isKindOfActivationSubject ^<Boolean> = (\r	^true\r)",
 "public methodMixin ^<MixinMirror> = (\r	^model method definingMixin\r)",
 "public name ^<String> = (\r	| n enclosing |\r	n:: model method name.\r	enclosing:: model enclosingActivation.\r	[nil = enclosing] whileFalse:\r		[n:: '[] in ', n.\r		 enclosing:: enclosing enclosingActivation].\r	^n\r)",
 "public receiverMixin ^<MixinMirror> = (\r	^model receiver getClass mixin\r)",
 "public restart = (\r	model restart.\r)",
 "public slotsDo: action <[:SlotSubject]> = (\r	action value: (SlotSubject name: 'self' value: model receiver).\r	model slots do:\r		[:local | action value: (SlotSubject name: local name value: local value)].\r)",
 "public source ^<String> = (\r	| s = model method source. |\r	nil = s ifTrue: [^'<source unavailable>'].\r	^s\r)",
 "public sourceRange ^<Interval> = (\r	^model sourceRange\r)",
 "public stepInto = (\r	model stepInto.\r)",
 "public stepOut = (\r	model stepOut.\r)",
 "public stepOver = (\r	model stepOver.\r)",
 "public stepThrough = (\r	model stepThrough.\r)",
 "public title ^<String> = (\r	^name , ' in ' , receiverMixin name , '(', methodMixin name , ')'.\r)",
 "class ThreadPresenter onSubject: s <ThreadSubject> = ProgrammingPresenter onSubject: s (\r	|\r	activations <PresenterList>\r	|\r)",
 "onSubject: s",
 "onSubject: s",
 "actionsMenu = (\r	^menuWithLabelsAndActions: {\r		{'Inspect Mirror'. [respondToInspectMirror]}.\r		{'Inspect Presenter'. [respondToInspectPresenter]}.\r	}\r)",
 "definition = (\r	^column: {\r		mainHeadingBlock: (column: {\r			row: {\r				(label: 'Thread: ', subject stateName) color: Color white.\r				filler.\r				dropDownMenu: [actionsMenu].\r			}.\r			mediumBlank.\r			row: {\r				filler.\r				button: 'Continue' action: [respondToContinue].\r				largeBlank.\r				button: 'Terminate' action: [respondToTerminate].\r				filler.\r			}.\r		}).\r		smallBlank.\r		minorHeadingBlock: (row: {\r			label: 'Activations'.\r			filler.\r			expandButtonWithAction: [respondToExpandAll].\r			blank: 3.\r			collapseButtonWithAction: [respondToCollapseAll].\r		}).\r		smallBlank.\r		definitionForActivationsList.\r		largeBlank.\r	}\r)",
 "definitionForActivationsList = (\r	^activations:: list: (subject refreshActivationChain collect: [:s | s presenter])\r)",
 "public isKindOfThreadPresenter ^<Boolean> = (\r	^true\r)",
 "mainHeadingBlock: body = (\r	^(padded: body with: {10. 10. 10. 10.})\r		color: (Gradient from: (Color h: 0 s: 0.5 v: 0.8) to: (Color h: 0 s: 0.5 v: 0.6))\r)",
 "public refresh = (\r	activations setPresenters: (subject refreshActivationChain collect: [:s | s presenter refresh]).\r	activations presenters do: [:first | ^first expand].\r)",
 "respondToCollapseAll = (\r	activations presenters do: [:activation <ActivationPresenter> | activation collapse].\r)",
 "respondToContinue = (\r	subject resume.\r	refresh.\r)",
 "respondToExpandAll = (\r	activations presenters do: [:activation <ActivationPresenter> | activation expand].\r)",
 "respondToInspectMirror = (\r	inspectObject: subject threadMirror.\r)",
 "respondToTerminate = (\r)",
 "public class ThreadSubject onModel: m <ThreadMirror> = Subject onModel: m (\r	|\r	protected storedActivations <List[ActivationSubject]> ::= List new.\r	|\r)",
 "onModel: m",
 "onModel: m",
 "public = other <Object> ^<Boolean> = (\r	other isKindOfThreadSubject ifFalse: [^false].\r	^model = other model\r)",
 "public createPresenter = (\r	^ThreadPresenter onSubject: self\r)",
 "public isKindOfThreadSubject ^<Boolean> = (\r	^true\r)",
 "public refreshActivationChain ^<List[ActivationSubject]> = (\r	| oldActivations newActivations activation overlapSize |\r\r	oldActivations:: storedActivations.\r	newActivations:: List new.\r	activation:: model suspendedActivation.\r	[nil = activation] whileFalse:\r		[newActivations add: (ActivationSubject onModel: activation in: self).\r		 activation:: activation sender].\r\r	replaceCommonSuffixFrom: oldActivations to: newActivations.\r\r	^storedActivations:: newActivations.\r)",
 "replaceCommonSuffixFrom: oldList to: newList = (\r	0 to: (newList size min: oldList size) - 1 do: [:offset |\r		|\r		newIndex = newList size - offset.\r		oldIndex = oldList size - offset.\r		|\r		(oldList at: oldIndex) = (newList at: newIndex)\r			ifTrue: [newList at: newIndex put: (oldList at: oldIndex)]\r			ifFalse: [^self]].\r)",
 "public resume = (\r	model resume. \r)",
 "public stateName ^<String> = (\r	model isFulfilled ifTrue: [^'Fulfilled'].\r	model isBroken ifTrue: [^'Broken'].\r	model isSuspended ifTrue: [^'Suspended'].\r	^'Unknown'\r)",
 "public threadMirror ^<ThreadMirror> = (\r	^model\r)",
 "class Minitest usingPlatform: platform = (\r(* Minitest is the unit testing framework of Newspeak.\r\rUsers familiar with SUnit should note that Minitest is not an SUnit port or clone, but rather a complete redesign that revises the core structures and mechanisms to simplify test definitions and to make use of language facilities unique to Newspeak.\r\rCORE CLASSES\r\rMost of the classes defined by this module are internal to its implementation and are not intended to be subclassed or directly instantiated by the framework users. SUnit users, note: this includes the class named TestCase! The only class the typical test writer imports and sublcasses is TestContext. A developer working on IDE tools may also need access to TestCatalog and Tester.\r\rBASIC TESTS\r\rDefining tests begins with defining the test module--a top-level class to hold everything else. As the arguments, the factory of a test module typically takes an instance of the Newspeak platform, an instance of the Minitest module, and the factory or factories that create the tested object(s).\r\r	class ListTesting usingPlatform: platform minitest: minitest listClass: listClass = (\r	|\r	private TestContext = minitest TestContext.\r	private List = listClass.\r	|\r	...\r\rThe actual tests are defined as methods of a test context, a subclass of TestContext nested inside the test module.\r\r	( * nested inside MyCollectionsTest * )\r	class ListTests = TestContext (\r	| list = List new. |\r	) (\r	testAddition = (\r	  list add: 1.\r	  assert: (list includes: 1)\r	)\r	testRemoval = (\r	  list add: 1; remove: 1.\r	  deny: (list includes: 1)\r	)\r	) : (\r	TEST_CONTEXT = ()\r	)\r\rThis test context defines two test methods, recognized as such because they begin with the word 'test'. To run each of those, the framework will create a fresh instance of the ListTests class and send it the message required to invoke the method. A separate instance is created to run each of the test methods in a test context, so the List used by testRemoval is different from the one used by testAddition.\r\rNote the empty class-side method named TEST_CONTEXT. This is what makes the test framework recognize this class as a test context and scan it for test methods. Eventually, when Newspeak supports it, class metadata will be used instead to mark classes as test contexts.\r\rThis important point is worth reiterating. A class is a test context if and only if it contains a class-side method named TEST_CONTEXT. Inheriting from TestContext by itself does NOT make a class a test context, it only provides it with behavior such as the various #assert:... messages useful in test methods. Being a test context means that the class is scanned for test methods by the framework, and instantiated to run each of those methods.\r\rSHARED STATE\r\rEach test method of a test context runs within a context instance created and initialized specifically to run that method. In cases when tests need access to information which is too expensive to create for each individual test, such as a group of Newspeak modules or a database session, it is possible to share the information between the tests. To do that, we introduce a _shared state class_ between the module and the test context, as in the following nesting diagram:\r\r	CompilerTests (top level)\r	CompilerHolder (holds onto a compiler instance; not marked a test context)\r	  StatementsTests (a test context)\r\rIn this example, StatementsTests is a test context class with a number of test methods, all of which require a compiler instance to test. Assuming that creating a compiler is expensive, we instead nest the test context in a class called CompilerHolder, defined something like\r\r	class CompilerHolder = (\r	| compiler = Compiler configuredInAParticularWay.\r	...\r\rWe assume that 'Compiler' is a name appropriately bound by the CompilerTests module. The CompilerHolder class is not marked as a test context, and does not require any particular behavior other than supporting the #new factory message.\r\rThe CompilerHolder class is instantiated only once before running all the tests of the CompilerTests module. The StatementsTests class of the CompilerHolder instance is repeatedly instantiated for each test it defines. Each instance of StatementsTests sees the 'compiler' slot of its enclosing object, which allows all of the tests defined in StatementsTests to use the same compiler instance.\r\rMore precisely, the behavior in the general case is this. To detect and run tests, the test framework recursively traverses class declarations starting from that of the top-level module and stopping at classes marked as test contexts. Classes nested inside a test context, if any, are ignored. In the resulting tree, the framework considers three distinct parts. The root of the tree is the class of the top-level test module instance (which already exists). The leaves of the tree are test context classes. Any nodes between the root and the leaves are shared state classes. Instances of shared state classes are created once before running the entire batch of tests defined in all test contexts of the module. Instances of test contexts are created multiple times, once for each test method of a context.\r\rRUNNING IT: TEST CONFIGURATIONS\r\rLike any Newspeak module, a test module expects the platform and other necessary information to be provided at the time an instance is created. That information includes the factory such as a class object, that will create the actual instances to test. At different times it may make sense to instantiate a module with different sets of parameters, for example to test different versions of a class or different classes implementing the same interface. Any such specific configuration of a test module is captured as a _test configuration_ class.\r\rA test configuration is defined as a top-level class, similar to an application configuration. [TODO: describe the factory method once we settle on the final selector to use.] Like an application configuration, a test configuration is supplied with an ideNamespace that provides access to all top-level modules currently in the IDE. Also like an application configuration, a test configuration is expected to capture in its private slots ('import') references to any modules it will eventually instantiate. For example, a configuration for the ListTesting module above may look something like\r\r	class ListTestingConfiguration using: ideNamespace = (\r	|\r	private ListTesting = ideNamepace ListTesting.\r	private LinkedList = ideNamespace Collections LinkedList.\r	|\r	...\r\rA configuration class should implement one instance-side method named testModulesUsingPlatform:minitest:. The method should instantiate and return a collection of configured test modules (in our example, only one).\r\r	testModulesUsingPlatform: platform minitest: minitest = (\r	^{ListTesting usingPlatform: platform minitest: minitest listClass: LinkedList}\r\rIf the Collections module includes other implementors of the List interface, the example can be extended to use multiple instances of ListTesting to test other implementors. For example, provided there is a collection class named ArrayList in Collections and it has been 'imported' into a slot of ListTestingConfiguration, we could rewrite the method to test both implementations:\r\r	testModulesUsingPlatform: platform minitest: minitest = (\r	^{\r	  ListTesting usingPlatform: platform minitest: minitest listClass: LinkedList.\r	  ListTesting usingPlatform: platform minitest: minitest listClass: ArrayList.\r	}\r\rAlternatively, we may define a separate test configuration to test ArrayList.\r\rREEDUCATION FOR SUNIT USERS\r\rThe following is a comparison of the key differences between the traditional SUnit API and the goodthinkful way of doing the same thing.\r\rTestCase vs TestContext\r\rIn SUnit, tests are defined as methods of a subclass of TestCase, while in Minitest TestContext takes it place. This is not a simple renaming. SUnit's TestCase suffers from a split personality. It is both a test fixture, which is a particular configuration of tested object on which a set of tests can be performed, and a command to run one of those tests. It is also another thing that we will eventually get to. The author believes this confusion, repeated in SUnit clones for other languages, leads to increased complexity and inconsistencies in terms and concepts (for example, by defining 'a TestCase' in SUnit, we in fact define many test cases). In contrast, Minitest assigns these responsibilities to separate classes, which are TestContext and TestCase. A test context defines a configuration of tested objects and the actual tests, while a TestCase is a command object for running a particular test of a test context. Minitests's TestCase is internal to the framework implementation and not normally exposed to the framework users.\r\rThe role of TestCase/TestContext as a superclass\r\rBecause of the merging of two independent concepts in SUnit's TestCase, the TestCase class in SUnit must be a superclass of a user-defined set of tests. In Minitest, a test context is recognized as a class marked as such (currently with a marker method, eventually in the class's metadata). A test context class usually inherits from TestContext, however that is not required by the framework. The only reason for this inheritance is to allow the use in test methods of the various #assert: methods defined by TestContext. A test context class is free not to inherit from TestContext, as long as it has some other way to signal the TestFailureException in case of a test failure. (This is why this text usually refers to a Minitest test context as 'a test context' rather than 'a TestContext').\r\rThe #setUp method vs instance initializer\r\rIn SUnit, any necessary initialization of a TestCase subclass is performed by the #setUp method. In Minitest, instances of text contexts are initialized (naturally) by their initializers. Again, the reason for this difference is the split personality of SUnit's TestCase, leading to what in essense are multiple initialization schemes for those personalities.\r\rThe #tearDown method vs the #cleanUp method\r\rA test context (or a shared class instance) can define any necessary clean up behavior as a method named #cleanUp. A similar method in SUnit is named #tearDown. Minitest makes this API change because of the necessary change to the other half of lifecycle management (#setUp vs instance initializer), and also because the author believes cleanUp is a more natural name, which is now free of danger of being confused with setUp.\r\rTestResources vs shared state classes\r\rSUnit provides test resources as a mechanism to share expensive to create objects between a batch of test cases. Minitest does that using enclosing shared state classes. There is no dedicated TestResource class in Minitest because the framework expects nothing from the shared state class API other than the ability to create an instance using #new. At the same time, the framework takes care of creating and cleaning up their instances, so the test programmer is free from concerns of maintaining resource instances and managing their lifecycle. Shared state is naturally accessible to all tests that require it a part of the lexical scope. Lexical containment also naturally specifies which tests require which resources, without the fragility and obscurity of the various #resources methods of SUnit.\r\rTestCases vs test configurations\r\rA TestCase subclass in SUnit is a concrete runnable test artifact (in the sense that we can select one in a UI tool and run its tests). In Minitest, a test module with any tests it contains is only an abstract declaration. It needs a test configuration to instantiate it with a specific set of parameters. Test configuration is the third personality of SUnit's TestCase separated into an independent class in Minitest. More about this in the next section.\r\rTestCase subclassing vs parameterizable tests\r\rSUnit supports further subclassing of TestCase subclasses. For example, tests for a widget library can define, say, WidgetTestCase with LabelTestCase and ButtonTestCase as subclasses. WidgetTestCase is an abstract class defining tests of the API common to all widgets, while ButtonTestCase specializes it with tests specific to buttons. It also defines the concrete class tests inherited from WidgetTestCase apply to. Running ButtonTestCase is supposed to run both the tests defined locally as well as those inherited from WidgetTestCase.\r\rMinitest does not--and more importantly, does not need to--support test context inheritance to accomplish what is described above. More precisely, any class in a test module is free to inherit from any other class, be it a test context or not. However, if a test context class inherits from another test context class, only test methods defined locally in that particular class are recognized and executed by the framework. This is not a limitation, but rather the test parameterization story made straight. Let's begin with an example of the Minitest way of organizing the tests described above.\r\rWe define 3 test modules with the following factory signatures:\r\r	WidgetTesting usingPlatform: platform minitest: minitest widgetClass: aClass\r	LabelTesting usingPlatform: platform minitest: minitest labelClass: aClass\r	ButtonTesting usingPlatform: platform minitest: minitest buttonClass: aClass\r\rEach would have at least one test context class with all the appropriate tests. We also define two configuration classes, LabelTestConfiguration and ButtonTestConfiguration. As an example, LabelTestConfiguration would import the Label class from the widget library and define this method:\r\r	testModulesUsingPlatform: platform minitest: minitest = (\r	^{\r	  WidgetTesting usingPlatform: platform minitest: minitest widgetClass: Label.\r	  LabelTesting usingPlatform: platform minitest: minitest labelClass: Label.\r	}\r\rHere is why this approach is cleaner. Remember the point from the discussion of TestCases and test configurations above. The third overloaded responsibility of TestCase in SUnit is test configuration. A LabelTestCase needs to inherit from WidgetTestCase so that the tests of the Widget interface defined in that abstract class can be applied to a concrete implementation (Label). The Minitest example uses the fact test definition is parameterizable by test configuration to organize the code around this pattern:\r\r1. A module does not hardcode the actual implementation class it tests, instead expecting a _factory_ (in this case a class metaobject) that can manufacture instances to test on request.\r\r2. All tests in a module are written to test a particular _interface_. Different interfaces should be tested by different modules.\r\r3. A test configuration is what chooses a particular _implementation class_ to test. The configuration creates test modules for all interfaces the class implements, parameterized with the class being tested.\r\rThis pattern is the recommended way to organize tests using Minitest. You can see that the ListTesting and ListTestingConfiguration follow a similar idea. ListTesting defines tests of the List interface, while the configuration applies it to two concrete implementation classes.\r\r\rLICENSE\r\rCopyright (c) 2010 Vassili Bykov\rCopyright (c) 2012 Cadence Design Systems, Inc.\r\rLicensed under the MIT license:\r\rPermission is hereby granted, free of charge, to any person\robtaining a copy of this software and associated documentation\rfiles (the ''Software''), to deal in the Software without\rrestriction, including without limitation the rights to use,\rcopy, modify, merge, publish, distribute, sublicense, and/or sell\rcopies of the Software, and to permit persons to whom the\rSoftware is furnished to do so, subject to the following\rconditions:\r\rThe above copyright notice and this permission notice shall be\rincluded in all copies or substantial portions of the Software.\r\rTHE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND,\rEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\rOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\rNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\rHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\rWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\rFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\rOTHER DEALINGS IN THE SOFTWARE. *)\r|\r	private Exception = platform kernel Exception.\r	private UnhandledError = platform kernel UnhandledError.\r\r	private Map = platform collections Map.\r	private IdentityMap = platform collections IdentityMap.\r	private IdentitySet = platform collections IdentitySet.\r	private List = platform collections List.\r	private Set = platform collections Set.\r\r	private Promise = platform actors Promise.\r\r	private ObjectMirror = platform mirrors ObjectMirror.\r	private Message = platform kernel Message.\r|)",
 " ",
 " ",
 "class TestCase environment: testEnvironment <TestEnvironment> selector: selector <Symbol> = (\r(* Represents a particular test (a method with the selector that begins with 'test') in a text context. This class, unlike SUnit's class by the same name, is internal to the framework and is not intended to be subclassed or instantiated by framework users. See TestContext.\r\rAn instance holds onto a test environment (which indirectly identifies the test context class) and a selector within the class. While a test is running, an instance also holds onto the test context's instance created to run the test. That instance is created prior to running the test. If the test is successful, the instance is immediately discarded. In case of a failure or an error, the instance is retained so that its state can be examined. *)\r|\r	public environment <TestEnvironment> = testEnvironment.\r	public selector <Symbol> = selector.\r	testContextInstance <TestContext>\r|)",
 " ",
 " ",
 "public cleanUp = (\r(* Clean up and forget the test context instance. This method runs within an exception handler established by the runUsing: method, so any errors in test context instance cleanup are ok. *)\r	testContextInstance isNil ifFalse:\r		[testContextInstance cleanUp.\r		testContextInstance:: nil]\r)",
 "instantiateTestContextUsing: tester <Tester> = (\r	testContextInstance:: environment createInstanceIn: (tester instanceFor: environment parent)\r)",
 "public printOn: stream <WriteStream> = (\r	super printOn: stream.\r	stream nextPutAll: ' ('.\r	environment printOn: stream.\r	stream nextPutAll: ' '.\r	selector printOn: stream.\r	stream nextPutAll: ')'.\r)",
 "public runAsyncUsing: tester <Tester> ^<Promise[TestResult]> =  (\r	instantiateTestContextUsing: tester.\r	^Promise\r		when: [self sendTestMessage] <-: value\r		fulfilled:\r			[:resolution |\r			(* At this point the test has been successful, so create the TestSuccess before it is removed. *)\r			| testSuccess = testContextInstance createSuccessResultFor: self. |\r			(* Clean up immediately after a successful test. This makes the test context instance\r	immeidately garbage-collectable, which is an important property for large test suites. *)\r			cleanUp.\r			testSuccess]\r		broken:\r			[:problem |\r			nil = testContextInstance\r				ifTrue: [TestError case: self exception: problem]\r				ifFalse: [testContextInstance createErrorResultFor: self exception: problem]]\r)",
 "public runToDebugFailureUsing: tester <Tester> ^<TestResult> = (\r	instantiateTestContextUsing: tester.\r	[sendTestMessage]\r		ensure: [cleanUp]\r)",
 "public runUnsafeUsing: tester <Tester> ^<TestResult> = (\r	| testSuccess |\r	instantiateTestContextUsing: tester.\r	[sendTestMessage.\r	(* At this point the test has been successful, so create the TestSuccess before it is removed. *)\r	testSuccess:: testContextInstance createSuccessResultFor: self.\r	(* Clean up immediately after a successful test. This makes the test context instance\r	immeidately garbage-collectable, which is an important property for large test suites. *)\r	cleanUp]\r		on: TestFailureException\r		do: [:ex | ^nil = testContextInstance (* testContextInstance should never be nil at this point, but just in case. *)\r					ifTrue: [TestFailure case: self description: ex messageText]\r					ifFalse: [testContextInstance createFailureResultFor: self description: ex messageText]].\r	^testSuccess\r)",
 "public runUsing: tester <Tester> ^<TestResult> = (\r	^[self runUnsafeUsing: tester]\r		on: Error\r		do: [:ex | ^nil = testContextInstance\r					ifTrue: [TestError case: self exception: ex]\r					ifFalse: [testContextInstance createErrorResultFor: self exception: ex]]\r)",
 "sendTestMessage = (\r	^(Message selector: selector arguments: {})\r		sendTo: testContextInstance\r)",
 "public class TestCatalog forModule: testModule = (\r(* A catalog of test suites defined by a given test module instance. A catalog is created using the primary forModule: factory method. Each of test context classes of the module produces a TestSuite that lists all test methods in the class. The catalog can report the names of all test context classes, and return a TestSuite corresponding to each class. It can also return a TestSuite with the union of all the class-level TestSuites. *)\r|\r	testModule <Object> = testModule.\r	testsByContextName <Map[String, TestSuite]> = Map new.\r|Initializer new populate)",
 " ",
 " ",
 "public allTests ^<TestSuite> = (\r(* Returns a test suite containing all test cases defined in all test context classes of the catalogued module. *)\r	| allTestCases |\r	allTestCases:: List new: testsByContextName size + 1 * 20.\r	testsByContextName do: [:each | allTestCases addAll: each testCases].\r	^TestSuite testCases: allTestCases\r)",
 "public testSuiteNamed: key <String> = (\r(* Returns a test suite containing all test cases of the given class. *)\r	^testsByContextName at: key\r)",
 "public testSuiteNames ^<Collection[String]> = (\r	(* Returns the (short) names of test context classes of the module. *)\r	^testsByContextName keys\r)",
 "class Initializer = (\r(* An initializer populates the enclosing catalog with content extracted from the test module. This class is internal to the TestCatalog implementation. *)\r)",
 " ",
 " ",
 "examineClass: mirror <ClassDeclarationMirror> under: parentEnvironment <TestEnvironment> = (\r(* Examine the given class. If it is a test context, create a test suite listing its test cases and add it to the catalog. *)\r	| thisEnvironment |\r	thisEnvironment:: TestEnvironment parent: parentEnvironment classDeclarationMirror: mirror.\r	(isTestContext: mirror) ifTrue:\r		[thisEnvironment testCases: (testCasesIn: mirror environment: thisEnvironment).\r		parentEnvironment addNestedEnvironment: thisEnvironment.\r		(* Nested test contexts do not appear to be useful, so once a test context is found\r		we do not look inside it. The framework's own tests rely on this. *)\r		^self].\r	mirror instanceSide nestedClasses do:\r		[:each |\r		examineClass: each under: thisEnvironment].\r	(* If after all the examination thisEnvironment ends up with no test cases, or child\r	environments containing test cases, its class need not to be instantiated at runtime.\r	In that case we can forget it right here - no need to add it to the parent. *)\r	thisEnvironment hasTestCasesTransitively ifTrue:\r		[parentEnvironment addNestedEnvironment: thisEnvironment]\r)",
 "isTestContext: mirror <ClassDeclarationMirror> = (\r	^mirror classSide methods includesMirrorNamed: testContextMarkerSelector\r)",
 "isTestMethod: methodMirror <MethodMirror> = (\r	| selector |\r	selector:: methodMirror name.\r	^(selector startsWith: 'test') and: [(selector endsWith: ':') not]\r)",
 "public populate = (\r(* Populate the testsByContextName dictionary of the enclosing TestCatalog instance with information extracted from the module. *)\r	| moduleMirror moduleEnvironment |\r	moduleEnvironment:: TopLevelTestEnvironment module: testModule.\r	moduleMirror:: (ObjectMirror reflecting: testModule) getClass.\r	moduleMirror nestedClasses do:\r		[:each | examineClass: each under: moduleEnvironment].\r	moduleEnvironment withAllNestedEnvironmentsDo:\r		[:each |\r		each hasTestCases ifTrue:\r			[testsByContextName at: each name put: each testSuite]]\r)",
 "testCasesIn: classMirror <ClassDeclarationMirror> environment: environment <TestEnvironment> ^<Collection[TestCase]> = (\r(* Return a collection of TestCases describing test methods in the given class. *)\r	| testCases |\r	testCases:: List new.\r	classMirror instanceSide methods do:\r		[:each <MethodMirror> |\r		(isTestMethod: each) ifTrue:\r			[testCases add:\r				(TestCase environment: environment selector: each name)]].\r	^testCases\r)",
 "testContextMarkerSelector = (\r(* A class that has a class-side method with this selector is recognized by the Initializer as a test context class. (The class's superclass chain is unimportant--test contexts inherit from TestContext only in order to get testing behavior such as the #assert: method). *)\r	^#TEST_CONTEXT\r)",
 "public class TestContext = (\r(* An object for defining and running individual tests. In this respect, it is the same thing as the TestCase class of the traditional SUnit framework. Unlike SUnit's TestCase, an instance does not double as a command for running a particular test method.\r\rThis class provides the behavior useful for running tests, such as the various #assert: methods inheritable by the user's TestContext subclasses. Inheriting that behavior is the only real reason to inherit from TestContext. The test framework does NOT recognize the user's test contexts on the basis of their inheritance. Instead, each class to be treated as a test context should be marked as such. Currently, it is done with a class-side marker method named TEST_CONTEXT. In the future, marker methods will be superseded by proper class metadata.\r\rAn instance is initialized by its 'natural' initializer. If any special cleanup behavior is required after running a test, a subclass may reimplement the #cleanUp method to define it. *)\r)",
 " ",
 " ",
 "assert: aBlockOrValue <[Boolean] | Boolean> = (\r	assert: aBlockOrValue description: 'Assertion failed'\r)",
 "assert: aBlockOrValue <[Boolean] | Boolean> description: messageText <String> = (\r	assert: aBlockOrValue descriptionBlock: [messageText]\r)",
 "assert: aBlockOrValue <[Boolean] | Boolean> descriptionBlock: messageBlock <[String]> = (\r	aBlockOrValue isKindOfClosure\r		ifTrue: [aBlockOrValue value ifFalse: [failWithMessage: messageBlock value]]\r		ifFalse: [aBlockOrValue ifFalse: [failWithMessage: messageBlock value]].\r)",
 "assert: anObject equals: expectedObject = (\r	(* Succeed if anObject = anotherObject. Preferrable to a simple 'assert: [a = b]' in a test method because in case of a failure the values compared are available for inspection as this method's arguments. *)\r	assert: anObject = expectedObject descriptionBlock:\r		['Equality assertion failed; expected: ',\r		 expectedObject printString,\r		 ', was: ',\r		 anObject printString]\r)",
 "assert: anObject equals: anotherObject description: messageText = (\r	(* Succeed if anObject = anotherObject. Preferrable to a simple 'assert: [a = b]' in a test method because in case of a failure the values compared are available for inspection as this method's arguments. *)\r	assert: anObject = anotherObject description: messageText\r)",
 "assert: anObject equals: anotherObject descriptionBlock: messageBlock = (\r	(* Succeed if anObject = anotherObject. Preferrable to a simple 'assert: [a = b]' in a test method because in case of a failure the values compared are available for inspection as this method's arguments. *)\r	assert: anObject = anotherObject descriptionBlock: messageBlock\r)",
 "assertList: actualList equals: expectedList = (\r	assert: actualList size = expectedList size descriptionBlock:\r		['List equality assertion failed; expected: ',\r		 expectedList printString,\r		 ', was: ',\r		 actualList printString].\r	1 to: actualList size do:\r		[:index | assert: (actualList at: index) equals: (expectedList at: index)].\r)",
 "public cleanUp = (\r(* Sent after a successful completion of a test, to clean up if simple garbage collection at some point in the future is not enough (which it normally should be). If a test completes abnormally, with either a failure or an error, the test context is retained by the test case which in turn is retained by the test result. In this case, the message is not sent until a later time when the test results are discarded. *)\r)",
 "public createErrorResultFor: testCase <TestCase> exception: ex <Error> = (\r	^TestError case: testCase exception: ex\r)",
 "public createFailureResultFor: testCase <TestCase> description: description <String> = (\r	^TestFailure case: testCase description: description\r)",
 "public createSuccessResultFor: testCase <TestCase> = (\r	^TestSuccess case: testCase\r)",
 "deny: aBlockOrBoolean <[Boolean] | Boolean> = (\r	deny: aBlockOrBoolean description: 'Denial failed'\r)",
 "deny: aBlockOrBoolean <[Boolean] | Boolean> description: messageText <String> = (\r	deny: aBlockOrBoolean descriptionBlock: [messageText]\r)",
 "deny: aBlockOrBoolean <[Boolean] | Boolean> descriptionBlock: messageBlock <[String]> = (\r	aBlockOrBoolean isKindOfClosure\r		ifTrue: [aBlockOrBoolean value ifTrue: [failWithMessage: messageBlock value]]\r		ifFalse: [aBlockOrBoolean ifTrue: [failWithMessage: messageBlock value]].\r)",
 "deny: anObject equals: expectedObject = (\r	(* Succeed if (anObject = anotherObject) not. Preferrable to a simple 'deny: [a = b]' in a test method because in case of a failure the values compared are available for inspection as this method's arguments. *)\r	deny: anObject = expectedObject descriptionBlock:\r		['Inequality assertion failed; expected not: ',\r		expectedObject printString,\r		', was: ',\r		anObject printString]\r)",
 "failWithMessage: messageText <String | nil> = (\r	TestFailureException new signal: messageText\r)",
 "should: aBlock signal: anException = (\r	should: aBlock signal: anException description: 'Expected exception not signalled'\r)",
 "should: aBlock signal: anException <Class | ExceptionSet> description: failureMessage <String> = (\r	should: aBlock signal: anException descriptionBlock: [failureMessage]\r)",
 "should: aBlock signal: anException <Class | ExceptionSet> descriptionBlock: descriptionBlock <[String]> = (\r	| signalled ::= false. |\r	[aBlock value]\r		on: anException\r		do: [:ex | signalled:: true].\r\r	signalled ifFalse: [failWithMessage: descriptionBlock value].\r)",
 "shouldnt: aBlock signal: anException = (\r	shouldnt: aBlock signal: anException description: 'Exception signalled'\r)",
 "shouldnt: aBlock signal: anException <Class | ExceptionSet> description: failureMessage <String> = (\r	shouldnt: aBlock signal: anException descriptionBlock: [failureMessage]\r)",
 "shouldnt: aBlock signal: anException <Class | ExceptionSet> descriptionBlock: descriptionBlock <[String]> = (\r	[aBlock value]\r		on: anException\r		do: [:ex | failWithMessage: descriptionBlock value]\r)",
 "class TestEnvironment parent: parent classDeclarationMirror: mirror = (\r(* Describes a class nested inside a test module. The class can be either a test context or a parent (direct or indirect) of at least one test context. Environments form a tree, with those that represent test contexts being the leaves. Environment are used by the framework to orchestrate the instantiation of their classes when running tests.\r\rAn instance holds onto the parent and a collection of child environments. The class accessor name is the selector of a message that can be sent to a class metaobject corresponding to the parent environment to obtain a class metaobject corresponding to this environment. For an environment representing a test context, testCases holds a collection (not a real TestSuite) of TestCases defined in the test context. *)\r|\r	public parent <TestEnvironment | TopLevelTestEnvironment> = parent.\r	nestedEnvironments <Collection[TestEnvironment]> = List new.\r	public testCases <Collection[TestCase]> ::= List new.\r	public classDeclarationMirror <ClassDeclarationMirror> = mirror.\r|)",
 " ",
 " ",
 "public addNestedEnvironment: environment = (\r	nestedEnvironments add: environment\r)",
 "classAccessorName = (\r(* The class accessor name is the selector of a message that can be sent to a class metaobject corresponding to the parent environment to obtain a class metaobject corresponding to this environment. *)\r	^classDeclarationMirror simpleName\r)",
 "classIn: parentObject <Object> ^<Class> = (\r(* Returns a class metaobject represented by this environment specific for the given instance of the class corresponding to this environment's parent. *)\r\r	^(Message selector: classAccessorName arguments: {})\r		sendTo: parentObject\r)",
 "public createInstanceIn: parentObject <Object> ^<Object> = (\r(* Creates and returns an instance of the class represented by this environment. *)\r	^(classIn: parentObject) new\r)",
 "public hasTestCases ^<Boolean> = (\r(* True if the class represented by this environment defines any test methods. *)\r	^testCases isEmpty not\r)",
 "public hasTestCasesTransitively ^<Boolean> = (\r	(* True if either the class represented by this environment or any of its nested classes define any test methods. *)\r	hasTestCases ifTrue: [^true].\r	nestedEnvironments do: [:any | any hasTestCasesTransitively ifTrue: [^true]].\r	^false\r)",
 "public isRoot ^<Boolean> = (\r(* True if this is a top-level environment representing the entire test module. *)\r	^false\r)",
 "public name = (\r	^classAccessorName\r)",
 "public parentEnvironmentsDo: aBlock = (\r(* Evaluate a one-argument block with direct and indirect parents of this environment, starting with the direct one and proceeding up to the top level. *)\r	parent withAllParentEnvironmentsDo: aBlock\r)",
 "public printOn: stream <WriteStream> = (\r	super printOn: stream.\r	stream nextPutAll: ' '.\r	classAccessorName printOn: stream.\r)",
 "public testSuite = (\r	^TestSuite testCases: testCases\r)",
 "public withAllNestedEnvironmentsDo: aBlock = (\r(* Evaluate aBlock with the receiver and all members of the transitive closure of its nested environments, in preorder. *)\r	aBlock value: self.\r	nestedEnvironments do: [:each | each withAllNestedEnvironmentsDo: aBlock]\r)",
 "public withAllParentEnvironmentsDo: aBlock = (\r(* Evaluate a one-argument block with the receiver and all environment in its parent chain all the way up to the top level, beginning with the receiver. *)\r	aBlock value: self.\r	parent withAllParentEnvironmentsDo: aBlock\r)",
 "public class TestError case: testCase exception: exception = TestResult case: testCase (\r(* Represents a test case that didn't complete because an error was signaled and not handled while running the test case. The instance holds onto the exception instance representing the error. *)\r|\r	public exception ::= exception.\r|)",
 "case: testCase",
 "case: testCase",
 "public isError = (\r	^true\r)",
 "public class TestFailure case: testCase description: text <String> = TestResult case: testCase (\r(* Represents a failed assertion in a test case. *)\r|\r	public description ::= text.\r|)",
 "case: testCase",
 "case: testCase",
 "public isFailure = (\r	^true\r)",
 "class TestFailureException = Exception (\r(* An exception thrown when an assertion fails inside a test. The description of the failure is the exception's message text. *)\r)",
 "Exception",
 "Exception",
 "public defaultAction = (\r	UnhandledError signalForException: self\r)",
 "class TestResult case: testCase = (\r(* The result of running a TestCase. An abstract class. *)\r|\r	public testCase ::= testCase.\r|)",
 " ",
 " ",
 "public cleanUp = (\r	testCase cleanUp\r)",
 "public isError ^<Boolean> = (\r	^false\r)",
 "public isFailure ^<Boolean> = (\r	^false\r)",
 "public isSuccess ^<Boolean> = (\r	^false\r)",
 "public class TestSuccess case: testCase = TestResult case: testCase (\r(* Represents a successful run of a test case. *)\r)",
 "case: testCase",
 "case: testCase",
 "public isSuccess = (\r	^true\r)",
 "public class TestSuite testCases: testCases <Collection[TestCase]> = (\r(* A TestSuite is a collection of TestCases. TestSuites are usually obtained from a TestCatalog created on an instance of a test module. *)\r|\r	private testCases_slot <Collection[TestCase]> = testCases.\r|)",
 " ",
 " ",
 "+ another <TestSuite> ^<TestSuite> = (\r	(* Returns a new TestSuite that contains TestCases of the receiver and the argument. *)\r	^TestSuite testCases: testCases, another testCases\r)",
 "public ++ another <TestSuite> ^<TestSuite> = (\r	(* Returns a new TestSuite that contains TestCases of the receiver and the argument. *)\r	^TestSuite testCases: testCases, another testCases\r)",
 "modules ^<Collection[Object]> = (\r(* Returns a collection of test module instances that contain test cases of the suite. *)\r	| result |\r	result:: IdentitySet new.\r	testCases do: [:each | result add: each module].\r	^result\r)",
 "public size ^<Integer> = (\r(* Returns the number of test cases in the suite. *)\r	^testCases size\r)",
 "public testCases ^<Collection[TestCase]> = (\r(* Returns a collection of test cases of the receiver. *)\r	^testCases_slot\r)",
 "public class Tester testSuite: suite = (\r(* A tool for executing TestCases. TestCases are supplied to it in the form of a TestSuite. An instance is single-use only. First it is created using the testSuite: primary factory method. Then the tests are executed, either by sending the #runAll message, or by reproducing the steps defined by #runAll in an external tool. Finally, the results can be retrieved from the 'errors', 'failures' and 'successes' slots. *)\r|\r	public errors\r	public failures\r	public successes\r\r	private testSuite = suite.\r	private testCaseList\r	private testsPerformed_\r	private instanceManager = TestContextManager new.\r|)",
 " ",
 " ",
 "public atEnd = (\r	(* Returns true if all test cases in the test suite have been executed. *)\r	^testsPerformed = testCount\r)",
 "public cleanUp = (\r(* This message should be sent to the tester once at some point after finishing running the tests. This will cause the tester to send the #cleanUp message to all instances of shared state classes created to run the tests. Sending this message is not essential to the test framework functionality, but without sending it the cleanup logic of shared state classes will not be called. However, an IDE tool may choose to delay sending this message in case there are tests failures or errors, so that the shared state can be examined by the user. *)\r	instanceManager cleanUpCoreInstances.\r)",
 "public cleanUpResults = (\r(* This message causes the #cleanUp message to be sent to all test results, which in turn clean ups their associated test cases, cleaning up and making garbage-collectable any test context instances they may still be holding onto. *)\r	successes do: [:each | each cleanUp].\r	errors do: [:each | each cleanUp].\r	failures do: [:each | each cleanUp]\r)",
 "public completedRatio ^<Float> = (\r	(* Return a number between 0 and 1 indicating the ratio of tests in the suite completed so far. *)\r	^testCount = 0\r		ifTrue: [1.0]\r		ifFalse: [testsPerformed asFloat / testCount]\r)",
 "public haveAllTestsSucceeded = (\r	^errors size = 0 and: [failures size = 0]\r)",
 "public instanceFor: environment <TestEnvironment> ^<Object> = (\r	^instanceManager ensureInstanceFor: environment\r)",
 "public peekSelector ^<Symbol> = (\r	(* Returns the selector of the upcoming test case. This message should only be sent if the #atEnd message returns false. *)\r	^(testCaseList at: testsPerformed_ + 1) selector\r)",
 "public prepare = (\r	(* This message must be sent to the tester once prior to running any tests. At this stage the tester instantiates shared state classes of the test module, which may potentially cause errors to be signaled. *)\r	errors:: List new.\r	failures:: List new.\r	successes:: List new.\r	testCaseList:: testSuite testCases.\r	testsPerformed_:: 0.\r	instanceManager createCoreInstances.\r)",
 "public runAll = (\r	prepare.\r	[[atEnd] whileFalse: [step]]\r		ensure: [cleanUp]\r)",
 "public runToDebugFailure: testCase = (\r	instanceManager createCoreInstancesFor: testCase.\r	[testCase runToDebugFailureUsing: self]\r		ensure: [cleanUp]\r)",
 "public runWithNoExceptionHandling: testCase = (\r	instanceManager createCoreInstancesFor: testCase.\r	[testCase runUnsafeUsing: self]\r		ensure: [cleanUp]\r)",
 "public step ^<TestResult> = (\r	(* Execute one test case, add the result to the appropriate collection and return it. This message should only be sent if the #atEnd message returns false. *)\r	| case result |\r	case:: testCaseList at: testsPerformed_ + 1.\r	result:: case runUsing: self.\r	testsPerformed_:: testsPerformed_ + 1.\r	result isError ifTrue: [errors add: result].\r	result isFailure ifTrue: [failures add: result].\r	result isSuccess ifTrue: [successes add: result].\r	^result\r)",
 "public stepAsync ^<TestResult> = (\r	(* Execute one test case, add the result to the appropriate collection and return it. This message should only be sent if the #atEnd message returns false. *)\r	| case |\r	case:: testCaseList at: testsPerformed_ + 1.\r	^Promise when: (case runAsyncUsing: self) fulfilled:\r		[:result |\r		 testsPerformed_:: testsPerformed_ + 1.\r		 result isError ifTrue: [errors add: result].\r		 result isFailure ifTrue: [failures add: result].\r		 result isSuccess ifTrue: [successes add: result].\r		 result]\r)",
 "public testCount = (\r	^testCaseList size\r)",
 "public testsPerformed = (\r	^testsPerformed_\r)",
 "class TestContextManager = (\r(* Creates and keeps track of instances of shared state classes for a test run. Shared state classes are classes nested inside a test module that in turn contain other shared state classes and/or test context classes. In other words, they are the classes that are neither the root nor the leaves of the class nesting tree. Within this class, instances of these classes are referred to as 'core instances'. *)\r|\r	instancesByEnvironment ::= IdentityMap new.\r|)",
 " ",
 " ",
 "public cleanUpCoreInstances = (\r(* Send the #cleanUp message to all core instances able to understand that message. *)\r	instancesByEnvironment do:\r		[:each |\r		(understandsCleanUp: each) ifTrue: [each cleanUp]].\r	instancesByEnvironment:: IdentityMap new.\r)",
 "coreEnvironments = (\r(* The core of the environment tree are the environments between the roots of the class tree and its fringe. They have to be instantiated once before running the suite and cleaned up after. *)\r	| result |\r	result:: Set new.\r	testSuite testCases do:\r		[:each |\r		each environment parentEnvironmentsDo:\r			[:eachParent |\r			eachParent isRoot ifFalse: [result add: eachParent]]].\r	^result\r)",
 "coreEnvironmentsFor: testCase <TestCase> = (\r	| result |\r	result:: List new.\r	testCase environment parentEnvironmentsDo:\r		[:each |\r		each isRoot ifFalse: [result add: each]].\r	^result\r)",
 "public createCoreInstances = (\r(* Create instances of all shared state classes, which are the classes that are not test contexts themselves but rather contain test contexts directly or indirectly. Such classes are instantiated once before running a suite of tests and cleaned up afterwards. *)\r	coreEnvironments do:\r		[:each |\r		ensureInstanceFor: each]\r)",
 "public createCoreInstancesFor: testCase <TestCase> = (\r(* Create instances of shared state classes required to run the argument testCase. See #createCoreInstances. *)\r	(coreEnvironmentsFor: testCase) do:\r		[:each |\r		ensureInstanceFor: each]\r)",
 "public ensureInstanceFor: environment <TestEnvironment> ^<Object> = (\r(* Return an instance of the class represented by the argument, creating one if necessary. *)\r	environment isRoot ifTrue: [^environment moduleInstance].\r	^instancesByEnvironment at: environment ifAbsent:\r		[| instance |\r		instance:: environment createInstanceIn: (ensureInstanceFor: environment parent).\r		instancesByEnvironment at: environment put: instance.\r		instance]\r)",
 "understandsCleanUp: object = (\r(* Answer true if the object understands the #cleanUp message. *)\r	| mirror |\r	mirror:: (ObjectMirror reflecting: object) getClass.\r	^mirror methods includesMirrorNamed: #cleanUp\r)",
 "testCatalogs: catalogs <Collection[TestCatalog]> = (\r	| suite ::= TestSuite testCases: List new. |\r	catalogs do: [:each | suite:: suite ++ each allTests].\r	^self testSuite: suite\r)",
 "public testModules: modules <Collection[TestModule]> = (\r	^testCatalogs: (modules collect: [:each | TestCatalog forModule: each])\r)",
 "class TopLevelTestEnvironment module: moduleInstance = (\r(* A test environment representing a test module instance. Unlike regular TestEnvironments, it has no parents, but otherwise supports much of the same protocol. *)\r|\r	public moduleInstance = moduleInstance.\r	nestedEnvironments = List new.\r|)",
 " ",
 " ",
 "public addNestedEnvironment: environment = (\r	nestedEnvironments add: environment\r)",
 "public hasTestCases ^<Boolean> = (\r(* A top-level test module instance cannot function as a test context because it cannot be created and discarded for each test run. *)\r	^false\r)",
 "public isRoot = (\r	^true\r)",
 "public parentEnvironmentsDo: aBlock = (\r(* No-op since this is the top level. *)\r)",
 "public withAllNestedEnvironmentsDo: aBlock = (\r(* Evaluate aBlock with the receiver and all elements of the transitive closure of its nested environments (preorder). *)\r	aBlock value: self.\r	nestedEnvironments do: [:each | each withAllNestedEnvironmentsDo: aBlock]\r)",
 "public withAllParentEnvironmentsDo: aBlock = (\r(* Evaluate a one-argument block with the receiver and all environment in its parent chain, which is to say with the receiver only. *)\r	aBlock value: self\r)",
 "class MinitestUI2 usingPlatform: platform minitest: minitest ide: ide = (\r	(* Hopscotch UI for unit testing using Minitest. *)\r	|\r	private List = platform collections List.\r	private Map = platform collections Map.\r	private Promise = platform actors Promise.\r	private Color = platform graphics Color.\r	private Gradient = platform hopscotch Gradient.\r	private Presenter = platform hopscotch Presenter.\r	private Subject = platform hopscotch Subject.\r\r	private TestCatalog = minitest TestCatalog.\r\r	private AssortedMethodsPresenter = ide browsing AssortedMethodsPresenter.\r	private MethodSubject = ide browsing MethodSubject.\r	private ProgrammingPresenter = ide browsing ProgrammingPresenter.\r\r	private ide = ide.\r	private platform = platform.\r	private minitest = minitest.\r	|\r)",
 " ",
 " ",
 "class TestResultListPresenter onSubject: s = AssortedMethodsPresenter onSubject: s (\r(* A presenter for a list of TestResults, such as a list of successes or failures of a test run. *)\r)",
 "onSubject: s",
 "onSubject: s",
 "public collapseAll = (\r  respondToCollapse: content presenters\r)",
 "contentPresenters ^ <Collection[Presenter]> = (\r	| sortedTestResults |\r	sortedTestResults:: subject results (* asSortedList:\r		[:a :b | a testCase selector < b testCase selector] *).\r	^sortedTestResults collect:\r		[:each <TestResult> |\r		(TestResultPresenter onSubject: (TestResultSubject onModel: each)) showIndicatorBar: false]\r)",
 "public expandAll = (\r  respondToExpand: content presenters.\r)",
 "runAll = (\r	sendUp respondToRunAll: content presenters\r)",
 "class TestResultListSubject onModel: list = Subject onModel: list (\r(* The subject of a list of test results, such as a list of successes or failures of a test run. The model is a list of TestResult instances. *)\r)",
 "onModel: list",
 "onModel: list",
 "public createPresenter = (\r	^TestResultListPresenter onSubject: self\r)",
 "public isEmpty ^ <Boolean> = (\r	^model isEmpty\r)",
 "public results = (\r	^model\r)",
 "class TestResultPresenter onSubject: s = ProgrammingPresenter onSubject: s (\r(* Shows a single TestResult as an expandable selector of the method defining the test. If the result is a failure, also shows the description of the failure. *)\r|\r	public showIndicatorBar <Boolean> ::= true.\r	methodPresenterSlot <ExpandableMethodPresenter>\r|)",
 "onSubject: s",
 "onSubject: s",
 "ancestorTestingOutcomePresenter = (\r	| ancestor ::= parent. |\r	[nil = ancestor] whileFalse:\r		[ancestor isKindOfTestingOutcomePresenter ifTrue:\r			[^ancestor].\r		 ancestor:: ancestor parent].\r	^nil\r)",
 "public collapse = (\r	methodPresenter collapse\r)",
 "definition ^ <Fragment> = (\r	^showIndicatorBar\r		ifTrue: [row: {indicatorBar. elastic:: resultColumn}]\r		ifFalse: [resultColumn]\r)",
 "exceptionFragment ^ <Fragment> = (\r	| link |\r	link::\r		(link: subject exception printString\r		action: [ancestorTestingOutcomePresenter runWithNoExceptionHandling: subject testCase])\r			color: footnoteColor.\r	^row: {\r		blank: 12.\r		elastic: link.\r		}\r)",
 "public expand = (\r	methodPresenter expand\r)",
 "failureFragment ^ <Fragment> = (\r	^row: {\r		blank: 12.\r		(link: subject failureDescription\r		action: [ancestorTestingOutcomePresenter runToDebugFailure: subject testCase])\r			color: footnoteColor\r		}\r)",
 "footnoteColor ^ <Color> = (\r	^Color gray: 0.7\r)",
 "indicatorBar = (\r	^(row: {blank: 5} ) color: statusColor.\r)",
 "methodPresenter ^ <ExpandableMethodPresenter> = (\r	methodPresenterSlot isNil ifTrue: [methodPresenterSlot:: methodPresenterDefinition].\r	^methodPresenterSlot\r)",
 "methodPresenterDefinition ^ <ExpandableMethodPresenter> = (\r	^subject methodSubject createPresenter\r		showClassName: true\r)",
 "resultColumn ^ <Fragment> = (\r	^column: {\r		methodPresenter.\r		subject isFailure ifTrue: [failureFragment] ifFalse: [nothing].\r		subject hasException ifTrue: [exceptionFragment] ifFalse: [nothing].\r		(* subject hasNoData ifTrue: [noDataFragment] *)\r	}\r)",
 "statusColor ^ <Color> = (\r	(* subject passed ifTrue: [^Color green].\r	subject failed ifTrue: [^Color red].\r	subject error ifTrue: [^Color black]. *)\r	^Color gray.\r)",
 "class TestResultSubject onModel: m <TestResult> = Subject onModel: m (\r(* The subject for presenting a single TestResult. *)\r)",
 "onModel: m",
 "onModel: m",
 "public = x <Object> ^ <Boolean> = (\r	x class = class ifFalse: [^false].\r	^selector = x selector and: [className = x className]\r)",
 "classDeclarationMirror = (\r	^testCase environment classDeclarationMirror\r)",
 "public className = (\r	^classDeclarationMirror qualifiedName\r)",
 "public exception = (\r	(* If the model is a test error, return the exception associated with the result. Otherwise return nil. *)\r	^model isError\r		ifTrue: [model exception]\r		ifFalse: [nil]\r)",
 "public failureDescription ^<String> = (\r	(* If the model is a failure, return the description of the failure. Otherwise return an empty string. *)\r	^isFailure\r		ifTrue: [model description]\r		ifFalse: ['']\r)",
 "public hasException ^<Boolean> = (\r	(* True if the test result has an exception associated with it, or in other words, the result is a test error. *)\r	^model isError\r)",
 "public hash = (\r	^selector hash * 37 + className hash\r)",
 "public isFailure = (\r	^model isFailure\r)",
 "public methodSubject = (\r	^MethodSubject onModel: (testCase environment classDeclarationMirror instanceSide methods findMirrorNamed: selector)\r)",
 "public selector ^ <Symbol> = (\r	^testCase selector\r)",
 "public testCase = (\r	^model testCase\r)",
 "class TestingInProgressPresenter onSubject: subject = Presenter onSubject: subject (\r(* Presents a Tester in the process of running tests. *)\r|\r	progressBar\r	currentSelector\r	errorCountHolder\r	failureCountHolder\r|)",
 "onSubject: subject",
 "onSubject: subject",
 "definition = (\r	schedule: [startTests].\r\r	errorCountHolder:: holder: [nothing].\r	failureCountHolder:: holder: [nothing].\r	(* progressBar:: progress. *)\r	currentSelector:: label: 'no tests yet'.	\r	^column: {\r		(* progressBar. *)\r		row: {label: 'Running '. currentSelector . label: '...'}.\r		errorCountHolder.\r		failureCountHolder.\r	}\r)",
 "public isTransient = (\r	(* Should not be recorded in navigation history. *)\r	^true\r)",
 "pumpTests = (\r	tester atEnd ifTrue:\r		[tester haveAllTestsSucceeded ifTrue: [tester cleanUp].\r		 enterSubject:: TestingOutcomeSubject tester: tester configClass: subject configClass.\r		 ^self].\r\r	currentSelector text: tester peekSelector.\r	(failureCountHolder hasVisual and: [tester failures size > 0]) ifTrue:\r		[failureCountHolder content: [row: {label: 'Failures: ', tester failures size asString}]].\r	(errorCountHolder hasVisual and: [tester errors size > 0]) ifTrue:\r		[errorCountHolder content: [row: {label: 'Errors: ', tester errors size asString}]].\r\r	schedule: \r		[Promise when: tester stepAsync fulfilled: [pumpTests]].\r)",
 "startTests = (\r	tester prepare.\r	pumpTests.\r)",
 "tester = (\r	^subject tester\r)",
 "public class TestingInProgressSubject tester: tester <Tester> configClass: configClass = Subject onModel: tester (\r(* Represents a Tester instance, in the process of running tests. *)\r|\r	public configClass = configClass.\r|)",
 "onModel: tester",
 "onModel: tester",
 "public createPresenter = (\r	^TestingInProgressPresenter onSubject: self\r)",
 "public refreshmentSubject = (\r	^self class tester: model configClass: configClass.\r)",
 "public tester = (\r	^model\r)",
 "public title = (\r	^'Running Tests'\r)",
 "public onConfiguration: configClass <Class> platform: platform minitest: minitest = (\r	| config modules tester |\r	config:: configClass packageTestsUsing: ide namespacing manifest.\r	modules:: config testModulesUsingPlatform: platform minitest: minitest.\r	tester:: minitest Tester testModules: modules.\r	^self tester: tester configClass: configClass.\r)",
 "class TestingOutcomePresenter onSubject: s <TestingOutcomeSubject> = ProgrammingPresenter onSubject: s (\r(* Shows an outcome of running a suite of tests, as a page with separate sections for errors, failures and successes. *)\r)",
 "onSubject: s",
 "onSubject: s",
 "definition ^ <Fragment> = (\r	^column: {\r	      headingDefinition.\r		blank: 2.\r		errors.\r		blank: 1.\r		failures.\r		blank: 1.\r		successes.\r	}\r)",
 "didAllTestsPass = (\r	^didNoTestsFail (* not tracking incomplete for now, so no difference from didNoTestsFail *)\r)",
 "didNoTestsFail ^ <Boolean> = (\r	^subject failures isEmpty and: [subject errors isEmpty]\r)",
 "errors ^ <Fragment> = (\r	^section: 'Errors'\r		with: subject errors\r		status: #error\r		color: errorsSectionColor\r)",
 "errorsSectionColor = (\r	^Gradient from: (Color h: 0 s: 0.15 v: 1) to: (Color h: 0 s: 0.15 v: 0.9)\r)",
 "failureHeadingColor = (\r	^Gradient from: (Color h: 0 s: 0.5 v: 0.8) to: (Color h: 0 s: 0.5 v: 0.6)\r)",
 "failures ^ <Fragment> = (\r	^section: 'Failures'\r		with: subject failures\r		status: #failure\r		color: failuresSectionColor\r)",
 "failuresSectionColor = (\r	^Gradient from: (Color h: 50 s: 0.3 v: 1) to: (Color h: 50 s: 0.3 v: 0.9)\r)",
 "headingBlock: fragment color: aColor = (\r	^(padded: fragment with: {10. 5. 5. 5}) color: aColor\r)",
 "headingContentsDefinition ^ <Presenter> = (\r	| statusMessage |\r	statusMessage::\r		didAllTestsPass\r			ifTrue: ['Passed']\r			ifFalse:\r				[didNoTestsFail\r					ifTrue: ['Incomplete test results']\r					ifFalse: ['Failed ']].\r	^row: {\r		(link: subject configurationName (* asText allBold *)\r			action: [browseClass: subject configClass]) color: Color white.\r		smallBlank.\r		(label: statusMessage (* asText allBold *)) color: Color white.\r		filler.\r		button: 'Run Again' action: [respondToRunAgain].\r(*		smallBlank.\r		button: 'Forget' action: [respondToForget] *)\r		}.\r)",
 "headingDefinition ^ <Presenter> = (\r	^(majorHeadingBlock: headingContentsDefinition)\r	color: (\r		didNoTestsFail\r			ifFalse: [failureHeadingColor]\r			ifTrue:\r				[successHeadingColor])\r)",
 "public isKindOfTestingOutcomePresenter ^<Boolean> = (\r	^true\r)",
 "public noticeAbandonment = (\r	subject tester haveAllTestsSucceeded ifFalse: [subject tester cleanUp].\r	super noticeAbandonment.\r)",
 "respondToRunAgain = (\r	| newSubject |\r	subject tester cleanUpResults.\r	subject tester haveAllTestsSucceeded ifFalse: [subject tester cleanUp].\r	newSubject:: TestingInProgressSubject\r		onConfiguration: subject configClass\r		platform: platform\r		minitest: minitest.\r	enterSubject: newSubject.\r)",
 "respondToRunAll: testCases = (\r(* Run the set of test cases given by testCases.  The UI uses this to re-run just the failures, or errors or successes. However, tests have shared state, which one has to tear down and re-initialize.\r\rOther sections that hold test results should be pointing at different shared state so that they can be re-examined  It doesn't look like things are set up to support this. *)\r	halt.\r)",
 "public runToDebugFailure: testCase = (\r	| thread <ThreadMirror> |\r	thread:: platform mirrors ActivationMirror invokeSuspended:\r		[subject tester runToDebugFailure: testCase].\r	enterSubject:: ide debugging ThreadSubject onModel: thread.\r)",
 "public runWithNoExceptionHandling: testCase = (\r	| thread <ThreadMirror> |\r	thread:: platform mirrors ActivationMirror invokeSuspended:\r		[subject tester runWithNoExceptionHandling: testCase].\r	enterSubject:: ide debugging ThreadSubject onModel: thread.\r)",
 "section: label <String> with: testCases <Collection[TestCase]> status: aSymbol <Symbol> color: aColor <Color | Gradient> ^ <Fragment> = (\r	| testedMethodsPresenter |\r	testedMethodsPresenter:: TestResultListPresenter onSubject: (TestResultListSubject onModel: testCases).\r	^column: {\r		headingBlock: (row: {\r			label: (label, ' (', testCases size printString, ')') (*asText allBold *).\r			largeBlank.\r			(* (link: 'run all' action: [testedMethodsPresenter runAll]) tinyFont. *)\r			filler.\r			expandButtonWithAction: [testedMethodsPresenter expandAll].\r			blank: 3.\r			collapseButtonWithAction: [testedMethodsPresenter collapseAll].\r		}) color: aColor.\r		blank: 3.\r		testedMethodsPresenter.\r	}\r)",
 "section: label <String> withHidden: testCases <Collection[TestCase]> status: aSymbol <Symbol> color: aColor <Color | Gradient> ^ <Fragment> = (\r	| contentHolder testedMethodsPresenter |\r	testedMethodsPresenter:: TestResultListPresenter onSubject: (TestResultListSubject onModel: testCases).\r	contentHolder:: holder:\r		(row: {\r			blank: 10.\r			testCases isEmpty ifFalse:\r				[(link: 'Show details...'\r				action: [contentHolder content: testedMethodsPresenter]) (*tinyFont*)]\r		}).\r	^column: {\r		headingBlock: (row: {\r			label: (label, ' (', testCases size printString, ')') (*asText allBold*).\r			largeBlank.\r			(* (link: 'run all' action:\r				[contentHolder content == testedMethodsPresenter\r					ifTrue: [testedMethodsPresenter runAll]\r					ifFalse: [respondToRunAll: testCases]\r				]) tinyFont. *)\r			filler.\r			expandButtonWithAction:\r				[contentHolder content = testedMethodsPresenter\r					ifTrue: [testedMethodsPresenter expandAll]].\r			blank: 3.\r			collapseButtonWithAction:\r				[contentHolder content = testedMethodsPresenter\r					ifTrue: [testedMethodsPresenter collapseAll]].\r		}) color: aColor.\r		blank: 3.\r		contentHolder.\r	}\r)",
 "successHeadingColor = (\r	^Gradient from: (Color h: 120 s: 0.5 v: 0.7) to: (Color h: 120 s: 0.5 v: 0.5)\r)",
 "successes ^ <Fragment> = (\r	^section: 'Successes'\r		withHidden: subject successes\r		status: #success\r		color: successesSectionColor\r)",
 "successesSectionColor = (\r	^Gradient from: (Color h: 90 s: 0.3 v: 1) to: (Color h: 90 s: 0.3 v: 0.9)\r)",
 "class TestingOutcomeSubject tester: tester <Tester> configClass: configClass = Subject onModel: tester (|\r	public configClass = configClass.\r|)",
 "onModel: tester",
 "onModel: tester",
 "public configurationName = (\r	^configClass name\r)",
 "public createPresenter = (\r	^TestingOutcomePresenter onSubject: self\r)",
 "public errors = (\r	^tester errors\r)",
 "public failures = (\r	^tester failures\r)",
 "public refreshmentSubject = (\r	^self class tester: tester configClass: configClass\r)",
 "public successes = (\r	^tester successes\r)",
 "public tester = (\r	^model\r)",
 "public title = (\r	^'Test Results for ', configurationName\r)",
 "class NamespacingForV8 usingPlatform: p = (\r(* Unlike most languages, Newspeak has no global namespace. The IDE, however, as an extra-linguistic tool does provide a namespace. This namespace is stateless and only contains Values, typically top-level classes or other namespaces. It is used by an application definition in its #packageUsing: to collect the pieces of a program or by a test configuration in #packageTestsUsing:.\r\rGilad notes on 12/18/13:\r\rWe need to decide on the semantics of these things.  Here is a proposal:\r\rNamespaces nest and act like scopes. In a given namespace, one can access the elements defined in it, and those of its parents. A name in a namespace shadows (not overrides! these are not classes) the same name in its parents.\r\rThe IDE maintains a current namespace that all operations are relative to. Creating a top level class adds a new one to the current namespace, but editing a class looks the class up whereever it is in the parent chain, and edits that version. One should warn if a new class shadows an existing one, and allow to clone a class from one namespace to another.\r\rThe namespace presenter shows a namespaces local entries and a collapsed entry for its parent. Expanding parents recursively gives you a flat view of the scope. Elements that shadow or are shadowed should be marked. Perhaps a complete view of the scope with shadoowed elements removed is useful too.\r\rCopyright 2008 Cadence Design Systems, Inc.\rCopyright 2012 Cadence Design Systems, Inc.\rCopyright 2013 Ryan Macnak\rCopyright 2013 Google Inc.\r\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0\r*)\r| (* imports *)\r	private ClassMirror = p mirrors ClassMirror.\r	private ObjectMirror = p mirrors ObjectMirror.\r	private Map = p collections Map.\r	(* module variables *)\r	public Root <Map[Symbol, Behavior | String | Form]> = p collections Map new.\r	public Categories = Namespace new.\r	public manifest = Manifest forNamespace: Root.\r|)",
 " ",
 " ",
 "public categoryNamespace: cat = (\r	^Categories at: cat ifAbsentPut: [CategoryNamespace forCategory: cat].\r)",
 "categoryOf: o <Object> = (\r	o isKindOfString ifTrue: [^#Text].\r	o isKindOfImage ifTrue: [^#Icons]. (* isForm won't work on web *)\r	(* o isKindOfBehavior ifTrue: [^(ClassMirror reflecting: o) mixin declaration header category asSymbol].*)\r	^#Unknown\r)",
 "public freshNamespace = (\r	^Namespace new\r)",
 "public refreshCategoryNamespaces = (\r	#NAMESPACEBOGUS.\r	Categories keysAndValuesDo:\r		[:k :v | v removeAll].\r	Root keysAndValuesDo:\r		[:k :v | | cat ns |\r		cat:: categoryOf: v.\r		ns:: categoryNamespace: cat.\r		ns at: k asSymbol put: v].\r)",
 "public removeKey: key <Symbol> ^ <Object> = (\r	| value <Object> |\r	#NAMESPACEBOGUS.\r	value:: Root removeKey: key.\r	refreshCategoryNamespaces.\r	^value\r)",
 "class CategoryNamespace forCategory: c = Namespace (|\rprotected category <Symbol> = c.\r|)",
 "Namespace",
 "Namespace",
 "public at: key put: value = (\r	(*value isKindOfBehavior ifTrue: [value mixin category: category].*)\r	Root at: key asSymbol put: value.\r	^super at: key asSymbol put: value\r)",
 "public isKindOfCategoryNamespace = (\r	^true\r)",
 "class Manifest forNamespace: ns = (\r	|\r	private namespace = ns.\r	|\r)",
 " ",
 " ",
 "protected doesNotUnderstand: message <Message> = (\r	^namespace at: message selector\r)",
 "class Namespace = (\r(* A mapping between unary selectors and Values. *)\r|\r	protected _dictionary ::= Map new.\r|)",
 " ",
 " ",
 "public at: symbol <Symbol> ^<Value> = (\r	^_dictionary at: symbol\r)",
 "public at: symbol <Symbol> ifAbsent: onAbsent <[Value]> ^<Value> = (\r	^_dictionary at: symbol ifAbsent: onAbsent\r)",
 "public at: symbol <Symbol> ifAbsentPut: onAbsent <Value> ^<Value> = (\r	(*assert: [symbol isSymbol and: [symbol isUnary]] message: 'Invalid key', symbol printString.*)\r	^_dictionary at: symbol ifAbsentPut: onAbsent\r)",
 "public at: symbol <Symbol> put: value <Value> ^<Value> = (\r	(*assert: [symbol isSymbol and: [symbol isUnary]] message: 'Invalid key'.*)\r	^_dictionary at: symbol put: value\r)",
 "public includesKey: symbol <Symbol> ^<Boolean> = (\r	^_dictionary includesKey: symbol\r)",
 "public isKindOfNamespace ^ <Boolean> = (\r	^true\r)",
 "public keys ^ <Collection[Symbol]> = (\r	^_dictionary keys\r)",
 "public keysAndValuesDo: binaryBlock <[:Symbol :Value]> = (\r	_dictionary keysAndValuesDo: binaryBlock\r)",
 "public removeAll = (\r	_dictionary: Map new.\r)",
 "public removeKey: name <Symbol> ^<Value> = (\r	^_dictionary removeKey: name\r)",
 "public removeKey: name <Symbol> ifAbsent: onAbsent ^<Value> = (\r	^_dictionary removeKey: name ifAbsent: onAbsent\r)",
 "class NewspeakColorization2 usingPlatform: p grammar: grammar = (\r(*\rNewspeak code colorizer.\r\rCopyright Google Inc. 2016 - 2017.\r*)\r	|\r	private Color = p graphics Color.\r	private Map = p collections Map.\r	private List = p collections List.\r	private ClassMirror = p mirrors ClassMirror.\r	private TypedNS3Grammar = grammar TypedNS3Grammar.\r	private StringBuilder = p kernel StringBuilder.\r	private TextProperties = p text TextProperties.\r	private TextString = p text TextString.\r	private TextBlock = p text TextBlock.\r	|\r)",
 " ",
 " ",
 "public class NS3BrowserColorizer = NS3Colorizer (\r(* The colorizer maps different kinds of language constructs to different text properties via the mapping defined\rby computePropertiesMap, which it stores in propertiesMap. The parsing process defined by the superclass produces an\ra list of ranges in the source, where each range identifies the kind of construct in that range (see class Range in the surrounding module).  Not every section of text has a range computed for it; only sections that define constructs with special textual properties are computed. Later we will compute a set of text objects which covers the entire source, filling in the parts that lack an entry in the range list with text objects with default properties.\r\rWe convert the list to an array (incidental), rangeArray and sort it in ascending order of start indices.\rThe ranges in the range list may overlap.  In consolidateRanges,  overlaps are eliminated by iterating over the sorted range list and comparing adjacent ranges pairwise. If they overlap, they may or may not have the same kind. If the kinds are the same, we merge the ranges into one. If they differ, we truncate the first range to eliminate the overlap.\r\rWe then traverse the range array and, using propertiesMap, compute a corresponding set of text objects that have the appropriate properties, and filling in the gaps with text objects that have default properties, as described above.\r*)|\r	propertiesMap <Map[Symbol, TextProperties]> = computePropertiesMap.\r	textSegments <List[TextString]>\r	inputString <String>\r	priorSegmentEnd <Integer>\r	rangeArray <Array>\r|)",
 "NS3Colorizer",
 "NS3Colorizer",
 "coloredText ^ <Text> = (\r  ^TextBlock units: textSegments\r)",
 "public colorizeClassDeclaration: s <String> fromClass: c <Class> via: cf <[:Range]> = (\r      setString: s class: c.\r      colorizeString: s withProduction: classDeclaration via: cf\r)",
 "public colorizeDoIt: s <String> fromClass: c <Class> via: cf <[:Range]> = (\r      setString: s class: c.\r      colorizeString: s withProduction: doItExpression via: cf\r)",
 "public colorizeHeader: s <String> fromClass: c <Class> via: cf <[:Range]> = (\r      setString: s class: c.\r      colorizeString: s withProduction: classHeader via: cf\r)",
 "public colorizeMethod: s <String> fromClass: c <Class> via: cf <[:Range]> = (\r      setString: s class: c.\r      colorizeString: s withProduction: methodDecl via: cf\r)",
 "colorizeString: s <String> withProduction: parser <CombinatorialParser> via: cf <[:Range]> = (\r	parser, eoi parseString: s ifError: [:msg :pos |\r		noteRange: #error from: pos to: inputSize.\r      ].\r	consolidateRanges.\r	rangeArray do: [:r | nil = r ifFalse: [cf value: r]].\r)",
 "computePropertiesMap ^ <Map[Symbol, TextProperties]> = (\r(* compute a mapping from 'kinds', which are symbols denoting logical categories of code, to textual properties used to colorize them*)\r  |\r  redBoldUnderlined <TextProperties> = TextProperties new color: Color red; weight: #bold; underline: true; yourself.\r  redUnderlined <TextProperties> = TextProperties new color: Color red; underline: true; yourself.\r  orangeBoldUnderlined <TextProperties> = TextProperties new color: Color orange;  weight: #bold; underline: true; yourself.\r  underlined <TextProperties> = TextProperties new  underline: true; yourself.\r  gray <TextProperties> = TextProperties new color: Color gray; yourself.\r  blue <TextProperties> = TextProperties new color: Color blue; yourself.\r  grayBold <TextProperties> = TextProperties new color: Color gray; weight: #bold; yourself.\r  blackBold <TextProperties> = TextProperties new color: Color black;  weight: #bold; yourself.\r  blueBold <TextProperties> = TextProperties new color: Color blue;  weight: #bold; yourself.\r  magentaBold <TextProperties> = TextProperties new color: Color magenta;  weight: #bold; yourself.\r  bold <TextProperties> = TextProperties new  weight: #bold; yourself.\r |\r\r      ^Map new\r		 at: #error put: redBoldUnderlined;\r             at: #undefinedUnary put: redUnderlined;\r             at: #undefinedBinary put: redUnderlined;\r             at: #undefinedKeyword put: redUnderlined;\r             at: #shadowingTempVar put: orangeBoldUnderlined;\r             at: #obsoleteMessage put: orangeBoldUnderlined;\r             at: #whitespaceWarning put: orangeBoldUnderlined;\r             at: #incompleteUnary put: underlined;\r             at: #incompleteBinary put: underlined;\r             at: #incompleteKeyword put: underlined;\r             at: #self put: gray;\r             at: #super put: gray;\r             at: #outer put: gray;\r             at: #true put: gray;\r             at: #false put: gray;\r             at: #nil put: gray;\r             at: #string put: gray;\r             at: #symbol put: gray;\r             at: #number put: gray;\r             at: #character put: gray;\r             at: #public put: gray;\r             at: #protected put: gray;\r             at: #private put: gray;\r             at: #tempVar put: grayBold;\r             at: #blockTempVar put: grayBold;\r             at: #blockPatternArg put: grayBold;\r             at: #patternArg put: grayBold;\r             at: #slotDecl put: grayBold;\r             at: #patternTempVar put: grayBold;\r             at: #methodTempBar put: blackBold;\r             at: #leftParenthesis put: blackBold;\r             at: #rightParenthesis put: blackBold;\r             at: #leftParenthesis3 put: blackBold;\r             at: #rightParenthesis3 put: blackBold;\r             at: #leftParenthesis6 put: blackBold;\r             at: #rightParenthesis6 put: blackBold;\r             at: #blockStart put: blackBold;\r             at: #blockEnd put: blackBold;\r             at: #blockStart3 put: blackBold;\r             at: #blockEnd3 put: blackBold;\r             at: #blockStart6 put: blackBold;\r             at: #blockEnd6 put: blackBold;\r             at: #leftBrace put: blackBold;\r             at: #rightBrace put: blackBold;\r             at: #leftBrace3 put: blackBold;\r             at: #rightBrace3 put: blackBold;\r             at: #leftBrace6 put: blackBold;\r             at: #rightBrace6 put: blackBold;\r             at: #messagePatternDecl put: bold;\r             at: #class put: gray;\r             at: #className put: bold;\r             at: #comment put: blue;\r             at: #type put: blueBold;\r             at: #return put: blueBold;\r             at: #leftParenthesis1 put: blueBold;\r             at: #rightParenthesis1 put: blueBold;\r             at: #leftParenthesis4 put: blueBold;\r             at: #rightParenthesis4 put: blueBold;\r             at: #leftParenthesis7 put: blueBold;\r             at: #rightParenthesis7 put: blueBold;\r             at: #blockStart1 put: blueBold;\r             at: #blockEnd1 put: blueBold;\r             at: #blockStart4 put: blueBold;\r             at: #blockEnd4 put: blueBold;\r             at: #blockStart7 put: blueBold;\r             at: #blockEnd7 put: blueBold;\r             at: #leftBrace1 put: blueBold;\r             at: #rightBrace1 put: blueBold;\r             at: #leftBrace4 put: blueBold;\r             at: #rightBrace4 put: blueBold;\r             at: #leftBrace7 put: blueBold;\r             at: #rightBrace7 put: blueBold;\r             at: #leftParenthesis2 put: magentaBold;\r             at: #rightParenthesis2 put: magentaBold;\r             at: #leftParenthesis5 put: magentaBold;\r             at: #rightParenthesis5 put: magentaBold;\r             at: #blockStart2 put: magentaBold;\r             at: #blockEnd2 put: magentaBold;\r             at: #blockStart5 put: magentaBold;\r             at: #blockEnd5 put: magentaBold;\r             at: #leftBrace2 put: magentaBold;\r             at: #rightBrace2 put: magentaBold;\r             at: #leftBrace5 put: magentaBold;\r             at: #rightBrace5 put: magentaBold;\r             yourself\r)",
 "computeTextSegments = (\r      | textString <TextString> |\r  consolidateRanges.\r  rangeArray do: [:r <Range> |\r	nil = r ifFalse: [\r      	r start > priorSegmentEnd ifTrue: [ (* add a segment for unmarked text between identified ranges *)\r			textString:: TextString forString: (inputString copyFrom: priorSegmentEnd to: r start - 1).\r			textSegments add: textString.\r		].\r	(* The range 0..size is degenerate and leads to errors in Squeak 5.0 Morphic layout of paragraphs. *)\r		textString:: TextString\r			forString: (inputString copyFrom: (r start max: 1) to: r end)\r			properties: (propertiesMap at: r kind ifAbsent: [TextProperties new color: Color black; yourself]).\r		textSegments add: textString.\r		priorSegmentEnd:: r end + 1.	(* remember last marked range *)\r		]\r	].\r      priorSegmentEnd < inputSize ifTrue: [ (* create a segment for the tail end of the source *)\r			textString:: TextString forString: (inputString copyFrom: priorSegmentEnd to: inputSize).\r			textSegments add: textString.\r	]\r)",
 "consolidateRanges = (\r   | index <Integer> ::= 1.  |\r	rangeArray:: rangeMap asArray. (*BOGUS - work around broken List>>sort on web*)\r	rangeArray sort: [:r1 <Range> :r2 <Range> | r1 start = r2 start ifTrue: [r1 end < r2 end] ifFalse: [r1 start < r2 start]].\r	[index < rangeArray size] whileTrue: [\r		consolidateRangesAt: index.\r		index:: index + 1.\r	]\r)",
 "consolidateRangesAt: index <Integer> = (\r| e1 <Range> e2 <Range>  |\r	e1:: rangeArray at: index.\r	e2:: rangeArray at: index + 1.\r      e2 start > e1 end\r		ifFalse: [ (* e1 and e2 overlap *)\r			e1 kind = e2 kind ifTrue: [ (* merge e1 & e2 *)\r			rangeArray at: index put: nil.\r			rangeArray at: index + 1 put: (Range kind: e1 kind start: e1 start end: e2 end).\r			] ifFalse: [ (* shorten e1 to eliminate overlap *)\r				rangeArray at: index put: (Range kind: e1 kind start: e1 start end: e2 start - 1).]\r			]\r)",
 "noteRange: kind <Symbol> from: start <Integer> to: end <Integer> = (\r   rangeMap add: (Range kind: kind start: (start max: 1) end: end).\r)",
 "public parseClassDecl: s <String> fromClass: c <Class> ^<Text> = (\r(* Questionable*)\r	| parser |\r\r      setString: s class: c.\r	^parseString: s withProduction: classDecl\r)",
 "public parseClassDeclaration: s <String> fromClass: c <Class> ^<Text> = (\r	| parser |\r\r      setString: s class: c.\r	^parseString: s withProduction: classDeclaration\r)",
 "public parseClassHeader: s <String> fromClass: c <Class> ^<Text> = (\r	| parser |\r\r      setString: s class: c.\r	^parseString: s withProduction: classHeader\r)",
 "public parseCodeBody: s <String> fromClass: c <Class> ^<Text> = (\r	| parser |\r\r      setString: s class: c.\r	^parseString: s withProduction: codeBody\r)",
 "public parseDoIt: s <String> fromClass: c <Class> ^<Text> = (\r	| parser |\r\r      setString: s class: c.\r	^parseString: s withProduction: doItExpression\r)",
 "public parseMethod: s <String> fromClass: c <Class> ^ <Text> = (\r	| parser |\r\r      setString: s class: c.\r	^parseString: s withProduction: methodDecl\r)",
 "public parseSlotDeclaration: s <String> fromClass: c <Class> ^<Text> = (\r	| parser |\r\r      setString: s class: c.\r	^parseString: s withProduction: slotDef, eoi\r)",
 "parseString: s <String> withProduction: parser <CombinatorialParser> ^ <Text> = (\r	parser, eoi parseString: s ifError: [:msg :pos |\r		noteRange: #error from: pos to: inputSize.\r		computeTextSegments.\r		^coloredText ].\r	computeTextSegments.\r	^coloredText\r)",
 "setString: s <String> class: c <ClassDeclarationMirror | Mixin> = (	\r	inputSize:: s size.	\r	inputString:: s.	\r	klass:: c.	\r	bracketDepth:: 0.	\r	braceDepth:: 0.	\r	parenDepth:: 0.	\r	rangeMap:: List new.\r	textSegments:: List new.	\r	priorSegmentEnd:: 1.	\r	cachedScopeStack: nil.)",
 "class Range kind: k start: s end: e = (\r(*\rInstances of this class describe a range of text in the source. The start and end of the range are given as indices into the source.\rThe kind is a descriptor for what sort of element the code describes - a type, an error, a literal etc. The kind will serve as a key for the colorizer to decide what color to use for the text described by the range.\r*)|\r	public kind <Symbol> = k.\r	public start <Integer> = s.\r	public end <Integer> = e.\r|)",
 " ",
 " ",
 "class NS3Colorizer = TypedNS3Grammar (\r(*\rThis class subclasses the grammar so that it can parse Newspeak source with specialized semantic actions that determine how to colorize the code. This is done by calling the noteRange:from:to: method.\r\rBecause colorization is used to identify shadowing and undefined names, a notion of scoping is needed. Therefore a stack of scopes, cachedScopeStack, is maintained. Scopes are represented by maps from symbols to symbols. The keys are names of declarations, and the values are kinds.\r\rIt might be better to produce an actual AST (or a subset thereof) and visit it in order to colorize. In the existing scheme, subexpressions may induce colorizations that are subsumed by their enclosing expressions or statements, and we are forced to explicitly account for these situations and withdraw colorizations. See for example the blockType method, or worse, binaryMsgPattern.\r*)|\r	cachedScopeStack\r	klass\r	rangeMap <List[Range]>\r	inputSize <Integer>\r	startComment\r	braceDepth <Integer>\r	bracketDepth <Integer>\r	parenDepth <Integer>\r	isFirst ::= true.\r	mixinMirrorForObject <MixinMirror> = (ClassMirror reflecting: Object) mixin.\r|)",
 "TypedNS3Grammar",
 "TypedNS3Grammar",
 "accessModifier = (\r	^super accessModifier wrapper: [ :mod :ws |\r		noteRange: mod value asSymbol from: mod start to: mod end.\r		mod]\r)",
 "beginComment = (\r	^(TokenizingParser withSubparser: super beginComment) wrap:\r		[:t | self noteRange: #unfinishedComment from: t start to: self inputSize. t].\r)",
 "binaryMsgPattern = (\r	^super binaryMsgPattern wrapper:\r		[:sel <Token> :p <Tuple[Token, Token]> | | typeRange <Range> |\r		self pushScope.\r		self currentScope at: p first value put: #parameter.\r		(* The machinations around the ranges are especially nasty here.\r		The formal parameter is initially colored as a slot, but we may want to\r		treat formals specially, so we retract its colorization. If the slot had a type,\r		we retract that too (because it is last) and later reinstate it.\r		*)\r		p last isNil ifFalse: [typeRange:: rangeMap removeLast].\r		rangeMap removeLast.\r		noteRange: #messagePatternDecl from: sel start to: sel end.\r		noteRange: #patternArg from: p first start to: p first end.\r		p last isNil ifFalse: [rangeMap add: typeRange].\r		].\r)",
 "binarySelector = (\r	^super binarySelector wrap:\r		[:t | | kind |\r		kind:: selector: t value\r			ifDefined: [#binary]\r			ifIncomplete: [#incompleteBinary]\r			ifUndefined: [#undefinedBinary]\r			ifObsolete: [#obsoleteMessage].\r		self noteRange: kind from: t start to: t end.\r		t].\r)",
 "block = (\r	^super block wrapper:\r		[:lb :params :cb :rb |\r		params isNil ifFalse: [params isEmpty ifFalse: [self popScope]].\r		{lb. params. cb. rb}]\r)",
 "blockParameter = (\r	^super blockParameter wrapper:\r		[:cn :sd | (* blockParameter ::= colon, slotDecl *)\r		| kind |\r		checkBlockParameter: sd first.\r		kind:: (symbolInScope: sd first value) ifTrue: [#shadowingTempVar] ifFalse: [#blockPatternArg].\r		noteRange: kind from: sd first start to: sd first end.\r		sd]\r)",
 "blockParameters = (\r	^super blockParameters wrapper:\r		[:ps :vb  | self pushScope.\r		ps do: [:p | self currentScope at: p first value put: #parameter].\r		{ps. vb}]\r)",
 "blockType = (\r(* The brackets around the block type will colorize themselves, but their\rcolorization is superceded by the surrounding type. Therefore we remove the last\rtwo elements from the rangeMap. *)\r	^super blockType wrapper:\r		[:lb :t :rb | rangeMap removeLast; removeLast. t ]\r)",
 "braceLevelString = (\r	^self braceDepth = 1 ifTrue: [''] ifFalse: [self braceDepth printString]\r)",
 "bracketLevelString = (\r	^self bracketDepth = 1 ifTrue: [''] ifFalse: [self bracketDepth printString]\r)",
 "characterConstant = (\r	^super characterConstant wrap:\r		[:t | self noteRange: #'$' from: t start to: t end. t].\r)",
 "checkBlockParameter: sd <Token> = (\r	(inputString runeAt: sd start - 1) = 58 ifTrue: [^self].\r	self noteRange: #whitespaceWarning from: sd start - 1 to: sd start -1\r)",
 "checkKeyword: kwd <Token> = (\r	kwd end >= inputSize ifTrue: [^self].\r	(inputString runeAt: kwd end + 1) <= 32 ifTrue: [^self].\r	self noteRange: #whitespaceWarning from: kwd start to: kwd end\r)",
 "classDeclaration: classDecl canUnderstand: selector = (\r	(classDecl instanceSide methods includesMirrorNamed: selector)\r		ifTrue: [^true].\r	(classDecl instanceSide nestedClasses includesMirrorNamed: selector)\r		ifTrue: [^true].\r	(classDecl instanceSide slots includesMirrorNamed: selector)\r		ifTrue: [^true].\r	^false	\r)",
 "public classHeader = (\r	^super classHeader\r		wrap:\r			[ :tokens |\r			(tokens at: 9) = nil ifFalse:\r				[ | decs |\r					decs:: (tokens at: 9) size = 3 ifTrue: [\r						((tokens at: 9) at: 2) ] ifFalse: [(tokens at: 9) at: 3].\r\r					decs\r					do: [ :each | noteRange: #slotDecl from: (each at: 2) first start to: (each at: 2) first end ] ].\r			tokens ]\r)",
 "classId = (\r  ^super classId wrap: [:cn | 	\r	  noteRange: #className from: cn start to: cn end.\r	  cn\r	]\r)",
 "classReservedWord = (\r  ^super classReservedWord wrap: [:c | \r	  noteRange: #class from: c start to: c end.\r	  c\r	]\r)",
 "public codeBody = (\r	^super codeBody wrapper:\r		[:litMsg :tmps :stmts |\r		tmps isNil ifFalse: [tmps isEmpty ifFalse: [self popScope]].\r		{tmps. stmts}]\r)",
 "comment = (\r	^super comment wrap:\r		[:token | self noteRange: #comment from: token start to: token end].\r)",
 "currentScope = (\r	self assert: [self scopeStack isEmpty not] message: 'Scope underflow'.\r	^self scopeStack last\r)",
 "decreaseBraceLevel = (\r	self braceDepth: (self braceDepth - 1) \\\\ 7.\r)",
 "decreaseBracketLevel = (\r	self bracketDepth: (self bracketDepth - 1) \\\\ 7.\r)",
 "decreaseParenLevel = (\r	self parenDepth: (self parenDepth - 1) \\\\ 7.\r)",
 "endComment = (\r	^(TokenizingParser withSubparser: super endComment) wrap:\r		[:t |  rangeMap removeLast. t].\r)",
 "extendedCanUnderstand: sel <Symbol> = (\r	| k <ClassDeclarationMirror> |\r	k: klass.\r	[nil = k] whileFalse:\r		[(classDeclaration: k canUnderstand: sel) ifTrue: [^true].	\r		 k: k enclosingClass].\r\r	(* klass mixin applications do: [:any | ^any canUnderstand: sel].*)\r	^classDeclaration: mixinMirrorForObject declaration canUnderstand: sel\r)",
 "increaseBraceLevel = (\r	self braceDepth: (self braceDepth + 1) \\\\ 7.\r)",
 "increaseBracketLevel = (\r	self bracketDepth: (self bracketDepth + 1) \\\\ 7.\r)",
 "increaseParenLevel = (\r	self parenDepth: (self parenDepth + 1) \\\\ 7.\r)",
 "keywordHereSend = (\r	^super keywordHereSend wrap:\r		[:kws | | sel kind sb |\r		sb:: StringBuilder new.\r		kws do: [:kwd |\r			rangeMap removeLast.\r			sb add: kwd first value].\r		sel:: sb asString.\r		kind:: symbol: sel\r			ifInScope: [#instVar]\r			ifNotInScope: [#undefinedKeyword]\r			ifObsolete: [#obsoleteMessage].\r		kws do:\r			[:kwp | noteRange: kind from: kwp first start to: kwp first end]]\r)",
 "keywordMsg = (\r	^super keywordMsg wrapper:\r		[:esend :kws |\r		| sel kind |\r		kws do: [:kwp | checkKeyword: (kwp at: 1)].\r\r		sel:: (kws inject: '' into: [:s :kwp | s, (kwp at: 1) value]) asString.\r		kind:: selector: sel\r			ifDefined: [#keyword]\r			ifIncomplete: [#incompleteKeyword]\r			ifUndefined: [#undefinedKeyword]\r			ifObsolete: [#obsoleteMessage].\r		kws do: [:kwp | self noteRange: kind from: kwp first start to: kwp first end]].\r)",
 "keywordMsgPattern = (\r	^super keywordMsgPattern wrap:\r		[:kws |\r		pushScope.\r		kws do: [:kwp | | kind |\r			kind:: (symbolInScope: kwp last first value)\r				ifTrue: [#shadowingTempVar]\r				ifFalse: [#patternArg].\r			currentScope at: kwp last first value put: #parameter.\r			noteRange: #messagePatternDecl from: kwp first start to: kwp first end.\r			noteRange: kind from: kwp last first start to: kwp last first end]]\r)",
 "lbracket = (\r	^super lbracket wrap:\r		[:t |\r		| range |\r		self increaseBracketLevel.\r		range:: ('blockStart', self bracketLevelString) asSymbol.\r		self noteRange: range from: t start to: t end.\r		t]\r)",
 "lcurly = (\r	^super lcurly wrap:\r		[:t | | range |\r		self increaseBraceLevel.\r		range:: ('leftBrace', self braceLevelString) asSymbol.\r		self noteRange: range from: t start to: t end.\r		t]\r)",
 "lparen = (\r	^super lparen wrap:\r		[:t | | range |\r		self increaseParenLevel.\r		range:: ('leftParenthesis', self parenLevelString) asSymbol.\r		self noteRange: range from: t start to: t end.\r		t]\r)",
 "method = (\r	| res |\r	self pushScope.\r	res:: super method.\r	self popScope.\r	^res\r)",
 "nestedClassDecl = (\r	^super nestedClassDecl wrap:\r		[:tokens | (* accessModifier opt, classDeclaration*)\r		noteRange: #className from: ((tokens last) at: 2) start to: ((tokens last) at: 2) end.\r		tokens]\r)",
 "noteRange: kind from: start to: end  = (\r	subclassResponsibility\r)",
 "number = (\r	^super number wrap:\r		[:t | self noteRange: #number from: t start to: t end. t].\r)",
 "parenLevelString = (\r	^self parenDepth = 1 ifTrue: [''] ifFalse: [self parenDepth printString]\r)",
 "pattern = (\r	^super pattern wrap:\r		[:tpl |\r		self noteRange: #string from: (tpl at: 1) start to: (tpl at: 3) end.\r		tpl at: 2]\r)",
 "popScope = (\r	self scopeStack removeLast\r)",
 "pushScope = (\r	self scopeStack addLast: Map new\r)",
 "rbracket = (\r	^super rbracket wrap:\r		[:t |\r		| range |\r		range:: ('blockEnd', self bracketLevelString) asSymbol.\r		self decreaseBracketLevel.\r		self noteRange: range from: t start to: t end.\r		t]\r)",
 "rcurly = (\r	^super rcurly wrap:\r		[:t | | range |\r		range:: ('rightBrace', self braceLevelString) asSymbol.\r		self decreaseBraceLevel.\r		self noteRange: range from: t start to: t end.\r		t]\r)",
 "returnStatement = (\r	^super returnStatement wrapper:\r		[:h <Token> :expr :od <Token> |\r		self noteRange: #return from: h start to: h end.\r		expr].\r)",
 "returnType = (\r	^super returnType wrapper:\r		[:h <Token> :t | self noteRange: #type from: h start to: h end. t]\r)",
 "rparen = (\r	^super rparen wrap:\r		[:t |  | range |\r		range:: ('rightParenthesis', self parenLevelString) asSymbol.\r		self decreaseParenLevel.\r		self noteRange: range from: t start to: t end.\r		t]\r)",
 "scopeStack = (\r	(* TODO: get rid of this, rename slot and initialize it*)\r	(* deal with forwarding reference *)\r	cachedScopeStack isKindOfCollection ifFalse:\r		[cachedScopeStack:: List new].\r	^cachedScopeStack\r)",
 "selector: sel ifDefined: definedAction ifIncomplete: incompleteAction ifUndefined: undefinedAction ifObsolete: obsoleteAction = (\r	({#isKindOf:. #out. #halt. #inspect. #flag:. #instVarAt:. #isMemberOf:. #~. #!=} includes: sel) ifTrue: [^obsoleteAction value].\r      ^definedAction value\r)",
 "semicolon = (\r	^super semicolon wrap:\r		[:t | self noteRange: #cascadeSeparator from: t start to: t end. t].\r)",
 "setterKeyword = (\r	^super setterKeyword wrap: [:skw <Token> | | kind |\r		checkKeyword: skw.\r		kind:: (self symbolInScope: (skw value copyFrom: 1 to: (skw end - skw start )))\r			ifTrue: [#instVar]\r			ifFalse: [#undefinedKeyword].\r		self noteRange: kind from: skw  start to: skw end.\r		skw]\r)",
 "slotDef = (\r	^super slotDef wrap:\r		[:tokens | | sd kind |\r		sd:: (tokens at: 2) first.\r		noteRange: #slotDecl from: sd start to: sd end.\r		(* isFirst ifTrue: [pushScope. isFirst: false]. *)\r		tokens]\r)",
 "slotName = (\r	^super slotName wrap:\r		[:n <Token> | | kind |\r		kind:: ({'self'. 'super'. 'outer'. 'true'. 'false'. 'nil'} includes: n value)\r			ifTrue: [n value asSymbol]\r                  ifFalse: [symbol: n value\r				ifInScope: [#instVar]\r				ifNotInScope: [#undefinedUnary]\r				ifObsolete: [#obsoleteMessage]].\r		noteRange: kind from: n start to: n end.\r		n]\r)",
 "string = (\r	^super string wrap:\r		[:t | self noteRange: #string from: t start to: t end. t]\r)",
 "symbol: aString <String> ifInScope: inScopeAction ifNotInScope: notInScopeAction ifObsolete: obsoleteAction = (\r	scopeStack do: [:s | (s includesKey: aString) ifTrue: [^inScopeAction value]].\r	^inScopeAction value (* BOGUS *)\r)",
 "symbolConstant = (\r	^super symbolConstant wrapper:\r		[:p <Token> :s |\r		self noteRange: #symbol from: p start to: s end.\r		s].\r)",
 "symbolInScope: aString <String> ^ <Boolean> = (\r	scopeStack do: [:s | (s includesKey: aString) ifTrue: [^true]].\r\r		(extendedCanUnderstand: aString) ifTrue: [^true].\r		^false\r)",
 "tempSlotDef = (\r	^super slotDef wrap: [ :tokens | | sd kind |\r		sd:: (tokens at: 2) first.\r		noteRange: #slotDecl from: sd start to: sd end.\r\r		isFirst ifTrue: [pushScope. isFirst: false].\r\r		kind:: (symbolInScope: sd value) ifTrue: [#shadowingTempVar] ifFalse: [#tempVar].\r		currentScope at: sd value put: #temporary.\r		currentScope at: sd value, ':' put: #temporary.\r		noteRange: kind from: sd start to: sd end.\r\r		tokens]\r)",
 "temporaries = (\r	|\r	tempSlotDefs = tempSlotDef star.\r 	tempSeqSlotDecls = vbar, tempSlotDefs, vbar.\r 	tempSimSlotDecls = vbar, vbar, tempSlotDefs, vbar, vbar.\r 	tempSlotDecls = tempSimSlotDecls | tempSeqSlotDecls.\r	|\r\r	^tempSlotDecls wrap:\r		[:parts | | vb1 vb2 vds vb3 vb4 |\r		parts size = 3\r			ifTrue:\r				[vb1:: parts at: 1.\r				vb2:: vb1.\r				vds:: parts at: 2.\r				vb3:: parts at: 3.\r				vb4:: vb3]\r			ifFalse:\r				[vb1:: parts at: 1.\r			vb2:: parts at: 2.\r			vds:: parts at: 3.\r			vb3:: parts at: 4.\r			vb4:: parts at: 5].\r\r		isFirst: true.\r		noteRange: #methodTempBar from: vb1 start to: vb2 end.\r		noteRange: #methodTempBar from: vb3 start to: vb4 end.\r		vds]\r)",
 "tupleType = (\r(* The braces around the tuple type will colorize themselves, but their\rcolorization is superceded by the surrounding type. Therefore we remove the last\rtwo elements from the rangeMap. *)\r	^super tupleType wrapper:\r		[:lc :t :rc | rangeMap removeLast; removeLast. t ]\r)",
 "type = (\r	^super type wrapper:\r		[:lb :te :rb | self noteRange: #type from: lb start to: rb end. te]\r)",
 "typeArguments = (\r(* The brackets around the type arguments will colorize themselves, but their\rcolorization is superceded by the surrounding type. Therefore we remove the last\rtwo elements from the rangeMap. *)\r	^super typeArguments wrapper:\r		[:lb :t :rb | rangeMap removeLast; removeLast. t ]\r)",
 "unaryMsgPattern = (\r	^super unaryMsgPattern wrap:\r		[:sel <Symbol> |\r		rangeMap removeLast.\r		self noteRange: #messagePatternDecl from: sel start to: sel end.\r		sel].\r)",
 "unarySelector = (\r	^super unarySelector wrap:\r		[:t | | kind |\r		kind:: selector: t value\r			ifDefined: [#unary]\r			ifIncomplete: [#incompleteUnary]\r			ifUndefined: [#undefinedUnary]\r			ifObsolete: [#obsoleteMessage].\r		self noteRange: kind from: t start to: t end.\r		t].\r)",
 "variableName = (\r	^super variableName wrap:\r		[:n <Token> |\r		n value = 'self' ifTrue: [self noteRange: #self from: n start to: n end]\r		ifFalse: [n value = 'super' ifTrue: [self noteRange: #super from: n start to: n end]\r		ifFalse: [n value = 'true' ifTrue: [self noteRange: #true from: n start to: n end]\r		ifFalse: [n value = 'false' ifTrue: [self noteRange: #false from: n start to: n end]\r		ifFalse: [n value = 'nil' ifTrue: [self noteRange: #nil from: n start to: n end]\r		ifFalse: []]]]].\r		n]\r)",
 "class NewspeakGrammar usingPlatform: p parsers: parsers = (\r(* The Newspeak grammar, both with and without type declarations.\r\rCopyright 2008 Cadence Design Systems, Inc.\rCopyright 2010 Felix Geller and Ryan Macnak\rCopyright 2012 Ryan Macnak\r\rLicensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)\r|\r\rprivate List = p collections List.\r\rprivate ExecutableGrammar = parsers ExecutableGrammar.\rprivate CollectingCommentParser = parsers CollectingCommentParser.\rprivate CombinatorialParser = parsers CombinatorialParser.\rprivate Token = parsers Token.\rpublic ParserError = parsers ParserError.\r|)",
 " ",
 " ",
 "class NS3Grammar = ExecutableGrammar (\r(* Grammar for Newspeak3 (without types). *)\r|\r	whitespace = super whitespace. (* cache whitespace parser *)\r	colon = tokenFromChar: \":\".\r	comma = tokenFromChar: \",\".\r	dollar = tokenFromChar: \"$\".\r	dot = tokenFromChar: \".\".\r	equalSign = tokenFromChar: \"=\".\r	hat = tokenFromChar: \"^\".\r	lbracket = tokenFromChar: \"[\".\r	lcurly = tokenFromChar: \"{\".\r	lparen = tokenFromChar: \"(\".\r	langleBracket = tokenFromChar: \"<\".\r	pound = tokenFromChar: \"#\".\r	rangleBracket = tokenFromChar: \">\".\r	rbracket = tokenFromChar: \"]\".\r	rcurly = tokenFromChar: \"}\".\r	rparen = tokenFromChar: \")\".\r	semicolon = tokenFromChar: \";\".\r	slash = tokenFromChar: \"/\".\r	vbar = tokenFromChar: \"|\".\r	mixinOperator = tokenFromSymbol: ':>'.\r	inverseMixinOperator = tokenFromSymbol: '<:'.\r	eventualSendOperator = tokenFromSymbol: '<-:'.\r	digit = charBetween: \"0\" and: \"9\".\r	digits = digit plus.\r	uppercaseLetter = charBetween: \"A\" and: \"Z\".\r	extendedDigits = (digit | uppercaseLetter) plus.\r	radix = digits, (char: \"r\").\r	fraction = (char: \".\"), digits.\r	extendedFraction = (char: \".\"), extendedDigits.\r	exponent = (char: \"e\"), (char: \"-\" ) opt, digits.\r	decimalNum = (char: \"-\") opt, digits, fraction opt, exponent opt.\r	radixNum = radix, (char: \"-\") opt, extendedDigits, extendedFraction opt, exponent opt.\r	num = radixNum | decimalNum.\r	(* must distinguish internal use of productions from use as tokens *)\r	number = tokenFor: num.\r	letter = uppercaseLetter | (charBetween: \"a\" and: \"z\").\r	specialCharacter = (char: \"+\") | (char: \"/\") | (char: \"\\\") | (char: \"*\")\r		| (char: \"~\") | (char: \"<\") | (char: \">\") | (char: \"=\")\r		| (char: \"@\") | (char: \"%\") | (char: \"|\") | (char: \"&\")\r		| (char: \"?\" ) | (char: \"!\") | (char: \",\").\r\r	character = digit | letter | specialCharacter\r		| (char: \"[\"  ) | (char: \"]\"  ) | (char: \"{\" ) | (char: \"}\" )\r		| (char: \"(\"  ) | (char: \")\" ) | (char: \"^\" ) | (char: \";\" )\r		| (char: \"$\" ) | (char: \"#\"  ) | (char: \":\" ) | (char: \".\" )\r		| (char: \"-\") | (char: \"_\") | (char: \"`\") (* the Smalltalk grammar neglects to add - to characters, or to comments. It does add | [self char: $' ], but these are both bugs. We also support underscores, which Squeak insists on turning into assignment arrows. However, we do not support these as assignments. *).\r\r	id = (letter | _), ((letter | digit | _)) star wrapper:\r		[:first :second | String fromRunes: {first}, second asArray].\r\r	public identifier = tokenFor: id.\r\r	charIncludingQuotesAndSpace = character | (char: \"'\" ) | (char: \"\"\" ) | (char: \" \").\r	characterConstant = tokenFor: (char: \"\"\"), charIncludingQuotesAndSpace, (char: \"\"\").\r\r	str = (char: \"'\"), stringBody, (char: \"'\") wrapper:\r		[:oq :es :eq | String fromRunes: es].\r\r	string = tokenFor: str.\r\r	kw = id, (char: \":\") wrapper:\r		[:i :c | i, ':'].\r\r	kwds = kw plus\r		wrap: [:c | c inject: '' into: [:s :e | s, e]].\r\r	public keyword = tokenFor: kw.\r\r	setterKw = kw, (char: \":\")\r		wrapper: [:i :c | i, ':'].\r\r	setterKeyword = tokenFor: setterKw.\r\r	sym = str | kwds | binSel | id.\r	symbol = tokenFor: sym.\r\r	comment = NSCommentParser new.\r\r	binSel = (specialCharacter | (char: \"-\")), specialCharacter star\r		wrapper: [:c1 :c2 |\r		(* probably delay interning as symbol until later phase *)\r		(String fromRunes: {c1}, c2) asSymbol].\r\r	binarySelector = tokenFor: binSel. (* maybe intern as symbol here *)\r\r\r	(* syntactic productions *)\r	symbolConstant = pound, symbol.\r	tuple = lcurly, (expression starSeparatedOrTerminatedBy: dot), rcurly.\r\r	(* patterns *)\r\r	(* adding literals for patterns *)\r	literal = pattern | number | symbolConstant | characterConstant | string | tuple.\r\r	pattern = (tokenFromChar: \"<\"), patternLiteral, (tokenFromChar: \">\").\r	patternLiteral = wildcardPattern | literalPattern | keywordPattern.\r\r	wildcardPattern = tokenFromChar: \"_\".\r\r	(* values which are comparable by means of #= *)\r	literalPattern = tokenFor: number | symbolConstant | characterConstant | string | tuple.\r\r	(* keyword patterns *)\r	keywordPattern = kwPatternPair plus.\r	kwPatternPair = keyword, kwPatternValue opt.\r	kwPatternValue = wildcardPattern | literalPattern | variablePattern | nestedPatternLiteral.\r	variablePattern = tokenFor: ((char: \"?\"), id).\r	nestedPatternLiteral = tokenFor: pattern.\r\r	slotName = identifier.\r	unarySelector = UnarySelectorParser new on: self. (* the one hack/flaw. See UnarySelectorParser for details *)\r\r	parenthesizedExpression = lparen, expression, rparen.\r\r	primary = slotName | literal | block | parenthesizedExpression.\r\r	unaryMsg = eventualSendOperator opt, unarySelector.\r	unaryExpression = primary, unaryMsg star.\r\r	binaryMsg = eventualSendOperator opt, binarySelector, unaryExpression.\r	binaryExpression = unaryExpression, binaryMsg star.\r\r	keywordMsg = eventualSendOperator opt, (keyword, binaryExpression) plus.\r\r	message = keywordMsg | binaryMsg | unaryMsg.\r\r	nontrivialUnaryMessages = unaryMsg plus, binaryMsg star, keywordMsg opt.\r	nontrivialBinaryMessages = binaryMsg plus, keywordMsg opt.\r	keywordMessages = keywordMsg.\r	nonEmptyMessages = nontrivialUnaryMessages | nontrivialBinaryMessages | keywordMessages.\r\r	keywordExpression = binaryExpression, keywordMsg opt.\r\r	keywordHereSend = keywordMsg.\r	cascadeMsg = semicolon, (keywordMsg | binaryMsg | unaryMsg).\r\r	msgCascade = nonEmptyMessages, cascadeMsg star.\r\r	cascadedMessageExpression = primary, msgCascade opt.\r\r	sendExpression = keywordHereSend | cascadedMessageExpression.\r\r	expression = setterKeyword star, sendExpression.\r\r	returnStatement = hat, expression, dot opt.\r\r	furtherStatements = dot, statements.\r	statementSequence = expression, furtherStatements  opt.\r 	statements = returnStatement | statementSequence | empty.\r\r	blockParameter = colon, slotDecl.\r	blockParameters = blockParameter plus, vbar.\r\r	slotDefs = slotDef star.\r	seqSlotDecls = vbar, slotDefs, vbar.\r	simSlotDecls = vbar, vbar, slotDefs, vbar, vbar.\r	slotDecls = simSlotDecls | seqSlotDecls.\r\r	temporaries = slotDecls.\r\r	beginNSComment = (char: \"(\"), (char: \"*\").\r	endNSComment = (char: \"*\"), (char: \")\").\r	keywordAndLiteral = keyword, literal.\r	literalMessage = unaryMsg | keywordAndLiteral plus.\r	literalMessageComment = beginNSComment, (tokenFromSymbol: #':literalmessage:'), whitespace opt, literalMessage, whitespace opt, endNSComment.\r\r	codeBody = (literalMessageComment | comment | whitespace) star, temporaries opt, statements.\r\r	block = lbracket, blockParameters opt, codeBody, rbracket.\r\r	slotDecl = identifier.\r\r	accessModifier =\r		((tokenFromSymbol: #private) |\r		 (tokenFromSymbol: #public) |\r		 (tokenFromSymbol: #protected)), whitespace.\r\r	slotDef = accessModifier opt, slotDecl,\r		(((tokenFromSymbol: #=) | (tokenFromSymbol: #'::=')), expression, dot) opt.\r\r	initExprs = expression starSeparatedOrTerminatedBy: dot.\r\r	unaryMsgPattern = unarySelector.\r	binaryMsgPattern = binarySelector, slotDecl.\r	keywordMsgPattern = (keyword, slotDecl) plus.\r	messagePattern = unaryMsgPattern | binaryMsgPattern | keywordMsgPattern.\r\r	(* Top level productions for classes *)\r	transientModifier = (tokenFromSymbol: #transient), whitespace.\r\r	public transientSlotDecl = accessModifier opt, transientModifier, slotDecl,\r	          ((tokenFromSymbol: #=) |\r	            (tokenFromSymbol: #'::=')\r	           ), expression, dot.\r\r\r      public methodHeader = accessModifier opt, messagePattern.\r	public methodDecl = accessModifier opt, messagePattern, equalSign, lparen, codeBody, rparen.\r\r	optionalFactorySection = messagePattern opt, equalSign.\r\r(* Binding the message pattern for the primary factory to the following equal sign is an odd factoring of the grammar designed to work around some ugly problems.\r\rThe two would naturally be separated in classPrefix below, e.g.,\r\r classPrefix = (tokenFromSymbol: #class), identifier, messagePattern opt, equalSign\r	              superclassClause opt.\r\rAlas, this doesn't work. If the primary factory signature is omitted, the equal sign and following superclass clause is matched. This eventually fails.  Unlike BNF,  the '|' operator  'cuts' at the first successful branch  rather than evaluating all branches in parallel or backtracking, so the message opt is not retried. We'd have to use a more general and expensive BNF style combinator.\r\rOriginally, we split this into two branches - one using a mandatory messagePattern and one with empty (the messagePattern could not simply be dropped, because the arity of the wrapper for each branch would differ).\r\rThis solution seems cleaner.\rAS YET UNTESTED.\r*)\r\r      classReservedWord = tokenFromSymbol: #class.\r\r      classId = identifier.\r\r	classPrefix = classReservedWord, classId, optionalFactorySection, superclassClause opt.\r\r	mixinApplication = classPrefix, inverseMixinOperator, sendExpression.\r\r	classComment = whitespace opt, comment. (* A hack, to preserve comments from a complete class declaration *)\r	sideDecl = lparen, classDecl star, transientSlotDecl star, methodDecl star, rparen.\r	classSideDecl = colon, lparen, methodDecl star, rparen.\r	languageId = identifier.\r	classCategory = string opt.\r\r	superclassClause = superclassPrefix opt, unaryMsg, message opt. (* unaryMsg should be identifier. Parser needs refactoring. *)\r\r	outerReceiver = (tokenFromSymbol: #outer), identifier.\r	superclassPrefix = outerReceiver |\r		(tokenFromSymbol: #self) |\r		(tokenFromSymbol: #super).\r\r	public classHeader =\r		(accessModifier opt, classReservedWord, classId, messagePattern, equalSign,\r		superclassClause opt, lparen, classComment opt,\r		slotDecls opt, initExprs,  rparen) |\r		(accessModifier opt, classReservedWord, classId, empty, equalSign,\r		superclassClause opt, lparen, classComment opt,\r		slotDecls opt,  initExprs, rparen).\r(* A gross hack to allow for a default constructor pattern.  This should at least be refactored (note the awful use of empty to keep the arity the same for the wrappearr in the parser. Ugh).\rIt would be nice to just say messagePattern opt]. Alas, because the '|' operator  'cuts' at the first successful branch  rather than evaluating all branches in parallel or backtracking, this won't work. *)\r\r	public classDeclaration = classHeader, sideDecl, classSideDecl opt.\r\r	inheritanceClause = superclassClause.\r\r	instanceInitializer = lparen, classComment opt, slotDecls opt, initExprs, rparen.\r\r	classBody = instanceInitializer, sideDecl, classSideDecl opt.\r\r	mixinAppSuffix = ((tokenFromSymbol: '<:'), inheritanceClause) plus, (dot | classBody).\r\r	mixinSpec = classBody | mixinAppSuffix.\r\r	explicitInheritanceListAndOrBody = inheritanceClause, mixinSpec.\r\r	defaultSuperclassAndBody = classBody.\r\r	inheritanceListAndOrBody = defaultSuperclassAndBody | explicitInheritanceListAndOrBody.\r\r	public classDecl =\r		(accessModifier opt, classReservedWord, classId, messagePattern, equalSign, inheritanceListAndOrBody) |\r		(accessModifier opt, classReservedWord, classId, empty, equalSign, inheritanceListAndOrBody).\r\r	toplevelClass = classCategory, classDecl.\r	compilationUnit = languageId, toplevelClass, eoi.\r\r	public doItExpression = codeBody, eoi.\r|)",
 "ExecutableGrammar",
 "ExecutableGrammar",
 "_ = (\r	^char: \"_\"\r)",
 "stringBody = (\r(* As an optimization, we process the body of a string with a dedicated scanning parser.\rIt should be equivalent to:\r\r	^(self character | self aWhitespaceChar | (self char: \"\"\" ) | self twoQuotes) star *)\r\r	^CollectingCommentParser new  termBlock:\r		[:input |\r		| c = input peek. |\r		c isNil\r			ifTrue: [false (* let main routine handle end of input *)]\r			ifFalse: [c = 39 (* $' asInteger *)\r				ifFalse: [false]\r				ifTrue: [\r					| pos |\r					pos: input position.\r					input next.\r					input peek = 39\r						ifTrue: [false]\r						ifFalse: [input position: pos. true]]]]\r)",
 "class NSCommentParser = CombinatorialParser (\r(* As an optimization, we handle comments with a dedicated parser. It should be equivalent to:\r\rbeginComment = (char: \"(\"), (char: \"*\" ).\rendComment = (char: \"*\" ), (char: \")\").\rmetadataTag = (char: $:), id, (char: $:).\rany = charBetween: (Character value: 0) and: (Character value: 16r10FFFF).\rcomment = beginComment,\r	metadataTag opt,\r	((endComment not, any) | comment) star,\r	endComment.\r\r*)\r)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public parse: input <ReadStream> inContext: context ifError: blk = (\r	| pos = input position. body = List new. |\r	(input atEnd not and: [input next = 40 (* ( *) and: [input atEnd not and: [input next = 42 (* * *)]]]) ifFalse:\r		[input position: pos.\r		^blk value: '(* expected' value: pos].\r\r	[ | c |\r	input atEnd ifTrue:\r		[input position: pos.\r		^blk value: '(* expected' value: pos].\r	c:: input next.\r	body add: c.\r	c = 40 (* ( *) ifTrue:\r		[ | d |\r		input atEnd ifTrue:\r			[input position: pos.\r			^blk value: '(* expected' value: pos].\r		d:: input next.\r		d = 42 (* * *) ifTrue: [\r			| res |\r			body removeLast. (* not part of comment body *)\r			input position: input position - 2.\r			res:: self parse: input inContext: context ifError:\r				[:msg :pos2 |\r				input position: pos.\r				^blk value: '(* expected 2' value: pos].\r			1 to: res value size do:\r				[:index | body add: (res value runeAt: index)].\r		] ifFalse: [\r			body add: d.\r		]].\r	c = 42 (* * *) ifTrue:\r		[ | d |\r		input atEnd ifTrue:\r			[input position: pos.\r			^blk value: '(* expected' value: pos].\r		d:: input next.\r		d = 41 (* \")\" *) ifTrue: [\r			body removeLast. (* not part of comment body *)\r			^Token\r				value: (String fromRunes: body)\r				start: pos end: input position]\r		ifFalse: [\r			input position: input position - 1. (* Consider next char as possible end star-paren *)\r		]].\r	c = nil ifTrue:\r		[input position: pos.\r		^blk value: '(* expected' value: pos].\r	] repeat.\r)",
 "public class TypedNS3Grammar = NS3Grammar (\r(* A parser for Strongtalk syntax. Adds productions for the Strongtalk type expression sublanguage, and the changes needed to use types in Newsqueak code. *)\r|\r\r	arg = tokenFromSymbol: #arg.\r	for = tokenFromSymbol: #for.\r	generic = tokenFromSymbol: #generic.\r	inheritedTypeOf = tokenFromSymbol: #inheritedTypeOf.\r	is = tokenFromSymbol: #is.\r	mssg = tokenFromSymbol: #message.\r	of = tokenFromSymbol: #of.\r\r	receiverType = tokenFromSymbol: #receiverType.\r	subtypeOf = tokenFromSymbol: #subtypeOf.\r	typeArg = tokenFromSymbol: #typeArg.\r	where = tokenFromSymbol: #where.\r	returnType = hat, type.\r\r	(* Type Grammar *)\r\r	type = langleBracket, typeExpr, rangleBracket.\r	typePrimary = identifier, typeArguments opt.\r	typeFactor = typePrimary | blockType | tupleType | parenthesizedTypeExpression.\r	parenthesizedTypeExpression = lparen, typeExpr, rparen.\r	typeTerm = typeFactor, identifier star.\r	typeExpr = typeTerm, ((vbar | semicolon | slash), typeExpr) opt.\r	typeArguments = lbracket, (typeExpr plusSeparatedBy: comma), rbracket.\r	tupleType = lcurly, (typeExpr starSeparatedBy: dot), rcurly.\r\r 	blockArgType = colon, typeTerm.\r	blockReturnType = typeExpr.\r	nonEmptyBlockArgList = blockArgType plus, (vbar, blockReturnType) opt.\r	blockType = lbracket, (nonEmptyBlockArgList | blockReturnType opt), rbracket.\r\r	(* Type inference *)\r\r	typePattern = langleBracket, typeFormal, (semicolon, typeFormal) star, rangleBracket. (* changed from {} to <> brackets to avoid conflict with tuples *)\r	typeFormal = where, identifier, typeParamConstraint opt, is, inferenceClause.\r	typeParamConstraint = langleBracket, typeBoundQualifier opt, typeExpr, rangleBracket.\r	typeBoundQualifier = subtypeOf | inheritedTypeOf.\r	inferenceClause = receiverType\r		| (returnType, returnTypeInferenceClause)\r		| typeArgInferenceClause\r		| (arg, number, (of, msgSelector) opt).\r	returnTypeInferenceClause = of, msgSelector.\r	msgSelector = symbolConstant, mssg, of, inferenceClause.\r	typeArgInferenceClause = typeArg, number, for, generic, symbolConstant, of, inferenceClause.\r |)",
 "NS3Grammar",
 "NS3Grammar",
 "messagePattern = (\r	^super messagePattern, returnType opt, typePattern opt. (* Type annotations *)\r)",
 "slotDecl = (\r	^super slotDecl , type opt.\r)",
 "class UnarySelectorParser = CombinatorialParser (\r(* In the absence of a separate lexer, an ambiguity arises, which this parser deals with.\r The problem is that when parsing a unary expression that is an argument to a keyword\r message, one expects a unary selector, which is an identifer.  However, it may be that the next\r token is actually a keyword, part of the surrounding message. If we aren't actually tokenizing,\r the prefix of the keyword will be misinterpreted as an identifier and hence as another unary\r message being sent to the argument.\r\r Using a lexer solves this but introduces a subtlety around the assignment operator :=. In that case\r if there is no whitespace between a variable name and the assignment, the variable name will\r be tokenized as a keyword rather than as an identifier. The Strongtalk parser, DeltaParser, deals\r with this specially. In the longterm, that is probably the way to go. *)\r| p |)",
 "CombinatorialParser",
 "CombinatorialParser",
 "public on: s = (\r	p: s.\r)",
 "public parse: input inContext: context ifError: blk = (\r	| pos |\r	pos:: input position.\r	p keyword\r		parse: input inContext: context\r		ifError: [:msg :position |\r			input position: pos.\r			^p identifier parse: input inContext: context ifError: blk].\r	input position: pos.\r	blk value: 'should not print' value: pos\r)",
 "class WorkspaceManagerForV8 usingPlatform: p <Platform> ide: webIde <HopscotchIDE> = (\r(*\rWorkspaces allow convenient live code evaluation in the Newspeak IDE. They provide access to an IDE namespace,\runconstrained by the scope of a single module.  This module implements workspaces in the IDE. It lacks much of\rthe functionality of the Newspeak-on-Squeak workspaces due to the impoverishment of the web platform.\r\rThis is also very much a work in progress. Because we don't yet support adding classes, we rely on the simple expedient of having a single Workspace class without custom subclasses.\r\rCopyright Google Inc.  2017.\r*)\r|\r	(* imports *)\r	private Presenter = p hopscotch core Presenter.\r	private Subject = p hopscotch core Subject.\r	private DefinitionListPresenter = webIde browsing DefinitionListPresenter.\r	private ObjectSubject = webIde browsing ObjectSubject.\r	private List = p collections List.\r	private ObjectMirror = p mirrors ObjectMirror.\r	(* module state *)\r	private workspaces <Map[Symbol, Workspace]> = List new.\r	private workspaceCounter <Integer> ::= 0.\r	private retainedPlatform = p.\r	private ide = webIde.\r	private Root = ide namespacing Root.\r|)",
 " ",
 " ",
 "currentWorkspaceNumberString ^ <String> = (\r	workspaceCounter:: workspaceCounter + 1.\r	^workspaceCounter printString\r)",
 "defaultWorkspaceText ^ <String> = (\r^'(* Workspaces provide access to the system scope,  allowing you to bypass Newspeak''s modularity at development time. You can evaluate the current selection (or the current line if the selection is empty) by pressing [Evaluate]. *)\r\rplatform.\ride.\r\rcopy: ''Hello, Pasty New World!'' (* Place the argument on the system clipboard. *)'\r)",
 "class AllWorkspacesPresenter onSubject: s = DefinitionListPresenter onSubject: s (\r(* This is the top-level presenter displayed when following the Workspaces link from the home page. It displays a list of WorkspacePresenters on all existing workspaces. *)\r)",
 "onSubject: s",
 "onSubject: s",
 "contentPresenters ^ <Collection[Presenter]> = (\r	^subject allWorkspaces collect: [:ws | expandableLineForWorkspace: ws]\r)",
 "definition = (\r	^column: {\r		minorHeadingBlock: (\r			row: {\r				label: 'Workspaces' (*asText allBold*).\r				largeBlank.\r				addButtonWithAction: [respondToAddWorkspace].\r				filler.\r				expandButtonWithAction: [expandAll].\r				blank: 3.\r				collapseButtonWithAction: [collapseAll].\r				blank: 3.\r				dropDownMenu: [workspaceListMenu].\r				largeBlank.\r				homeButton.\r				smallBlank.\r				refreshButton.\r				}\r			).\r		mediumBlank.\r		super definition.\r		mediumBlank.\r	}\r)",
 "expandableLineForWorkspace: ws <Workspace> = (\r	| toggle |\r	toggle::\r		collapsed: [workspaceRowFor: ws]\r		expanded: [\r			(ObjectSubject onModel: (ObjectMirror reflecting: ws)) presenter]\r		initiallyExpanded: workspaces size = 1.\r	(*toggle onUserToggled: [toggle requestVisibility].*)\r	^toggle\r)",
 "presenterRequestsWorkspaceDeletion: workspace <Workspace> = (\r	subject deleteWorkspace: workspace.\r	refresh.\r)",
 "respondToAddWorkspace = (\r	subject addWorkspace.\r	refresh.\r)",
 "respondToDeleteWorkspace: ws <Workspace> = (\r	subject deleteWorkspace: ws.\r	refresh.\r)",
 "workspaceListMenu = (\r	^menuWithLabelsAndActions: {\r		{'Inspect Presenter' . [respondToInspectPresenter]}\r		}\r)",
 "workspaceMenuFor: ws <Workspace> = (\r	^menuWithLabelsAndActions: {\r		{'Delete workspace ', ws class name. [respondToDeleteWorkspace: ws]}\r		}\r)",
 "workspaceRowFor: ws <Workspace> = (\r	^row: {\r		link: ws printString\r		action: [ | s = ObjectSubject onModel: (ObjectMirror reflecting: ws). |\r				enterSubject: s.\r	 ].\r		filler.\r		dropDownMenu: [workspaceMenuFor: ws].\r	}\r)",
 "public class AllWorkspacesSubject onModel: dontCare = Subject onModel: dontCare (\r(* Subject for the list of all workspaces. It is responsible for creating and deleting workspace classes and instances. *)\r)",
 "onModel: dontCare",
 "onModel: dontCare",
 "public = anotherSubject ^<Boolean> = (\r	(* All workspace subjects are considered the same so that clicking the Workspaces link on the home page always takes us to the same page instead of multiplying them. *)\r	^anotherSubject isKindOfWorkspaceSubject\r)",
 "public addWorkspace = (\r	| ws <Workspace> |\r	ws:: Workspace new.\r	(* ws workspaceText: defaultWorkspaceText.*)\r	workspaces add: ws.\r)",
 "public allWorkspaces ^ <Collection[Workspace]> = (\r	(* Ensure there is always a workspace to work with. *)\r	workspaces isEmpty ifTrue: [addWorkspace].\r	^workspaces\r)",
 "public createPresenter ^ <AllWorkspacesPresenter> = (\r	^AllWorkspacesPresenter onSubject: self\r)",
 "public deleteWorkspace: ws <Workspace> = (\r	workspaces remove: ws.\r)",
 "public hash ^<Integer> = (\r	^self class hash\r)",
 "public isKindOfWorkspaceSubject ^ <Boolean> = (\r	^true\r)",
 "public title ^<String> = (\r	^'Workspaces'\r)",
 "public new = (\r(* An AllWorkspacesSubject always has its module as its model. This method is a dummy to satisfy the requirements of the Subject class protocol. Hence it doesn't care about the formal parameter  'dontCare'. *)\r	^onModel: nil\r)",
 "public class Workspace = (\r(* The superclass of workspaces. *)\r|\rpublic workspaceText\r|)",
 " ",
 " ",
 "public actors = (^retainedPlatform actors)",
 "public aliens = (^retainedPlatform aliens)",
 "public class = (\r	^super class\r)",
 "public collections = (^retainedPlatform collections)",
 "protected doesNotUnderstand: message = (\r	^Root\r		at: message selector\r		ifAbsent: [super doesNotUnderstand: message]\r)",
 "public files = (^retainedPlatform files)",
 "public findInSource: stringOrRegex = (\r	stringOrRegex isKindOfString ifFalse: [unimplemented].\r	^methods select: [:method | method getSource includesSubString: stringOrRegex].\r)",
 "public graphics = (^retainedPlatform graphics)",
 "public hopscotch = (^retainedPlatform hopscotch)",
 "public ide ^ <HopscotchWebIDE> = (\r	^outer WorkspaceManagerForV8 ide\r)",
 "public kernel = (^retainedPlatform kernel)",
 "public mirrors = (^retainedPlatform mirrors)",
 "platform ^ <Platform> = (\r	^retainedPlatform\r)",
 "public streams = (^retainedPlatform streams)",
 "public text = (\r	^retainedPlatform text\r)",
 "class AccessModifierTesting usingPlatform: platform  testFramework: minitest = (|\r	private TestContext = minitest TestContext.\r	private ClassMirror = platform mirrors ClassMirror.\r	private MessageNotUnderstood = platform kernel MessageNotUnderstood.\r|)",
 " ",
 " ",
 "public class ClassAccessingTests = TestContext (\r(*	Try to access classes with different access modifiers, but only via public send.\r	 Class access is implemented via accessor methods - so fetching a class falls back to finding the appropriate method.\r	All kind of different method sends are already tested in the MethodAcessingTests. *)\r|\r	testSubjects = TestSubjects new.\r|)",
 "TestContext",
 "TestContext",
 "public testPrivateClassAccess = (\r	should: [testSubjects APrivateClass] signal: MessageNotUnderstood.\r)",
 "public testProtectedClassAccess = (\r	should: [testSubjects AProtectedClass] signal: MessageNotUnderstood.\r)",
 "public testPublicClassAccess = (\r	assert: testSubjects APublicClass new ping = #pong.\r)",
 "public testPublicClassAccess2 = (\r	testSubjects AClass\r)",
 "TEST_CONTEXT = ()",
 "public class JITTests = TestContext ()",
 "TestContext",
 "TestContext",
 "public testImplicitReceiverMNU = (\r	| aImplicitReceiverMnu = ImplicitReceiverMNU new. |\r	10 timesRepeat:\r		[assert: aImplicitReceiverMnu sendSuperFoo equals: #ImplicitReceiverMNUSuper].\r)",
 "public testOuterMNU = (\r	| anInner = OuterMNU new Inner new. |\r	10 timesRepeat:\r		[assert: anInner sendOuterFoo equals: #OuterMNUSuper].\r)",
 "public testPolymorphicSuper = (\r	| d1 = D1 new. d2 = D2 new. d3 = D3 new. |\r	10 timesRepeat:\r		[assert: d1 superFoo equals: 'A'.\r		assert: d2 superFoo equals: 'A'.\r		assert: d3 superFoo equals: 'A'].\r)",
 "public testSelfMNU = (\r	| aSelfMnu = SelfMNU new. |\r	10 timesRepeat:\r		[assert: aSelfMnu sendSelfFoo equals: #SelfMNUSuper].\r)",
 "public testSuperMNU = (\r	| aSuperMnu = SuperMNU new. |\r	10 timesRepeat:\r		[assert: aSuperMnu sendSuperFoo equals: #SuperMNUSuper].\r)",
 "class A = ()",
 " ",
 " ",
 "protected foo = (\r	^'A'\r)",
 "class B = A ()",
 "A",
 "A",
 "private foo = (\r	^'B'\r)",
 "class C = B ()",
 "B",
 "B",
 "public foo = (\r	^'C'\r)",
 "public superFoo = (\r	^super foo\r)",
 "class D1 = C ()",
 "C",
 "C",
 "public foo = (\r	^'D1'\r)",
 "class D2 = C ()",
 "C",
 "C",
 "public foo = (\r	^'D2'\r)",
 "class D3 = C ()",
 "C",
 "C",
 "public foo = (\r	^'D3'\r)",
 "class ImplicitReceiverMNU = ImplicitReceiverMNUSuper (\r)",
 "ImplicitReceiverMNUSuper",
 "ImplicitReceiverMNUSuper",
 "private result = (\r	^#ImplicitReceiverMNU.\r)",
 "public sendImplicitReceiverFoo = (\r	^foo\r)",
 "class ImplicitReceiverMNUSuper = (\r)",
 " ",
 " ",
 "doesNotUnderstand: message = (\r	^result\r)",
 "private result = (\r	^#ImplicitReceiverMNUSuper.\r)",
 "class OuterMNU = OuterMNUSuper (\r)",
 "OuterMNUSuper",
 "OuterMNUSuper",
 "private result = (\r	^#OuterMNU.\r)",
 "public class Inner = ()",
 " ",
 " ",
 "public sendOuterFoo = (\r	^outer OuterMNU foo\r)",
 "class OuterMNUSuper = (\r)",
 " ",
 " ",
 "doesNotUnderstand: message = (\r	^result (* This implicit receiver send will crash if the method receiver is wrong. *)\r)",
 "private result = (\r	^#OuterMNUSuper.\r)",
 "class SelfMNU = SelfMNUSuper (\r)",
 "SelfMNUSuper",
 "SelfMNUSuper",
 "private result = (\r	^#SelfMNU\r)",
 "public sendSelfFoo = (\r	^self foo\r)",
 "class SelfMNUSuper = (\r)",
 " ",
 " ",
 "doesNotUnderstand: message = (\r	^result\r)",
 "private result = (\r	^#SelfMNUSuper\r)",
 "class SuperMNU = SuperMNUSuper (\r)",
 "SuperMNUSuper",
 "SuperMNUSuper",
 "private result = (\r	^#SuperMNU\r)",
 "public sendSuperFoo = (\r	^super foo\r)",
 "class SuperMNUSuper = (\r)",
 " ",
 " ",
 "doesNotUnderstand: message = (\r	^result\r)",
 "private result = (\r	^#SuperMNUSuper\r)",
 "TEST_CONTEXT = ()",
 "public class MethodAccessingTests = TestContext (\r(* Test access to methods with different access modifiers *)\r|\r	testSubjects = TestSubjects new.\r|)",
 "TestContext",
 "TestContext",
 "public testDefaultImplicitReceiverSend = (\r	(* send a message via an implicitReceiverSend which goes to a method with default access modifier *)\r	assert: testSubjects ASubClass new ASubInnerClass new defaultImplicitReceiverSend = #defaultImplicitReceiverTarget.\r)",
 "public testDefaultImplicitReceiverSendWithInheritance = (\r	(* send a message via implicitReceiverSend which goes to a method with default access modifier with inheritance *)\r	assert: testSubjects ASubClass new defaultImplicitReceiverSendWithInheritance = #defaultMethod.\r)",
 "public testDefaultOuterSend = (\r	(* send a message via an outerSend which goes to a method with default access modifier *)\r	assert: testSubjects AClass new AInnerClass new outerDefaultMethod = #defaultMethod.\r)",
 "public testDefaultOuterSendWithInheritance = (\r	(* send a message via an outerSend which goes to a method with default access modifier via inheritance *)\r	assert: testSubjects ASubClass new ASubInnerClass new defaultOuterSendWithInheritance = #defaultMethod.\r)",
 "public testDefaultPublicSend = (\r	(* send a message via publicSend which goes to a method with default access modifier *)\r	should: [testSubjects AClass new defaultMethod] signal: MessageNotUnderstood.\r)",
 "public testDefaultPublicSendWithInheritance = (\r	(* send a message via publicSend which goes to a method with default access modifier in the super chain *)\r	should: [testSubjects ASubClass new defaultMethod] signal: MessageNotUnderstood.\r)",
 "public testDefaultSelfSend = (\r	(* send a message via selfSend which goes to a method with default access modifier *)\r	assert: testSubjects AClass new selfDefaultMethod = #defaultMethod.\r)",
 "public testDefaultSelfSendWithInheritance = (\r	(* send a message via selfSend which goes to a method with default access modifier in the super chain *)\r	assert: testSubjects ASubClass new selfDefaultMethod = #defaultMethod.\r)",
 "public testDefaultSuperSend = (\r	(* send a message via superSend which goes to a method with default access modifier *)\r	assert: testSubjects ASubClass new superDefaultMethod = #defaultMethod.\r)",
 "public testImplicitPrivateOverriddenByProtected = (\r	assert: testSubjects AClass new AInnerClass new implicitPrivateOverriddenByProtected\r	equals: #private.\r	assert: testSubjects ASubClass new AInnerClass new implicitPrivateOverriddenByProtected\r	equals: #private.\r)",
 "public testImplicitPrivateOverriddenByPublic = (\r	assert: testSubjects AClass new AInnerClass new implicitPrivateOverriddenByPublic\r	equals: #private.\r	assert: testSubjects ASubClass new AInnerClass new implicitPrivateOverriddenByPublic\r	equals: #private.\r)",
 "public testImplicitProtectedOverriddenByPrivate = (\r	assert: testSubjects AClass new AInnerClass new implicitProtectedOverriddenByPrivate\r	equals: #protected.\r	assert: testSubjects ASubClass new AInnerClass new implicitProtectedOverriddenByPrivate\r	equals: #protected.\r)",
 "public testImplicitProtectedOverriddenByPublic = (\r	assert: testSubjects AClass new AInnerClass new implicitProtectedOverriddenByPublic\r	equals: #protected.\r	assert: testSubjects ASubClass new AInnerClass new implicitProtectedOverriddenByPublic\r	equals: #public.\r)",
 "public testImplicitPublicOverriddenByPrivate = (\r	assert: testSubjects AClass new AInnerClass new implicitPublicOverriddenByPrivate\r	equals: #public.\r	assert: testSubjects ASubClass new AInnerClass new implicitPublicOverriddenByPrivate\r	equals: #public.\r)",
 "public testImplicitPublicOverriddenByProtected = (\r	assert: testSubjects AClass new AInnerClass new implicitPublicOverriddenByProtected\r	equals: #public.\r	assert: testSubjects ASubClass new AInnerClass new implicitPublicOverriddenByProtected\r	equals: #protected.\r)",
 "public testObjectEncapsulationPrivate = (\r	| sharedClass = testSubjects AClass. |\r	should: [ sharedClass new callPrivateMethodOn: sharedClass new ]\r	signal: MessageNotUnderstood.\r)",
 "public testObjectEncapsulationProtected = (\r	| sharedClass = testSubjects AClass. |\r	should: [ sharedClass new callProtectedMethodOn: sharedClass new ]\r	signal: MessageNotUnderstood.\r)",
 "public testOrdinaryPrivateOverriddenByProtected = (\r	should: [testSubjects ASubClass new privateOverriddenByProtected]\r	signal: MessageNotUnderstood.\r)",
 "public testOrdinaryPrivateOverriddenByPublic = (\r	assert: testSubjects ASubClass new privateOverriddenByPublic\r	equals: #public.\r)",
 "public testOrdinaryProtectedOverriddenByPrivate = (\r	should: [testSubjects ASubClass new protectedOverriddenByPrivate]\r	signal: MessageNotUnderstood.\r)",
 "public testOrdinaryProtectedOverriddenByPublic = (\r	assert: testSubjects ASubClass new protectedOverriddenByPublic\r	equals: #public.\r)",
 "public testOrdinaryPublicOverriddenByPrivate = (\r	assert: testSubjects ASubClass new publicOverriddenByPrivate\r	equals: #public.\r)",
 "public testOrdinaryPublicOverriddenByProtected = (\r	should: [testSubjects ASubClass new publicOverriddenByProtected]\r	signal: MessageNotUnderstood.\r)",
 "public testOuterPrivateOverriddenByProtected = (\r	assert: testSubjects AClass new AInnerClass new outerPrivateOverriddenByProtected\r	equals: #private.\r	assert: testSubjects ASubClass new AInnerClass new outerPrivateOverriddenByProtected\r	equals: #private.\r)",
 "public testOuterPrivateOverriddenByPublic = (\r	assert: testSubjects AClass new AInnerClass new outerPrivateOverriddenByPublic\r	equals: #private.\r	assert: testSubjects ASubClass new AInnerClass new outerPrivateOverriddenByPublic\r	equals: #private.\r)",
 "public testOuterProtectedOverriddenByPrivate = (\r	assert: testSubjects AClass new AInnerClass new outerProtectedOverriddenByPrivate\r	equals: #protected.\r	assert: testSubjects ASubClass new AInnerClass new outerProtectedOverriddenByPrivate\r	equals: #protected.\r)",
 "public testOuterProtectedOverriddenByPublic = (\r	assert: testSubjects AClass new AInnerClass new outerProtectedOverriddenByPublic\r	equals: #protected.\r	assert: testSubjects ASubClass new AInnerClass new outerProtectedOverriddenByPublic\r	equals: #public.\r)",
 "public testOuterPublicOverriddenByPrivate = (\r	assert: testSubjects AClass new AInnerClass new outerPublicOverriddenByPrivate\r	equals: #public.\r	assert: testSubjects ASubClass new AInnerClass new outerPublicOverriddenByPrivate\r	equals: #public.\r)",
 "public testOuterPublicOverriddenByProtected = (\r	assert: testSubjects AClass new AInnerClass new outerPublicOverriddenByProtected\r	equals: #public.\r	assert: testSubjects ASubClass new AInnerClass new outerPublicOverriddenByProtected\r	equals: #protected.\r)",
 "public testOverriddenMethodInASubInnerClassClassViaImplicitReceiverSend = (\r	assert: testSubjects ASubClass new callOverriddenMethod = #privateOverriddenMethod.\r)",
 "public testOverriddenMethodInInnerClassPublicSend = (\r	assert: testSubjects ASubClass new overriddenMethod equals: #overriddenMethod\r)",
 "public testOverriddenMethodInSuperClassViaImplicitReceiverSend = (\r	assert: testSubjects AClass new AInnerClass new callHiddenMethod = #privateHiddenMethod.\r)",
 "public testOverriddenMethodInSuperClassViaPublicSend = (\r	should: [testSubjects AClass new AInnerClass new hiddenMethod] signal: MessageNotUnderstood.\r)",
 "public testPrivateDoesNotUnderstand = (\r	assert: testSubjects WithPrivateDNU new foo\r	equals: #privateDNU.\r)",
 "public testPrivateImplicitReceiverSend = (\r	(* send a message via implicitReceiverSend which goes to a private method *)\r	assert: testSubjects ASubClass new ASubInnerClass new privateImplicitReceiverSend = #privateImplicitReceiverTarget.\r)",
 "public testPrivateImplicitReceiverSendWithInheritance = (\r	(* send a message via implicitReceiverSend which goes to a private method via inheritance *)\r	should: [testSubjects ASubClass new privateImplicitReceiverSendWithInheritance] signal: MessageNotUnderstood.\r)",
 "public testPrivateOuterSend = (\r	(* send a message via outerSend which goes to a private method *)\r	assert: testSubjects AClass new AInnerClass new outerPrivateMethod = #privateMethod.\r)",
 "public testPrivateOuterSendWithInheritance = (\r	(* send a message via outerSend which goes to a private method via inheritance *)\r	should: [testSubjects ASubClass new ASubInnerClass new privateOuterSendWithInheritance] signal: MessageNotUnderstood.\r)",
 "public testPrivatePublicSend = (\r	(* send a message via publicSend which goes to a private method *)\r	should: [testSubjects AClass new privateMethod] signal: MessageNotUnderstood.\r)",
 "public testPrivatePublicSendWithInheritance = (\r	(* send a message via publicSend which goes to a private method in the super chain *)\r	should: [testSubjects ASubClass new privateMethod] signal: MessageNotUnderstood.\r)",
 "public testPrivateSelfSend = (\r	(* send a message via selfSend which goes to a private method*)\r	assert: testSubjects AClass new selfPrivateMethod = #privateMethod.\r)",
 "public testPrivateSelfSendwithInheritance = (\r	(* send a message via selfSend which goes to a private method in the super chain *)\r	should: [ testSubjects ASubClass new selfPrivateMethod ] signal: MessageNotUnderstood.\r)",
 "public testPrivateSuperSend = (\r	(* send a message via superSend which goes to a private method *)\r	should: [ testSubjects ASubClass new superPrivateMethod ] signal: MessageNotUnderstood.\r)",
 "public testProtectedImplicitReceiverSend = (\r	(* send a message via implicitReceiverSend which goes to a protected method *)\r	assert: testSubjects ASubClass new ASubInnerClass new protectedImplicitReceiverSend = #protectedImplicitReceiverTarget.\r)",
 "public testProtectedImplicitReceiverSendWithInheritance = (\r	(* send a message via implicitReceiverSend which goes to a protected method via inheritance *)\r	assert: testSubjects ASubClass new protectedImplicitReceiverSendWithInheritance = #protectedMethod.\r)",
 "public testProtectedOuterSend = (\r	(* send a message via outerSend which goes to a protected method *)\r	assert: testSubjects AClass new AInnerClass new outerProtectedMethod = #protectedMethod.\r)",
 "public testProtectedOuterSendWithInheritance = (\r	(* send a message via outerSend which goes to a protected method via inheritance *)\r	assert: testSubjects ASubClass new ASubInnerClass new protectedOuterSendWithInheritance = #protectedMethod.\r)",
 "public testProtectedPublicSend = (\r	(* send a message via publicSend which goes to a protected method *)\r	should: [testSubjects AClass new protectedMethod] signal: MessageNotUnderstood.\r)",
 "public testProtectedPublicSendWithInheritance = (\r	(* send a message via publicSend which goes to a protected method in the super chain *)\r	should: [testSubjects ASubClass new protectedMethod] signal: MessageNotUnderstood.\r)",
 "public testProtectedSelfSend = (\r	(* send a message via selfSend which goes to a protected method*)\r	assert: testSubjects AClass new selfProtectedMethod = #protectedMethod.\r)",
 "public testProtectedSelfSendWithInheritance = (\r	(* send a message via selfSend which goes to a protected method in the super chain *)\r	assert: testSubjects ASubClass new selfProtectedMethod = #protectedMethod.\r)",
 "public testProtectedSuperSend = (\r	(* send a message via superSend which goes to a protected method *)\r	assert: testSubjects ASubClass new superProtectedMethod = #protectedMethod.\r)",
 "public testPublicImplicitReceiverSend = (\r	(* send a message via implicitReceiverSend which goes to a public method *)\r	assert: testSubjects ASubClass new ASubInnerClass new publicImplicitReceiverSend = #publicImplicitReceiverTarget.\r)",
 "public testPublicImplicitReceiverSendWithInheritance = (\r	(* send a message via implicitReceiverSend which goes to a public method via inheritance *)\r	assert: testSubjects ASubClass new publicImplicitReceiverSendWithInheritance = #publicMethod.\r)",
 "public testPublicOuterSend = (\r	(* send a message via outerSend which goes to a public method *)\r	assert: testSubjects AClass new AInnerClass new outerPublicMethod = #publicMethod.\r)",
 "public testPublicOuterSendWithInheritance = (\r	(* send a message via outerSend which goes to a public method via inheritance *)\r	assert: testSubjects ASubClass new ASubInnerClass new publicOuterSendWithInheritance = #publicMethod.\r)",
 "public testPublicPublicSend = (\r	(* send a message via publicSend which goes to a public method *)\r	assert: testSubjects AClass new publicMethod = #publicMethod.\r)",
 "public testPublicPublicSendWithInheritance = (\r	(* send a message via publicSend which goes to a public method in the super chain *)\r	assert: testSubjects ASubClass new publicMethod = #publicMethod.\r)",
 "public testPublicSelfSend = (\r	(* send a message via selfSend which goes to a public method*)\r	assert: testSubjects AClass new selfPublicMethod = #publicMethod.\r)",
 "public testPublicSelfSendWithInheritance = (\r	(* send a message via selfSend which goes to a public method in the super chain *)\r	assert: testSubjects ASubClass new selfPublicMethod = #publicMethod.\r)",
 "public testPublicSuperSend = (\r	(* send a message via superSend which goes to a public method *)\r	assert: testSubjects ASubClass new superPublicMethod = #publicMethod.\r)",
 "public testSelfPrivateOverriddenByProtected = (\r	assert: testSubjects ASubClass new selfPrivateOverriddenByProtected\r	equals: #private.\r	assert: testSubjects ASubClass new selfFromSubPrivateOverriddenByProtected\r	equals: #protected.\r)",
 "public testSelfPrivateOverriddenByPublic = (\r	assert: testSubjects ASubClass new selfPrivateOverriddenByPublic\r	equals: #private.\r	assert: testSubjects ASubClass new selfFromSubPrivateOverriddenByPublic\r	equals: #public.\r)",
 "public testSelfProtectedOverriddenByPrivate = (\r	assert: testSubjects ASubClass new selfProtectedOverriddenByPrivate\r	equals: #protected.\r	assert: testSubjects ASubClass new selfFromSubProtectedOverriddenByPrivate\r	equals: #private.\r)",
 "public testSelfProtectedOverriddenByPublic = (\r	assert: testSubjects ASubClass new selfProtectedOverriddenByPublic\r	equals: #public.\r	assert: testSubjects ASubClass new selfFromSubProtectedOverriddenByPublic\r	equals: #public.\r)",
 "public testSelfPublicOverriddenByPrivate = (\r	assert: testSubjects ASubClass new selfPublicOverriddenByPrivate\r	equals: #public.\r	assert: testSubjects ASubClass new selfFromSubPublicOverriddenByPrivate\r	equals: #private.\r)",
 "public testSelfPublicOverriddenByProtected = (\r	assert: testSubjects ASubClass new selfPublicOverriddenByProtected\r	equals: #protected.\r	assert: testSubjects ASubClass new selfFromSubPublicOverriddenByProtected\r	equals: #protected.\r)",
 "public testSuperPrivateOverriddenByProtected = (\r	should: [testSubjects ASubClass new superFromSubPrivateOverriddenByProtected]\r	signal: MessageNotUnderstood.\r)",
 "public testSuperPrivateOverriddenByPublic = (\r	should: [testSubjects ASubClass new superFromSubPrivateOverriddenByPublic]\r	signal: MessageNotUnderstood.\r)",
 "public testSuperProtectedOverriddenByPrivate = (\r	assert: testSubjects ASubClass new superFromSubProtectedOverriddenByPrivate\r	equals: #protected.\r)",
 "public testSuperProtectedOverriddenByPublic = (\r	assert: testSubjects ASubClass new superFromSubProtectedOverriddenByPublic\r	equals: #protected.\r)",
 "public testSuperPublicOverriddenByPrivate = (\r	assert: testSubjects ASubClass new superFromSubPublicOverriddenByPrivate\r	equals: #public.\r)",
 "public testSuperPublicOverriddenByProtected = (\r	assert: testSubjects ASubClass new superFromSubPublicOverriddenByProtected\r	equals: #public.\r)",
 "TEST_CONTEXT = ()",
 "public class SlotAccessingTests = TestContext (\r(*	Try to access slots with different access modifiers, but only via public send.\r	 Slot access is implemented via accessor methods - so fetching a slot falls back to finding the appropriate method.\r	All kind of different method sends are already tested in the MethodAcessingTests. *)\r|\r	testSubjects = TestSubjects new.\r|)",
 "TestContext",
 "TestContext",
 "public testDefaultSlotAccess = (\r	should: [testSubjects AClass new defaultSlot] signal: MessageNotUnderstood.\r)",
 "public testPrivateSlotAccess = (\r	should: [testSubjects AClass new privateSlot] signal: MessageNotUnderstood.\r)",
 "public testProtectedSlotAccess = (\r	should: [testSubjects AClass new protectedSlot] signal: MessageNotUnderstood.\r)",
 "public testPublicSlotAccess = (\r	assert: testSubjects AClass new publicSlot = #publicSlot.\r)",
 "TEST_CONTEXT = ()",
 "public class TestSubjects = (\r(* Holds a bunch of classes which we test against *)\r)",
 " ",
 " ",
 "public class AClass = (\r(* A class with a default access modifier. Slots and methods of all sort to be tested against *)\r|\r	public		publicSlot		= #publicSlot.\r	protected	protectedSlot	= #protectedSlot.\r	private		privateSlot		= #privateSlot.\r				defaultSlot		= #defaultSlot.\r|)",
 " ",
 " ",
 "public callPrivateMethodOn: other = (\r	^other privateMethod\r)",
 "public callProtectedMethodOn: other = (\r	^other protectedMethod\r)",
 "defaultMethod = (\r	^#defaultMethod\r)",
 "public hiddenMethod = (\r	(*	This is a public method which is hidden by an inner class.\r		This should never be executed when called from the inner class via implicit receiver send. *)\r	^#hiddenMethod\r)",
 "public overriddenMethod = (\r	(*	This is a public method which is overridden by a subclass.\r		This should never be executed when called from the subclass via implicit receiver send. *)\r	^#overriddenMethod\r)",
 "private privateMethod = (\r	^#privateMethod\r)",
 "private privateOverriddenByProtected = (\r	^#private\r)",
 "private privateOverriddenByPublic = (\r	^#private\r)",
 "protected protectedMethod = (\r	^#protectedMethod\r)",
 "protected protectedOverriddenByPrivate = (\r	^#protected\r)",
 "protected protectedOverriddenByPublic = (\r	^#protected\r)",
 "public publicMethod = (\r	^#publicMethod\r)",
 "public publicOverriddenByPrivate = (\r	^#public\r)",
 "public publicOverriddenByProtected = (\r	^#public\r)",
 "public selfDefaultMethod = (\r	^self defaultMethod\r)",
 "public selfPrivateMethod = (\r	^self privateMethod\r)",
 "public selfPrivateOverriddenByProtected = (\r	^self privateOverriddenByProtected\r)",
 "public selfPrivateOverriddenByPublic = (\r	^self privateOverriddenByPublic\r)",
 "public selfProtectedMethod = (\r	^self protectedMethod\r)",
 "public selfProtectedOverriddenByPrivate = (\r	^self protectedOverriddenByPrivate\r)",
 "public selfProtectedOverriddenByPublic = (\r	^self protectedOverriddenByPublic\r)",
 "public selfPublicMethod = (\r	^self publicMethod\r)",
 "public selfPublicOverriddenByPrivate = (\r	^self publicOverriddenByPrivate\r)",
 "public selfPublicOverriddenByProtected = (\r	^self publicOverriddenByProtected\r)",
 "public class AInnerClass = (\r(* A class to test outerSends with different accessModifiers.*)\r|\r	public		publicSlot		= #innerPublicSlot.\r	protected	protectedSlot	= #innerProtectedSlot.\r	private		privateSlot		= #innerPrivateSlot.\r				defaultSlot		= #innerDefaultSlot.\r|)",
 " ",
 " ",
 "public callHiddenMethod = (\r	^hiddenMethod\r)",
 "defaultMethod = (\r	^#innerDefaultMethod\r)",
 "private hiddenMethod = (\r	(*	This is a private method which hides a method with the same signature from an outer class.\r		The outer method should never be executed when called from an instance of this class via implicit receiver send. *)\r	^#privateHiddenMethod\r)",
 "public implicitPrivateOverriddenByProtected = (\r	^privateOverriddenByProtected\r)",
 "public implicitPrivateOverriddenByPublic = (\r	^privateOverriddenByPublic\r)",
 "public implicitProtectedOverriddenByPrivate = (\r	^protectedOverriddenByPrivate\r)",
 "public implicitProtectedOverriddenByPublic = (\r	^protectedOverriddenByPublic\r)",
 "public implicitPublicOverriddenByPrivate = (\r	^publicOverriddenByPrivate\r)",
 "public implicitPublicOverriddenByProtected = (\r	^publicOverriddenByProtected\r)",
 "public outerDefaultMethod = (\r	^outer AClass defaultMethod\r)",
 "public outerPrivateMethod = (\r	^outer AClass privateMethod\r)",
 "public outerPrivateOverriddenByProtected = (\r	^outer AClass privateOverriddenByProtected\r)",
 "public outerPrivateOverriddenByPublic = (\r	^outer AClass privateOverriddenByPublic\r)",
 "public outerProtectedMethod = (\r	^outer AClass protectedMethod\r)",
 "public outerProtectedOverriddenByPrivate = (\r	^outer AClass protectedOverriddenByPrivate\r)",
 "public outerProtectedOverriddenByPublic = (\r	^outer AClass protectedOverriddenByPublic\r)",
 "public outerPublicMethod = (\r	^outer AClass publicMethod\r)",
 "public outerPublicOverriddenByPrivate = (\r	^outer AClass publicOverriddenByPrivate\r)",
 "public outerPublicOverriddenByProtected = (\r	^outer AClass publicOverriddenByProtected\r)",
 "private privateMethod = (\r	^#innerPrivateMethod\r)",
 "protected protectedMethod = (\r	^#innerProtectedMethod\r)",
 "public publicMethod = (\r	^#innerPublicMethod\r)",
 "private class APrivateClass = ()",
 " ",
 " ",
 "class AProtectedClass = ()",
 " ",
 " ",
 "public class APublicClass = ()",
 " ",
 " ",
 "public ping = (\r	^#pong\r)",
 "public class ASubClass = AClass (\r(* A class to test access to inherited slots/methods *)\r)",
 "AClass",
 "AClass",
 "public callOverriddenMethod = (\r	^overriddenMethod\r)",
 "public defaultImplicitReceiverSendWithInheritance = (\r	^defaultMethod\r)",
 "private overriddenMethod = (\r	(*	This is a private method which overrides a method with the same signature from a super class.\r		The super method should never be executed when called from an instance of this class via implicit receiver send. *)\r	^#privateOverriddenMethod\r)",
 "public privateImplicitReceiverSendWithInheritance = (\r	^privateMethod\r)",
 "protected privateOverriddenByProtected = (\r	^#protected\r)",
 "public privateOverriddenByPublic = (\r	^#public\r)",
 "public protectedImplicitReceiverSendWithInheritance = (\r	^protectedMethod\r)",
 "private protectedOverriddenByPrivate = (\r	^#private\r)",
 "public protectedOverriddenByPublic = (\r	^#public\r)",
 "public publicImplicitReceiverSendWithInheritance = (\r	^publicMethod\r)",
 "private publicOverriddenByPrivate = (\r	^#private\r)",
 "protected publicOverriddenByProtected = (\r	^#protected\r)",
 "public selfDefaultMethod = (\r	^self defaultMethod\r)",
 "public selfFromSubPrivateOverriddenByProtected = (\r	^self privateOverriddenByProtected\r)",
 "public selfFromSubPrivateOverriddenByPublic = (\r	^self privateOverriddenByPublic\r)",
 "public selfFromSubProtectedOverriddenByPrivate = (\r	^self protectedOverriddenByPrivate\r)",
 "public selfFromSubProtectedOverriddenByPublic = (\r	^self protectedOverriddenByPublic\r)",
 "public selfFromSubPublicOverriddenByPrivate = (\r	^self publicOverriddenByPrivate\r)",
 "public selfFromSubPublicOverriddenByProtected = (\r	^self publicOverriddenByProtected\r)",
 "public selfPrivateMethod = (\r	^self privateMethod\r)",
 "public selfProtectedMethod = (\r	^self protectedMethod\r)",
 "public selfPublicMethod = (\r	^self publicMethod\r)",
 "public superDefaultMethod = (\r	^super defaultMethod\r)",
 "public superFromSubPrivateOverriddenByProtected = (\r	^super privateOverriddenByProtected\r)",
 "public superFromSubPrivateOverriddenByPublic = (\r	^super privateOverriddenByPublic\r)",
 "public superFromSubProtectedOverriddenByPrivate = (\r	^super protectedOverriddenByPrivate\r)",
 "public superFromSubProtectedOverriddenByPublic = (\r	^super protectedOverriddenByPublic\r)",
 "public superFromSubPublicOverriddenByPrivate = (\r	^super publicOverriddenByPrivate\r)",
 "public superFromSubPublicOverriddenByProtected = (\r	^super publicOverriddenByProtected\r)",
 "public superPrivateMethod = (\r	^super privateMethod\r)",
 "public superProtectedMethod = (\r	^super protectedMethod\r)",
 "public superPublicMethod = (\r	^super publicMethod\r)",
 "public class ASubInnerClass = (\r(* A Class to test outerSends in combination with inheritance *)\r|\r				defaultImplicitReceiverTarget		= #defaultImplicitReceiverTarget.\r	public		publicImplicitReceiverTarget		= #publicImplicitReceiverTarget.\r	protected	protectedImplicitReceiverTarget	= #protectedImplicitReceiverTarget.\r	private		privateImplicitReceiverTarget		= #privateImplicitReceiverTarget.\r|)",
 " ",
 " ",
 "public defaultImplicitReceiverSend = (\r	^defaultImplicitReceiverTarget\r)",
 "public defaultOuterSendWithInheritance = (\r	^outer ASubClass defaultMethod\r)",
 "public privateImplicitReceiverSend = (\r	^privateImplicitReceiverTarget\r)",
 "public privateOuterSendWithInheritance = (\r	^outer ASubClass privateMethod\r)",
 "public protectedImplicitReceiverSend = (\r	^protectedImplicitReceiverTarget\r)",
 "public protectedOuterSendWithInheritance = (\r	^outer ASubClass protectedMethod\r)",
 "public publicImplicitReceiverSend = (\r	^publicImplicitReceiverTarget\r)",
 "public publicOuterSendWithInheritance = (\r	^outer ASubClass publicMethod\r)",
 "public class WithPrivateDNU = ()",
 " ",
 " ",
 "private doesNotUnderstand: message = (\r	^#privateDNU\r)",
 "class AccessModifierTestingConfiguration packageTestsUsing: manifest = (|\rprivate AccessModifierTesting = manifest AccessModifierTesting.\r|)",
 " ",
 " ",
 "public testModulesUsingPlatform: platform minitest: minitest = (\r	^{AccessModifierTesting\r		usingPlatform: platform\r		testFramework: minitest}\r)",
 "class KernelTests usingPlatform: p minitest: m = (|\rprivate TestContext = m TestContext.\rprivate MessageNotUnderstood = p kernel MessageNotUnderstood.\rprivate Exception = p kernel Exception.\rprivate Stopwatch = p kernel Stopwatch.\rprivate List = p collections List.\r|)",
 " ",
 " ",
 "largestNegativeLargeInteger = (\r	(* -1 << 63 - 1 *)\r	^-9223372036854775809\r)",
 "maxDoubleInt = (\r	(* 1 << 53 *)\r	^9007199254740992\r)",
 "maxInt31 = (\r	(* 1 << 30 - 1 *)\r	^1073741823\r)",
 "maxInt32 = (\r	(* 1 << 31 - 1 *)\r	^2147483647\r)",
 "maxInt63 = (\r	(* 1 << 62 - 1 *)\r	^4611686018427387903\r)",
 "maxInt64 = (\r	(* 1 << 63 - 1 *)\r	^9223372036854775807\r)",
 "minDoubleInt = (\r	(* -1 << 53 *)\r	^-9007199254740992\r)",
 "minInt31 = (\r	(* -1 << 30 *)\r	^-1073741824\r)",
 "minInt32 = (\r	(* -1 << 31 *)\r	^-2147483648\r)",
 "minInt63 = (\r	(* -1 << 62 *)\r	^-4611686018427387904\r)",
 "minInt64 = (\r	(* -1 << 63 *)\r	^-9223372036854775808\r)",
 "smallestPositiveLargeInteger = (\r	(* 1 << 63 *)\r	^9223372036854775808\r)",
 "public class ArrayTests = TestContext ()",
 "TestContext",
 "TestContext",
 "public testArrayAsArray = (\r	| array = Array new: 3. |\r	assert: array asArray equals: array.\r)",
 "public testArrayAt = (\r	| array = Array new: 2. empty = Array new: 0. |\r	array at: 1 put: 'apple'.\r	array at: 2 put: 'banana'.\r\r	assert: (array at: 1) equals: 'apple'.\r	assert: (array at: 2) equals: 'banana'.\r	should: [array at: 0] signal: Error.\r	should: [array at: 3] signal: Error.\r	should: [array at: -3] signal: Error.\r	should: [array at: nil] signal: Error.\r\r	should: [empty at: 1] signal: Error.\r)",
 "public testArrayAtPut = (\r	| array = Array new: 2. empty = Array new: 0. |\r	assert: (array at: 1 put: 'apple') equals: 'apple'.\r	assert: (array at: 2 put: 'banana') equals: 'banana'.\r	should: [array at: 0 put: 'orange'] signal: Error.\r	should: [array at: 3 put: 'orange'] signal: Error.\r	should: [array at: -3 put: 'orange'] signal: Error.\r	should: [array at: nil put: 'orange'] signal: Error.\r\r	should: [empty at: 1 put: 'orange'] signal: Error.\r)",
 "public testArrayConcatenation = (\r	|\r	a = Array new: 1.\r	b = Array new: 3.\r	c\r	|\r	a at: 1 put: 'apple'.\r	b at: 1 put: 'banana'.\r	b at: 2 put: 'orange'.\r	b at: 3 put: 'strawberry'.\r	c:: a, b.\r\r	assert: c isKindOfArray.\r	assert: c size equals: 4.\r	assert: (c at: 1) equals: 'apple'.\r	assert: (c at: 2) equals: 'banana'.\r	assert: (c at: 3) equals: 'orange'.\r	assert: (c at: 4) equals: 'strawberry'.\r)",
 "public testArrayEqualityIsIdentity = (\r	|\r	empty1 = Array new: 0.\r	empty2 = Array new: 0.\r	simple1 = Array new: 1.\r	simple2 = Array new: 1.\r	cycle1 = Array new: 1.\r	cycle2 = Array new: 1.\r	|\r	simple1 at: 1 put: 42.\r	simple2 at: 1 put: 42.\r	cycle1 at: 1 put: cycle1.\r	cycle2 at: 1 put: cycle2.\r\r	assert: empty1 equals: empty1.\r	assert: empty2 equals: empty2.\r	deny: empty1 equals: empty2.\r	deny: empty2 equals: empty1.\r\r	assert: simple1 equals: simple1.\r	assert: simple2 equals: simple2.\r	deny: simple1 equals: simple2.\r	deny: simple2 equals: simple1.\r\r	assert: cycle1 equals: cycle1.\r	assert: cycle2 equals: cycle2.\r	deny: cycle1 equals: cycle2.\r	deny: cycle2 equals: cycle1.\r)",
 "public testArrayFirstLast = (\r	| array = Array new: 2. empty = Array new: 0. |\r	array at: 1 put: 'apple'.\r	array at: 2 put: 'banana'.\r\r	assert: (array first) equals: 'apple'.\r	assert: (array last) equals: 'banana'.\r\r	should: [empty first] signal: Error.\r	should: [empty last] signal: Error.\r)",
 "public testArrayFloatIndex = (\r	| array = Array new: 1. |\r	should: [array at: 1 asFloat] signal: Error.\r	should: [array at: 1 asFloat put: 'apple'] signal: Error.\r)",
 "public testArrayIndexOf = (\r	| array = Array new: 6. empty = Array new: 0. |\r	array at: 1 put: 42.\r	array at: 2 put: nil.\r	array at: 3 put: 'apple'.\r	array at: 4 put: 'banana'.\r	array at: 5 put: 'apple'.\r	array at: 6 put: 'banana'.\r\r	assert: (array indexOf: 42) equals: 1.\r	assert: (array indexOf: nil) equals: 2.\r	assert: (array indexOf: 'apple') equals: 3.\r	assert: (array indexOf: 'banana') equals: 4.\r	assert: (array indexOf: 'noSuchElement') equals: 0.\r\r	assert: (empty indexOf: 'noSuchElement') equals: 0.\r)",
 "public testArrayIsEmpty = (\r	assert: (Array new: 0) isEmpty.\r	deny: (Array new: 1) isEmpty.\r)",
 "public testArrayNew = (\r	assert: (Array new: 0) size equals: 0.\r	assert: (Array new: 500) size equals: 500.\r\r	should: [Array new: -1] signal: Error.\r	should: [Array new: '10'] signal: Error.\r	should: [Array new: nil] signal: Error.\r	should: [Array new] signal: MessageNotUnderstood.\r)",
 "public testArrayReplace = (\r	| array replacement result |\r	array:: Array new: 5.\r	array at: 1 put: 10.\r	array at: 2 put: 20.\r	array at: 3 put: 30.\r	array at: 4 put: 40.\r	array at: 5 put: 50.\r\r	replacement:: Array new: 3.\r	replacement at: 1 put: 110.\r	replacement at: 2 put: 120.\r	replacement at: 3 put: 130.\r\r	(* Empty. *)\r	result:: array replaceFrom: 3 to: 2 with: replacement startingAt: 2.\r	assert: result equals: array.\r	assert: (array at: 1) equals: 10.\r	assert: (array at: 2) equals: 20.\r	assert: (array at: 3) equals: 30.\r	assert: (array at: 4) equals: 40.\r	assert: (array at: 5) equals: 50.\r\r	(* One. *)\r	result:: array replaceFrom: 3 to: 3 with: replacement startingAt: 1.\r	assert: result equals: array.\r	assert: (array at: 1) equals: 10.\r	assert: (array at: 2) equals: 20.\r	assert: (array at: 3) equals: 110.\r	assert: (array at: 4) equals: 40.\r	assert: (array at: 5) equals: 50.\r\r	(* Two. *)\r	result:: array replaceFrom: 3 to: 4 with: replacement startingAt: 2.\r	assert: result equals: array.\r	assert: (array at: 1) equals: 10.\r	assert: (array at: 2) equals: 20.\r	assert: (array at: 3) equals: 120.\r	assert: (array at: 4) equals: 130.\r	assert: (array at: 5) equals: 50.\r\r	(* Three. *)\r	result:: array replaceFrom: 1 to: 3 with: replacement startingAt: 1.\r	assert: result equals: array.\r	assert: (array at: 1) equals: 110.\r	assert: (array at: 2) equals: 120.\r	assert: (array at: 3) equals: 130.\r	assert: (array at: 4) equals: 130.\r	assert: (array at: 5) equals: 50.\r\r	(* After end source *)\r	should: [array replaceFrom: 1 to: 3 with: replacement startingAt: 6] signal: Error.\r	(* Crossing end source *)\r	should: [array replaceFrom: 1 to: 3 with: replacement startingAt: 3] signal: Error.\r	(* Before beginning source *)\r	should: [array replaceFrom: 1 to: 3 with: replacement startingAt: -3] signal: Error.\r	(* Crossing begining source *)\r	should: [array replaceFrom: 1 to: 3 with: replacement startingAt: 0] signal: Error.\r\r	(* After end destination *)\r	should: [array replaceFrom: 6 to: 6 with: replacement startingAt: 1] signal: Error.\r	(* Crossing end destination *)\r	should: [array replaceFrom: 5 to: 6 with: replacement startingAt: 1] signal: Error.\r	(* Before beginning destination *)\r	should: [array replaceFrom: 0 to: 0 with: replacement startingAt: 1] signal: Error.\r	(* Crossing begining destination *)\r	should: [array replaceFrom: 0 to: 2 with: replacement startingAt: 1] signal: Error.\r\r	should: [array replaceFrom: nil to: 3 with: replacement startingAt: 1] signal: Error.\r	should: [array replaceFrom: 3 to: nil with: replacement startingAt: 1] signal: Error.\r	should: [array replaceFrom: 3 to: 3 with: nil startingAt: 1] signal: Error.\r	should: [array replaceFrom: 3 to: 3 with: replacement startingAt: nil] signal: Error.\r)",
 "public testArrayReplaceSlideDown = (\r	| array result |\r	array:: Array new: 7.\r	array at: 1 put: 10.\r	array at: 2 put: 20.\r	array at: 3 put: 30.\r	array at: 4 put: 40.\r	array at: 5 put: 50.\r	array at: 6 put: 60.\r	array at: 7 put: 70.\r\r	result:: array replaceFrom: 3 to: 7 with: array startingAt: 1.\r	assert: result equals: array.\r	assert: (array at: 1) equals: 10.\r	assert: (array at: 2) equals: 20.\r	assert: (array at: 3) equals: 10.\r	assert: (array at: 4) equals: 20.\r	assert: (array at: 5) equals: 30.\r	assert: (array at: 6) equals: 40.\r	assert: (array at: 7) equals: 50.\r)",
 "public testArrayReplaceSlideUp = (\r	| array result |\r	array:: Array new: 7.\r	array at: 1 put: 10.\r	array at: 2 put: 20.\r	array at: 3 put: 30.\r	array at: 4 put: 40.\r	array at: 5 put: 50.\r	array at: 6 put: 60.\r	array at: 7 put: 70.\r\r	result:: array replaceFrom: 1 to: 5 with: array startingAt: 3.\r	assert: result equals: array.\r	assert: (array at: 1) equals: 30.\r	assert: (array at: 2) equals: 40.\r	assert: (array at: 3) equals: 50.\r	assert: (array at: 4) equals: 60.\r	assert: (array at: 5) equals: 70.\r	assert: (array at: 6) equals: 60.\r	assert: (array at: 7) equals: 70.\r)",
 "public testArraySort = (\r	| array |\r	array:: {12. 15. 3. 5. 10. 6. 8. 1. 13. 11. 16. 4. 14. 9. 2. 7}.\r	assert: array size equals: 16.\r	array sort: [:a :b | a < b].\r	1 to: 16 do: [:index | assert: (array at: index) equals: index].\r\r	array:: {12. 8. 9. 7. 2. 10. 4. 6. 5. 3. 13. 15. 14. 1. 11}.\r	assert: array size equals: 15.\r	array sort: [:a :b | a < b].\r	1 to: 15 do: [:index | assert: (array at: index) equals: index].\r\r	array:: {10. 12. 2. 11. 14. 4. 13. 3. 9. 8. 7. 5. 6. 1}.\r	assert: array size equals: 14.\r	array sort: [:a :b | a < b].\r	1 to: 14 do: [:index | assert: (array at: index) equals: index].\r\r	array:: {12. 6. 10. 5. 7. 9. 2. 4. 1. 11. 3. 8. 13}.\r	assert: array size equals: 13.\r	array sort: [:a :b | a < b].\r	1 to: 13 do: [:index | assert: (array at: index) equals: index].\r)",
 "public testArrayWithAll = (\r	| array bytearray list result |\r	array:: Array new: 2.\r	array at: 1 put: 'A'.\r	array at: 2 put: 'B'.\r	result:: Array withAll: array.\r	assert: result size equals: 2.\r	assert: (result at: 1) equals: 'A'.\r	assert: (result at: 2) equals: 'B'.\r\r	bytearray:: ByteArray new: 2.\r	bytearray at: 1 put: 67.\r	bytearray at: 2 put: 68.\r	result:: Array withAll: bytearray.\r	assert: result size equals: 2.\r	assert: (result at: 1) equals: 67.\r	assert: (result at: 2) equals: 68.\r\r	result:: Array withAll: 'EF'.\r	assert: result size equals: 2.\r	assert: (result at: 1) equals: 69.\r	assert: (result at: 2) equals: 70.\r\r	list:: List new.\r	list add: 'G'.\r	list add: 'H'.\r	result:: Array withAll: list.\r	assert: result size equals: 2.\r	assert: (result at: 1) equals: 'G'.\r	assert: (result at: 2) equals: 'H'.\r\r	should: [Array withAll: -1] signal: Error.\r	should: [Array withAll: 16r110000] signal: Error.\r	should: [Array withAll: nil] signal: Error.\r	should: [Array withAll: 122 asFloat] signal: Error.\r)",
 "public testIsKindOfArray = (\r	assert: (Array new: 0) isKindOfArray.\r	deny: (ByteArray new: 0) isKindOfArray.\r	deny: 0 isKindOfArray.\r	deny: 1.5 isKindOfArray.\r	deny: 'Array new' isKindOfArray.\r	deny: nil isKindOfArray.\r)",
 "TEST_CONTEXT = ()",
 "public class BehaviorTests = TestContext ()",
 "TestContext",
 "TestContext",
 "public testBehaviorBasicNew = (\r	should: [Object basicNew] signal: MessageNotUnderstood.\r\r	(* :todo: basicNew should also fail from a class-side method. *)\r)",
 "public testBehaviorInternalsAreHidden = (\r	(* Squeak, JS *)\r	should: [Object superclass] signal: MessageNotUnderstood.\r	should: [Object methodDictionary] signal: MessageNotUnderstood.\r	should: [Object mixin] signal: MessageNotUnderstood.\r	should: [Object enclosingObject] signal: MessageNotUnderstood.\r	should: [Object format] signal: MessageNotUnderstood.\r\r	(* PrimordialSoup *)\r	should: [Object _superclass] signal: MessageNotUnderstood.\r	should: [Object _methods] signal: MessageNotUnderstood.\r	should: [Object _enclosingObject] signal: MessageNotUnderstood.\r	should: [Object _mixin] signal: MessageNotUnderstood.\r	should: [Object _classIndex] signal: MessageNotUnderstood.\r	should: [Object _format] signal: MessageNotUnderstood.\r)",
 "public testBehaviorName = (\r	(* :todo: Which to we want? *)\r	(* should: [Object name] signal: MessageNotUnderstood.\r	assert: Object name equals: 'Object'.\r	assert: Object name equals: 'KernelForImplementation`Object'. *)\r)",
 "public testIsKindOfBehavior = (\r	assert: Object isKindOfBehavior.\r	deny: nil isKindOfBehavior.\r	deny: false isKindOfBehavior.\r	deny: true isKindOfBehavior.\r	deny: 0 isKindOfBehavior.\r)",
 "TEST_CONTEXT = ()",
 "public class BooleanTests = TestContext ()",
 "TestContext",
 "TestContext",
 "public testBooleanAsString = (\r	assert: true asString equals: 'true'.\r	assert: false asString equals: 'false'.\r)",
 "public testBooleanEvaluatingConjuction = (\r	assert: true & true.\r	deny: true & false.\r	deny: false & true.\r	deny: false & false.\r)",
 "public testBooleanEvaluatingDisjuction = (\r	assert: true | true.\r	assert: true | false.\r	assert: false | true.\r	deny: false | false.\r)",
 "public testBooleanNonEvaluatingConjuction = (\r	assert: (true and: [true]).\r	deny: (true and: [false]).\r	deny: (false and: [doesNotExecute]).\r)",
 "public testBooleanNonEvaluatingDisjuction = (\r	assert: (true or: [doesNotExecute]).\r	assert: (false or: [true]).\r	deny: (false or: [false]).\r)",
 "public testBooleanNot = (\r	deny: true not.\r	assert: false not.\r)",
 "public testBooleanPrintString = (\r	assert: true printString equals: 'true'.\r	assert: false printString equals: 'false'.\r)",
 "TEST_CONTEXT = ()",
 "public class ByteArrayTests = TestContext ()",
 "TestContext",
 "TestContext",
 "b: string = (\r	^ByteArray withAll: string\r)",
 "public testByteArrayAt = (\r	| array = ByteArray new: 2. empty = ByteArray new: 0. |\r	array at: 1 put: 3.\r	array at: 2 put: 4.\r\r	assert: (array at: 1) equals: 3.\r	assert: (array at: 2) equals: 4.\r	should: [array at: 0] signal: Error.\r	should: [array at: 3] signal: Error.\r	should: [array at: -3] signal: Error.\r	should: [array at: nil] signal: Error.\r\r	should: [empty at: 1] signal: Error.\r)",
 "public testByteArrayAtPut = (\r	| array = ByteArray new: 2. empty = ByteArray new: 0. |\r	assert: (array at: 1 put: 3) equals: 3.\r	assert: (array at: 2 put: 4) equals: 4.\r	should: [array at: 0 put: 5] signal: Error.\r	should: [array at: 3 put: 6] signal: Error.\r	should: [array at: -3 put: 7] signal: Error.\r	should: [array at: nil put: 8] signal: Error.\r\r	assert: (array at: 1 put: 0) equals: 0.\r	assert: (array at: 2 put: 255) equals: 255.\r	should: [array at: 1 put: -1] signal: Error.\r	should: [array at: 1 put: 256] signal: Error.\r\r	should: [empty at: 1 put: 9] signal: Error.\r)",
 "public testByteArrayCopyFromTo = (\r	| array = ByteArray new: 4. empty = ByteArray new: 0. copy |\r	array at: 1 put: 16rA.\r	array at: 2 put: 16rB.\r	array at: 3 put: 16rC.\r	array at: 4 put: 16rD.\r\r	copy:: array copyFrom: 1 to: 4.\r	assert: copy size equals: 4.\r	assert: (copy at: 1) equals: 16rA.\r	assert: (copy at: 4) equals: 16rD.\r\r	copy:: array copyFrom: 2 to: 3.\r	assert: copy size equals: 2.\r	assert: (copy at: 1) equals: 16rB.\r	assert: (copy at: 2) equals: 16rC.\r\r	1 to: 4 do:\r		[:start |\r		 copy:: array copyFrom: start to: start - 1.\r		 assert: copy size equals: 0].\r\r	copy:: empty copyFrom: 1 to: 0.\r	assert: copy size equals: 0.\r\r	should: [empty copyFrom: 0 to: 0] signal: Error.\r	should: [empty copyFrom: 2 to: 0] signal: Error.\r	should: [empty copyFrom: 1 to: 1] signal: Error.\r\r	should: [array copyFrom: 4 to: 5] signal: Error.\r	should: [array copyFrom: nil to: 2] signal: Error.\r	should: [array copyFrom: 2 to: nil] signal: Error.\r	should: [array copyFrom: 2 to: 50] signal: Error.\r	should: [array copyFrom: 0 to: 2] signal: Error.\r	should: [array copyFrom: 2 asFloat to: 3] signal: Error.\r	should: [array copyFrom: 2 to: 3 asFloat] signal: Error.\r)",
 "public testByteArrayEndsWith = (\r	| foo zero empty |\r	foo:: ByteArray new: 3.\r	foo at: 1 put: 102.\r	foo at: 2 put: 111.\r	foo at: 3 put: 111.\r	zero:: ByteArray new: 1.\r	zero at: 1 put: 48.\r	empty:: ByteArray new: 0.\r\r	assert: (foo endsWith: 'o').\r	assert: (foo endsWith: 'foo').\r	assert: (foo endsWith: foo).\r	assert: (foo endsWith: '').\r	assert: (foo endsWith: empty).\r	assert: (empty endsWith: '').\r	assert: (foo endsWith: empty).\r	deny: (foo endsWith: 'toolongfoo').\r	deny: (foo endsWith: 'boo').\r	deny: (foo endsWith: 'bar').\r	deny: (empty endsWith: 'foo').\r	deny: (empty endsWith: foo).\r\r	should: [zero endsWith: 0] signal: Error.\r	should: [foo endsWith: true] signal: Error.\r	should: [foo endsWith: nil] signal: Error.\r)",
 "public testByteArrayFloatIndex = (\r	| array = ByteArray new: 1. |\r	should: [array at: 1 asFloat] signal: Error.\r	should: [array at: 1 asFloat put: 0] signal: Error.\r)",
 "public testByteArrayIndexOf = (\r	assert: ((b: 'fofofobar') indexOf: (b: 'fofo')) equals: 1.\r	assert: ((b: 'fofofobar') indexOf: (b: 'bar')) equals: 7.\r	assert: ((b: 'fofofobar') indexOf: (b: 'barr')) equals: 0.\r	assert: ((b: 'fofofobar') indexOf: (b: 'fob')) equals: 5.\r	assert: ((b: 'fofofobar') indexOf: (b: 'baz')) equals: 0.\r	assert: ((b: 'fofofobar') indexOf: (b: 'f')) equals: 1.\r	assert: ((b: 'fofofobar') indexOf: (b: 'r')) equals: 9.\r	assert: ((b: 'fofofobar') indexOf: (b: '')) equals: 1.\r\r	assert: ((b: 'tiny') indexOf: (b: 'toolong')) equals: 0.\r\r	assert: ((b: '') indexOf: (b: '')) equals: 1.\r	assert: ((b: '') indexOf: (b: 'baz')) equals: 0.\r\r	should: [(b: 'fofofobar') indexOf: 0] signal: Error.\r	should: [(b: '') indexOf: Object new] signal: Error.\r)",
 "public testByteArrayIndexOfStartingAt = (\r	assert: ((b: 'fofofobar') indexOf: (b: 'fofo') startingAt: 1) equals: 1.\r	assert: ((b: 'fofofobar') indexOf: (b: 'fofo') startingAt: 2) equals: 3.\r	assert: ((b: 'fofofobar') indexOf: (b: 'fofo') startingAt: 3) equals: 3.\r	assert: ((b: 'fofofobar') indexOf: (b: 'fofo') startingAt: 4) equals: 0.\r	assert: ((b: 'fofofobar') indexOf: (b: 'bar') startingAt: 1) equals: 7.\r	assert: ((b: 'fofofobar') indexOf: (b: 'bar') startingAt: 7) equals: 7.\r	assert: ((b: 'fofofobar') indexOf: (b: 'bar') startingAt: 8) equals: 0.\r	assert: ((b: 'fofofobar') indexOf: (b: 'barr') startingAt: 6) equals: 0.\r	assert: ((b: 'fofofobar') indexOf: (b: 'fob') startingAt: 5) equals: 5.\r	assert: ((b: 'fofofobar') indexOf: (b: 'fob') startingAt: 6) equals: 0.\r	assert: ((b: 'fofofobar') indexOf: (b: 'baz') startingAt: 1) equals: 0.\r	assert: ((b: 'fofofobar') indexOf: (b: 'f') startingAt: 1) equals: 1.\r	assert: ((b: 'fofofobar') indexOf: (b: 'f') startingAt: 2) equals: 3.\r	assert: ((b: 'fofofobar') indexOf: (b: 'r') startingAt: 1) equals: 9.\r	assert: ((b: 'fofofobar') indexOf: (b: 'r') startingAt: 9) equals: 9.\r	assert: ((b: 'fofofobar') indexOf: (b: '') startingAt: 1) equals: 1.\r	assert: ((b: 'fofofobar') indexOf: (b: '') startingAt: 5) equals: 5.\r	assert: ((b: 'fofofobar') indexOf: (b: '') startingAt: 9) equals: 9.\r\r	assert: ((b: 'tiny') indexOf: (b: 'toolong') startingAt: 1) equals: 0.\r	assert: ((b: 'tiny') indexOf: (b: 'toolong') startingAt: 3) equals: 0.\r\r	assert: ((b: '') indexOf: (b: '') startingAt: 1) equals: 1.\r	assert: ((b: '') indexOf: (b: 'baz') startingAt: 1) equals: 0.\r\r	should: [(b: 'fofofobar') indexOf: 0 startingAt: 1] signal: Error.\r	should: [(b: 'fofobobar') indexOf: Object new startingAt: 1] signal: Error.\r\r	should: [(b: 'fofofobar') indexOf: (b: 'foo') startingAt: 0] signal: Error.\r	should: [(b: 'fofofobar') indexOf: (b: 'foo') startingAt: 11] signal: Error.\r	should: [(b: '') indexOf: (b: '') startingAt: 0] signal: Error.\r	should: [(b: '') indexOf: (b: '') startingAt: 2] signal: Error.\r)",
 "public testByteArrayIsEmpty = (\r	assert: (ByteArray new: 0) isEmpty.\r	deny: (ByteArray new: 1) isEmpty.\r)",
 "public testByteArrayLargeAllocation = (\r	| size = 8 * 1024 * 1024. |\r	assert: (ByteArray new: size) size equals: size.\r	assert: (ByteArray new: size) size equals: size.\r	assert: (ByteArray new: size) size equals: size.\r)",
 "public testByteArrayLastIndexOf = (\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'fofo')) equals: 3.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'bar')) equals: 7.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'barr')) equals: 0.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'fob')) equals: 5.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'baz')) equals: 0.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'f')) equals: 5.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'r')) equals: 9.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: '')) equals: 10.\r\r	assert: ((b: 'tiny') lastIndexOf: (b: 'toolong')) equals: 0.\r\r	assert: ((b: '') lastIndexOf: (b: '')) equals: 1.\r	assert: ((b: '') lastIndexOf: (b: 'baz')) equals: 0.\r\r	should: [(b: 'fofofobar') lastIndexOf: 0] signal: Error.\r	should: [(b: '') lastIndexOf: Object new] signal: Error.\r)",
 "public testByteArrayLastIndexOfStartingAt = (\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'fofo') startingAt: 10) equals: 3.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'fofo') startingAt: 4) equals: 3.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'fofo') startingAt: 3) equals: 3.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'fofo') startingAt: 1) equals: 1.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'bar') startingAt: 10) equals: 7.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'bar') startingAt: 7) equals: 7.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'bar') startingAt: 6) equals: 0.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'barr') startingAt: 10) equals: 0.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'fob') startingAt: 10) equals: 5.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'fob') startingAt: 4) equals: 0.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'baz') startingAt: 10) equals: 0.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'f') startingAt: 10) equals: 5.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'f') startingAt: 4) equals: 3.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'f') startingAt: 2) equals: 1.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'r') startingAt: 10) equals: 9.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'r') startingAt: 9) equals: 9.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: 'r') startingAt: 8) equals: 0.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: '') startingAt: 10) equals: 10.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: '') startingAt: 5) equals: 5.\r	assert: ((b: 'fofofobar') lastIndexOf: (b: '') startingAt: 1) equals: 1.\r\r	assert: ((b: 'tiny') lastIndexOf: (b: 'toolong') startingAt: 4) equals: 0.\r	assert: ((b: 'tiny') lastIndexOf: (b: 'toolong') startingAt: 2) equals: 0.\r\r	assert: ((b: '') lastIndexOf: (b: '') startingAt: 1) equals: 1.\r	assert: ((b: '') lastIndexOf: (b: 'baz') startingAt: 1) equals: 0.\r\r	should: [(b: 'fofofobar') lastIndexOf: 0 startingAt: 1] signal: Error.\r	should: [(b: '') lastIndexOf: Object new startingAt: 1] signal: Error.\r\r	should: [(b: 'fofofobar') lastIndexOf: (b: 'foo') startingAt: 0] signal: Error.\r	should: [(b: 'fofofobar') lastIndexOf: (b: 'foo') startingAt: 11] signal: Error.\r	should: [(b: '') lastIndexOf: (b: '') startingAt: 0] signal: Error.\r	should: [(b: '') lastIndexOf: (b: '') startingAt: 2] signal: Error.\r)",
 "public testByteArrayNew = (\r	assert: (ByteArray new: 0) size equals: 0.\r	assert: (ByteArray new: 500) size equals: 500.\r\r	should: [ByteArray new: -1] signal: Error.\r	should: [ByteArray new: '10'] signal: Error.\r	should: [ByteArray new: nil] signal: Error.\r	should: [ByteArray new] signal: MessageNotUnderstood.\r)",
 "public testByteArrayReplace = (\r	| array replacement result |\r	array:: ByteArray new: 5.\r	array at: 1 put: 10.\r	array at: 2 put: 20.\r	array at: 3 put: 30.\r	array at: 4 put: 40.\r	array at: 5 put: 50.\r\r	replacement:: ByteArray new: 3.\r	replacement at: 1 put: 110.\r	replacement at: 2 put: 120.\r	replacement at: 3 put: 130.\r\r	(* Empty. *)\r	result:: array replaceFrom: 3 to: 2 with: replacement startingAt: 2.\r	assert: result equals: array.\r	assert: (array at: 1) equals: 10.\r	assert: (array at: 2) equals: 20.\r	assert: (array at: 3) equals: 30.\r	assert: (array at: 4) equals: 40.\r	assert: (array at: 5) equals: 50.\r\r	(* One. *)\r	result:: array replaceFrom: 3 to: 3 with: replacement startingAt: 1.\r	assert: result equals: array.\r	assert: (array at: 1) equals: 10.\r	assert: (array at: 2) equals: 20.\r	assert: (array at: 3) equals: 110.\r	assert: (array at: 4) equals: 40.\r	assert: (array at: 5) equals: 50.\r\r	(* Two. *)\r	result:: array replaceFrom: 3 to: 4 with: replacement startingAt: 2.\r	assert: result equals: array.\r	assert: (array at: 1) equals: 10.\r	assert: (array at: 2) equals: 20.\r	assert: (array at: 3) equals: 120.\r	assert: (array at: 4) equals: 130.\r	assert: (array at: 5) equals: 50.\r\r	(* Three. *)\r	result:: array replaceFrom: 1 to: 3 with: replacement startingAt: 1.\r	assert: result equals: array.\r	assert: (array at: 1) equals: 110.\r	assert: (array at: 2) equals: 120.\r	assert: (array at: 3) equals: 130.\r	assert: (array at: 4) equals: 130.\r	assert: (array at: 5) equals: 50.\r\r	(* After end source *)\r	should: [array replaceFrom: 1 to: 3 with: replacement startingAt: 6] signal: Error.\r	(* Crossing end source *)\r	should: [array replaceFrom: 1 to: 3 with: replacement startingAt: 3] signal: Error.\r	(* Before beginning source *)\r	should: [array replaceFrom: 1 to: 3 with: replacement startingAt: -3] signal: Error.\r	(* Crossing begining source *)\r	should: [array replaceFrom: 1 to: 3 with: replacement startingAt: 0] signal: Error.\r\r	(* After end destination *)\r	should: [array replaceFrom: 6 to: 6 with: replacement startingAt: 1] signal: Error.\r	(* Crossing end destination *)\r	should: [array replaceFrom: 5 to: 6 with: replacement startingAt: 1] signal: Error.\r	(* Before beginning destination *)\r	should: [array replaceFrom: 0 to: 0 with: replacement startingAt: 1] signal: Error.\r	(* Crossing begining destination *)\r	should: [array replaceFrom: 0 to: 2 with: replacement startingAt: 1] signal: Error.\r\r	should: [array replaceFrom: nil to: 3 with: replacement startingAt: 1] signal: Error.\r	should: [array replaceFrom: 3 to: nil with: replacement startingAt: 1] signal: Error.\r	should: [array replaceFrom: 3 to: 3 with: nil startingAt: 1] signal: Error.\r	should: [array replaceFrom: 3 to: 3 with: replacement startingAt: nil] signal: Error.\r)",
 "public testByteArrayReplaceSlideDown = (\r	| array result |\r	array:: ByteArray new: 7.\r	array at: 1 put: 10.\r	array at: 2 put: 20.\r	array at: 3 put: 30.\r	array at: 4 put: 40.\r	array at: 5 put: 50.\r	array at: 6 put: 60.\r	array at: 7 put: 70.\r\r	result:: array replaceFrom: 3 to: 7 with: array startingAt: 1.\r	assert: result equals: array.\r	assert: (array at: 1) equals: 10.\r	assert: (array at: 2) equals: 20.\r	assert: (array at: 3) equals: 10.\r	assert: (array at: 4) equals: 20.\r	assert: (array at: 5) equals: 30.\r	assert: (array at: 6) equals: 40.\r	assert: (array at: 7) equals: 50.\r)",
 "public testByteArrayReplaceSlideUp = (\r	| array result |\r	array:: ByteArray new: 7.\r	array at: 1 put: 10.\r	array at: 2 put: 20.\r	array at: 3 put: 30.\r	array at: 4 put: 40.\r	array at: 5 put: 50.\r	array at: 6 put: 60.\r	array at: 7 put: 70.\r\r	result:: array replaceFrom: 1 to: 5 with: array startingAt: 3.\r	assert: result equals: array.\r	assert: (array at: 1) equals: 30.\r	assert: (array at: 2) equals: 40.\r	assert: (array at: 3) equals: 50.\r	assert: (array at: 4) equals: 60.\r	assert: (array at: 5) equals: 70.\r	assert: (array at: 6) equals: 60.\r	assert: (array at: 7) equals: 70.\r)",
 "public testByteArrayStartsWith = (\r	| foo zero empty |\r	foo:: ByteArray new: 3.\r	foo at: 1 put: 102.\r	foo at: 2 put: 111.\r	foo at: 3 put: 111.\r	zero:: ByteArray new: 1.\r	zero at: 1 put: 48.\r	empty:: ByteArray new: 0.\r\r	assert: (foo startsWith: 'f').\r	assert: (foo startsWith: 'foo').\r	assert: (foo startsWith: foo).\r	assert: (foo startsWith: '').\r	assert: (foo startsWith: empty).\r	assert: (empty startsWith: '').\r	assert: (empty startsWith: empty).\r	deny: (foo startsWith: 'toolong').\r	deny: (foo startsWith: 'fob').\r	deny: (foo startsWith: 'bar').\r	deny: (empty startsWith: 'foo').\r	deny: (empty startsWith: foo).\r\r	should: [zero startsWith: 0] signal: Error.\r	should: [foo startsWith: true] signal: Error.\r	should: [foo startsWith: nil] signal: Error.\r)",
 "public testByteArrayWithAll = (\r	| array bytearray list result |\r	array:: Array new: 0.\r	result:: ByteArray withAll: array.\r	assert: result size equals: 0.\r\r	array:: Array new: 3.\r	array at: 1 put: 10.\r	array at: 2 put: 20.\r	array at: 3 put: 30.\r	result:: ByteArray withAll: array.\r	assert: result size equals: 3.\r	assert: (result at: 1) equals: 10.\r	assert: (result at: 2) equals: 20.\r	assert: (result at: 3) equals: 30.\r\r	bytearray:: ByteArray new: 0.\r	result:: ByteArray withAll: bytearray.\r	assert: result size equals: 0.\r\r	bytearray:: ByteArray new: 3.\r	bytearray at: 1 put: 110.\r	bytearray at: 2 put: 120.\r	bytearray at: 3 put: 130.\r	result:: ByteArray withAll: bytearray.\r	assert: result size equals: 3.\r	assert: (result at: 1) equals: 110.\r	assert: (result at: 2) equals: 120.\r	assert: (result at: 3) equals: 130.\r\r	result:: ByteArray withAll: ''.\r	assert: result size equals: 0.\r\r	result:: ByteArray withAll: 'soup'.\r	assert: result size equals: 4.\r	assert: (result at: 1) equals: 115.\r	assert: (result at: 2) equals: 111.\r	assert: (result at: 3) equals: 117.\r	assert: (result at: 4) equals: 112.\r\r	list:: List new.\r	list add: 102.\r	list add: 111.\r	list add: 120.\r	result:: ByteArray withAll: list.\r	assert: result size equals: 3.\r	assert: (result at: 1) equals: 102.\r	assert: (result at: 2) equals: 111.\r	assert: (result at: 3) equals: 120.\r\r	should: [ByteArray withAll: -1] signal: Error.\r	should: [ByteArray withAll: 16r110000] signal: Error.\r	should: [ByteArray withAll: nil] signal: Error.\r	should: [ByteArray withAll: 122 asFloat] signal: Error.\r\r	should: [ByteArray withAll: {nil}] signal: Error.\r	should: [ByteArray withAll: {-1}] signal: Error.\r	should: [ByteArray withAll: {16r256}] signal: Error.\r	should: [ByteArray withAll: {nil}] signal: Error.\r	should: [ByteArray withAll: {122 asFloat}] signal: Error.\r	should: [ByteArray withAll: {'z'}] signal: Error.\r\r	list:: List new.\r	list add: 256.\r	should: [String withAll: list] signal: Error.\r)",
 "public testIsKindOfByteArray = (\r	assert: (ByteArray new: 0) isKindOfByteArray.\r	deny: (Array new: 0) isKindOfByteArray.\r	deny: 0 isKindOfByteArray.\r	deny: 1.5 isKindOfByteArray.\r	deny: 'Array new' isKindOfByteArray.\r	deny: nil isKindOfByteArray.\r)",
 "TEST_CONTEXT = ()",
 "public class ClosureTests = TestContext ()",
 "TestContext",
 "TestContext",
 "cannotReturn = (\r	^[^42]\r)",
 "ensure1 = (\r	[^'try-block'] ensure: [^'ensure-block'].\r	^'afterward'\r)",
 "ensure2 = (\r	^['try-block'] ensure: ['ensure-block'].\r)",
 "ensure3 = (\r	[^'try-block'] ensure: ['ensure-block'].\r	^'afterward'\r)",
 "public testCannotReturn = (\r	should: [cannotReturn value] signal: Error.\r)",
 "public testCull = (\r	assert: ([42] cull: 7) equals: 42.\r	assert: ([42] cull: 7 cull: 9) equals: 42.\r	assert: ([42] cull: 7 cull: 9 cull: 11) equals: 42.\r\r	assert: ([:a | a] cull: 7) equals: 7.\r	assert: ([:a | a] cull: 7 cull: 9) equals: 7.\r	assert: ([:a | a] cull: 7 cull: 9 cull: 11) equals: 7.\r\r	should: [[:a :b | a + b] cull: 7] signal: Error.\r	assert: ([:a :b | a + b] cull: 7 cull: 9) equals: 16.\r	assert: ([:a :b | a + b] cull: 7 cull: 9 cull: 11) equals: 16.\r\r	should: [[:a :b :c | a + b + c] cull: 7] signal: Error.\r	should: [[:a :b :c | a + b + c] cull: 7 cull: 9] signal: Error.\r	assert: ([:a :b :c | a + b + c] cull: 7 cull: 9 cull: 11) equals: 27.\r)",
 "public testEnsure = (\r	assert: ensure1 equals: 'ensure-block'.\r	assert: ensure2 equals: 'try-block'.\r	assert: ensure3 equals: 'try-block'.\r)",
 "public testIsKindOfClosure = (\r	assert: [3 + 4] isKindOfClosure.\r	deny: (3 + 4) isKindOfClosure.\r	deny: {3 + 4} isKindOfClosure.\r)",
 "public testNumArgs = (\r	assert: [3 + 4] numArgs equals: 0.\r	assert: [:x | x + 4] numArgs equals: 1.\r	assert: [:x :y | x + y] numArgs equals: 2.\r)",
 "public testValue = (\r	assert: [3 - 4] value equals: -1.\r	assert: ([:x | x - 4] value: 14) equals: 10.\r	assert: ([:x :y | x - y] value: 42 value: 24) equals: 18.\r	assert: ([:x :y :z | x - y + z] value: 13 value: 3 value: 1) equals: 11.\r)",
 "public testValueTooFew = (\r	should: [[:x | x - 4] value] signal: Error.\r	should: [[:x :y | x - y] value: 1] signal: Error.\r	should: [[:x :y :z | 3 - 4] value: 1 value: 2] signal: Error.\r)",
 "public testValueTooMany = (\r	should: [[3 - 4] value: 1] signal: Error.\r	should: [[:x | x - 4] value: 1 value: 2] signal: Error.\r	should: [[:x :y | x - y] value: 1 value: 2 value: 3] signal: Error.\r)",
 "public testValueWithArguments = (\r	(* Should this be called apply: ? *)\r\r	assert: ([3 - 4] valueWithArguments: {}) equals: -1.\r	assert: ([:x | x - 4] valueWithArguments: {14}) equals: 10.\r	assert: ([:x :y | x - y] valueWithArguments: {42. 24}) equals: 18.\r	assert: ([:x :y :z | x - y + z] valueWithArguments: {13. 3. 1}) equals: 11.\r)",
 "public testValueWithArgumentsList = (\r	assert: ([3 - 4] valueWithArguments: (List withAll: {})) equals: -1.\r	assert: ([:x | x - 4] valueWithArguments: (List withAll: {14})) equals: 10.\r	assert: ([:x :y | x - y] valueWithArguments: (List withAll: {42. 24})) equals: 18.\r	assert: ([:x :y :z | x - y + z] valueWithArguments: (List withAll: {13. 3. 1})) equals: 11.\r)",
 "public testValueWithArgumentsNonArray = (\r	should: [[1] valueWithArguments: nil] signal: Error.\r	should: [[1] valueWithArguments: false] signal: Error.\r	should: [[1] valueWithArguments: true] signal: Error.\r	should: [[1] valueWithArguments: 'string'] signal: Error.\r	should: [[1] valueWithArguments: 0] signal: Error.\r	should: [[1] valueWithArguments: []] signal: Error.\r)",
 "public testValueWithArgumentsTooFew = (\r	should: [[:x | x - 4] valueWithArguments: {}] signal: Error.\r	should: [[:x :y | x - y] valueWithArguments: {1}] signal: Error.\r	should: [[:x :y :z | x - y + z] valueWithArguments: {1. 2}] signal: Error.\r)",
 "public testValueWithArgumentsTooMany = (\r	should: [[3 - 4] valueWithArguments: {1}] signal: Error.\r	should: [[:x | x - 4] valueWithArguments: {1. 2}] signal: Error.\r	should: [[:x :y | x - y] valueWithArguments: {1. 2. 3}] signal: Error.\r	should: [[:x :y :z | x - y + z] valueWithArguments: {1. 2. 3. 4}] signal: Error.\r)",
 "TEST_CONTEXT = ()",
 "class DnuAnswerMessage = ()",
 " ",
 " ",
 "protected doesNotUnderstand: message = (\r	^message\r)",
 "public class ExceptionTests = TestContext ()",
 "TestContext",
 "TestContext",
 "nonLocalReturnCrossingExceptionHandler = (\r	[^'correct']\r		on: Error\r		do: [:ex | ^'wrong1'].\r	^'wrong2'\r)",
 "public testExceptionHandled = (\r	|\r	beforeSignal ::= false.\r	afterSignal ::= false.\r	handler ::= false.\r	exceptionSignaled\r	exceptionHandled\r	result\r	|\r\r	result::\r		[beforeSignal:: true.\r		 exceptionSignaled:: Exception new.\r		 exceptionSignaled signal.\r		 afterSignal:: true.\r		 42]\r			on: Exception\r			do: [:ex | handler:: true. exceptionHandled:: ex. 84].\r\r	assert: beforeSignal.\r	deny: afterSignal.\r	assert: handler.\r	assert: exceptionSignaled equals: exceptionHandled.\r	assert: result equals: 84.\r)",
 "public testExceptionInvalidPass = (\r	| ex |\r\r	(* Already handled. *)\r	ex:: Exception new.\r	[ex signal] on: Exception do: [:e | ].\r	should: [ex pass] signal: Error.\r\r	(* Already resumed. *)\r	ex:: Exception new.\r	[ex signal] on: Exception do: [:e | e resume: 42].\r	should: [ex pass] signal: Error.\r\r	(* Already returned. *)\r	ex:: Exception new.\r	[ex signal] on: Exception do: [:e | e return: 42].\r	should: [ex pass] signal: Error.\r\r	(* Never signaled. *)\r	ex:: Exception new.\r	should: [ex pass] signal: Error.\r)",
 "public testExceptionInvalidResume = (\r	| ex |\r\r	(* Already handled. *)\r	ex:: Exception new.\r	[ex signal] on: Exception do: [:e | ].\r	should: [ex resume: 84] signal: Error.\r\r	(* Already resumed. *)\r	ex:: Exception new.\r	[ex signal] on: Exception do: [:e | e resume: 42].\r	should: [ex resume: 84] signal: Error.\r\r	(* Already returned. *)\r	ex:: Exception new.\r	[ex signal] on: Exception do: [:e | e return: 42].\r	should: [ex resume: 84] signal: Error.\r\r	(* Never signaled. *)\r	ex:: Exception new.\r	should: [ex resume: 84] signal: Error.\r)",
 "public testExceptionInvalidReturn = (\r	| ex |\r\r	(* Already handled. *)\r	ex:: Exception new.\r	[ex signal] on: Exception do: [:e | ].\r	should: [ex return: 84] signal: Error.\r\r	(* Already resumed. *)\r	ex:: Exception new.\r	[ex signal] on: Exception do: [:e | e resume: 42].\r	should: [ex return: 84] signal: Error.\r\r	(* Already returned. *)\r	ex:: Exception new.\r	[ex signal] on: Exception do: [:e | e return: 42].\r	should: [ex return: 84] signal: Error.\r\r	(* Never signaled. *)\r	ex:: Exception new.\r	should: [ex return: 84] signal: Error.\r)",
 "public testExceptionPass = (\r	|\r	beforeSignal ::= false.\r	afterSignal ::= false.\r	afterInnerTry ::= false.\r	outerHandler ::= false.\r	innerHandler ::= false.\r	afterPass ::= false.\r	|\r\r\r	[\r		[\r			beforeSignal:: true.\r			Exception new signal.\r			afterSignal:: true.\r		] on: Exception do:\r			[:ex |\r			innerHandler:: true.\r			ex pass.\r			afterPass:: true].\r		afterInnerTry:: true.\r	] on: Exception do: [:ex | outerHandler:: true].\r\r	assert: beforeSignal.\r	deny: afterSignal.\r	assert: innerHandler.\r	deny: afterPass.\r	deny: afterInnerTry.\r	assert: outerHandler.\r)",
 "public testExceptionResume = (\r	|\r	beforeSignal ::= false.\r	afterSignal ::= false.\r	handler ::= false.\r	afterResume ::= false.\r	exceptionSignaled\r	exceptionHandled\r	signalResult\r	result\r	|\r\r	result::\r		[beforeSignal:: true.\r		 exceptionSignaled:: Exception new.\r		 signalResult:: exceptionSignaled signal.\r		 afterSignal:: true.\r		 42]\r			on: Exception\r			do:\r				[:ex |\r				handler:: true.\r				exceptionHandled:: ex.\r				ex resume: 63.\r				afterResume:: true.\r				84].\r\r	assert: beforeSignal.\r	assert: afterSignal.\r	assert: handler.\r	deny: afterResume.\r	assert: exceptionSignaled equals: exceptionHandled.\r	assert: signalResult equals: 63.\r	assert: result equals: 42.\r)",
 "public testExceptionReturn = (\r	|\r	beforeSignal ::= false.\r	afterSignal ::= false.\r	handler ::= false.\r	afterReturn ::= false.\r	exceptionSignaled\r	exceptionHandled\r	signalResult\r	result\r	|\r\r	result::\r		[beforeSignal:: true.\r		 exceptionSignaled:: Exception new.\r		 signalResult:: exceptionSignaled signal.\r		 afterSignal:: true.\r		 42]\r			on: Exception\r			do:\r				[:ex |\r				handler:: true.\r				exceptionHandled:: ex.\r				ex return: 63.\r				afterReturn:: true.\r				84].\r\r	assert: beforeSignal.\r	deny: afterSignal.\r	assert: handler.\r	deny: afterReturn.\r	assert: exceptionSignaled equals: exceptionHandled.\r	assert: signalResult equals: nil.\r	assert: result equals: 63.\r)",
 "public testExceptionSignalInHandler = (\r	|\r	outerBefore ::= false.\r	outerAfter ::= false.\r	innerBefore ::= false.\r	innerAfter ::= false.\r	innerExceptionSignaled\r	innerExceptionCaught\r	handlerExceptionSignaled\r	outerExceptionCaught\r	|\r\r	[outerBefore:: true.\r		[innerBefore:: true.\r		 innerExceptionSignaled:: Exception new.\r		 innerExceptionSignaled signal.\r		 innerAfter:: true]\r			on: Exception\r			do:\r				[:ex |\r				handlerExceptionSignaled:: Exception new.\r				handlerExceptionSignaled signal].\r	 outerAfter:: true]\r		on: Exception\r		do: [:ex | outerExceptionCaught:: ex].\r\r	assert: outerBefore.\r	assert: innerBefore.\r	deny: innerAfter.\r	deny: outerAfter.\r	assert: outerExceptionCaught equals: handlerExceptionSignaled.\r)",
 "public testExceptionTypeMatch1 = (\r	|\r	beforeSignal ::= false.\r	afterSignal ::= false.\r	afterInnerTry ::= false.\r	outerHandler ::= false.\r	innerHandler ::= false.\r	|\r\r\r	[\r		[\r			beforeSignal:: true.\r			Exception new signal.\r			afterSignal:: true.\r		] on: TestException do: [:ex | innerHandler:: true].\r		afterInnerTry:: true.\r	] on: Exception do: [:ex | outerHandler:: true].\r\r	assert: beforeSignal.\r	deny: afterSignal.\r	deny: innerHandler.\r	deny: afterInnerTry.\r	assert: outerHandler.\r)",
 "public testExceptionTypeMatch2 = (\r	|\r	beforeSignal ::= false.\r	afterSignal ::= false.\r	afterInnerTry ::= false.\r	outerHandler ::= false.\r	innerHandler ::= false.\r	|\r\r\r	[\r		[\r			beforeSignal:: true.\r			TestException new signal.\r			afterSignal:: true.\r		] on: TestException do: [:ex | innerHandler:: true].\r		afterInnerTry:: true.\r	] on: Exception do: [:ex | outerHandler:: true].\r\r	assert: beforeSignal.\r	deny: afterSignal.\r	assert: innerHandler.\r	assert: afterInnerTry.\r	deny: outerHandler.\r)",
 "public testExceptionTypeMatch3 = (\r	|\r	beforeSignal ::= false.\r	afterSignal ::= false.\r	afterInnerTry ::= false.\r	outerHandler ::= false.\r	innerHandler ::= false.\r	|\r\r\r	[\r		[\r			beforeSignal:: true.\r			TestException new signal.\r			afterSignal:: true.\r		] on: Exception do: [:ex | innerHandler:: true].\r		afterInnerTry:: true.\r	] on: TestException do: [:ex | outerHandler:: true].\r\r	assert: beforeSignal.\r	deny: afterSignal.\r	assert: innerHandler.\r	assert: afterInnerTry.\r	deny: outerHandler.\r)",
 "public testNonLocalReturnCrossingExceptionHandler = (\r	assert: nonLocalReturnCrossingExceptionHandler equals: 'correct'\r)",
 "TEST_CONTEXT = ()",
 "public class FloatTests = TestContext ()",
 "TestContext",
 "TestContext",
 "assert: observedValue approximatelyEquals: expectedValue = (\r	| delta |\r	delta:: observedValue - expectedValue.\r	delta < 0 ifTrue: [delta:: 0 - delta].\r	delta < 0.00000001 ifFalse:\r		[failWithMessage: 'Expected ', expectedValue printString, ', actual ', observedValue printString].\r)",
 "e = (\r	^Float parse: '2.718281828459045'\r)",
 "infinity = (\r	^Float parse: 'Infinity'\r)",
 "ln2 = (\r	^Float parse: '0.6931471805599453'\r)",
 "nan = (\r	^Float parse: 'NaN'\r)",
 "negativeInfinity = (\r	^Float parse: '-Infinity'\r)",
 "pi = (\r	^Float parse: '3.1415926535897932'\r)",
 "sqrt2 = (\r	^Float parse: '1.4142135623730951'\r)",
 "public testFloatAdd = (\r	assert: 3 asFloat + 4 asFloat equals: 7 asFloat.\r	assert: 3.5 asFloat + 4.5 asFloat equals: 8 asFloat.\r)",
 "public testFloatAsInteger = (\r	| nan posInfinity negInfinity |\r\r	(* truncation *)\r	assert: 3.0 asFloat asInteger equals: 3.\r	assert: -3.0 asFloat asInteger equals: -3.\r	assert: 3.4 asFloat asInteger equals: 3.\r	assert: 3.5 asFloat asInteger equals: 3.\r	assert: -3.4 asFloat asInteger equals: -3.\r	assert: -3.5 asFloat asInteger equals: -3.\r\r	assert: minDoubleInt asFloat asInteger equals: minDoubleInt.\r	deny: (minDoubleInt - 1) asFloat asInteger equals: minDoubleInt + 1.\r	assert: maxDoubleInt asFloat asInteger equals: maxDoubleInt.\r	deny: (maxDoubleInt + 1) asFloat asInteger equals: maxDoubleInt + 1.\r\r	nan:: Float parse: 'NaN'.\r	posInfinity:: Float parse: 'Infinity'.\r	negInfinity:: Float parse: '-Infinity'.\r	should: [nan asInteger] signal: Error.\r	should: [posInfinity asInteger] signal: Error.\r	should: [negInfinity asInteger] signal: Error.\r)",
 "public testFloatAsLargeInteger = (\r	assert: (Float parse: '-9223372036854775809.0') asInteger equals: -9223372036854775808.\r	assert: (Float parse: '9223372036854775808.0') asInteger equals: smallestPositiveLargeInteger.\r\r	assert: (Float parse: '4503599627370496.0') asInteger equals: 4503599627370496.\r	assert: (Float parse: '9007199254740992.0') asInteger equals: 9007199254740992.\r	assert: (Float parse: '13510798882111488.0') asInteger equals: 13510798882111488.\r	assert: (Float parse: '9007199254740992.0') asInteger equals: 9007199254740992.\r	assert: (Float parse: '18014398509481984.0') asInteger equals: 18014398509481984.\r	assert: (Float parse: '27021597764222976.0') asInteger equals: 27021597764222976.\r	assert: (Float parse: '18014398509481984.0') asInteger equals: 18014398509481984.\r	assert: (Float parse: '36028797018963970.0') asInteger equals: 36028797018963968.\r	assert: (Float parse: '54043195528445950.0') asInteger equals: 54043195528445952.\r\r	assert: (Float parse: '24740339110622220000.0') asInteger equals: 24740339110622220288.\r	assert: (Float parse: '5.312947368603608e+28') asInteger equals: 53129473686036081173933850624.\r	assert: (Float parse: '2.2818935193521754e+38') asInteger equals: 228189351935217540518047176097429192704.\r	assert: (Float parse: '1.658568574584348e+173') asInteger equals: 165856857458434792594590690796997344645011320494961564483172792646347034888659021126627038240664816862208980330541286657468273292758481943260235328058958538937625559982669824.\r\r	assert: (Float parse: '19342813113834066795298816') asInteger equals: 1 << (32 + 52).\r	assert: (Float parse: '83076749736557242056487941267521536') asInteger equals: 1 << (64 + 52).\r	assert: (Float parse: '356811923176489970264571492362373784095686656') asInteger equals: 1 << (96 + 52).\r\r	assert: (((1 << 53) - 1) << (1023 - 52)) asFloat asInteger equals: (((1 << 53) - 1) << (1023 - 52)).\r)",
 "public testFloatAsMediumInteger = (\r	assert: (Float parse: '2147483647.0') asInteger equals: maxInt32.\r	assert: (Float parse: '-2147483648.0') asInteger equals: minInt32.\r\r	assert: (Float parse: '461168601842738750.0') asInteger equals: 461168601842738752.\r	assert: (Float parse: '-4611686018427387904.0') asInteger equals: minInt63.\r\r	assert: (Float parse: '9223372036854774784.0') asInteger equals: 9223372036854774784.\r	assert: (Float parse: '-9223372036854775808.0') asInteger equals: minInt64.\r\r	assert: (Float parse: '14627351835422149374.0') asInteger equals: 14627351835422148608.\r)",
 "public testFloatAsSmallInteger = (\r	assert: (Float parse: '7.0') asInteger equals: 7.\r\r	assert: (Float parse: '1073741823.0') asInteger equals: maxInt31.\r	assert: (Float parse: '-1073741824.0') asInteger equals: minInt31.\r\r	assert: (Float parse: '3405695742.0') asInteger equals: 16rCAFECAFE.\r)",
 "public testFloatAsString = (\r	| fmax fmin |\r	assert: 3 asFloat asString equals: '3.0'.\r	assert: (3 asFloat / 2 asFloat) asString equals: '1.5'.\r	assert: (1 asFloat / 3 asFloat) asString equals: '0.3333333333333333'.\r	assert: (-22 asFloat / 7 asFloat) asString equals: '-3.142857142857143'.\r\r	assert: (Float parse: 'NaN') asString equals: 'NaN'.\r	assert: (Float parse: 'Infinity') asString equals: 'Infinity'.\r	assert: (Float parse: '-Infinity') asString equals: '-Infinity'.\r\r	fmax:: '1.7976931348623157e+308'.\r	assert: (Float parse: fmax) asString equals: '1.7976931348623157e+308'.\r	fmin:: '-1.7976931348623157e+308'.\r	assert: (Float parse: fmin) asString equals: '-1.7976931348623157e+308'.\r)",
 "public testFloatAsStringExponential = (\r	| fmax fmin |\r	assert: (3 asFloat asStringExponential: 0) equals: '3e+0'.\r	assert: (3 asFloat asStringExponential: 1) equals: '3.0e+0'.\r	assert: (3 asFloat asStringExponential: 2) equals: '3.00e+0'.\r	assert: ((3 asFloat / 2 asFloat) asStringExponential: 0) equals: '2e+0'.\r	assert: ((3 asFloat / 2 asFloat) asStringExponential: 1) equals: '1.5e+0'.\r	assert: ((3 asFloat / 2 asFloat) asStringExponential: 2) equals: '1.50e+0'.\r	assert: ((1 asFloat / 3 asFloat) asStringExponential: 0) equals: '3e-1'.\r	assert: ((1 asFloat / 3 asFloat) asStringExponential: 1) equals: '3.3e-1'.\r	assert: ((1 asFloat / 3 asFloat) asStringExponential: 2) equals: '3.33e-1'.\r	assert: ((200 asFloat / 3 asFloat) asStringExponential: 0) equals: '7e+1'.\r	assert: ((200 asFloat / 3 asFloat) asStringExponential: 1) equals: '6.7e+1'.\r	assert: ((200 asFloat / 3 asFloat) asStringExponential: 2) equals: '6.67e+1'.\r	assert: ((200 asFloat / 3 asFloat) asStringExponential: 3) equals: '6.667e+1'.\r	assert: ((200 asFloat / 3 asFloat) asStringExponential: 4) equals: '6.6667e+1'.\r	assert: ((-22 asFloat / 7 asFloat) asStringExponential: 0) equals: '-3e+0'.\r	assert: ((-22 asFloat / 7 asFloat) asStringExponential: 1) equals: '-3.1e+0'.\r	assert: ((-22 asFloat / 7 asFloat) asStringExponential: 2) equals: '-3.14e+0'.\r\r	assert: ((Float parse: '0.0') asStringExponential: 0) equals: '0e+0'.\r	assert: ((Float parse: '0.0') asStringExponential: 1) equals: '0.0e+0'.\r	assert: ((Float parse: '0.0') asStringExponential: 2) equals: '0.00e+0'.\r	assert: ((Float parse: '-0.0') asStringExponential: 0) equals: '-0e+0'.\r	assert: ((Float parse: '-0.0') asStringExponential: 1) equals: '-0.0e+0'.\r	assert: ((Float parse: '-0.0') asStringExponential: 2) equals: '-0.00e+0'.\r	assert: ((Float parse: 'NaN') asStringExponential: 0) equals: 'NaN'.\r	assert: ((Float parse: 'NaN') asStringExponential: 1) equals: 'NaN'.\r	assert: ((Float parse: 'NaN') asStringExponential: 2) equals: 'NaN'.\r	assert: ((Float parse: 'Infinity') asStringExponential: 0) equals: 'Infinity'.\r	assert: ((Float parse: 'Infinity') asStringExponential: 1) equals: 'Infinity'.\r	assert: ((Float parse: 'Infinity') asStringExponential: 2) equals: 'Infinity'.\r	assert: ((Float parse: '-Infinity') asStringExponential: 0) equals: '-Infinity'.\r	assert: ((Float parse: '-Infinity') asStringExponential: 1) equals: '-Infinity'.\r	assert: ((Float parse: '-Infinity') asStringExponential: 2) equals: '-Infinity'.\r\r	fmax:: '1.7976931348623157e+308'.\r	assert: ((Float parse: fmax) asStringExponential: 0) equals: '2e+308'.\r	assert: ((Float parse: fmax) asStringExponential: 1) equals: '1.8e+308'.\r	assert: ((Float parse: fmax) asStringExponential: 2) equals: '1.80e+308'.\r	assert: ((Float parse: fmax) asStringExponential: 10) equals: '1.7976931349e+308'.\r	assert: ((Float parse: fmax) asStringExponential: 20) equals: '1.79769313486231570815e+308'.\r	fmin:: '-1.7976931348623157e+308'.\r	assert: ((Float parse: fmin) asStringExponential: 0) equals: '-2e+308'.\r	assert: ((Float parse: fmin) asStringExponential: 1) equals: '-1.8e+308'.\r	assert: ((Float parse: fmin) asStringExponential: 2) equals: '-1.80e+308'.\r	assert: ((Float parse: fmin) asStringExponential: 10) equals: '-1.7976931349e+308'.\r	assert: ((Float parse: fmin) asStringExponential: 20) equals: '-1.79769313486231570815e+308'.\r)",
 "public testFloatAsStringExponentialErrors = (\r	should: [0 asFloat asStringExponential: -1] signal: Error.\r	should: [0 asFloat asStringExponential: 21] signal: Error.\r	should: [0 asFloat asStringExponential: nil] signal: Error.\r	should: [0 asFloat asStringExponential: '1'] signal: Error.\r)",
 "public testFloatAsStringFixed = (\r	| fmax fmin |\r	assert: (3 asFloat asStringFixed: 0) equals: '3'.\r	assert: (3 asFloat asStringFixed: 1) equals: '3.0'.\r	assert: (3 asFloat asStringFixed: 2) equals: '3.00'.\r	assert: ((3 asFloat / 2 asFloat) asStringFixed: 0) equals: '2'.\r	assert: ((3 asFloat / 2 asFloat) asStringFixed: 1) equals: '1.5'.\r	assert: ((3 asFloat / 2 asFloat) asStringFixed: 2) equals: '1.50'.\r	assert: ((1 asFloat / 3 asFloat) asStringFixed: 0) equals: '0'.\r	assert: ((1 asFloat / 3 asFloat) asStringFixed: 1) equals: '0.3'.\r	assert: ((1 asFloat / 3 asFloat) asStringFixed: 2) equals: '0.33'.\r	assert: ((200 asFloat / 3 asFloat) asStringFixed: 0) equals: '67'.\r	assert: ((200 asFloat / 3 asFloat) asStringFixed: 1) equals: '66.7'.\r	assert: ((200 asFloat / 3 asFloat) asStringFixed: 2) equals: '66.67'.\r	assert: ((200 asFloat / 3 asFloat) asStringFixed: 3) equals: '66.667'.\r	assert: ((200 asFloat / 3 asFloat) asStringFixed: 4) equals: '66.6667'.\r	assert: ((-22 asFloat / 7 asFloat) asStringFixed: 0) equals: '-3'.\r	assert: ((-22 asFloat / 7 asFloat) asStringFixed: 1) equals: '-3.1'.\r	assert: ((-22 asFloat / 7 asFloat) asStringFixed: 2) equals: '-3.14'.\r\r	assert: ((Float parse: '0.0') asStringFixed: 0) equals: '0'.\r	assert: ((Float parse: '0.0') asStringFixed: 1) equals: '0.0'.\r	assert: ((Float parse: '0.0') asStringFixed: 2) equals: '0.00'.\r	assert: ((Float parse: '-0.0') asStringFixed: 0) equals: '-0'.\r	assert: ((Float parse: '-0.0') asStringFixed: 1) equals: '-0.0'.\r	assert: ((Float parse: '-0.0') asStringFixed: 2) equals: '-0.00'.\r	assert: ((Float parse: 'NaN') asStringFixed: 0) equals: 'NaN'.\r	assert: ((Float parse: 'NaN') asStringFixed: 1) equals: 'NaN'.\r	assert: ((Float parse: 'NaN') asStringFixed: 2) equals: 'NaN'.\r	assert: ((Float parse: 'Infinity') asStringFixed: 0) equals: 'Infinity'.\r	assert: ((Float parse: 'Infinity') asStringFixed: 1) equals: 'Infinity'.\r	assert: ((Float parse: 'Infinity') asStringFixed: 2) equals: 'Infinity'.\r	assert: ((Float parse: '-Infinity') asStringFixed: 0) equals: '-Infinity'.\r	assert: ((Float parse: '-Infinity') asStringFixed: 1) equals: '-Infinity'.\r	assert: ((Float parse: '-Infinity') asStringFixed: 2) equals: '-Infinity'.\r\r	fmax:: '1.7976931348623157e+308'.\r	assert: ((Float parse: fmax) asStringFixed: 0) equals: '1.7976931348623157e+308'.\r	assert: ((Float parse: fmax) asStringFixed: 1) equals: '1.7976931348623157e+308'.\r	assert: ((Float parse: fmax) asStringFixed: 2) equals: '1.7976931348623157e+308'.\r	assert: ((Float parse: fmax) asStringFixed: 10) equals: '1.7976931348623157e+308'.\r	assert: ((Float parse: fmax) asStringFixed: 20) equals: '1.7976931348623157e+308'.\r	fmin:: '-1.7976931348623157e+308'.\r	assert: ((Float parse: fmin) asStringFixed: 0) equals: '-1.7976931348623157e+308'.\r	assert: ((Float parse: fmin) asStringFixed: 1) equals: '-1.7976931348623157e+308'.\r	assert: ((Float parse: fmin) asStringFixed: 2) equals: '-1.7976931348623157e+308'.\r	assert: ((Float parse: fmin) asStringFixed: 10) equals: '-1.7976931348623157e+308'.\r	assert: ((Float parse: fmin) asStringFixed: 20) equals: '-1.7976931348623157e+308'.\r)",
 "public testFloatAsStringFixedErrors = (\r	should: [0 asFloat asStringFixed: -1] signal: Error.\r	should: [0 asFloat asStringFixed: 21] signal: Error.\r	should: [0 asFloat asStringFixed: nil] signal: Error.\r	should: [0 asFloat asStringFixed: '1'] signal: Error.\r)",
 "public testFloatAsStringPrecision = (\r	| fmax fmin |\r	assert: (3 asFloat asStringPrecision: 1) equals: '3'.\r	assert: (3 asFloat asStringPrecision: 2) equals: '3.0'.\r	assert: (3 asFloat asStringPrecision: 3) equals: '3.00'.\r	assert: ((3 asFloat / 2 asFloat) asStringPrecision: 1) equals: '2'.\r	assert: ((3 asFloat / 2 asFloat) asStringPrecision: 2) equals: '1.5'.\r	assert: ((3 asFloat / 2 asFloat) asStringPrecision: 3) equals: '1.50'.\r	assert: ((1 asFloat / 3 asFloat) asStringPrecision: 1) equals: '0.3'.\r	assert: ((1 asFloat / 3 asFloat) asStringPrecision: 2) equals: '0.33'.\r	assert: ((1 asFloat / 3 asFloat) asStringPrecision: 3) equals: '0.333'.\r	assert: ((200 asFloat / 3 asFloat) asStringPrecision: 1) equals: '7e+1'.\r	assert: ((200 asFloat / 3 asFloat) asStringPrecision: 2) equals: '67'.\r	assert: ((200 asFloat / 3 asFloat) asStringPrecision: 3) equals: '66.7'.\r	assert: ((200 asFloat / 3 asFloat) asStringPrecision: 4) equals: '66.67'.\r	assert: ((200 asFloat / 3 asFloat) asStringPrecision: 5) equals: '66.667'.\r	assert: ((-22 asFloat / 7 asFloat) asStringPrecision: 1) equals: '-3'.\r	assert: ((-22 asFloat / 7 asFloat) asStringPrecision: 2) equals: '-3.1'.\r	assert: ((-22 asFloat / 7 asFloat) asStringPrecision: 3) equals: '-3.14'.\r\r	assert: ((Float parse: '0.0') asStringPrecision: 1) equals: '0'.\r	assert: ((Float parse: '0.0') asStringPrecision: 2) equals: '0.0'.\r	assert: ((Float parse: '0.0') asStringPrecision: 3) equals: '0.00'.\r	assert: ((Float parse: '-0.0') asStringPrecision: 1) equals: '-0'.\r	assert: ((Float parse: '-0.0') asStringPrecision: 2) equals: '-0.0'.\r	assert: ((Float parse: '-0.0') asStringPrecision: 3) equals: '-0.00'.\r	assert: ((Float parse: 'NaN') asStringPrecision: 1) equals: 'NaN'.\r	assert: ((Float parse: 'NaN') asStringPrecision: 2) equals: 'NaN'.\r	assert: ((Float parse: 'NaN') asStringPrecision: 3) equals: 'NaN'.\r	assert: ((Float parse: 'Infinity') asStringPrecision: 1) equals: 'Infinity'.\r	assert: ((Float parse: 'Infinity') asStringPrecision: 2) equals: 'Infinity'.\r	assert: ((Float parse: 'Infinity') asStringPrecision: 3) equals: 'Infinity'.\r	assert: ((Float parse: '-Infinity') asStringPrecision: 1) equals: '-Infinity'.\r	assert: ((Float parse: '-Infinity') asStringPrecision: 2) equals: '-Infinity'.\r	assert: ((Float parse: '-Infinity') asStringPrecision: 3) equals: '-Infinity'.\r\r	fmax:: '1.7976931348623157e+308'.\r	assert: ((Float parse: fmax) asStringPrecision: 1) equals: '2e+308'.\r	assert: ((Float parse: fmax) asStringPrecision: 2) equals: '1.8e+308'.\r	assert: ((Float parse: fmax) asStringPrecision: 3) equals: '1.80e+308'.\r	assert: ((Float parse: fmax) asStringPrecision: 10) equals: '1.797693135e+308'.\r	assert: ((Float parse: fmax) asStringPrecision: 20) equals: '1.7976931348623157081e+308'.\r	fmin:: '-1.7976931348623157e+308'.\r	assert: ((Float parse: fmin) asStringPrecision: 1) equals: '-2e+308'.\r	assert: ((Float parse: fmin) asStringPrecision: 2) equals: '-1.8e+308'.\r	assert: ((Float parse: fmin) asStringPrecision: 3) equals: '-1.80e+308'.\r	assert: ((Float parse: fmin) asStringPrecision: 10) equals: '-1.797693135e+308'.\r	assert: ((Float parse: fmin) asStringPrecision: 20) equals: '-1.7976931348623157081e+308'.\r)",
 "public testFloatAsStringPrecisionErrors = (\r	should: [0 asFloat asStringPrecision: 0] signal: Error.\r	should: [0 asFloat asStringPrecision: 22] signal: Error.\r	should: [0 asFloat asStringPrecision: nil] signal: Error.\r	should: [0 asFloat asStringPrecision: '1'] signal: Error.\r)",
 "public testFloatCeiling = (\r	assert: 3.0 asFloat ceiling equals: 3.\r	assert: 3.4 asFloat ceiling equals: 4.\r	assert: 3.5 asFloat ceiling equals: 4.\r	assert: -3.4 asFloat ceiling equals: -3.\r	assert: -3.5 asFloat ceiling equals: -3.\r\r	assert: minDoubleInt asFloat ceiling equals: minDoubleInt.\r	(* :todo: Should float-integer comparison be precise?\r	deny: (minDoubleInt - 1) asFloat ceiling equals: minDoubleInt + 1. *)\r	assert: maxDoubleInt asFloat ceiling equals: maxDoubleInt.\r	(* :todo: Should float-integer comparison be precise?\r	deny: (maxDoubleInt + 1) asFloat ceiling equals: maxDoubleInt + 1. *)\r\r	minInt64 asFloat ceiling.\r	maxInt64 asFloat ceiling.\r)",
 "public testFloatCommonLogarithm = (\r	assert: 100 asFloat log equals: 2.\r	assert: 10 asFloat log equals: 1.\r	assert: 1 asFloat log equals: 0.\r	assert: 0.1 asFloat log approximatelyEquals: -1.\r	assert: 0.01 asFloat log approximatelyEquals: -2.\r\r	assert: -1 asFloat log isNaN.\r\r	assert: infinity log equals: infinity.\r	assert: negativeInfinity log isNaN.\r	assert: nan log isNaN.\r)",
 "public testFloatComparisonErrors = (\r	deny: 4.25 asFloat = '4.25'.\r	should: [4.25 asFloat < '4.25'] signal: Error.\r	should: [4.25 asFloat > '4.25'] signal: Error.\r	should: [4.25 asFloat <= '4.25'] signal: Error.\r	should: [4.25 asFloat >= '4.25'] signal: Error.\r\r	deny: 4.25 asFloat = {4.25 asFloat}.\r	should: [4.25 asFloat < {4.25 asFloat}] signal: Error.\r	should: [4.25 asFloat > {4.25 asFloat}] signal: Error.\r	should: [4.25 asFloat <= {4.25 asFloat}] signal: Error.\r	should: [4.25 asFloat >= {4.25 asFloat}] signal: Error.\r)",
 "public testFloatComparisons = (\r	assert: 1.618 asFloat = 1.618 asFloat.\r	deny: 1.618 asFloat < 1.618 asFloat.\r	deny: 1.618 asFloat > 1.618 asFloat.\r	assert: 1.618 asFloat <= 1.618 asFloat.\r	assert: 1.618 asFloat >= 1.618 asFloat.\r\r	deny: 1.2 asFloat = 1.3 asFloat.\r	assert: 1.2 asFloat < 1.3 asFloat.\r	deny: 1.2 asFloat > 1.3 asFloat.\r	assert: 1.2 asFloat <= 1.3 asFloat.\r	deny: 1.2 asFloat >= 1.3 asFloat.\r\r	deny: -1.2 asFloat = 1.3 asFloat.\r	assert: -1.2 asFloat < 1.3 asFloat.\r	deny: -1.2 asFloat > 1.3 asFloat.\r	assert: -1.2 asFloat <= 1.3 asFloat.\r	deny: -1.2 asFloat >= 1.3 asFloat.\r\r	deny: 1.2 asFloat = -1.3 asFloat.\r	deny: 1.2 asFloat < -1.3 asFloat.\r	assert: 1.2 asFloat > -1.3 asFloat.\r	deny: 1.2 asFloat <= -1.3 asFloat.\r	assert: 1.2 asFloat >= -1.3 asFloat.\r\r	deny: -1.2 asFloat = -1.3 asFloat.\r	deny: -1.2 asFloat < -1.3 asFloat.\r	assert: -1.2 asFloat > -1.3 asFloat.\r	deny: -1.2 asFloat <= -1.3 asFloat.\r	assert: -1.2 asFloat >= -1.3 asFloat.\r)",
 "public testFloatCosine = (\r	assert: (-2 * pi) cos approximatelyEquals: 1.\r	assert: (-3 * pi / 2) cos approximatelyEquals: 0.\r	assert: (0 - pi) cos approximatelyEquals: -1.\r	assert: (0 - (pi / 2)) cos approximatelyEquals: 0.\r	assert: 0 asFloat cos approximatelyEquals: 1.\r	assert: (pi / 2) cos approximatelyEquals: 0.\r	assert: pi cos approximatelyEquals: -1.\r	assert: (3 * pi / 2) cos approximatelyEquals: 0.\r	assert: (2 * pi) cos approximatelyEquals: 1.\r\r	assert: infinity cos isNaN.\r	assert: negativeInfinity cos isNaN.\r	assert: nan cos isNaN.\r)",
 "public testFloatDivide = (\r	assert: 3 asFloat / 4 asFloat equals: 0.75 asFloat.\r	assert: 3.5 asFloat / 3.5 asFloat equals: 1 asFloat.\r	assert: (3.5 asFloat / 0.0 asFloat) equals: (Float parse: 'Infinity').\r	assert: (-3.5 asFloat / 0.0 asFloat) equals: (Float parse: '-Infinity').\r	assert: (0.0 asFloat / 0.0 asFloat) isNaN.\r)",
 "public testFloatExponential = (\r	assert: 1 asFloat exp approximatelyEquals: e.\r	assert: 0 asFloat exp equals: 1.\r\r	assert: infinity exp equals: infinity.\r	assert: negativeInfinity exp equals: 0.\r	assert: nan exp isNaN.\r)",
 "public testFloatFloor = (\r	assert: 3.0 asFloat floor equals: 3.\r	assert: 3.4 asFloat floor equals: 3.\r	assert: 3.5 asFloat floor equals: 3.\r	assert: -3.4 asFloat floor equals: -4.\r	assert: -3.5 asFloat floor equals: -4.\r\r	assert: minDoubleInt asFloat floor equals: minDoubleInt.\r	(* :todo: Should float-integer comparison be precise?\r	deny: (minDoubleInt - 1) asFloat floor equals: minDoubleInt + 1. *)\r	assert: maxDoubleInt asFloat floor equals: maxDoubleInt.\r	(* :todo: Should float-integer comparison be precise?\r	deny: (maxDoubleInt + 1) asFloat floor equals: maxDoubleInt + 1. *)\r\r	minInt64 asFloat floor.\r	maxInt64 asFloat floor.\r)",
 "public testFloatFunctions = (\r	(* :todo: Tests results with some tolerance. *)\r\r	assert: 3 asFloat sin isKindOfFloat.\r	assert: 3 asFloat cos isKindOfFloat.\r	assert: 3 asFloat tan isKindOfFloat.\r	assert: 3 asFloat sqrt isKindOfFloat.\r	assert: 3 asFloat log isKindOfFloat.\r	assert: 3 asFloat ln isKindOfFloat.\r	assert: 3 asFloat exp isKindOfFloat.\r\r	assert: 3 sin isKindOfFloat.\r	assert: 3 cos isKindOfFloat.\r	assert: 3 tan isKindOfFloat.\r	assert: 3 sqrt isKindOfFloat.\r	assert: 3 log isKindOfFloat.\r	assert: 3 ln isKindOfFloat.\r	assert: 3 exp isKindOfFloat.\r)",
 "public testFloatHash = (\r	assert: -3 asFloat hash equals: -3 hash.\r	assert: 0 asFloat hash equals: 0 hash.\r	assert: 3 asFloat hash equals: 3 hash.\r\r	assert: minDoubleInt asFloat hash equals: minDoubleInt hash.\r	assert: maxDoubleInt asFloat hash equals: maxDoubleInt hash.\r)",
 "public testFloatIsNaN = (\r	assert: nan isNaN.\r	deny: infinity isNaN.\r	deny: negativeInfinity isNaN.\r)",
 "public testFloatMixedAdd = (\r	assert: 3 + 4 asFloat equals: 7.\r	assert: 3 asFloat + 4 equals: 7.\r\r	assert: minInt31 + 4 asFloat equals: -1073741820 asFloat.\r	assert: 3 asFloat + minInt31 equals: -1073741821 asFloat.\r	assert: maxInt31 + 4 asFloat equals: 1073741827 asFloat.\r	assert: 3 asFloat + maxInt31 equals: 1073741826 asFloat.\r\r	assert: minInt63 + 4 asFloat equals: -4611686018427387900 asFloat.\r	assert: 3 asFloat + minInt63 equals: -4611686018427387901 asFloat.\r	assert: maxInt63 + 4 asFloat equals: 4611686018427387907 asFloat.\r	assert: 3 asFloat + maxInt63 equals: 4611686018427387906 asFloat.\r\r	assert: minInt64 + 4 asFloat equals: -9223372036854775804 asFloat.\r	assert: 3 asFloat + minInt64 equals: -9223372036854775805 asFloat.\r	assert: maxInt64 + 4 asFloat equals: (Float parse: '9.223372036854776e18').\r	assert: 3 asFloat + maxInt64 equals: (Float parse: '9.223372036854776e18').\r\r	assert: smallestPositiveLargeInteger + 4 asFloat equals: (Float parse: '9.223372036854776e18').\r	assert: 3 asFloat + smallestPositiveLargeInteger equals: (Float parse: '9.223372036854776e18').\r	assert: largestNegativeLargeInteger + 4 asFloat equals: (Float parse: '-9.223372036854776e18').\r	assert: 3 asFloat + largestNegativeLargeInteger equals: (Float parse: '-9.223372036854776e18').\r)",
 "public testFloatMixedComparisons = (\r	deny: 1.618 asFloat = 42.\r	assert: 1.618 asFloat < 42.\r	deny: 1.618 asFloat > 42.\r	assert: 1.618 asFloat <= 42.\r	deny: 1.618 asFloat >= 42.\r\r	deny: 42 = 1.618 asFloat.\r	deny: 42 < 1.618 asFloat.\r	assert: 42 > 1.618 asFloat.\r	deny: 42 <= 1.618 asFloat.\r	assert: 42 >= 1.618 asFloat.\r\r	assert: 42 asFloat = 42.\r	deny: 42 asFloat < 42.\r	deny: 42 asFloat > 42.\r	assert: 42 asFloat <= 42.\r	assert: 42 asFloat >= 42.\r\r	assert: 42 = 42 asFloat.\r	deny: 42 < 42 asFloat.\r	deny: 42 > 42 asFloat.\r	assert: 42 <= 42 asFloat.\r	assert: 42 >= 42 asFloat.\r\r	deny: 42 asFloat = maxInt64.\r	assert: 42 asFloat < maxInt64.\r	deny: 42 asFloat > maxInt64.\r	assert: 42 asFloat <= maxInt64.\r	deny: 42 asFloat >= maxInt64.\r\r	deny: maxInt64 = 42 asFloat.\r	deny: maxInt64 < 42 asFloat.\r	assert: maxInt64 > 42 asFloat.\r	deny: maxInt64 <= 42 asFloat.\r	assert: maxInt64 >= 42 asFloat.\r\r	deny: 42 asFloat = minInt64.\r	deny: 42 asFloat < minInt64.\r	assert: 42 asFloat > minInt64.\r	deny: 42 asFloat <= minInt64.\r	assert: 42 asFloat >= minInt64.\r\r	deny: minInt64 = 42 asFloat.\r	assert: minInt64 < 42 asFloat.\r	deny: minInt64 > 42 asFloat.\r	assert: minInt64 <= 42 asFloat.\r	deny: minInt64 >= 42 asFloat.\r\r	deny: 42 asFloat = smallestPositiveLargeInteger.\r	assert: 42 asFloat < smallestPositiveLargeInteger.\r	deny: 42 asFloat > smallestPositiveLargeInteger.\r	assert: 42 asFloat <= smallestPositiveLargeInteger.\r	deny: 42 asFloat >= smallestPositiveLargeInteger.\r\r	deny: smallestPositiveLargeInteger = 42 asFloat.\r	deny: smallestPositiveLargeInteger < 42 asFloat.\r	assert: smallestPositiveLargeInteger > 42 asFloat.\r	deny: smallestPositiveLargeInteger <= 42 asFloat.\r	assert: smallestPositiveLargeInteger >= 42 asFloat.\r\r	deny: 42 asFloat = largestNegativeLargeInteger.\r	deny: 42 asFloat < largestNegativeLargeInteger.\r	assert: 42 asFloat > largestNegativeLargeInteger.\r	deny: 42 asFloat <= largestNegativeLargeInteger.\r	assert: 42 asFloat >= largestNegativeLargeInteger.\r\r	deny: largestNegativeLargeInteger = 42 asFloat.\r	assert: largestNegativeLargeInteger < 42 asFloat.\r	deny: largestNegativeLargeInteger > 42 asFloat.\r	assert: largestNegativeLargeInteger <= 42 asFloat.\r	deny: largestNegativeLargeInteger >= 42 asFloat.\r)",
 "public testFloatMixedDivide = (\r	assert: 3 / 4 asFloat equals: 0.75 asFloat.\r	assert: 3 asFloat / 4 equals: 0.75 asFloat.\r\r	assert: minInt31 / 4 asFloat equals: (Float parse: '-2.68435456e8').\r	assert: 3 asFloat / minInt31 equals: (Float parse: '-2.7939677238464355e-9').\r	assert: maxInt31 / 4 asFloat equals: (Float parse: '2.6843545575e8').\r	assert: 3 asFloat / maxInt31 equals: (Float parse: '2.7939677264485208e-9').\r\r	assert: minInt63 / 4 asFloat equals: (Float parse: '-1.152921504606847e18').\r	assert: 3 asFloat / minInt63 equals: (Float parse: '-6.505213034913027e-19').\r	assert: maxInt63 / 4 asFloat equals: (Float parse: '1.152921504606847e18').\r	assert: 3 asFloat / maxInt63 equals: (Float parse: '6.505213034913027e-19').\r\r	assert: minInt64 / 4 asFloat equals: (Float parse: '-2.305843009213694e18').\r	assert: 3 asFloat / minInt64 equals: (Float parse: '-3.2526065174565133e-19').\r	assert: maxInt64 / 4 asFloat equals: (Float parse: '2.305843009213694e18').\r	assert: 3 asFloat / maxInt64 equals: (Float parse: '3.2526065174565133e-19').\r\r	assert: smallestPositiveLargeInteger / 4 asFloat equals: (Float parse: '2.305843009213694e18').\r	assert: 3 asFloat / smallestPositiveLargeInteger equals: (Float parse: '3.2526065174565133e-19').\r	assert: largestNegativeLargeInteger / 4 asFloat equals: (Float parse: '-2.305843009213694e18').\r	assert: 3 asFloat / largestNegativeLargeInteger equals: (Float parse: '-3.2526065174565133e-19').\r\r	assert: 3 asFloat / 0 equals: (Float parse: 'Infinity').\r	assert: -3 / 0 asFloat equals: (Float parse: '-Infinity').\r	assert: (0 asFloat / 0) isNaN.\r	assert: (0 / 0 asFloat) isNaN.\r)",
 "public testFloatMixedMultiply = (\r	assert: 3 * 4 asFloat equals: 12 asFloat.\r	assert: 3 asFloat * 4 equals: 12 asFloat.\r\r	assert: minInt31 * 4 asFloat equals: (Float parse: '-4.294967296e9').\r	assert: 3 asFloat * minInt31 equals: -3221225472 asFloat.\r	assert: maxInt31 * 4 asFloat equals: 4294967292 asFloat.\r	assert: 3 asFloat * maxInt31 equals: 3221225469 asFloat.\r\r	assert: minInt63 * 4 asFloat equals: (Float parse: '-1.8446744073709552e19').\r	assert: 3 asFloat * minInt63 equals: (Float parse: '-1.3835058055282164e19').\r	assert: maxInt63 * 4 asFloat equals: (Float parse: '1.8446744073709552e19').\r	assert: 3 asFloat * maxInt63 equals: (Float parse: '1.3835058055282164e19').\r\r	assert: minInt64 * 4 asFloat equals: (Float parse: '-3.6893488147419103e19').\r	assert: 3 asFloat * minInt64 equals: (Float parse: '-2.7670116110564327e19').\r	assert: maxInt64 * 4 asFloat equals: (Float parse: '3.6893488147419103e19').\r	assert: 3 asFloat * maxInt64 equals: (Float parse: '2.7670116110564327e19').\r\r	assert: smallestPositiveLargeInteger * 4 asFloat equals: (Float parse: '3.6893488147419103e19').\r	assert: 3 asFloat * smallestPositiveLargeInteger equals: (Float parse: '2.7670116110564327e19').\r	assert: largestNegativeLargeInteger * 4 asFloat equals: (Float parse: '-3.6893488147419103e19').\r	assert: 3 asFloat * largestNegativeLargeInteger equals: (Float parse: '-2.7670116110564327e19').\r\r	assert: 3 asFloat * 0 equals: 0 asFloat.\r	assert: 0 * 4 asFloat equals: 0 asFloat.\r)",
 "public testFloatMixedSubtract = (\r	assert: 3 - 4 asFloat equals: -1 asFloat.\r	assert: 3 asFloat - 4 equals: -1 asFloat.\r\r	assert: minInt31 - 4 asFloat equals: -1073741828 asFloat.\r	assert: 3 asFloat - minInt31 equals: (Float parse: '1.073741827e9').\r	assert: maxInt31 - 4 asFloat equals: (Float parse: '1.073741819e9').\r	assert: 3 asFloat - maxInt31 equals: (Float parse: '-1.07374182e9').\r\r	assert: minInt63 - 4 asFloat equals: (Float parse: '-4.611686018427388e18').\r	assert: 3 asFloat - minInt63 equals: (Float parse: '4.611686018427388e18').\r	assert: maxInt63 - 4 asFloat equals: (Float parse: '4.611686018427388e18').\r	assert: 3 asFloat - maxInt63 equals: (Float parse: '-4.611686018427388e18').\r\r	assert: minInt64 - 4 asFloat equals: (Float parse: '-9.223372036854776e18').\r	assert: 3 asFloat - minInt64 equals: (Float parse: '9.223372036854776e18').\r	assert: maxInt64 - 4 asFloat equals: (Float parse: '9.223372036854776e18').\r	assert: 3 asFloat - maxInt64 equals: (Float parse: '-9.223372036854776e18').\r\r	assert: smallestPositiveLargeInteger - 4 asFloat equals: (Float parse: '9.223372036854776e18').\r	assert: 3 asFloat - smallestPositiveLargeInteger equals: (Float parse: '-9.223372036854776e18').\r	assert: largestNegativeLargeInteger - 4 asFloat equals: (Float parse: '-9.223372036854776e18').\r	assert: 3 asFloat - largestNegativeLargeInteger equals: (Float parse: '9.223372036854776e18').\r)",
 "public testFloatMultiply = (\r	assert: 3 asFloat * 4 asFloat equals: 12 asFloat.\r	assert: 3.5 asFloat * 4.5 asFloat equals: 15.75 asFloat.\r	assert: 3.5 asFloat * 0 asFloat equals: 0 asFloat.\r)",
 "public testFloatNaturalLogarithm = (\r	assert: 2 asFloat ln equals: ln2.\r	assert: e ln equals: 1.\r\r	assert: -1 asFloat ln isNaN.\r\r	assert: infinity ln equals: infinity.\r	assert: negativeInfinity ln isNaN.\r	assert: nan ln isNaN.\r)",
 "public testFloatOperatorsInvalidArgument = (\r	should: [0 asFloat + nil] signal: Error.\r	should: [0 asFloat - nil] signal: Error.\r	should: [0 asFloat / nil] signal: Error.\r	should: [0 asFloat * nil] signal: Error.\r	should: [0 asFloat // nil] signal: Error.\r	should: [0 asFloat \\\\ nil] signal: Error.\r	should: [0 asFloat quo: nil] signal: Error.\r	should: [0 asFloat rem: nil] signal: Error.\r	should: [0 asFloat << nil] signal: Error.\r	should: [0 asFloat >> nil] signal: Error.\r	should: [0 asFloat bitAnd: nil] signal: Error.\r	should: [0 asFloat bitOr: nil] signal: Error.\r	should: [0 asFloat bitXor: nil] signal: Error.\r)",
 "public testFloatParse = (\r	assert: (Float parse: '3') isKindOfFloat.\r	assert: (Float parse: '3') equals: 3 asFloat.\r\r	assert: (Float parse: '3.') isKindOfFloat.\r	assert: (Float parse: '3.') equals: 3 asFloat.\r\r	assert: (Float parse: '3.0') isKindOfFloat.\r	assert: (Float parse: '3.0') equals: 3 asFloat.\r\r	assert: (Float parse: '0003.0000') isKindOfFloat.\r	assert: (Float parse: '0003.0000') equals: 3 asFloat.\r\r	assert: (Float parse: '-3') isKindOfFloat.\r	assert: (Float parse: '-3') equals: -3 asFloat.\r\r	assert: (Float parse: '1.5') isKindOfFloat.\r	assert: (Float parse: '1.5') equals: 1.5 asFloat.\r\r	assert: (Float parse: 'NaN') isKindOfFloat.\r	deny: (Float parse: 'NaN') equals: (Float parse: 'NaN').\r	assert: (Float parse: 'NaN') asString equals: 'NaN'.\r\r	assert: (Float parse: 'Infinity') isKindOfFloat.\r	assert: (Float parse: 'Infinity') > 0.\r	assert: (Float parse: 'Infinity') asString equals: 'Infinity'.\r	assert: (Float parse: '-Infinity') isKindOfFloat.\r	assert: (Float parse: '-Infinity') < 0.\r	assert: (Float parse: '-Infinity') asString equals: '-Infinity'.\r\r	should: [Float parse: 'xyz'] signal: Error.\r	should: [Float parse: ''] signal: Error.\r	should: [Float parse: '--9'] signal: Error.\r	should: [Float parse: 'nan'] signal: Error.\r	should: [Float parse: 'NAN'] signal: Error.\r	should: [Float parse: 'infinity'] signal: Error.\r	should: [Float parse: '-infinity'] signal: Error.\r	should: [Float parse: 'inf'] signal: Error.\r	should: [Float parse: '-inf'] signal: Error.\r)",
 "public testFloatRounded = (\r	assert: 3.0 asFloat rounded equals: 3.\r	assert: 3.4 asFloat rounded equals: 3.\r	assert: 3.5 asFloat rounded equals: 4.\r	assert: -3.4 asFloat rounded equals: -3.\r	assert: -3.5 asFloat rounded equals: -4.\r\r	minInt64 asFloat rounded.\r	maxInt64 asFloat rounded.\r)",
 "public testFloatSine = (\r	assert: (-2 * pi) sin approximatelyEquals: 0.\r	assert: (-3 * pi / 2) sin approximatelyEquals: 1.\r	assert: (0 - pi) sin approximatelyEquals: 0.\r	assert: (0 - (pi / 2)) sin approximatelyEquals: -1.\r	assert: 0 asFloat sin approximatelyEquals: 0.\r	assert: (pi / 2) sin approximatelyEquals: 1.\r	assert: pi sin approximatelyEquals: 0.\r	assert: (3 * pi / 2) sin approximatelyEquals: -1.\r	assert: (2 * pi) sin approximatelyEquals: 0.\r\r	assert: infinity sin isNaN.\r	assert: negativeInfinity sin isNaN.\r	assert: nan sin isNaN.\r)",
 "public testFloatSquareRoot = (\r	assert: 4 asFloat sqrt equals: 2.\r	assert: 2 asFloat sqrt equals: sqrt2.\r	assert: 0 asFloat sqrt equals: 0.\r\r	assert: -1 asFloat sqrt isNaN.\r\r	assert: infinity sqrt equals: infinity.\r	assert: negativeInfinity sqrt isNaN.\r	assert: nan sqrt isNaN.\r)",
 "public testFloatSubtract = (\r	assert: 3 asFloat - 4 asFloat equals: -1 asFloat.\r	assert: 3.5 asFloat - 4.5 asFloat equals: -1 asFloat.\r)",
 "public testFloatTangent = (\r	assert: (0 - pi) tan approximatelyEquals: 0.\r	assert: -1 asFloat tan approximatelyEquals: (Float parse: '-1.5574077246549025').\r	assert: 0 asFloat tan approximatelyEquals: 0.\r	assert: 1 asFloat tan approximatelyEquals: (Float parse: '1.5574077246549025').\r	assert: pi tan approximatelyEquals: 0.\r\r	assert: infinity tan isNaN.\r	assert: negativeInfinity tan isNaN.\r	assert: nan tan isNaN.\r)",
 "public testIsKindOfFloat = (\r	deny: 'foo' isKindOfFloat.\r	deny: #foo isKindOfFloat.\r	deny: ('foo', 'bar') isKindOfFloat.\r	deny: 1 isKindOfFloat.\r	deny: 1.5 isKindOfFloat.\r	assert: 1.5 asFloat isKindOfFloat.\r	deny: true isKindOfFloat.\r	deny: nil isKindOfFloat.\r	deny: {} isKindOfFloat.\r	deny: [] isKindOfFloat.\r)",
 "TEST_CONTEXT = ()",
 "public class FractionTests = TestContext ()",
 "TestContext",
 "TestContext",
 "public testFractionAdd = (\r	assert: (1/3) + (1/3) equals: (2/3).\r	assert: (1/3) + (2/3) equals: 1.\r\r	assert: (1/3) + (2/5) equals: (11/15).\r	assert: (6/9) + (1/12) equals: (3/4).\r\r	assert: (-1/3) + (2/5) equals: (1/15).\r	assert: (1/3) + (-2/5) equals: (-1/15).\r	assert: (-1/3) + (-2/5) equals: (-11/15).\r)",
 "public testFractionAsInteger = (\r	(* Truncated *)\r	assert: (2 / 5) asInteger equals: 0.\r	assert: (3 / 5) asInteger equals: 0.\r	assert: (4 / 5) asInteger equals: 0.\r	assert: (5 / 5) asInteger equals: 1.\r	assert: (7 / 5) asInteger equals: 1.\r	assert: (8 / 5) asInteger equals: 1.\r	assert: (9 / 5) asInteger equals: 1.\r\r	assert: (-2 / 5) asInteger equals: 0.\r	assert: (-3 / 5) asInteger equals: 0.\r	assert: (-4 / 5) asInteger equals: 0.\r	assert: (-5 / 5) asInteger equals: -1.\r	assert: (-7 / 5) asInteger equals: -1.\r	assert: (-8 / 5) asInteger equals: -1.\r	assert: (-9 / 5) asInteger equals: -1.\r)",
 "public testFractionAsString = (\r	assert: 1.5 asString equals: '(3/2)'.\r	assert: (-3 / 2) asString equals: '(-3/2)'.\r	assert: (3 / -2) asString equals: '(-3/2)'.\r	assert: (-3 / -2) asString equals: '(3/2)'.\r)",
 "public testFractionCeiling = (\r	assert: (2 / 5) ceiling equals: 1.\r	assert: (3 / 5) ceiling equals: 1.\r	assert: (4 / 5) ceiling equals: 1.\r	assert: (5 / 5) ceiling equals: 1.\r	assert: (7 / 5) ceiling equals: 2.\r	assert: (8 / 5) ceiling equals: 2.\r	assert: (9 / 5) ceiling equals: 2.\r\r	assert: (-2 / 5) ceiling equals: 0.\r	assert: (-3 / 5) ceiling equals: 0.\r	assert: (-4 / 5) ceiling equals: 0.\r	assert: (-5 / 5) ceiling equals: -1.\r	assert: (-7 / 5) ceiling equals: -1.\r	assert: (-8 / 5) ceiling equals: -1.\r	assert: (-9 / 5) ceiling equals: -1.\r)",
 "public testFractionComparisionErrors = (\r	deny: (1/9) = '(1/9)'.\r	should: [(1/9) < '(1/9)'] signal: Error.\r	should: [(1/9) > '(1/9)'] signal: Error.\r	should: [(1/9) <= '(1/9)'] signal: Error.\r	should: [(1/9) >= '(1/9)'] signal: Error.\r\r	deny: (1/9) = {1/9}.\r	should: [(1/9) < {1/9}] signal: Error.\r	should: [(1/9) > {1/9}] signal: Error.\r	should: [(1/9) <= {1/9}] signal: Error.\r	should: [(1/9) >= {1/9}] signal: Error.\r)",
 "public testFractionComparisions = (\r	assert: (1/9) = (1/9).\r	deny: (1/9) < (1/9).\r	deny: (1/9) > (1/9).\r	assert: (1/9) <= (1/9).\r	assert: (1/9) >= (1/9).\r\r	deny: (2/7) = (3/5).\r	assert: (2/7) < (3/5).\r	deny: (2/7) > (3/5).\r	assert: (2/7) <= (3/5).\r	deny: (2/7) >= (3/5).\r\r	deny: (-3/5) = (2/7).\r	assert: (-3/5) < (2/7).\r	deny: (-3/5) > (2/7).\r	assert: (-3/5) <= (2/7).\r	deny: (-3/5) >= (2/7).\r\r	deny: (3/5) = (-2/7).\r	deny: (3/5) < (-2/7).\r	assert: (3/5) > (-2/7).\r	deny: (3/5) <= (-2/7).\r	assert: (3/5) >= (-2/7).\r\r	deny: (-3/5) = (-2/7).\r	assert: (-3/5) < (-2/7).\r	deny: (-3/5) > (-2/7).\r	assert: (-3/5) <= (-2/7).\r	deny: (-3/5) >= (-2/7).\r)",
 "public testFractionDivide = (\r	assert: (1/3) / (1/3) equals: 1.\r	assert: (1/3) / (2/3) equals: (1/2).\r\r	assert: (1/3) / (2/5) equals: (5/6).\r	assert: (6/9) / (1/12) equals: 8.\r\r	assert: (-1/3) / (2/5) equals: (-5/6).\r	assert: (1/3) / (-2/5) equals: (-5/6).\r	assert: (-1/3) / (-2/5) equals: (5/6).\r\r	assert: (1/3) / (3/4) equals: (4/9).\r	assert: (1/3) / (4/3) equals: (1/4).\r)",
 "public testFractionFloor = (\r	assert: (2 / 5) floor equals: 0.\r	assert: (3 / 5) floor equals: 0.\r	assert: (4 / 5) floor equals: 0.\r	assert: (5 / 5) floor equals: 1.\r	assert: (7 / 5) floor equals: 1.\r	assert: (8 / 5) floor equals: 1.\r	assert: (9 / 5) floor equals: 1.\r\r	assert: (-2 / 5) floor equals: -1.\r	assert: (-3 / 5) floor equals: -1.\r	assert: (-4 / 5) floor equals: -1.\r	assert: (-5 / 5) floor equals: -1.\r	assert: (-7 / 5) floor equals: -2.\r	assert: (-8 / 5) floor equals: -2.\r	assert: (-9 / 5) floor equals: -2.\r)",
 "public testFractionMixedAdd = (\r	assert: (22/7) + 3 equals: (43/7).\r	assert: (22/7) + maxInt32 equals: (15032385551/7).\r	assert: ((5/4) + 3 asFloat) isKindOfFloat.\r	assert: (5/4) + 3 asFloat equals: 4.25 asFloat.\r\r	assert: 3 + (22/7) equals: (43/7).\r	assert: maxInt32 + (22/7) equals: (15032385551/7).\r	assert: (3 asFloat + (5/4)) isKindOfFloat.\r	assert: 3 asFloat + (5/4) equals: 4.25 asFloat.\r)",
 "public testFractionMixedComparisions = (\r	deny: (9/7) = 1.\r	deny: (9/7) < 1.\r	assert: (9/7) > 1.\r	deny: (9/7) <= 1.\r	assert: (9/7) >= 1.\r\r	deny: 1 = (9/7).\r	assert: 1 < (9/7).\r	deny: 1 > (9/7).\r	assert: 1 <= (9/7).\r	deny: 1 >= (9/7).\r\r	deny: (9/7) = 1 asFloat.\r	deny: (9/7) < 1 asFloat.\r	assert: (9/7) > 1 asFloat.\r	deny: (9/7) <= 1 asFloat.\r	assert: (9/7) >= 1 asFloat.\r\r	deny: 1 asFloat = (9/7).\r	assert: 1 asFloat < (9/7).\r	deny: 1 asFloat > (9/7).\r	assert: 1 asFloat <= (9/7).\r	deny: 1 asFloat >= (9/7).\r)",
 "public testFractionMixedDivide = (\r	assert: (22/7) / 3 equals: (22/21).\r	assert: (22/7) / 14 equals: (11/49).\r	assert: (22/7) / 11 equals: (2/7).\r	assert: (22/7) / maxInt32 equals: (22/15032385529).\r	assert: ((5/4) / 3 asFloat) isKindOfFloat.\r	assert: (5/4) / 3 asFloat equals: 0.4166666666666667 asFloat.\r\r	assert: 3 / (22/7) equals: (21/22).\r	assert: 14 / (22/7) equals: (49/11).\r	assert: 11 / (22/7) equals: (7/2).\r	assert: maxInt32 / (22/7) equals: (15032385529/22).\r	assert: (3 asFloat / (5/4)) isKindOfFloat.\r	assert: 3 asFloat / (5/4) equals: 2.4 asFloat.\r)",
 "public testFractionMixedMultiply = (\r	assert: (22/7) * 3 equals: (66/7).\r	assert: (22/7) * 14 equals: 44.\r	assert: (22/7) * maxInt32 equals: (47244640234/7).\r	assert: ((5/4) * 3 asFloat) isKindOfFloat.\r	assert: (5/4) * 3 asFloat equals: 3.75 asFloat.\r\r	assert: 3 * (22/7) equals: (66/7).\r	assert: 14 * (22/7) equals: 44.\r	assert: maxInt32 * (22/7) equals: (47244640234/7).\r	assert: (3 asFloat * (5/4)) isKindOfFloat.\r	assert: 3 asFloat * (5/4) equals: 3.75 asFloat.\r)",
 "public testFractionMixedSubtract = (\r	assert: (22/7) - 3 equals: (1/7).\r	assert: (22/7) - maxInt32 equals: (-15032385507/7).\r	assert: ((5/4) - 3 asFloat) isKindOfFloat.\r	assert: (5/4) - 3 asFloat equals: -1.75 asFloat.\r\r	assert: 3 - (22/7) equals: (-1/7).\r	assert: maxInt32 - (22/7) equals: (15032385507/7).\r	assert: (3 asFloat - (5/4)) isKindOfFloat.\r	assert: 3 asFloat - (5/4) equals: 1.75 asFloat.\r)",
 "public testFractionMultiply = (\r	assert: (1/3) * (1/3) equals: (1/9).\r	assert: (1/3) * (2/3) equals: (2/9).\r\r	assert: (1/3) * (2/5) equals: (2/15).\r	assert: (6/9) * (1/12) equals: (1/18).\r\r	assert: (-1/3) * (2/5) equals: (-2/15).\r	assert: (1/3) * (-2/5) equals: (-2/15).\r	assert: (-1/3) * (-2/5) equals: (2/15).\r\r	assert: (1/3) * (3/4) equals: (1/4).\r)",
 "public testFractionReduced = (\r	assert: (6 / 9) numerator equals: 2.\r	assert: (6 / 9) denominator equals: 3.\r\r	assert: (-6 / 9) numerator equals: -2.\r	assert: (-6 / 9) denominator equals: 3.\r\r	assert: (6 / -9) numerator equals: -2.\r	assert: (6 / -9) denominator equals: 3.\r\r	assert: (-6 / -9) numerator equals: 2.\r	assert: (-6 / -9) denominator equals: 3.\r\r	assert: (9 / 3) isKindOfInteger.\r	assert: (9 / 3) numerator equals: 3.\r	assert: (9 / 3) denominator equals: 1.\r)",
 "public testFractionRounded = (\r	assert: (2 / 5) rounded equals: 0.\r	assert: (3 / 5) rounded equals: 1.\r	assert: (4 / 5) rounded equals: 1.\r	assert: (5 / 5) rounded equals: 1.\r	assert: (7 / 5) rounded equals: 1.\r	assert: (8 / 5) rounded equals: 2.\r	assert: (9 / 5) rounded equals: 2.\r\r	assert: (-2 / 5) rounded equals: 0.\r	assert: (-3 / 5) rounded equals: -1.\r	assert: (-4 / 5) rounded equals: -1.\r	assert: (-5 / 5) rounded equals: -1.\r	assert: (-7 / 5) rounded equals: -1.\r	assert: (-8 / 5) rounded equals: -2.\r	assert: (-9 / 5) rounded equals: -2.\r\r	assert: (1 / 2) rounded equals: 1.\r	assert: (-1 / 2) rounded equals: -1.\r)",
 "public testFractionSubtract = (\r	assert: (1/3) - (1/3) equals: 0.\r	assert: (1/3) - (2/3) equals: (-1/3).\r\r	assert: (1/3) - (2/5) equals: (-1/15).\r	assert: (6/9) - (1/12) equals: (7/12).\r\r	assert: (-1/3) - (2/5) equals: (-11/15).\r	assert: (1/3) - (-2/5) equals: (11/15).\r	assert: (-1/3) - (-2/5) equals: (1/15).\r)",
 "public testIsKindOfFraction = (\r	deny: 'foo' isKindOfFraction.\r	deny: #foo isKindOfFraction.\r	deny: ('foo', 'bar') isKindOfFraction.\r	assert: 1 isKindOfFraction.\r	assert: (1 / 2) isKindOfFraction.\r	assert: 1.5 isKindOfFraction.\r	deny: 1.5 asFloat isKindOfFraction.\r	deny: true isKindOfFraction.\r	deny: nil isKindOfFraction.\r	deny: {} isKindOfFraction.\r	deny: [] isKindOfFraction.\r)",
 "TEST_CONTEXT = ()",
 "public class GCTests = TestContext ()",
 "TestContext",
 "TestContext",
 "public testFragmentation = (\r	| cells new |\r	cells:: Array new: 4096.\r	1 to: cells size by: 2 do:\r		[:index |\r		 cells at: index put: Object new.\r		 cells at: index + 1 put: (Array new: 64).\r		 Array new: 64].\r\r	1 to: cells size by: 2 do:\r		[:index |\r		 cells at: index + 1 put: nil].\r\r	1 to: cells size by: 2 do:\r		[:index |\r		 cells at: index + 1 put: (Array new: 64 + 1)].\r)",
 "public testLargeAllocation = (\r	| size = 1024 * 1024. |\r	assert: (ByteArray new: size) size equals: size.\r	assert: (ByteArray new: size) size equals: size.\r	assert: (ByteArray new: size) size equals: size.\r)",
 "public testMarkStackOverflow = (\r	| tree prev |\r	32 timesRepeat:\r		[tree:: Array new: 16 * 1024.\r		 tree at: tree size put: prev.\r		 prev:: tree.\r		 1 to: tree size - 1 do:\r			[:index |\r			 tree at: index put: Object new.\r			 (* Mix in garbage to avoid new-space growth. *)\r			 6 timesRepeat: [Object new]]].\r\r	prev:: nil.\r\r	32 timesRepeat:\r		[tree:: Array new: 16 * 1024.\r		 tree at: 1 put: prev.\r		 prev:: tree.\r		 2 to: tree size do:\r			[:index |\r			 tree at: index put: Object new.\r			 (* Mix in garbage to avoid new-space growth. *)\r			 6 timesRepeat: [Object new]]].\r)",
 "public testRememberedSetOverflow = (\r	| cells new |\r	cells:: Array new: 128 * 1024.\r	1 to: cells size do:\r		[:index | cells at: index put: (Array new: 1).\r		 (* Mix in garbage to avoid new-space growth while tenuring the cells. *)\r		 4 timesRepeat: [Object new]].\r\r	(* Create many old->new stores without intermediate allocations. *)\r	new:: Object new.\r	1 to: cells size do: [:index | (cells at: index) at: 1 put: new].\r	1 to: cells size do: [:index | assert: ((cells at: index) at: 1) equals: new].\r)",
 "TEST_CONTEXT = ()",
 "public class IntegerTests = TestContext ()",
 "TestContext",
 "TestContext",
 "public testIntegerAdd = (\r	(* smi + smi, mint + mint, smi + mint, mint + smi *)\r	assert: minInt31 + maxInt31 equals: -1.\r	assert: minInt32 + maxInt32 equals: -1.\r	assert: minInt63 + maxInt63 equals: -1.\r	assert: minInt64 + maxInt64 equals: -1.\r\r	assert: maxInt31 + maxInt31 equals: 2147483646.\r	assert: maxInt32 + maxInt32 equals: 4294967294.\r	assert: maxInt63 + maxInt63 equals: 9223372036854775806.\r\r	assert: minInt31 + minInt32 equals: -3221225472.\r	assert: minInt32 + minInt31 equals: -3221225472.\r	assert: minInt31 + minInt63 equals: -4611686019501129728.\r	assert: minInt63 + minInt31 equals: -4611686019501129728.\r	assert: minInt32 + minInt63 equals: -4611686020574871552.\r	assert: minInt63 + minInt32 equals: -4611686020574871552.\r\r	assert: maxInt31 + maxInt32 equals: 3221225470.\r	assert: maxInt32 + maxInt31 equals: 3221225470.\r	assert: maxInt31 + maxInt63 equals: 4611686019501129726.\r	assert: maxInt63 + maxInt31 equals: 4611686019501129726.\r	assert: maxInt32 + maxInt63 equals: 4611686020574871550.\r	assert: maxInt63 + maxInt32 equals: 4611686020574871550.\r\r	assert: minInt31 + maxInt32 equals: 1073741823.\r	assert: maxInt32 + minInt31  equals: 1073741823.\r	assert: minInt31 + maxInt63 equals: 4611686017353646079.\r	assert: maxInt63 + minInt31 equals: 4611686017353646079.\r	assert: minInt32 + maxInt63 equals: 4611686016279904255.\r	assert: maxInt63 + minInt32 equals: 4611686016279904255.\r\r	assert: maxInt31 + minInt32 equals: -1073741825.\r	assert: minInt32 + maxInt31 equals: -1073741825.\r	assert: maxInt31 + minInt63 equals: -4611686017353646081.\r	assert: minInt63 + maxInt31 equals: -4611686017353646081.\r	assert: maxInt32 + minInt63 equals: -4611686016279904257.\r	assert: minInt63 + maxInt32 equals: -4611686016279904257.\r)",
 "public testIntegerAsInteger = (\r	assert: -1 asInteger equals: -1.\r	assert: 0 asInteger equals: 0.\r	assert: 1 asInteger equals: 1.\r\r	assert: minInt31 asInteger equals: minInt31.\r	assert: minInt32 asInteger equals: minInt32.\r	assert: minInt63 asInteger equals: minInt63.\r	assert: minInt64 asInteger equals: minInt64.\r	assert: maxInt31 asInteger equals: maxInt31.\r	assert: maxInt32 asInteger equals: maxInt32.\r	assert: maxInt63 asInteger equals: maxInt63.\r	assert: maxInt64 asInteger equals: maxInt64.\r)",
 "public testIntegerCeiling = (\r	assert: -1 ceiling equals: -1.\r	assert: 0 ceiling equals: 0.\r	assert: 1 ceiling equals: 1.\r\r	assert: minInt31 ceiling equals: minInt31.\r	assert: minInt32 ceiling equals: minInt32.\r	assert: minInt63 ceiling equals: minInt63.\r	assert: minInt64 ceiling equals: minInt64.\r	assert: maxInt31 ceiling equals: maxInt31.\r	assert: maxInt32 ceiling equals: maxInt32.\r	assert: maxInt63 ceiling equals: maxInt63.\r	assert: maxInt64 ceiling equals: maxInt64.\r)",
 "public testIntegerComparisons = (\r	deny: maxInt31 = maxInt64.\r	assert: maxInt31 < maxInt64.\r	deny: maxInt31 > maxInt64.\r	assert: maxInt31 <= maxInt64.\r	deny: maxInt31 >= maxInt64.\r\r	deny: maxInt64 = maxInt31.\r	deny: maxInt64 < maxInt31.\r	assert: maxInt64 > maxInt31.\r	deny: maxInt64 <= maxInt31.\r	assert: maxInt64 >= maxInt31.\r\r	deny: minInt31 = minInt64.\r	deny: minInt31 < minInt64.\r	assert: minInt31 > minInt64.\r	deny: minInt31 <= minInt64.\r	assert: minInt31 >= minInt64.\r\r	deny: minInt64 = minInt31.\r	assert: minInt64 < minInt31.\r	deny: minInt64 > minInt31.\r	assert: minInt64 <= minInt31.\r	deny: minInt64 >= minInt31.\r)",
 "public testIntegerFloor = (\r	assert: -1 floor equals: -1.\r	assert: 0 floor equals: 0.\r	assert: 1 floor equals: 1.\r\r	assert: minInt31 floor equals: minInt31.\r	assert: minInt32 floor equals: minInt32.\r	assert: minInt63 floor equals: minInt63.\r	assert: minInt64 floor equals: minInt64.\r	assert: maxInt31 floor equals: maxInt31.\r	assert: maxInt32 floor equals: maxInt32.\r	assert: maxInt63 floor equals: maxInt63.\r	assert: maxInt64 floor equals: maxInt64.\r)",
 "public testIntegerMultiply = (\r	(* smi + smi, mint + mint, smi + mint, mint + smi *)\r	assert: minInt31 * 1 equals: minInt31.\r	assert: minInt32 * 1 equals: minInt32.\r	assert: minInt63 * 1 equals: minInt63.\r	assert: minInt64 * 1 equals: minInt64.\r	assert: maxInt31 * 1 equals: maxInt31.\r	assert: maxInt32 * 1 equals: maxInt32.\r	assert: maxInt63 * 1 equals: maxInt63.\r	assert: maxInt64 * 1 equals: maxInt64.\r\r	assert: minInt31 * -1 equals: 1073741824.\r	assert: minInt32 * -1 equals: 2147483648.\r	assert: minInt63 * -1 equals: 4611686018427387904.\r	(* big int: assert: minInt64 * -1 equals: 9223372036854775808. *)\r\r	assert: minInt31 * maxInt31 equals: -1152921503533105152.\r	assert: minInt31 * minInt31 equals: 1152921504606846976.\r	assert: maxInt31 * maxInt31 equals: 1152921502459363329.\r\r	assert: minInt32 * maxInt32 equals: -4611686016279904256.\r	assert: minInt32 * minInt32 equals: 4611686018427387904.\r	assert: maxInt32 * maxInt32 equals: 4611686014132420609.\r)",
 "public testIntegerParse = (\r	assert: (Integer parse: '3') equals: 3.\r	assert: (Integer parse: '-3') equals: -3.\r	assert: (Integer parse: '0123456789') equals: 0123456789.\r	assert: (Integer parse: '-0123456789') equals: -0123456789.\r	assert: (Integer parse: 'CAFE' radix: 16) equals: 16rCAFE.\r	assert: (Integer parse: 'cafe' radix: 16) equals: 16rCAFE.\r	assert: (Integer parse: 'Z' radix: 36) equals: 35.\r	assert: (Integer parse: 'z' radix: 36) equals: 35.\r\r	2 to: 36 do: [:radix | assert: (Integer parse: '10' radix: radix) equals: radix].\r	2 to: 36 do: [:radix | assert: (Integer parse: '100' radix: radix) equals: radix * radix].\r\r	(* Last valid digit. *)\r	2 to: 36 do:\r		[:radix |\r		assert: (Integer parse: ('123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' copyFrom: radix - 1 to: radix - 1) radix: radix) equals: radix - 1.\r		assert: (Integer parse: ('123456789abcdefghijklmnopqrstuvwxyz' copyFrom: radix - 1 to: radix - 1) radix: radix) equals: radix - 1].\r\r	(* Digit out of range. *)\r	2 to: 36 do:\r		[:radix |\r		should: [Integer parse: ('123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' copyFrom: radix to: radix) radix: radix] signal: Error.\r		should: [Integer parse: ('123456789abcdefghijklmnopqrstuvwxyz' copyFrom: radix to: radix) radix: radix] signal: Error].\r\r	(* Bad radix *)\r	should: [Integer parse: '0' radix: -1] signal: Error.\r	should: [Integer parse: '0' radix: 0] signal: Error.\r	should: [Integer parse: '0' radix: 1] signal: Error.\r	should: [Integer parse: '0' radix: 37] signal: Error.\r\r	should: [Integer parse: 'xyz'] signal: Error.\r	should: [Integer parse: ''] signal: Error.\r	should: [Integer parse: '--9'] signal: Error.\r	should: [Integer parse: 'nan'] signal: Error.\r	should: [Integer parse: 'NAN'] signal: Error.\r	should: [Integer parse: 'infinity'] signal: Error.\r	should: [Integer parse: '-infinity'] signal: Error.\r	should: [Integer parse: 'inf'] signal: Error.\r	should: [Integer parse: '-inf'] signal: Error.\r	should: [Integer parse: '3.0'] signal: Error.\r\r	should: [Integer parse: ' 3'] signal: Error.\r	should: [Integer parse: '3 '] signal: Error.\r)",
 "public testIntegerRounded = (\r	assert: -1 rounded equals: -1.\r	assert: 0 rounded equals: 0.\r	assert: 1 rounded equals: 1.\r\r	assert: minInt31 rounded equals: minInt31.\r	assert: minInt32 rounded equals: minInt32.\r	assert: minInt63 rounded equals: minInt63.\r	assert: minInt64 rounded equals: minInt64.\r	assert: maxInt31 rounded equals: maxInt31.\r	assert: maxInt32 rounded equals: maxInt32.\r	assert: maxInt63 rounded equals: maxInt63.\r	assert: maxInt64 rounded equals: maxInt64.\r)",
 "public testIntegerSubtract = (\r	(* smi + smi, mint + mint, smi + mint, mint + smi *)\r	assert: maxInt31 - minInt31 equals: 2147483647.\r	assert: maxInt32 - minInt32 equals: 4294967295.\r	assert: maxInt63 - minInt63 equals: 9223372036854775807.\r	(* big int assert: maxInt64 - minInt64 equals: 18446744073709551615. *)\r\r	assert: maxInt31 - maxInt31 equals: 0.\r	assert: maxInt32 - maxInt32 equals: 0.\r	assert: maxInt63 - maxInt63 equals: 0.\r\r	assert: minInt31 - minInt32 equals: 1073741824.\r	assert: minInt32 - minInt31 equals: -1073741824.\r	assert: minInt31 - minInt63 equals: 4611686017353646080.\r	assert: minInt63 - minInt31 equals: -4611686017353646080.\r	assert: minInt32 - minInt63 equals: 4611686016279904256.\r	assert: minInt63 - minInt32 equals: -4611686016279904256.\r\r	assert: maxInt31 - maxInt32 equals: -1073741824.\r	assert: maxInt32 - maxInt31 equals: 1073741824.\r	assert: maxInt31 - maxInt63 equals: -4611686017353646080.\r	assert: maxInt63 - maxInt31 equals: 4611686017353646080.\r	assert: maxInt32 - maxInt63 equals: -4611686016279904256.\r	assert: maxInt63 - maxInt32 equals: 4611686016279904256.\r\r	assert: minInt31 - maxInt32 equals: -3221225471.\r	assert: maxInt32 - minInt31 equals: 3221225471.\r	assert: minInt31 - maxInt63 equals: -4611686019501129727.\r	assert: maxInt63 - minInt31 equals: 4611686019501129727.\r	assert: minInt32 - maxInt63 equals: -4611686020574871551.\r	assert: maxInt63 - minInt32 equals: 4611686020574871551.\r\r	assert: maxInt31 - minInt32 equals: 3221225471.\r	assert: minInt32 - maxInt31 equals: -3221225471.\r	assert: maxInt31 - minInt63 equals: 4611686019501129727.\r	assert: minInt63 - maxInt31 equals: -4611686019501129727.\r	assert: maxInt32 - minInt63 equals: 4611686020574871551.\r	assert: minInt63 - maxInt32 equals: -4611686020574871551.\r)",
 "public testIsKindOfInteger = (\r	deny: 'foo' isKindOfInteger.\r	deny: #foo isKindOfInteger.\r	deny: ('foo', 'bar') isKindOfInteger.\r	assert: 1 isKindOfInteger.\r	deny: 1.5 isKindOfInteger.\r	deny: 1.5 asFloat isKindOfInteger.\r	deny: true isKindOfInteger.\r	deny: nil isKindOfInteger.\r	deny: {} isKindOfInteger.\r	deny: [] isKindOfInteger.\r)",
 "public testLargeIntegerAdd = (\r	|\r	a = 16rC425942592C7528C08D25976E.\r	b = 16r9087475AA2733891DCA2F72AF2B.\r	c = 16r1BC2B572BD48EF6C8EE227273D781.\r	d = 0 - a.\r	e = 0 - b.\r	f = 0 - c.\r	|\r\r	assert: minInt64 + minInt64 equals: -18446744073709551616.\r	assert: maxInt64 + maxInt64 equals: 18446744073709551614.\r	assert: largestNegativeLargeInteger + 1 equals: -9223372036854775808.\r	assert: largestNegativeLargeInteger + -1 equals: -9223372036854775810.\r	assert: smallestPositiveLargeInteger + 1 equals: 9223372036854775809.\r	assert: smallestPositiveLargeInteger + -1 equals: 9223372036854775807.\r	assert: smallestPositiveLargeInteger + largestNegativeLargeInteger equals: -1.\r\r	assert: a + a equals: 1942543737076956262258113720028.\r	assert: b + a equals: 184182826110503236225824504432281.\r	assert: c + a equals: 9009794925061437128082056516562671.\r	assert: d + a equals: 0.\r	assert: e + a equals: -182240282373426279963566390712253.\r	assert: f + a equals: -9007852381324360171819798402842643.\r\r	assert: a + b equals: 184182826110503236225824504432281.\r	assert: b + b equals: 366423108483929516189390895144534.\r	assert: c + b equals: 9192035207434863408045622907274924.\r	assert: d + b equals: 182240282373426279963566390712253.\r	assert: e + b equals: 0.\r	assert: f + b equals: -8825612098950933891856232012130390.\r\r	assert: a + c equals: 9009794925061437128082056516562671.\r	assert: b + c equals: 9192035207434863408045622907274924.\r	assert: c + c equals: 18017647306385797299901854919405314.\r	assert: d + c equals: 9007852381324360171819798402842643.\r	assert: e + c equals: 8825612098950933891856232012130390.\r	assert: f + c equals: 0.\r\r	assert: a + d equals: 0.\r	assert: b + d equals: 182240282373426279963566390712253.\r	assert: c + d equals: 9007852381324360171819798402842643.\r	assert: d + d equals: -1942543737076956262258113720028.\r	assert: e + d equals: -184182826110503236225824504432281.\r	assert: f + d equals: -9009794925061437128082056516562671.\r\r	assert: a + e equals: -182240282373426279963566390712253.\r	assert: b + e equals: 0.\r	assert: c + e equals: 8825612098950933891856232012130390.\r	assert: d + e equals: -184182826110503236225824504432281.\r	assert: e + e equals: -366423108483929516189390895144534.\r	assert: f + e equals: -9192035207434863408045622907274924.\r\r	assert: a + f equals: -9007852381324360171819798402842643.\r	assert: b + f equals: -8825612098950933891856232012130390.\r	assert: c + f equals: 0.\r	assert: d + f equals: -9009794925061437128082056516562671.\r	assert: e + f equals: -9192035207434863408045622907274924.\r	assert: f + f equals: -18017647306385797299901854919405314.\r)",
 "public testLargeIntegerAnd = (\r	|\r	a = 16rFFAABBCCDDEE997766.\r	b = 16rEEEEEEEEEEEEEEEE.\r	c = 16rCC0011223344556677.\r	d = 16r8888008888888888.\r	e = 0 - a.\r	f = 0 - b.\r	g = 0 - c.\r	h = 0 - d.\r	|\r\r	assert: (a bitAnd: a) equals: a.\r	assert: (a bitAnd: b) equals: 12297866913035871846.\r	assert: (a bitAnd: c) equals: 3763140576185509045862.\r	assert: (a bitAnd: d) equals: 9838113972397015040.\r	assert: (a bitAnd: e) equals: 2.\r	assert: (a bitAnd: f) equals: 4703924523943555305730.\r	assert: (a bitAnd: g) equals: 953081814671082131712.\r	assert: (a bitAnd: h) equals: 4706384276884194162528.\r\r	assert: (b bitAnd: a) equals: 12297866913035871846.\r	assert: (b bitAnd: b) equals: b.\r	assert: (b bitAnd: c) equals: 37530569565798.\r	assert: (b bitAnd: d) equals: 9838113972397049992.\r	assert: (b bitAnd: e) equals: 4919094222426376330.\r	assert: (b bitAnd: f) equals: 2.\r	assert: (b bitAnd: g) equals: 17216923604892682376.\r	assert: (b bitAnd: h) equals: 7378847163065198184.\r\r	assert: (c bitAnd: a) equals: 3763140576185509045862.\r	assert: (c bitAnd: b) equals: 37530569565798.\r	assert: (c bitAnd: c) equals: c.\r	assert: (c bitAnd: d) equals: 0.\r	assert: (c bitAnd: e) equals: 37529428688914.\r	assert: (c bitAnd: f) equals: 3763140576184368168978.\r	assert: (c bitAnd: g) equals: 1.\r	assert: (c bitAnd: h) equals: 3763140613714937734768.\r\r	assert: (d bitAnd: a) equals: 9838113972397015040.\r	assert: (d bitAnd: b) equals: 9838113972397049992.\r	assert: (d bitAnd: c) equals: 0.\r	assert: (d bitAnd: d) equals: d.\r	assert: (d bitAnd: e) equals: 34952.\r	assert: (d bitAnd: f) equals: -0.\r	assert: (d bitAnd: g) equals: 9838113972397049992.\r	assert: (d bitAnd: h) equals: 8.\r\r	assert: (e bitAnd: a) equals: 2.\r	assert: (e bitAnd: b) equals: 4919094222426376330.\r	assert: (e bitAnd: c) equals: 37529428688914.\r	assert: (e bitAnd: d) equals: 34952.\r	assert: (e bitAnd: e) equals: e.\r	assert: (e bitAnd: f) equals: -4721141485079017553902.\r	assert: (e bitAnd: g) equals: -4716222428386019866488.\r	assert: (e bitAnd: h) equals: -4716222390856591212520.\r\r	assert: (f bitAnd: a) equals: 4703924523943555305730.\r	assert: (f bitAnd: b) equals: 2.\r	assert: (f bitAnd: c) equals: 3763140576184368168978.\r	assert: (f bitAnd: d) equals: 0.\r	assert: (f bitAnd: e) equals: -4721141485079017553902.\r	assert: (f bitAnd: f) equals: f.\r	assert: (f bitAnd: g) equals: -3780357537319830417152.\r	assert: (f bitAnd: h) equals: -17216961135462248176.\r\r	assert: (g bitAnd: a) equals: 953081814671082131712.\r	assert: (g bitAnd: b) equals: 17216923604892682376.\r	assert: (g bitAnd: c) equals: 1.\r	assert: (g bitAnd: d) equals: 9838113972397049992.\r	assert: (g bitAnd: e) equals: -4716222428386019866488.\r	assert: (g bitAnd: f) equals: -3780357537319830417152.\r	assert: (g bitAnd: g) equals: g.\r	assert: (g bitAnd: h) equals: -3772978727687334784760.\r\r	assert: (h bitAnd: a) equals: 4706384276884194162528.\r	assert: (h bitAnd: b) equals: 7378847163065198184.\r	assert: (h bitAnd: c) equals: 3763140613714937734768.\r	assert: (h bitAnd: d) equals: 8.\r	assert: (h bitAnd: e) equals: -4716222390856591212520.\r	assert: (h bitAnd: f) equals: -17216961135462248176.\r	assert: (h bitAnd: g) equals: -3772978727687334784760.\r	assert: (h bitAnd: h) equals: h.\r\r	assert: (0 bitAnd: a) equals: 0.\r	assert: (0 bitAnd: b) equals: 0.\r	assert: (0 bitAnd: c) equals: 0.\r	assert: (0 bitAnd: d) equals: 0.\r	assert: (0 bitAnd: e) equals: 0.\r	assert: (0 bitAnd: f) equals: 0.\r	assert: (0 bitAnd: g) equals: 0.\r	assert: (0 bitAnd: h) equals: 0.\r\r	assert: (a bitAnd: 0) equals: 0.\r	assert: (b bitAnd: 0) equals: 0.\r	assert: (c bitAnd: 0) equals: 0.\r	assert: (d bitAnd: 0) equals: 0.\r	assert: (e bitAnd: 0) equals: 0.\r	assert: (f bitAnd: 0) equals: 0.\r	assert: (g bitAnd: 0) equals: 0.\r	assert: (h bitAnd: 0) equals: 0.\r)",
 "public testLargeIntegerAsFloat = (\r	assert: largestNegativeLargeInteger asFloat equals: (Float parse: '-9223372036854775809.0').\r	assert: smallestPositiveLargeInteger asFloat equals: (Float parse: '9223372036854775808.0').\r\r	assert: (1 << 52) asFloat equals: (Float parse: '4503599627370496.0').\r	assert: (2 << 52) asFloat equals: (Float parse: '9007199254740992.0').\r	assert: (3 << 52) asFloat equals: (Float parse: '13510798882111488.0').\r	assert: (1 << 53) asFloat equals: (Float parse: '9007199254740992.0').\r	assert: (2 << 53) asFloat equals: (Float parse: '18014398509481984.0').\r	assert: (3 << 53) asFloat equals: (Float parse: '27021597764222976.0').\r	assert: (1 << 54) asFloat equals: (Float parse: '18014398509481984.0').\r	assert: (2 << 54) asFloat equals: (Float parse: '36028797018963970.0').\r	assert: (3 << 54) asFloat equals: (Float parse: '54043195528445950.0').\r\r	assert: (1 << 52 + 1) asFloat equals: (Float parse: '4503599627370497.0').\r	assert: (2 << 52 + 1) asFloat equals: (Float parse: '9007199254740992.0').\r	assert: (3 << 52 + 1) asFloat equals: (Float parse: '13510798882111488.0').\r	assert: (1 << 53 + 1) asFloat equals: (Float parse: '9007199254740992.0').\r	assert: (2 << 53 + 1) asFloat equals: (Float parse: '18014398509481984.0').\r	assert: (3 << 53 + 1) asFloat equals: (Float parse: '27021597764222976.0').\r	assert: (1 << 54 + 1) asFloat equals: (Float parse: '18014398509481984.0').\r	assert: (2 << 54 + 1) asFloat equals: (Float parse: '36028797018963970.0').\r	assert: (3 << 54 + 1) asFloat equals: (Float parse: '54043195528445950.0').\r\r	assert: (1 << 52 + 2) asFloat equals: (Float parse: '4503599627370498.0').\r	assert: (2 << 52 + 2) asFloat equals: (Float parse: '9007199254740994.0').\r	assert: (3 << 52 + 2) asFloat equals: (Float parse: '13510798882111490.0').\r	assert: (1 << 53 + 2) asFloat equals: (Float parse: '9007199254740994.0').\r	assert: (2 << 53 + 2) asFloat equals: (Float parse: '18014398509481984.0').\r	assert: (3 << 53 + 2) asFloat equals: (Float parse: '27021597764222976.0').\r	assert: (1 << 54 + 2) asFloat equals: (Float parse: '18014398509481984.0').\r	assert: (2 << 54 + 2) asFloat equals: (Float parse: '36028797018963970.0').\r	assert: (3 << 54 + 2) asFloat equals: (Float parse: '54043195528445950.0').\r\r	assert: (1 << 52 + 3) asFloat equals: (Float parse: '4503599627370499.0').\r	assert: (2 << 52 + 3) asFloat equals: (Float parse: '9007199254740996.0').\r	assert: (3 << 52 + 3) asFloat equals: (Float parse: '13510798882111492.0').\r	assert: (1 << 53 + 3) asFloat equals: (Float parse: '9007199254740996.0').\r	assert: (2 << 53 + 3) asFloat equals: (Float parse: '18014398509481988.0').\r	assert: (3 << 53 + 3) asFloat equals: (Float parse: '27021597764222980.0').\r	assert: (1 << 54 + 3) asFloat equals: (Float parse: '18014398509481988.0').\r	assert: (2 << 54 + 3) asFloat equals: (Float parse: '36028797018963970.0').\r	assert: (3 << 54 + 3) asFloat equals: (Float parse: '54043195528445950.0').\r\r	assert: (16rABABABABABABABAB << 1) asFloat equals: (Float parse: '24740339110622220000.0').\r	assert: (16rABABABABABABABAB << 32) asFloat equals: (Float parse: '5.312947368603608e+28').\r	assert: (16rABABABABABABABAB << 64) asFloat equals: (Float parse: '2.2818935193521754e+38').\r	assert: (16rABABABABABABABAB << 512) asFloat equals: (Float parse: '1.658568574584348e+173').\r	assert: (16rABABABABABABABAB << 1024) asFloat equals: (Float parse: 'Infinity').\r\r	assert: (((1 << 53) - 1) << (1023 - 52)) asFloat equals: (Float parse: '1.7976931348623157e+308').\r	assert: ((1 << 53) << (1023 - 52)) asFloat equals: (Float parse: 'Infinity').\r)",
 "public testLargeIntegerAsString = (\r	assert: largestNegativeLargeInteger asString equals: '-9223372036854775809'.\r	assert: smallestPositiveLargeInteger asString equals: '9223372036854775808'.\r\r	assert: 16rFFFFFFFFFFFFFFFF asString equals: '18446744073709551615'.\r	assert: 16rABCDABCDABCDABCD asString equals: '12379739850550389709'.\r	assert: -9999999999999999999 asString equals: '-9999999999999999999'.\r)",
 "public testLargeIntegerComparisions = (\r	assert: smallestPositiveLargeInteger = smallestPositiveLargeInteger.\r	deny: smallestPositiveLargeInteger < smallestPositiveLargeInteger.\r	deny: smallestPositiveLargeInteger > smallestPositiveLargeInteger.\r	assert: smallestPositiveLargeInteger <= smallestPositiveLargeInteger.\r	assert: smallestPositiveLargeInteger >= smallestPositiveLargeInteger.\r\r	assert: largestNegativeLargeInteger = largestNegativeLargeInteger.\r	deny: largestNegativeLargeInteger < largestNegativeLargeInteger.\r	deny: largestNegativeLargeInteger > largestNegativeLargeInteger.\r	assert: largestNegativeLargeInteger <= largestNegativeLargeInteger.\r	assert: largestNegativeLargeInteger >= largestNegativeLargeInteger.\r\r	deny: smallestPositiveLargeInteger = largestNegativeLargeInteger.\r	deny: smallestPositiveLargeInteger < largestNegativeLargeInteger.\r	assert: smallestPositiveLargeInteger > largestNegativeLargeInteger.\r	deny: smallestPositiveLargeInteger <= largestNegativeLargeInteger.\r	assert: smallestPositiveLargeInteger >= largestNegativeLargeInteger.\r\r	deny: largestNegativeLargeInteger = smallestPositiveLargeInteger.\r	assert: largestNegativeLargeInteger < smallestPositiveLargeInteger.\r	deny: largestNegativeLargeInteger > smallestPositiveLargeInteger.\r	assert: largestNegativeLargeInteger <= smallestPositiveLargeInteger.\r	deny: largestNegativeLargeInteger >= smallestPositiveLargeInteger.\r\r	deny: smallestPositiveLargeInteger = 0.\r	deny: smallestPositiveLargeInteger < 0.\r	assert: smallestPositiveLargeInteger > 0.\r	deny: smallestPositiveLargeInteger <= 0.\r	assert: smallestPositiveLargeInteger >= 0.\r\r	deny: 0 = smallestPositiveLargeInteger.\r	assert: 0 < smallestPositiveLargeInteger.\r	deny: 0 > smallestPositiveLargeInteger.\r	assert: 0 <= smallestPositiveLargeInteger.\r	deny: 0 >= smallestPositiveLargeInteger.\r\r	deny: largestNegativeLargeInteger = 0.\r	assert: largestNegativeLargeInteger < 0.\r	deny: largestNegativeLargeInteger > 0.\r	assert: largestNegativeLargeInteger <= 0.\r	deny: largestNegativeLargeInteger >= 0.\r\r	deny: 0 = largestNegativeLargeInteger.\r	deny: 0 < largestNegativeLargeInteger.\r	assert: 0 > largestNegativeLargeInteger.\r	deny: 0 <= largestNegativeLargeInteger.\r	assert: 0 >= largestNegativeLargeInteger.\r\r	deny: smallestPositiveLargeInteger = maxInt64.\r	deny: smallestPositiveLargeInteger < maxInt64.\r	assert: smallestPositiveLargeInteger > maxInt64.\r	deny: smallestPositiveLargeInteger <= maxInt64.\r	assert: smallestPositiveLargeInteger >= maxInt64.\r\r	deny: maxInt64 = smallestPositiveLargeInteger.\r	assert: maxInt64 < smallestPositiveLargeInteger.\r	deny: maxInt64 > smallestPositiveLargeInteger.\r	assert: maxInt64 <= smallestPositiveLargeInteger.\r	deny: maxInt64 >= smallestPositiveLargeInteger.\r\r	deny: largestNegativeLargeInteger = minInt64.\r	assert: largestNegativeLargeInteger < minInt64.\r	deny: largestNegativeLargeInteger > minInt64.\r	assert: largestNegativeLargeInteger <= minInt64.\r	deny: largestNegativeLargeInteger >= minInt64.\r\r	deny: minInt64 = largestNegativeLargeInteger.\r	deny: minInt64 < largestNegativeLargeInteger.\r	assert: minInt64 > largestNegativeLargeInteger.\r	deny: minInt64 <= largestNegativeLargeInteger.\r	assert: minInt64 >= largestNegativeLargeInteger.\r\r	(* Difference at middle digit. *)\r	deny: 16rFFFFAAAAFFFFFFFF = 16rFFFFBBBBFFFFFFFF.\r	assert: 16rFFFFAAAAFFFFFFFF < 16rFFFFBBBBFFFFFFFF.\r	deny: 16rFFFFAAAAFFFFFFFF > 16rFFFFBBBBFFFFFFFF.\r	assert: 16rFFFFAAAAFFFFFFFF <= 16rFFFFBBBBFFFFFFFF.\r	deny: 16rFFFFAAAAFFFFFFFF >= 16rFFFFBBBBFFFFFFFF.\r\r	deny: 16rFFFFBBBBFFFFFFFF = 16rFFFFAAAAFFFFFFFF.\r	deny: 16rFFFFBBBBFFFFFFFF < 16rFFFFAAAAFFFFFFFF.\r	assert: 16rFFFFBBBBFFFFFFFF > 16rFFFFAAAAFFFFFFFF.\r	deny: 16rFFFFBBBBFFFFFFFF <= 16rFFFFAAAAFFFFFFFF.\r	assert: 16rFFFFBBBBFFFFFFFF >= 16rFFFFAAAAFFFFFFFF.\r\r	(* Difference at last digit. *)\r	deny: 16rFFFFFFFFFFFFFFFA = 16rFFFFFFFFFFFFFFFB.\r	assert: 16rFFFFFFFFFFFFFFFA < 16rFFFFFFFFFFFFFFFB.\r	deny: 16rFFFFFFFFFFFFFFFA > 16rFFFFFFFFFFFFFFFB.\r	assert: 16rFFFFFFFFFFFFFFFA <= 16rFFFFFFFFFFFFFFFB.\r	deny: 16rFFFFFFFFFFFFFFFA >= 16rFFFFFFFFFFFFFFFB.\r\r	deny: 16rFFFFFFFFFFFFFFFB = 16rFFFFFFFFFFFFFFFA.\r	deny: 16rFFFFFFFFFFFFFFFB < 16rFFFFFFFFFFFFFFFA.\r	assert: 16rFFFFFFFFFFFFFFFB > 16rFFFFFFFFFFFFFFFA.\r	deny: 16rFFFFFFFFFFFFFFFB <= 16rFFFFFFFFFFFFFFFA.\r	assert: 16rFFFFFFFFFFFFFFFB >= 16rFFFFFFFFFFFFFFFA.\r\r	(* Different number of digits. *)\r	deny: 16rFFFFFFFFFFFFFFFF = 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.\r	assert: 16rFFFFFFFFFFFFFFFF < 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.\r	deny: 16rFFFFFFFFFFFFFFFF > 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.\r	assert: 16rFFFFFFFFFFFFFFFF <= 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.\r	deny: 16rFFFFFFFFFFFFFFFF >= 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.\r\r	deny: 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF = 16rFFFFFFFFFFFFFFFF.\r	deny: 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF < 16rFFFFFFFFFFFFFFFF.\r	assert: 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF > 16rFFFFFFFFFFFFFFFF.\r	deny: 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <= 16rFFFFFFFFFFFFFFFF.\r	assert: 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >= 16rFFFFFFFFFFFFFFFF.\r)",
 "public testLargeIntegerDiv = (\r	|\r	a = 16rC425942592C7528C08D25976E.\r	b = 16r9087475AA2733891DCA2F72AF2B.\r	c = 16r1BC2B572BD48EF6C8EE227273D781.\r	d = 0 - a.\r	e = 0 - b.\r	f = 0 - c.\r	|\r\r	assert: a // 1 equals: a.\r	assert: b // 1 equals: b.\r	assert: c // 1 equals: c.\r	assert: d // 1 equals: d.\r	assert: e // 1 equals: e.\r	assert: f // 1 equals: f.\r\r	assert: a // -1 equals: 0 - a.\r	assert: b // -1 equals: 0 - b.\r	assert: c // -1 equals: 0 - c.\r	assert: d // -1 equals: 0 - d.\r	assert: e // -1 equals: 0 - e.\r	assert: f // -1 equals: 0 - f.\r\r	assert: a // 254 equals: 3823904994245976894208885275.\r	assert: b // 254 equals: 721305331661278575175966329024.\r	assert: c // 254 equals: 35467809658239758464373730156309.\r	assert: d // 254 equals: -3823904994245976894208885276.\r	assert: e // 254 equals: -721305331661278575175966329025.\r	assert: f // 254 equals: -35467809658239758464373730156310.\r\r	assert: a // 255 equals: 3808909288386188749525713176.\r	assert: b // 255 equals: 718476683301822580763511559106.\r	assert: c // 255 equals: 35328720208599602548827166508637.\r	assert: d // 255 equals: -3808909288386188749525713177.\r	assert: e // 255 equals: -718476683301822580763511559107.\r	assert: f // 255 equals: -35328720208599602548827166508638.\r\r	assert: a // 256 equals: 3794030736478430199722878359.\r	assert: b // 256 equals: 715670133757674836307404092079.\r	assert: c // 256 equals: 35190717395284760351370810389463.\r	assert: d // 256 equals: -3794030736478430199722878360.\r	assert: e // 256 equals: -715670133757674836307404092080.\r	assert: f // 256 equals: -35190717395284760351370810389464.\r\r	assert: a // -254 equals: -3823904994245976894208885276.\r	assert: b // -254 equals: -721305331661278575175966329025.\r	assert: c // -254 equals: -35467809658239758464373730156310.\r	assert: d // -254 equals: 3823904994245976894208885275.\r	assert: e // -254 equals: 721305331661278575175966329024.\r	assert: f // -254 equals: 35467809658239758464373730156309.\r\r	assert: a // -255 equals: -3808909288386188749525713177.\r	assert: b // -255 equals: -718476683301822580763511559107.\r	assert: c // -255 equals: -35328720208599602548827166508638.\r	assert: d // -255 equals: 3808909288386188749525713176.\r	assert: e // -255 equals: 718476683301822580763511559106.\r	assert: f // -255 equals: 35328720208599602548827166508637.\r\r	assert: a // -256 equals: -3794030736478430199722878360.\r	assert: b // -256 equals: -715670133757674836307404092080.\r	assert: c // -256 equals: -35190717395284760351370810389464.\r	assert: d // -256 equals: 3794030736478430199722878359.\r	assert: e // -256 equals: 715670133757674836307404092079.\r	assert: f // -256 equals: 35190717395284760351370810389463.\r\r	assert: a // a equals: 1.\r	assert: b // a equals: 188.\r	assert: c // a equals: 9275.\r	assert: d // a equals: -1.\r	assert: e // a equals: -189.\r	assert: f // a equals: -9276.\r\r	assert: a // b equals: 0.\r	assert: b // b equals: 1.\r	assert: c // b equals: 49.\r	assert: d // b equals: -1.\r	assert: e // b equals: -1.\r	assert: f // b equals: -50.\r\r	assert: a // c equals: 0.\r	assert: b // c equals: 0.\r	assert: c // c equals: 1.\r	assert: d // c equals: -1.\r	assert: e // c equals: -1.\r	assert: f // c equals: -1.\r\r	assert: a // d equals: -1.\r	assert: b // d equals: -189.\r	assert: c // d equals: -9276.\r	assert: d // d equals: 1.\r	assert: e // d equals: 188.\r	assert: f // d equals: 9275.\r\r	assert: a // e equals: -1.\r	assert: b // e equals: -1.\r	assert: c // e equals: -50.\r	assert: d // e equals: 0.\r	assert: e // e equals: 1.\r	assert: f // e equals: 49.\r\r	assert: a // f equals: -1.\r	assert: b // f equals: -1.\r	assert: c // f equals: -1.\r	assert: d // f equals: 0.\r	assert: e // f equals: 0.\r	assert: f // f equals: 1.\r\r	should: [a // 0] signal: Error.\r	should: [b // 0] signal: Error.\r	should: [c // 0] signal: Error.\r	should: [d // 0] signal: Error.\r	should: [e // 0] signal: Error.\r	should: [f // 0] signal: Error.\r\r	assert: 0 // a equals: 0.\r	assert: 0 // b equals: 0.\r	assert: 0 // c equals: 0.\r	assert: 0 // d equals: 0.\r	assert: 0 // e equals: 0.\r	assert: 0 // f equals: 0.\r)",
 "public testLargeIntegerDivide = (\r	|\r	a = 16rC425942592C7528C08D25976E.\r	b = 16r9087475AA2733891DCA2F72AF2B.\r	c = 16r1BC2B572BD48EF6C8EE227273D781.\r	d = 0 - a.\r	e = 0 - b.\r	f = 0 - c.\r	|\r\r	assert: a / 1 equals: a.\r	assert: b / 1 equals: b.\r	assert: c / 1 equals: c.\r	assert: d / 1 equals: d.\r	assert: e / 1 equals: e.\r	assert: f / 1 equals: f.\r\r	assert: a / -1 equals: 0 - a.\r	assert: b / -1 equals: 0 - b.\r	assert: c / -1 equals: 0 - c.\r	assert: d / -1 equals: 0 - d.\r	assert: e / -1 equals: 0 - e.\r	assert: f / -1 equals: 0 - f.\r\r	assert: a / 254 > 0.  deny: (a / 254) isKindOfInteger.\r	assert: b / 254 > 0.  deny: (b / 254) isKindOfInteger.\r	assert: c / 254 > 0.  deny: (c / 254) isKindOfInteger.\r	assert: d / 254 < 0.  deny: (d / 254) isKindOfInteger.\r	assert: e / 254 < 0.  deny: (e / 254) isKindOfInteger.\r	assert: f / 254 < 0.  deny: (f / 254) isKindOfInteger.\r\r	assert: a / 255 > 0.  deny: (a / 255) isKindOfInteger.\r	assert: b / 255 > 0.  deny: (b / 255) isKindOfInteger.\r	assert: c / 255 > 0.  deny: (c / 255) isKindOfInteger.\r	assert: d / 255 < 0.  deny: (d / 255) isKindOfInteger.\r	assert: e / 255 < 0.  deny: (e / 255) isKindOfInteger.\r	assert: f / 255 < 0.  deny: (f / 255) isKindOfInteger.\r\r	assert: a / 256 > 0.  deny: (a / 256) isKindOfInteger.\r	assert: b / 256 > 0.  deny: (b / 256) isKindOfInteger.\r	assert: c / 256 > 0.  deny: (c / 256) isKindOfInteger.\r	assert: d / 256 < 0.  deny: (d / 256) isKindOfInteger.\r	assert: e / 256 < 0.  deny: (e / 256) isKindOfInteger.\r	assert: f / 256 < 0.  deny: (f / 256) isKindOfInteger.\r\r	assert: a / -254 < 0.  deny: (a / -254) isKindOfInteger.\r	assert: b / -254 < 0.  deny: (b / -254) isKindOfInteger.\r	assert: c / -254 < 0.  deny: (c / -254) isKindOfInteger.\r	assert: d / -254 > 0.  deny: (d / -254) isKindOfInteger.\r	assert: e / -254 > 0.  deny: (e / -254) isKindOfInteger.\r	assert: f / -254 > 0.  deny: (f / -254) isKindOfInteger.\r\r	assert: a / -255 < 0.  deny: (a / -255) isKindOfInteger.\r	assert: b / -255 < 0.  deny: (b / -255) isKindOfInteger.\r	assert: c / -255 < 0.  deny: (c / -255) isKindOfInteger.\r	assert: d / -255 > 0.  deny: (d / -255) isKindOfInteger.\r	assert: e / -255 > 0.  deny: (e / -255) isKindOfInteger.\r	assert: f / -255 > 0.  deny: (f / -255) isKindOfInteger.\r\r	assert: a / -256 < 0.  deny: (a / -256) isKindOfInteger.\r	assert: b / -256 < 0.  deny: (b / -256) isKindOfInteger.\r	assert: c / -256 < 0.  deny: (c / -256) isKindOfInteger.\r	assert: d / -256 > 0.  deny: (d / -256) isKindOfInteger.\r	assert: e / -256 > 0.  deny: (e / -256) isKindOfInteger.\r	assert: f / -256 > 0.  deny: (f / -256) isKindOfInteger.\r\r	assert: a / a equals: 1.\r	assert: b / a > 0.  deny: (b / a) isKindOfInteger.\r	assert: c / a > 0.  deny: (c / a) isKindOfInteger.\r	assert: d / a equals: -1.\r	assert: e / a < 0.  deny: (e / a) isKindOfInteger.\r	assert: f / a < 0.  deny: (f / a) isKindOfInteger.\r\r	assert: a / b > 0.  deny: (a / b) isKindOfInteger.\r	assert: b / b equals: 1.\r	assert: c / b > 0.  deny: (c / b) isKindOfInteger.\r	assert: d / b < 0.  deny: (d / b) isKindOfInteger.\r	assert: e / b equals: -1.\r	assert: f / b < 0.  deny: (f / b) isKindOfInteger.\r\r	assert: a / c > 0.  deny: (a / c) isKindOfInteger.\r	assert: b / c > 0.  deny: (b / c) isKindOfInteger.\r	assert: c / c equals: 1.\r	assert: d / c < 0.  deny: (d / c) isKindOfInteger.\r	assert: e / c < 0.  deny: (e / c) isKindOfInteger.\r	assert: f / c equals: -1.\r\r	assert: a / d equals: -1.\r	assert: b / d < 0.  deny: (b / d) isKindOfInteger.\r	assert: c / d < 0.  deny: (c / d) isKindOfInteger.\r	assert: d / d equals: 1.\r	assert: e / d > 0.  deny: (e / d) isKindOfInteger.\r	assert: f / d > 0.  deny: (f / d) isKindOfInteger.\r\r	assert: a / e < 0.  deny: (a / e) isKindOfInteger.\r	assert: b / e equals: -1.\r	assert: c / e < 0.  deny: (c / e) isKindOfInteger.\r	assert: d / e > 0.  deny: (d / e) isKindOfInteger.\r	assert: e / e equals: 1.\r	assert: f / e > 0.  deny: (f / e) isKindOfInteger.\r\r	assert: a / f < 0.  deny: (a / f) isKindOfInteger.\r	assert: b / f < 0.  deny: (b / f) isKindOfInteger.\r	assert: c / f equals: -1.\r	assert: d / f > 0.  deny: (d / f) isKindOfInteger.\r	assert: e / f > 0.  deny: (e / f) isKindOfInteger.\r	assert: f / f equals: 1.\r\r	assert: a * a / a equals: a.\r	assert: a * f / a equals: f.\r	assert: a * f / f equals: a.\r	assert: f * f / f equals: f.\r\r	assert: b * b / b equals: b.\r	assert: b * e / b equals: e.\r	assert: b * e / e equals: b.\r	assert: e * e / e equals: e.\r\r	assert: c * c / c equals: c.\r	assert: c * d / c equals: d.\r	assert: c * d / d equals: c.\r	assert: d * d / d equals: d.\r\r	should: [a / 0] signal: Error.\r	should: [b / 0] signal: Error.\r	should: [c / 0] signal: Error.\r	should: [d / 0] signal: Error.\r	should: [e / 0] signal: Error.\r	should: [f / 0] signal: Error.\r\r	assert: 0 / a equals: 0.\r	assert: 0 / b equals: 0.\r	assert: 0 / c equals: 0.\r	assert: 0 / d equals: 0.\r	assert: 0 / e equals: 0.\r	assert: 0 / f equals: 0.\r)",
 "public testLargeIntegerInvert = (\r	assert: largestNegativeLargeInteger bitInvert equals: smallestPositiveLargeInteger.\r	assert: smallestPositiveLargeInteger bitInvert equals: largestNegativeLargeInteger.\r	assert: 16rFFFFFFFFFFFFFFFF bitInvert equals: -18446744073709551616.\r	assert: 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF bitInvert equals: -340282366920938463463374607431768211456.\r	assert: -18446744073709551616 bitInvert equals: 16rFFFFFFFFFFFFFFFF.\r	assert: -340282366920938463463374607431768211456 bitInvert equals: 16rFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.\r)",
 "public testLargeIntegerMod = (\r	|\r	a = 16rC425942592C7528C08D25976E.\r	b = 16r9087475AA2733891DCA2F72AF2B.\r	c = 16r1BC2B572BD48EF6C8EE227273D781.\r	d = 0 - a.\r	e = 0 - b.\r	f = 0 - c.\r	|\r\r	assert: a \\\\ 1 equals: 0.\r	assert: b \\\\ 1 equals: 0.\r	assert: c \\\\ 1 equals: 0.\r	assert: d \\\\ 1 equals: 0.\r	assert: e \\\\ 1 equals: 0.\r	assert: f \\\\ 1 equals: 0.\r\r	assert: a \\\\ -1 equals: 0.\r	assert: b \\\\ -1 equals: 0.\r	assert: c \\\\ -1 equals: 0.\r	assert: d \\\\ -1 equals: 0.\r	assert: e \\\\ -1 equals: 0.\r	assert: f \\\\ -1 equals: 0.\r\r	assert: a \\\\ 254 equals: 164.\r	assert: b \\\\ 254 equals: 171.\r	assert: c \\\\ 254 equals: 171.\r	assert: d \\\\ 254 equals: 90.\r	assert: e \\\\ 254 equals: 83.\r	assert: f \\\\ 254 equals: 83.\r\r	assert: a \\\\ 255 equals: 134.\r	assert: b \\\\ 255 equals: 237.\r	assert: c \\\\ 255 equals: 222.\r	assert: d \\\\ 255 equals: 121.\r	assert: e \\\\ 255 equals: 18.\r	assert: f \\\\ 255 equals: 33.\r\r	assert: a \\\\ 256 equals: 110.\r	assert: b \\\\ 256 equals: 43.\r	assert: c \\\\ 256 equals: 129.\r	assert: d \\\\ 256 equals: 146.\r	assert: e \\\\ 256 equals: 213.\r	assert: f \\\\ 256 equals: 127.\r\r	assert: a \\\\ -254 equals: -90.\r	assert: b \\\\ -254 equals: -83.\r	assert: c \\\\ -254 equals: -83.\r	assert: d \\\\ -254 equals: -164.\r	assert: e \\\\ -254 equals: -171.\r	assert: f \\\\ -254 equals: -171.\r\r	assert: a \\\\ -255 equals: -121.\r	assert: b \\\\ -255 equals: -18.\r	assert: c \\\\ -255 equals: -33.\r	assert: d \\\\ -255 equals: -134.\r	assert: e \\\\ -255 equals: -237.\r	assert: f \\\\ -255 equals: -222.\r\r	assert: a \\\\ -256 equals: -146.\r	assert: b \\\\ -256 equals: -213.\r	assert: c \\\\ -256 equals: -127.\r	assert: d \\\\ -256 equals: -110.\r	assert: e \\\\ -256 equals: -43.\r	assert: f \\\\ -256 equals: -129.\r\r	assert: a \\\\ a equals: 0.\r	assert: b \\\\ a equals: 612442956730869442432757889635.\r	assert: c \\\\ a equals: 277072498513983728925083072807.\r	assert: d \\\\ a equals: 0.\r	assert: e \\\\ a equals: 358828911807608688696298970379.\r	assert: f \\\\ a equals: 694199370024494402203973787207.\r\r	assert: a \\\\ b equals: 971271868538478131129056860014.\r	assert: b \\\\ b equals: 0.\r	assert: c \\\\ b equals: 31457495336625503310850528661574.\r	assert: d \\\\ b equals: 182240282373426279963566390712253.\r	assert: e \\\\ b equals: 0.\r	assert: f \\\\ b equals: 151754058905339254783844918910693.\r\r	assert: a \\\\ c equals: a.\r	assert: b \\\\ c equals: b.\r	assert: c \\\\ c equals: 0.\r	assert: d \\\\ c equals: 9007852381324360171819798402842643.\r	assert: e \\\\ c equals: 8825612098950933891856232012130390.\r	assert: f \\\\ c equals: 0.\r\r	assert: a \\\\ d equals: 0.\r	assert: b \\\\ d equals: -358828911807608688696298970379.\r	assert: c \\\\ d equals: -694199370024494402203973787207.\r	assert: d \\\\ d equals: 0.\r	assert: e \\\\ d equals: -612442956730869442432757889635.\r	assert: f \\\\ d equals: -277072498513983728925083072807.\r\r	assert: a \\\\ e equals: -182240282373426279963566390712253.\r	assert: b \\\\ e equals: 0.\r	assert: c \\\\ e equals: -151754058905339254783844918910693.\r	assert: d \\\\ e equals: -971271868538478131129056860014.\r	assert: e \\\\ e equals: 0.\r	assert: f \\\\ e equals: -31457495336625503310850528661574.\r\r	assert: a \\\\ f equals: -9007852381324360171819798402842643.\r	assert: b \\\\ f equals: -8825612098950933891856232012130390.\r	assert: c \\\\ f equals: 0.\r	assert: d \\\\ f equals: d.\r	assert: e \\\\ f equals: e.\r	assert: f \\\\ f equals: 0.\r\r	should: [a \\\\ 0] signal: Error.\r	should: [b \\\\ 0] signal: Error.\r	should: [c \\\\ 0] signal: Error.\r	should: [d \\\\ 0] signal: Error.\r	should: [e \\\\ 0] signal: Error.\r	should: [f \\\\ 0] signal: Error.\r\r	assert: 0 \\\\ a equals: 0.\r	assert: 0 \\\\ b equals: 0.\r	assert: 0 \\\\ c equals: 0.\r	assert: 0 \\\\ d equals: 0.\r	assert: 0 \\\\ e equals: 0.\r	assert: 0 \\\\ f equals: 0.\r)",
 "public testLargeIntegerOr = (\r	|\r	a = 16rFFAABBCCDDEE997766.\r	b = 16rEEEEEEEEEEEEEEEE.\r	c = 16rCC0011223344556677.\r	d = 16r8888008888888888.\r	e = 0 - a.\r	f = 0 - b.\r	g = 0 - c.\r	h = 0 - d.\r	|\r\r	assert: (a bitOr: a) equals: a.\r	assert: (a bitOr: b) equals: 4721141485079017553902.\r	assert: (a bitOr: c) equals: 4716222428386019866487.\r	assert: (a bitOr: d) equals: 4716222390856591212526.\r	assert: (a bitOr: e) equals: -2.\r	assert: (a bitOr: f) equals: -4919094222426376330.\r	assert: (a bitOr: g) equals: -37529428688913.\r	assert: (a bitOr: h) equals: -34946.\r\r	assert: (b bitOr: a) equals: 4721141485079017553902.\r	assert: (b bitOr: b) equals: b.\r	assert: (b bitOr: c) equals: 3780357537319830417151.\r	assert: (b bitOr: d) equals: 17216961135462248174.\r	assert: (b bitOr: e) equals: -4703924523943555305730.\r	assert: (b bitOr: f) equals: -2.\r	assert: (b bitOr: g) equals: -3763140576184368168977.\r	assert: (b bitOr: h) equals: -2.\r\r	assert: (c bitOr: a) equals: 4716222428386019866487.\r	assert: (c bitOr: b) equals: 3780357537319830417151.\r	assert: (c bitOr: c) equals: c.\r	assert: (c bitOr: d) equals: 3772978727687334784767.\r	assert: (c bitOr: e) equals: -953081814671082131713.\r	assert: (c bitOr: f) equals: -17216923604892682377.\r	assert: (c bitOr: g) equals: -1.\r	assert: (c bitOr: h) equals: -9838113972397049985.\r\r	assert: (d bitOr: a) equals: 4716222390856591212526.\r	assert: (d bitOr: b) equals: 17216961135462248174.\r	assert: (d bitOr: c) equals: 3772978727687334784767.\r	assert: (d bitOr: d) equals: d.\r	assert: (d bitOr: e) equals: -4706384276884194162534.\r	assert: (d bitOr: f) equals: -7378847163065198182.\r	assert: (d bitOr: g) equals: -3763140613714937734775.\r	assert: (d bitOr: h) equals: -8.\r\r	assert: (e bitOr: a) equals: -2.\r	assert: (e bitOr: b) equals: -4703924523943555305730.\r	assert: (e bitOr: c) equals: -953081814671082131713.\r	assert: (e bitOr: d) equals: -4706384276884194162534.\r	assert: (e bitOr: e) equals: e.\r	assert: (e bitOr: f) equals: -12297866913035871846.\r	assert: (e bitOr: g) equals: -3763140576185509045861.\r	assert: (e bitOr: h) equals: -9838113972397015046.\r\r	assert: (f bitOr: a) equals: -4919094222426376330.\r	assert: (f bitOr: b) equals: -2.\r	assert: (f bitOr: c) equals: -17216923604892682377.\r	assert: (f bitOr: d) equals: -7378847163065198182.\r	assert: (f bitOr: e) equals: -12297866913035871846.\r	assert: (f bitOr: f) equals: f.\r	assert: (f bitOr: g) equals: -37530569565797.\r	assert: (f bitOr: h) equals: -9838113972397049990.\r\r	assert: (g bitOr: a) equals: -37529428688913.\r	assert: (g bitOr: b) equals: -3763140576184368168977.\r	assert: (g bitOr: c) equals: -1.\r	assert: (g bitOr: d) equals: -3763140613714937734775.\r	assert: (g bitOr: e) equals: -3763140576185509045861.\r	assert: (g bitOr: f) equals: -37530569565797.\r	assert: (g bitOr: g) equals: g.\r	assert: (g bitOr: h) equals: -7.\r\r	assert: (h bitOr: a) equals: -34946.\r	assert: (h bitOr: b) equals: -2.\r	assert: (h bitOr: c) equals: -9838113972397049985.\r	assert: (h bitOr: d) equals: -8.\r	assert: (h bitOr: e) equals: -9838113972397015046.\r	assert: (h bitOr: f) equals: -9838113972397049990.\r	assert: (h bitOr: g) equals: -7.\r	assert: (h bitOr: h) equals: h.\r\r	assert: (0 bitOr: a) equals: a.\r	assert: (0 bitOr: b) equals: b.\r	assert: (0 bitOr: c) equals: c.\r	assert: (0 bitOr: d) equals: d.\r	assert: (0 bitOr: e) equals: e.\r	assert: (0 bitOr: f) equals: f.\r	assert: (0 bitOr: g) equals: g.\r	assert: (0 bitOr: h) equals: h.\r\r	assert: (a bitOr: 0) equals: a.\r	assert: (b bitOr: 0) equals: b.\r	assert: (c bitOr: 0) equals: c.\r	assert: (d bitOr: 0) equals: d.\r	assert: (e bitOr: 0) equals: e.\r	assert: (f bitOr: 0) equals: f.\r	assert: (g bitOr: 0) equals: g.\r	assert: (h bitOr: 0) equals: h.\r)",
 "public testLargeIntegerParse = (\r	assert: (Integer parse: '-9223372036854775809') equals: largestNegativeLargeInteger.\r	assert: (Integer parse: '9223372036854775808') equals: smallestPositiveLargeInteger.\r\r	assert: (Integer parse: 'FFFFFFFFFFFFFFFF' radix: 16) equals: 16rFFFFFFFFFFFFFFFF.\r	assert: (Integer parse: 'ABCDABCDABCDABCD' radix: 16) equals: 16rABCDABCDABCDABCD.\r	assert: (Integer parse: '-9999999999999999999') equals: -9999999999999999999.\r)",
 "public testLargeIntegerQuo = (\r	|\r	a = 16rC425942592C7528C08D25976E.\r	b = 16r9087475AA2733891DCA2F72AF2B.\r	c = 16r1BC2B572BD48EF6C8EE227273D781.\r	d = 0 - a.\r	e = 0 - b.\r	f = 0 - c.\r	|\r\r	assert: (a quo: 1) equals: a.\r	assert: (b quo: 1) equals: b.\r	assert: (c quo: 1) equals: c.\r	assert: (d quo: 1) equals: d.\r	assert: (e quo: 1) equals: e.\r	assert: (f quo: 1) equals: f.\r\r	assert: (a quo: -1) equals: 0 - a.\r	assert: (b quo: -1) equals: 0 - b.\r	assert: (c quo: -1) equals: 0 - c.\r	assert: (d quo: -1) equals: 0 - d.\r	assert: (e quo: -1) equals: 0 - e.\r	assert: (f quo: -1) equals: 0 - f.\r\r	assert: (a quo: 254) equals: 3823904994245976894208885275.\r	assert: (b quo: 254) equals: 721305331661278575175966329024.\r	assert: (c quo: 254) equals: 35467809658239758464373730156309.\r	assert: (d quo: 254) equals: -3823904994245976894208885275.\r	assert: (e quo: 254) equals: -721305331661278575175966329024.\r	assert: (f quo: 254) equals: -35467809658239758464373730156309.\r\r	assert: (a quo: 255) equals: 3808909288386188749525713176.\r	assert: (b quo: 255) equals: 718476683301822580763511559106.\r	assert: (c quo: 255) equals: 35328720208599602548827166508637.\r	assert: (d quo: 255) equals: -3808909288386188749525713176.\r	assert: (e quo: 255) equals: -718476683301822580763511559106.\r	assert: (f quo: 255) equals: -35328720208599602548827166508637.\r\r	assert: (a quo: 256) equals: 3794030736478430199722878359.\r	assert: (b quo: 256) equals: 715670133757674836307404092079.\r	assert: (c quo: 256) equals: 35190717395284760351370810389463.\r	assert: (d quo: 256) equals: -3794030736478430199722878359.\r	assert: (e quo: 256) equals: -715670133757674836307404092079.\r	assert: (f quo: 256) equals: -35190717395284760351370810389463.\r\r	assert: (a quo: -254) equals: -3823904994245976894208885275.\r	assert: (b quo: -254) equals: -721305331661278575175966329024.\r	assert: (c quo: -254) equals: -35467809658239758464373730156309.\r	assert: (d quo: -254) equals: 3823904994245976894208885275.\r	assert: (e quo: -254) equals: 721305331661278575175966329024.\r	assert: (f quo: -254) equals: 35467809658239758464373730156309.\r\r	assert: (a quo: -255) equals: -3808909288386188749525713176.\r	assert: (b quo: -255) equals: -718476683301822580763511559106.\r	assert: (c quo: -255) equals: -35328720208599602548827166508637.\r	assert: (d quo: -255) equals: 3808909288386188749525713176.\r	assert: (e quo: -255) equals: 718476683301822580763511559106.\r	assert: (f quo: -255) equals: 35328720208599602548827166508637.\r\r	assert: (a quo: -256) equals: -3794030736478430199722878359.\r	assert: (b quo: -256) equals: -715670133757674836307404092079.\r	assert: (c quo: -256) equals: -35190717395284760351370810389463.\r	assert: (d quo: -256) equals: 3794030736478430199722878359.\r	assert: (e quo: -256) equals: 715670133757674836307404092079.\r	assert: (f quo: -256) equals: 35190717395284760351370810389463.\r\r	assert: (a quo: a) equals: 1.\r	assert: (b quo: a) equals: 188.\r	assert: (c quo: a) equals: 9275.\r	assert: (d quo: a) equals: -1.\r	assert: (e quo: a) equals: -188.\r	assert: (f quo: a) equals: -9275.\r\r	assert: (a quo: b) equals: 0.\r	assert: (b quo: b) equals: 1.\r	assert: (c quo: b) equals: 49.\r	assert: (d quo: b) equals: 0.\r	assert: (e quo: b) equals: -1.\r	assert: (f quo: b) equals: -49.\r\r	assert: (a quo: c) equals: 0.\r	assert: (b quo: c) equals: 0.\r	assert: (c quo: c) equals: 1.\r	assert: (d quo: c) equals: 0.\r	assert: (e quo: c) equals: 0.\r	assert: (f quo: c) equals: -1.\r\r	assert: (a quo: d) equals: -1.\r	assert: (b quo: d) equals: -188.\r	assert: (c quo: d) equals: -9275.\r	assert: (d quo: d) equals: 1.\r	assert: (e quo: d) equals: 188.\r	assert: (f quo: d) equals: 9275.\r\r	assert: (a quo: e) equals: 0.\r	assert: (b quo: e) equals: -1.\r	assert: (c quo: e) equals: -49.\r	assert: (d quo: e) equals: 0.\r	assert: (e quo: e) equals: 1.\r	assert: (f quo: e) equals: 49.\r\r	assert: (a quo: f) equals: 0.\r	assert: (b quo: f) equals: 0.\r	assert: (c quo: f) equals: -1.\r	assert: (d quo: f) equals: 0.\r	assert: (e quo: f) equals: 0.\r	assert: (f quo: f) equals: 1.\r\r	should: [a quo: 0] signal: Error.\r	should: [b quo: 0] signal: Error.\r	should: [c quo: 0] signal: Error.\r	should: [d quo: 0] signal: Error.\r	should: [e quo: 0] signal: Error.\r	should: [f quo: 0] signal: Error.\r\r	assert: (0 quo: a) equals: 0.\r	assert: (0 quo: b) equals: 0.\r	assert: (0 quo: c) equals: 0.\r	assert: (0 quo: d) equals: 0.\r	assert: (0 quo: e) equals: 0.\r	assert: (0 quo: f) equals: 0.\r)",
 "public testLargeIntegerRem = (\r	|\r	a = 16rC425942592C7528C08D25976E.\r	b = 16r9087475AA2733891DCA2F72AF2B.\r	c = 16r1BC2B572BD48EF6C8EE227273D781.\r	d = 0 - a.\r	e = 0 - b.\r	f = 0 - c.\r	|\r\r	assert: (a rem: 1) equals: 0.\r	assert: (b rem: 1) equals: 0.\r	assert: (c rem: 1) equals: 0.\r	assert: (d rem: 1) equals: 0.\r	assert: (e rem: 1) equals: 0.\r	assert: (f rem: 1) equals: 0.\r\r	assert: (a rem: -1) equals: 0.\r	assert: (b rem: -1) equals: 0.\r	assert: (c rem: -1) equals: 0.\r	assert: (d rem: -1) equals: 0.\r	assert: (e rem: -1) equals: 0.\r	assert: (f rem: -1) equals: 0.\r\r	assert: (a rem: 254) equals: 164.\r	assert: (b rem: 254) equals: 171.\r	assert: (c rem: 254) equals: 171.\r	assert: (d rem: 254) equals: -164.\r	assert: (e rem: 254) equals: -171.\r	assert: (f rem: 254) equals: -171.\r\r	assert: (a rem: 255) equals: 134.\r	assert: (b rem: 255) equals: 237.\r	assert: (c rem: 255) equals: 222.\r	assert: (d rem: 255) equals: -134.\r	assert: (e rem: 255) equals: -237.\r	assert: (f rem: 255) equals: -222.\r\r	assert: (a rem: 256) equals: 110.\r	assert: (b rem: 256) equals: 43.\r	assert: (c rem: 256) equals: 129.\r	assert: (d rem: 256) equals: -110.\r	assert: (e rem: 256) equals: -43.\r	assert: (f rem: 256) equals: -129.\r\r	assert: (a rem: -254) equals: 164.\r	assert: (b rem: -254) equals: 171.\r	assert: (c rem: -254) equals: 171.\r	assert: (d rem: -254) equals: -164.\r	assert: (e rem: -254) equals: -171.\r	assert: (f rem: -254) equals: -171.\r\r	assert: (a rem: -255) equals: 134.\r	assert: (b rem: -255) equals: 237.\r	assert: (c rem: -255) equals: 222.\r	assert: (d rem: -255) equals: -134.\r	assert: (e rem: -255) equals: -237.\r	assert: (f rem: -255) equals: -222.\r\r	assert: (a rem: -256) equals: 110.\r	assert: (b rem: -256) equals: 43.\r	assert: (c rem: -256) equals: 129.\r	assert: (d rem: -256) equals: -110.\r	assert: (e rem: -256) equals: -43.\r	assert: (f rem: -256) equals: -129.\r\r	assert: (a rem: a) equals: 0.\r	assert: (b rem: a) equals: 612442956730869442432757889635.\r	assert: (c rem: a) equals: 277072498513983728925083072807.\r	assert: (d rem: a) equals: 0.\r	assert: (e rem: a) equals: -612442956730869442432757889635.\r	assert: (f rem: a) equals: -277072498513983728925083072807.\r\r	assert: (a rem: b) equals: a.\r	assert: (b rem: b) equals: 0.\r	assert: (c rem: b) equals: 31457495336625503310850528661574.\r	assert: (d rem: b) equals: d.\r	assert: (e rem: b) equals: 0.\r	assert: (f rem: b) equals: -31457495336625503310850528661574.\r\r	assert: (a rem: c) equals: a.\r	assert: (b rem: c) equals: b.\r	assert: (c rem: c) equals: 0.\r	assert: (d rem: c) equals: d.\r	assert: (e rem: c) equals: e.\r	assert: (f rem: c) equals: 0.\r\r	assert: (a rem: d) equals: 0.\r	assert: (b rem: d) equals: 612442956730869442432757889635.\r	assert: (c rem: d) equals: 277072498513983728925083072807.\r	assert: (d rem: d) equals: 0.\r	assert: (e rem: d) equals: -612442956730869442432757889635.\r	assert: (f rem: d) equals: -277072498513983728925083072807.\r\r	assert: (a rem: e) equals: a.\r	assert: (b rem: e) equals: 0.\r	assert: (c rem: e) equals: 31457495336625503310850528661574.\r	assert: (d rem: e) equals: d.\r	assert: (e rem: e) equals: 0.\r	assert: (f rem: e) equals: -31457495336625503310850528661574.\r\r	assert: (a rem: f) equals: a.\r	assert: (b rem: f) equals: b.\r	assert: (c rem: f) equals: 0.\r	assert: (d rem: f) equals: d.\r	assert: (e rem: f) equals: e.\r	assert: (f rem: f) equals: 0.\r\r	should: [a rem: 0] signal: Error.\r	should: [b rem: 0] signal: Error.\r	should: [c rem: 0] signal: Error.\r	should: [d rem: 0] signal: Error.\r	should: [e rem: 0] signal: Error.\r	should: [f rem: 0] signal: Error.\r\r	assert: (0 rem: a) equals: 0.\r	assert: (0 rem: b) equals: 0.\r	assert: (0 rem: c) equals: 0.\r	assert: (0 rem: d) equals: 0.\r	assert: (0 rem: e) equals: 0.\r	assert: (0 rem: f) equals: 0.\r)",
 "public testLargeIntegerShiftLeft = (\r	|\r	a = 16rABCD1234DCBA432155.\r	b = 0 - 16rABCD1234DCBA432155.\r	|\r	assert: a << 0 equals: a.\r	assert: b << 0 equals: b.\r\r	assert: a << 7 equals: 405653781510951904782976.\r	assert: b << 7 equals: -405653781510951904782976.\r	assert: a << 8 equals: 811307563021903809565952.\r	assert: b << 8 equals: -811307563021903809565952.\r	assert: a << 9 equals: 1622615126043807619131904.\r	assert: b << 9 equals: -1622615126043807619131904.\r\r	assert: a << 15 equals: 103847368066803687624441856.\r	assert: b << 15 equals: -103847368066803687624441856.\r	assert: a << 16 equals: 207694736133607375248883712.\r	assert: b << 16 equals: -207694736133607375248883712.\r	assert: a << 17 equals: 415389472267214750497767424.\r	assert: b << 17 equals: -415389472267214750497767424.\r\r	assert: a << 31 equals: 6805741113626046472155421474816.\r	assert: b << 31 equals: -6805741113626046472155421474816.\r	assert: a << 32 equals: 13611482227252092944310842949632.\r	assert: b << 32 equals: -13611482227252092944310842949632.\r	assert: a << 33 equals: 27222964454504185888621685899264.\r	assert: b << 33 equals: -27222964454504185888621685899264.\r\r	assert: a << 63 equals: 29230435508066489571683709863430807617536.\r	assert: b << 63 equals: -29230435508066489571683709863430807617536.\r	assert: a << 64 equals: 58460871016132979143367419726861615235072.\r	assert: b << 64 equals: -58460871016132979143367419726861615235072.\r	assert: a << 65 equals: 116921742032265958286734839453723230470144.\r	assert: b << 65 equals: -116921742032265958286734839453723230470144.\r\r	(* should: [a << maxInt31] signal: OutOfMemory.\r	should: [b << maxInt31] signal: OutOfMemory.\r	should: [a << maxInt63] signal: OutOfMemory.\r	should: [b << maxInt63] signal: OutOfMemory.\r	should: [a << maxInt64] signal: OutOfMemory.\r	should: [b << maxInt64] signal: OutOfMemory.\r	should: [a << a] signal: OutOfMemory.\r	should: [b << a] signal: OutOfMemory. *)\r\r	should: [a << -1] signal: Error.\r	should: [b << -1] signal: Error.\r	should: [a << minInt31] signal: Error.\r	should: [b << minInt31] signal: Error.\r	should: [a << minInt63] signal: Error.\r	should: [b << minInt63] signal: Error.\r	should: [a << minInt64] signal: Error.\r	should: [b << minInt64] signal: Error.\r	should: [a << b] signal: Error.\r	should: [b << b] signal: Error.\r)",
 "public testLargeIntegerShiftRight = (\r	|\r	a = 16rABCD1234DCBA432100.\r	b = 0 - 16rABCD1234DCBA432100.\r	|\r	assert: a >> 0 equals: a.\r	assert: b >> 0 equals: b.\r\r	assert: a >> 7 equals: 24759141937924310594.\r	assert: b >> 7 equals: -24759141937924310594.\r	assert: a >> 8 equals: 12379570968962155297.\r	assert: b >> 8 equals: -12379570968962155297.\r	assert: a >> 9 equals: 6189785484481077648.\r	assert: b >> 9 equals: -6189785484481077649.\r\r	assert: a >> 15 equals: 96715398195016838.\r	assert: b >> 15 equals: -96715398195016839.\r	assert: a >> 16 equals: 48357699097508419.\r	assert: b >> 16 equals: -48357699097508420.\r	assert: a >> 17 equals: 24178849548754209.\r	assert: b >> 17 equals: -24178849548754210.\r\r	assert: a >> 31 equals: 1475759860153.\r	assert: b >> 31 equals: -1475759860154.\r	assert: a >> 32 equals: 737879930076.\r	assert: b >> 32 equals: -737879930077.\r	assert: a >> 33 equals: 368939965038.\r	assert: b >> 34 equals: -184469982520.\r\r	assert: a >> 63 equals: 343.\r	assert: b >> 63 equals: -344.\r	assert: a >> 64 equals: 171.\r	assert: b >> 64 equals: -172.\r	assert: a >> 65 equals: 85.\r	assert: b >> 65 equals: -86.\r\r	assert: a >> maxInt31 equals: 0.\r	assert: b >> maxInt31 equals: -1.\r	assert: a >> maxInt63 equals: 0.\r	assert: b >> maxInt63 equals: -1.\r	assert: a >> maxInt64 equals: 0.\r	assert: b >> maxInt64 equals: -1.\r	assert: a >> a equals: 0.\r	assert: b >> a equals: -1.\r\r	should: [a >> -1] signal: Error.\r	should: [b >> -1] signal: Error.\r	should: [a >> minInt31] signal: Error.\r	should: [b >> minInt31] signal: Error.\r	should: [a >> minInt63] signal: Error.\r	should: [b >> minInt63] signal: Error.\r	should: [a >> minInt64] signal: Error.\r	should: [b >> minInt64] signal: Error.\r	should: [a >> b] signal: Error.\r	should: [b >> b] signal: Error.\r)",
 "public testLargeIntegerSubtract = (\r	|\r	a = 16rC425942592C7528C08D25976E.\r	b = 16r9087475AA2733891DCA2F72AF2B.\r	c = 16r1BC2B572BD48EF6C8EE227273D781.\r	d = 0 - a.\r	e = 0 - b.\r	f = 0 - c.\r	|\r\r	assert: minInt64 - minInt64 equals: 0.\r	assert: maxInt64 - maxInt64 equals: 0.\r	assert: largestNegativeLargeInteger - 1 equals: -9223372036854775810.\r	assert: largestNegativeLargeInteger - -1 equals: -9223372036854775808.\r	assert: smallestPositiveLargeInteger - 1 equals: 9223372036854775807.\r	assert: smallestPositiveLargeInteger - -1 equals: 9223372036854775809.\r	assert: smallestPositiveLargeInteger - largestNegativeLargeInteger equals: 18446744073709551617.\r\r	assert: a - a equals: 0.\r	assert: b - a equals: 182240282373426279963566390712253.\r	assert: c - a equals: 9007852381324360171819798402842643.\r	assert: d - a equals: -1942543737076956262258113720028.\r	assert: e - a equals: -184182826110503236225824504432281.\r	assert: f - a equals: -9009794925061437128082056516562671.\r\r	assert: a - b equals: -182240282373426279963566390712253.\r	assert: b - b equals: 0.\r	assert: c - b equals: 8825612098950933891856232012130390.\r	assert: d - b equals: -184182826110503236225824504432281.\r	assert: e - b equals: -366423108483929516189390895144534.\r	assert: f - b equals: -9192035207434863408045622907274924.\r\r	assert: a - c equals: -9007852381324360171819798402842643.\r	assert: b - c equals: -8825612098950933891856232012130390.\r	assert: c - c equals: 0.\r	assert: d - c equals: -9009794925061437128082056516562671.\r	assert: e - c equals: -9192035207434863408045622907274924.\r	assert: f - c equals: -18017647306385797299901854919405314.\r\r	assert: a - d equals: 1942543737076956262258113720028.\r	assert: b - d equals: 184182826110503236225824504432281.\r	assert: c - d equals: 9009794925061437128082056516562671.\r	assert: d - d equals: 0.\r	assert: e - d equals: -182240282373426279963566390712253.\r	assert: f - d equals: -9007852381324360171819798402842643.\r\r	assert: a - e equals: 184182826110503236225824504432281.\r	assert: b - e equals: 366423108483929516189390895144534.\r	assert: c - e equals: 9192035207434863408045622907274924.\r	assert: d - e equals: 182240282373426279963566390712253.\r	assert: e - e equals: 0.\r	assert: f - e equals: -8825612098950933891856232012130390.\r\r	assert: a - f equals: 9009794925061437128082056516562671.\r	assert: b - f equals: 9192035207434863408045622907274924.\r	assert: c - f equals: 18017647306385797299901854919405314.\r	assert: d - f equals: 9007852381324360171819798402842643.\r	assert: e - f equals: 8825612098950933891856232012130390.\r	assert: f - f equals: 0.\r)",
 "public testLargeIntegerXor = (\r	|\r	a = 16rFFAABBCCDDEE997766.\r	b = 16rEEEEEEEEEEEEEEEE.\r	c = 16rCC0011223344556677.\r	d = 16r8888008888888888.\r	e = 0 - a.\r	f = 0 - b.\r	g = 0 - c.\r	h = 0 - d.\r	|\r\r	assert: (a bitXor: a) equals: 0.\r	assert: (a bitXor: b) equals: 4708843618165981682056.\r	assert: (a bitXor: c) equals: 953081852200510820625.\r	assert: (a bitXor: d) equals: 4706384276884194197486.\r	assert: (a bitXor: e) equals: -4.\r	assert: (a bitXor: f) equals: -4708843618165981682060.\r	assert: (a bitXor: g) equals: -953081852200510820625.\r	assert: (a bitXor: h) equals: -4706384276884194197474.\r\r	assert: (b bitXor: a) equals: 4708843618165981682056.\r	assert: (b bitXor: b) equals: 0.\r	assert: (b bitXor: c) equals: 3780357499789260851353.\r	assert: (b bitXor: d) equals: 7378847163065198182.\r	assert: (b bitXor: e) equals: -4708843618165981682060.\r	assert: (b bitXor: f) equals: -4.\r	assert: (b bitXor: g) equals: -3780357499789260851353.\r	assert: (b bitXor: h) equals: -7378847163065198186.\r\r	assert: (c bitXor: a) equals: 953081852200510820625.\r	assert: (c bitXor: b) equals: 3780357499789260851353.\r	assert: (c bitXor: c) equals: 0.\r	assert: (c bitXor: d) equals: 3772978727687334784767.\r	assert: (c bitXor: e) equals: -953081852200510820627.\r	assert: (c bitXor: f) equals: -3780357499789260851355.\r	assert: (c bitXor: g) equals: -2.\r	assert: (c bitXor: h) equals: -3772978727687334784753.\r\r	assert: (d bitXor: a) equals: 4706384276884194197486.\r	assert: (d bitXor: b) equals: 7378847163065198182.\r	assert: (d bitXor: c) equals: 3772978727687334784767.\r	assert: (d bitXor: d) equals: 0.\r	assert: (d bitXor: e) equals: -4706384276884194197486.\r	assert: (d bitXor: f) equals: -7378847163065198182.\r	assert: (d bitXor: g) equals: -3772978727687334784767.\r	assert: (d bitXor: h) equals: -16.\r\r	assert: (e bitXor: a) equals: -4.\r	assert: (e bitXor: b) equals: -4708843618165981682060.\r	assert: (e bitXor: c) equals: -953081852200510820627.\r	assert: (e bitXor: d) equals: -4706384276884194197486.\r	assert: (e bitXor: e) equals: 0.\r	assert: (e bitXor: f) equals: 4708843618165981682056.\r	assert: (e bitXor: g) equals: 953081852200510820627.\r	assert: (e bitXor: h) equals: 4706384276884194197474.\r\r	assert: (f bitXor: a) equals: -4708843618165981682060.\r	assert: (f bitXor: b) equals: -4.\r	assert: (f bitXor: c) equals: -3780357499789260851355.\r	assert: (f bitXor: d) equals: -7378847163065198182.\r	assert: (f bitXor: e) equals: 4708843618165981682056.\r	assert: (f bitXor: f) equals: 0.\r	assert: (f bitXor: g) equals: 3780357499789260851355.\r	assert: (f bitXor: h) equals: 7378847163065198186.\r\r	assert: (g bitXor: a) equals: -953081852200510820625.\r	assert: (g bitXor: b) equals: -3780357499789260851353.\r	assert: (g bitXor: c) equals: -2.\r	assert: (g bitXor: d) equals: -3772978727687334784767.\r	assert: (g bitXor: e) equals: 953081852200510820627.\r	assert: (g bitXor: f) equals: 3780357499789260851355.\r	assert: (g bitXor: g) equals: 0.\r	assert: (g bitXor: h) equals: 3772978727687334784753.\r\r	assert: (h bitXor: a) equals: -4706384276884194197474.\r	assert: (h bitXor: b) equals: -7378847163065198186.\r	assert: (h bitXor: c) equals: -3772978727687334784753.\r	assert: (h bitXor: d) equals: -16.\r	assert: (h bitXor: e) equals: 4706384276884194197474.\r	assert: (h bitXor: f) equals: 7378847163065198186.\r	assert: (h bitXor: g) equals: 3772978727687334784753.\r	assert: (h bitXor: h) equals: 0.\r\r	assert: (0 bitXor: a) equals: a.\r	assert: (0 bitXor: b) equals: b.\r	assert: (0 bitXor: c) equals: c.\r	assert: (0 bitXor: d) equals: d.\r	assert: (0 bitXor: e) equals: e.\r	assert: (0 bitXor: f) equals: f.\r	assert: (0 bitXor: g) equals: g.\r	assert: (0 bitXor: h) equals: h.\r\r	assert: (a bitXor: 0) equals: a.\r	assert: (b bitXor: 0) equals: b.\r	assert: (c bitXor: 0) equals: c.\r	assert: (d bitXor: 0) equals: d.\r	assert: (e bitXor: 0) equals: e.\r	assert: (f bitXor: 0) equals: f.\r	assert: (g bitXor: 0) equals: g.\r	assert: (h bitXor: 0) equals: h.\r)",
 "public testLargeIntegerZeroShiftLeft = (\r	(* Shifts need to consider clamping only for zero. *)\r	assert: 0 << 32 equals: 0.\r	assert: 0 << 64 equals: 0.\r	assert: 0 << 96 equals: 0.\r	assert: 0 << 128 equals: 0.\r\r	assert: 0 << 31 equals: 0.\r	assert: 0 << 63 equals: 0.\r	assert: 0 << 95 equals: 0.\r	assert: 0 << 127 equals: 0.\r\r	assert: 0 << 33 equals: 0.\r	assert: 0 << 65 equals: 0.\r	assert: 0 << 97 equals: 0.\r	assert: 0 << 129 equals: 0.\r)",
 "public testLargeIntegerZeroShiftRight = (\r	(* Shifts need to consider clamping only for zero. *)\r	assert: 0 >> 32 equals: 0.\r	assert: 0 >> 64 equals: 0.\r	assert: 0 >> 96 equals: 0.\r	assert: 0 >> 128 equals: 0.\r\r	assert: 0 >> 31 equals: 0.\r	assert: 0 >> 63 equals: 0.\r	assert: 0 >> 95 equals: 0.\r	assert: 0 >> 127 equals: 0.\r\r	assert: 0 >> 33 equals: 0.\r	assert: 0 >> 65 equals: 0.\r	assert: 0 >> 97 equals: 0.\r	assert: 0 >> 129 equals: 0.\r)",
 "public testMediumIntegerAddOverflow = (\r	assert: minInt64 + -1 equals: -9223372036854775809.\r	assert: maxInt64 + 1 equals: 9223372036854775808.\r	assert: maxInt64 + maxInt64 equals: 18446744073709551614.\r	assert: minInt64 + minInt64 equals: -18446744073709551616.\r)",
 "public testMediumIntegerAnd = (\r	assert: (minInt31 bitAnd: 0) equals: 0.\r	assert: (minInt32 bitAnd: 0) equals: 0.\r	assert: (minInt63 bitAnd: 0) equals: 0.\r	assert: (minInt64 bitAnd: 0) equals: 0.\r	assert: (maxInt31 bitAnd: 0) equals: 0.\r	assert: (maxInt32 bitAnd: 0) equals: 0.\r	assert: (maxInt63 bitAnd: 0) equals: 0.\r	assert: (maxInt64 bitAnd: 0) equals: 0.\r\r	assert: (minInt31 bitAnd: minInt31) equals: minInt31.\r	assert: (minInt32 bitAnd: minInt32) equals: minInt32.\r	assert: (minInt63 bitAnd: minInt63) equals: minInt63.\r	assert: (minInt64 bitAnd: minInt64) equals: minInt64.\r	assert: (maxInt31 bitAnd: maxInt31) equals: maxInt31.\r	assert: (maxInt32 bitAnd: maxInt32) equals: maxInt32.\r	assert: (maxInt63 bitAnd: maxInt63) equals: maxInt63.\r	assert: (maxInt64 bitAnd: maxInt64) equals: maxInt64.\r\r	assert: (minInt31 bitAnd: maxInt31) equals: 0.\r	assert: (minInt32 bitAnd: maxInt32) equals: 0.\r	assert: (minInt63 bitAnd: maxInt63) equals: 0.\r	assert: (minInt64 bitAnd: maxInt64) equals: 0.\r\r	assert: (maxInt32 bitAnd: maxInt31) equals: maxInt31.\r	assert: (maxInt63 bitAnd: maxInt31) equals: maxInt31.\r	assert: (maxInt64 bitAnd: maxInt31) equals: maxInt31.\r\r	assert: (maxInt63 bitAnd: maxInt32) equals: maxInt32.\r	assert: (maxInt64 bitAnd: maxInt32) equals: maxInt32.\r\r	assert: (maxInt64 bitAnd: maxInt63) equals: maxInt63.\r)",
 "public testMediumIntegerAsFloat = (\r	assert: maxInt32 asFloat equals: (Float parse: '2147483647.0').\r	assert: minInt32 asFloat equals: (Float parse: '-2147483648.0').\r\r	assert: maxInt63 asFloat equals: (Float parse: '4611686018427387903.0').\r	assert: minInt63 asFloat equals: (Float parse: '-4611686018427387904.0').\r\r	assert: maxInt64 asFloat equals: (Float parse: '9223372036854775807.0').\r	assert: minInt64 asFloat equals: (Float parse: '-9223372036854775808.0').\r\r	assert: 16rCAFECAFECAFECAFE asFloat equals: (Float parse: '14627351835422149374.0').\r)",
 "public testMediumIntegerAsString = (\r	assert: maxInt64 asString equals: '9223372036854775807'.\r	assert: minInt64 asString equals: '-9223372036854775808'.\r)",
 "public testMediumIntegerComparisons = (\r	assert: minInt64 = minInt64.\r	deny: minInt64 < minInt64.\r	deny: minInt64 > minInt64.\r	assert: minInt64 <= minInt64.\r	assert: minInt64 >= minInt64.\r\r	assert: maxInt64 = maxInt64.\r	deny: maxInt64 < maxInt64.\r	deny: maxInt64 > maxInt64.\r	assert: maxInt64 <= maxInt64.\r	assert: maxInt64 >= maxInt64.\r\r	deny: maxInt64 = minInt64.\r	deny: maxInt64 < minInt64.\r	assert: maxInt64 > minInt64.\r	deny: maxInt64 <= minInt64.\r	assert: maxInt64 >= minInt64.\r\r	deny: minInt64 = maxInt64.\r	assert: minInt64 < maxInt64.\r	deny: minInt64 > maxInt64.\r	assert: minInt64 <= maxInt64.\r	deny: minInt64 >= maxInt64.\r)",
 "public testMediumIntegerDiv = (\r	assert: minInt31 // 1 equals: minInt31.\r	assert: minInt32 // 1 equals: minInt32.\r	assert: minInt63 // 1 equals: minInt63.\r	assert: minInt64 // 1 equals: minInt64.\r	assert: maxInt31 // 1 equals: maxInt31.\r	assert: maxInt32 // 1 equals: maxInt32.\r	assert: maxInt63 // 1 equals: maxInt63.\r	assert: maxInt64 // 1 equals: maxInt64.\r\r	assert: minInt31 // -1 equals: 1073741824.\r	assert: minInt32 // -1 equals: 2147483648.\r	assert: minInt63 // -1 equals: 4611686018427387904.\r	(* big int: assert: minInt64 // -1 equals: 9223372036854775808. *)\r	assert: maxInt31 // -1 equals: -1073741823.\r	assert: maxInt32 // -1 equals: -2147483647.\r	assert: maxInt63 // -1 equals: -4611686018427387903.\r	assert: maxInt64 // -1 equals: -9223372036854775807.\r\r	assert: minInt31 // 7 equals: -153391690.\r	assert: minInt32 // 7 equals: -306783379.\r	assert: minInt63 // 7 equals: -658812288346769701.\r	(* assert: minInt64 // 7 equals: -1317624576693539402. *)\r	assert: maxInt31 // 7 equals: 153391689.\r	assert: maxInt32 // 7 equals: 306783378.\r	assert: maxInt63 // 7 equals: 658812288346769700.\r	(* assert: maxInt64 // 7 equals: 1317624576693539401. *)\r\r	assert: minInt31 // -7 equals: 153391689.\r	assert: minInt32 // -7 equals: 306783378.\r	assert: minInt63 // -7 equals: 658812288346769700.\r	(* big int intermediate: assert: minInt64 // -7 equals: 1317624576693539401. *)\r	assert: maxInt31 // -7 equals: -153391689.\r	assert: maxInt32 // -7 equals: -306783379.\r	assert: maxInt63 // -7 equals: -658812288346769701.\r	(* assert: maxInt64 // -7 equals: -1317624576693539401. *)\r\r	(* big int intermediates\r	assert: minInt31 // minInt64 equals: 0.\r	assert: minInt32 // minInt64 equals: 0.\r	assert: minInt63 // minInt64 equals: 0.\r	assert: minInt64 // minInt64 equals: 1.\r	assert: maxInt31 // minInt64 equals: -1.\r	assert: maxInt32 // minInt64 equals: -1.\r	assert: maxInt63 // minInt64 equals: -1.\r	assert: maxInt64 // minInt64 equals: -1. *)\r\r	should: [minInt64 // 0] signal: Error.\r	should: [maxInt64 // 0] signal: Error.\r\r	assert: 0 // minInt64 equals: 0.\r	assert: 0 // maxInt64 equals: 0.\r)",
 "public testMediumIntegerDivOverflow = (\r	assert: minInt64 // -1 equals: 9223372036854775808.\r	assert: minInt64 // 7 equals: -1317624576693539402.\r	assert: maxInt64 // 7 equals: 1317624576693539401.\r	assert: minInt64 // -7 equals: 1317624576693539401.\r	assert: maxInt64 // -7 equals: -1317624576693539401.\r\r	assert: minInt31 // minInt64 equals: 0.\r	assert: minInt32 // minInt64 equals: 0.\r	assert: minInt63 // minInt64 equals: 0.\r	assert: minInt64 // minInt64 equals: 1.\r	assert: maxInt31 // minInt64 equals: -1.\r	assert: maxInt32 // minInt64 equals: -1.\r	assert: maxInt63 // minInt64 equals: -1.\r	assert: maxInt64 // minInt64 equals: -1.\r)",
 "public testMediumIntegerDivide = (\r	assert: minInt31 / 1 equals: minInt31.\r	assert: minInt32 / 1 equals: minInt32.\r	assert: minInt63 / 1 equals: minInt63.\r	assert: minInt64 / 1 equals: minInt64.\r	assert: maxInt31 / 1 equals: maxInt31.\r	assert: maxInt32 / 1 equals: maxInt32.\r	assert: maxInt63 / 1 equals: maxInt63.\r	assert: maxInt64 / 1 equals: maxInt64.\r\r	assert: minInt31 / -1 equals: 1073741824.\r	assert: minInt32 / -1 equals: 2147483648.\r	assert: minInt63 / -1 equals: 4611686018427387904.\r	(* big int: assert: minInt64 / -1 equals: 9223372036854775808. *)\r	assert: maxInt31 / -1 equals: -1073741823.\r	assert: maxInt32 / -1 equals: -2147483647.\r	assert: maxInt63 / -1 equals: -4611686018427387903.\r	assert: maxInt64 / -1 equals: -9223372036854775807.\r\r	should: [minInt64 / 0] signal: Error.\r	should: [maxInt64 / 0] signal: Error.\r\r	assert: 0 / minInt64 equals: 0.\r	assert: 0 / maxInt64 equals: 0.\r)",
 "public testMediumIntegerDivideOverflow = (\r	assert: minInt64 / -1 equals: 9223372036854775808.\r)",
 "public testMediumIntegerInvert = (\r	assert: minInt31 bitInvert equals: maxInt31.\r	assert: minInt32 bitInvert equals: maxInt32.\r	assert: minInt63 bitInvert equals: maxInt63.\r	assert: minInt64 bitInvert equals: maxInt64.\r	assert: maxInt31 bitInvert equals: minInt31.\r	assert: maxInt32 bitInvert equals: minInt32.\r	assert: maxInt63 bitInvert equals: minInt63.\r	assert: maxInt64 bitInvert equals: minInt64.\r)",
 "public testMediumIntegerMod = (\r	assert: minInt31 \\\\ 1 equals: 0.\r	assert: minInt32 \\\\ 1 equals: 0.\r	assert: minInt63 \\\\ 1 equals: 0.\r	assert: minInt64 \\\\ 1 equals: 0.\r	assert: maxInt31 \\\\ 1 equals: 0.\r	assert: maxInt32 \\\\ 1 equals: 0.\r	assert: maxInt63 \\\\ 1 equals: 0.\r	assert: maxInt64 \\\\ 1 equals: 0.\r\r	assert: minInt31 \\\\ -1 equals: 0.\r	assert: minInt32 \\\\ -1 equals: 0.\r	assert: minInt63 \\\\ -1 equals: 0.\r	assert: minInt64 \\\\ -1 equals: 0.\r	assert: maxInt31 \\\\ -1 equals: 0.\r	assert: maxInt32 \\\\ -1 equals: 0.\r	assert: maxInt63 \\\\ -1 equals: 0.\r	assert: maxInt64 \\\\ -1 equals: 0.\r\r	assert: minInt31 \\\\ 7 equals: 6.\r	assert: minInt32 \\\\ 7 equals: 5.\r	assert: minInt63 \\\\ 7 equals: 3.\r	assert: minInt64 \\\\ 7 equals: 6.\r	assert: maxInt31 \\\\ 7 equals: 0.\r	assert: maxInt32 \\\\ 7 equals: 1.\r	assert: maxInt63 \\\\ 7 equals: 3.\r	assert: maxInt64 \\\\ 7 equals: 0.\r\r	assert: minInt31 \\\\ -7 equals: -1.\r	assert: minInt32 \\\\ -7 equals: -2.\r	assert: minInt63 \\\\ -7 equals: -4.\r	assert: minInt64 \\\\ -7 equals: -1.\r	assert: maxInt31 \\\\ -7 equals: 0.\r	assert: maxInt32 \\\\ -7 equals: -6.\r	assert: maxInt63 \\\\ -7 equals: -4.\r	assert: maxInt64 \\\\ -7 equals: 0.\r\r	assert: minInt31 \\\\ minInt64 equals: -1073741824.\r	assert: minInt32 \\\\ minInt64 equals: -2147483648.\r	assert: minInt63 \\\\ minInt64 equals: -4611686018427387904.\r	assert: minInt64 \\\\ minInt64 equals: 0.\r	assert: maxInt31 \\\\ minInt64 equals: -9223372035781033985.\r	assert: maxInt32 \\\\ minInt64 equals: -9223372034707292161.\r	assert: maxInt63 \\\\ minInt64 equals: -4611686018427387905.\r	assert: maxInt64 \\\\ minInt64 equals: -1.\r\r	should: [minInt64 \\\\ 0] signal: Error.\r	should: [maxInt64 \\\\ 0] signal: Error.\r\r	assert: 0 \\\\ minInt64 equals: 0.\r	assert: 0 \\\\ maxInt64 equals: 0.\r)",
 "public testMediumIntegerOperatorsInvalidArgument = (\r	should: [maxInt64 + nil] signal: Error.\r	should: [maxInt64 - nil] signal: Error.\r	should: [maxInt64 / nil] signal: Error.\r	should: [maxInt64 * nil] signal: Error.\r	should: [maxInt64 // nil] signal: Error.\r	should: [maxInt64 \\\\ nil] signal: Error.\r	should: [maxInt64 quo: nil] signal: Error.\r	should: [maxInt64 rem: nil] signal: Error.\r	should: [maxInt64 << nil] signal: Error.\r	should: [maxInt64 >> nil] signal: Error.\r	should: [maxInt64 bitAnd: nil] signal: Error.\r	should: [maxInt64 bitOr: nil] signal: Error.\r	should: [0 bitXor: nil] signal: Error.\r)",
 "public testMediumIntegerOr = (\r	assert: (minInt31 bitOr: 0) equals: minInt31.\r	assert: (minInt32 bitOr: 0) equals: minInt32.\r	assert: (minInt63 bitOr: 0) equals: minInt63.\r	assert: (minInt64 bitOr: 0) equals: minInt64.\r	assert: (maxInt31 bitOr: 0) equals: maxInt31.\r	assert: (maxInt32 bitOr: 0) equals: maxInt32.\r	assert: (maxInt63 bitOr: 0) equals: maxInt63.\r	assert: (maxInt64 bitOr: 0) equals: maxInt64.\r\r	assert: (minInt31 bitOr: minInt31) equals: minInt31.\r	assert: (minInt32 bitOr: minInt32) equals: minInt32.\r	assert: (minInt63 bitOr: minInt63) equals: minInt63.\r	assert: (minInt64 bitOr: minInt64) equals: minInt64.\r	assert: (maxInt31 bitOr: maxInt31) equals: maxInt31.\r	assert: (maxInt32 bitOr: maxInt32) equals: maxInt32.\r	assert: (maxInt63 bitOr: maxInt63) equals: maxInt63.\r	assert: (maxInt64 bitOr: maxInt64) equals: maxInt64.\r\r	assert: (minInt31 bitOr: maxInt31) equals: -1.\r	assert: (minInt32 bitOr: maxInt32) equals: -1.\r	assert: (minInt63 bitOr: maxInt63) equals: -1.\r	assert: (minInt64 bitOr: maxInt64) equals: -1.\r\r	assert: (maxInt32 bitOr: maxInt31) equals: maxInt32.\r	assert: (maxInt63 bitOr: maxInt31) equals: maxInt63.\r	assert: (maxInt64 bitOr: maxInt31) equals: maxInt64.\r\r	assert: (maxInt63 bitOr: maxInt32) equals: maxInt63.\r	assert: (maxInt64 bitOr: maxInt32) equals: maxInt64.\r\r	assert: (maxInt64 bitOr: maxInt63) equals: maxInt64.\r)",
 "public testMediumIntegerParse = (\r	assert: (Integer parse: '9223372036854775807') equals: maxInt64.\r	assert: (Integer parse: '-9223372036854775808') equals: minInt64.\r)",
 "public testMediumIntegerQuo = (\r	assert: (minInt31 quo: 1) equals: minInt31.\r	assert: (minInt32 quo: 1) equals: minInt32.\r	assert: (minInt63 quo: 1) equals: minInt63.\r	assert: (minInt64 quo: 1) equals: minInt64.\r	assert: (maxInt31 quo: 1) equals: maxInt31.\r	assert: (maxInt32 quo: 1) equals: maxInt32.\r	assert: (maxInt63 quo: 1) equals: maxInt63.\r	assert: (maxInt64 quo: 1) equals: maxInt64.\r\r	assert: (minInt31 quo: -1) equals: 1073741824.\r	assert: (minInt32 quo: -1) equals: 2147483648.\r	assert: (minInt63 quo: -1) equals: 4611686018427387904.\r	(* big int: assert: (minInt64 quo: -1) equals: 9223372036854775808. *)\r	assert: (maxInt31 quo: -1) equals: -1073741823.\r	assert: (maxInt32 quo: -1) equals: -2147483647.\r	assert: (maxInt63 quo: -1) equals: -4611686018427387903.\r	assert: (maxInt64 quo: -1) equals: -9223372036854775807.\r\r	assert: (minInt31 quo: 7) equals: -153391689.\r	assert: (minInt32 quo: 7) equals: -306783378.\r	assert: (minInt63 quo: 7) equals: -658812288346769700.\r	assert: (minInt64 quo: 7) equals: -1317624576693539401.\r	assert: (maxInt31 quo: 7) equals: 153391689.\r	assert: (maxInt32 quo: 7) equals: 306783378.\r	assert: (maxInt63 quo: 7) equals: 658812288346769700.\r	assert: (maxInt64 quo: 7) equals: 1317624576693539401.\r\r	assert: (minInt31 quo: -7) equals: 153391689.\r	assert: (minInt32 quo: -7) equals: 306783378.\r	assert: (minInt63 quo: -7) equals: 658812288346769700.\r	assert: (minInt64 quo: -7) equals: 1317624576693539401.\r	assert: (maxInt31 quo: -7) equals: -153391689.\r	assert: (maxInt32 quo: -7) equals: -306783378.\r	assert: (maxInt63 quo: -7) equals: -658812288346769700.\r	assert: (maxInt64 quo: -7) equals: -1317624576693539401.\r\r	assert: (minInt31 quo: minInt64) equals: 0.\r	assert: (minInt32 quo: minInt64) equals: 0.\r	assert: (minInt63 quo: minInt64) equals: 0.\r	assert: (minInt64 quo: minInt64) equals: 1.\r	assert: (maxInt31 quo: minInt64) equals: 0.\r	assert: (maxInt32 quo: minInt64) equals: 0.\r	assert: (maxInt63 quo: minInt64) equals: 0.\r	assert: (maxInt64 quo: minInt64) equals: 0.\r\r	should: [minInt64 quo: 0] signal: Error.\r	should: [maxInt64 quo: 0] signal: Error.\r\r	assert: (0 quo: minInt64) equals: 0.\r	assert: (0 quo: maxInt64) equals: 0.\r)",
 "public testMediumIntegerQuoOverflow = (\r	assert: (minInt64 quo: -1) equals: 9223372036854775808.\r)",
 "public testMediumIntegerRem = (\r	assert: (minInt31 rem: 1) equals: 0.\r	assert: (minInt32 rem: 1) equals: 0.\r	assert: (minInt63 rem: 1) equals: 0.\r	assert: (minInt64 rem: 1) equals: 0.\r	assert: (maxInt31 rem: 1) equals: 0.\r	assert: (maxInt32 rem: 1) equals: 0.\r	assert: (maxInt63 rem: 1) equals: 0.\r	assert: (maxInt64 rem: 1) equals: 0.\r\r	assert: (minInt31 rem: -1) equals: 0.\r	assert: (minInt32 rem: -1) equals: 0.\r	assert: (minInt63 rem: -1) equals: 0.\r	assert: (minInt64 rem: -1) equals: 0.\r	assert: (maxInt31 rem: -1) equals: 0.\r	assert: (maxInt32 rem: -1) equals: 0.\r	assert: (maxInt63 rem: -1) equals: 0.\r	assert: (maxInt64 rem: -1) equals: 0.\r\r	assert: (minInt31 rem: 7) equals: -1.\r	assert: (minInt32 rem: 7) equals: -2.\r	assert: (minInt63 rem: 7) equals: -4.\r	assert: (minInt64 rem: 7) equals: -1.\r	assert: (maxInt31 rem: 7) equals: 0.\r	assert: (maxInt32 rem: 7) equals: 1.\r	assert: (maxInt63 rem: 7) equals: 3.\r	assert: (maxInt64 rem: 7) equals: 0.\r\r	assert: (minInt31 rem: -7) equals: -1.\r	assert: (minInt32 rem: -7) equals: -2.\r	assert: (minInt63 rem: -7) equals: -4.\r	assert: (minInt64 rem: -7) equals: -1.\r	assert: (maxInt31 rem: -7) equals: 0.\r	assert: (maxInt32 rem: -7) equals: 1.\r	assert: (maxInt63 rem: -7) equals: 3.\r	assert: (maxInt64 rem: -7) equals: 0.\r\r	assert: (minInt31 rem: minInt64) equals: -1073741824.\r	assert: (minInt32 rem: minInt64) equals: -2147483648.\r	assert: (minInt63 rem: minInt64) equals: -4611686018427387904.\r	assert: (minInt64 rem: minInt64) equals: 0.\r	assert: (maxInt31 rem: minInt64) equals: 1073741823.\r	assert: (maxInt32 rem: minInt64) equals: 2147483647.\r	assert: (maxInt63 rem: minInt64) equals: 4611686018427387903.\r	assert: (maxInt64 rem: minInt64) equals: 9223372036854775807.\r\r	should: [minInt64 rem: 0] signal: Error.\r	should: [maxInt64 rem: 0] signal: Error.\r\r	assert: (0 rem: minInt64) equals: 0.\r	assert: (0 rem: maxInt64) equals: 0.\r)",
 "public testMediumIntegerShiftLeft = (\r	assert: minInt31 << 0 equals: minInt31.\r	assert: minInt32 << 0 equals: minInt32.\r	assert: minInt63 << 0 equals: minInt63.\r	assert: minInt64 << 0 equals: minInt64.\r	assert: maxInt31 << 0 equals: maxInt31.\r	assert: maxInt32 << 0 equals: maxInt32.\r	assert: maxInt63 << 0 equals: maxInt63.\r	assert: maxInt64 << 0 equals: maxInt64.\r\r	assert: minInt31 << 1 equals: -2147483648.\r	assert: minInt32 << 1 equals: -4294967296.\r	assert: minInt63 << 1 equals: -9223372036854775808.\r	(* big int: assert: minInt64 << 1 equals: -18446744073709551616. *)\r	assert: maxInt31 << 1 equals: 2147483646.\r	assert: maxInt32 << 1 equals: 4294967294.\r	assert: maxInt63 << 1 equals: 9223372036854775806.\r	(* big int: assert: maxInt64 << 1 equals: 18446744073709551614. *)\r\r	assert: minInt31 << 2 equals: -4294967296.\r	assert: minInt32 << 2 equals: -8589934592.\r	(* big int assert: minInt63 << 2 equals: -18446744073709551616. *)\r	(* big int assert: minInt64 << 2 equals: -36893488147419103232. *)\r	assert: maxInt31 << 2 equals: 4294967292.\r	assert: maxInt32 << 2 equals: 8589934588.\r	(* big int assert: maxInt63 << 2 equals: 18446744073709551612. *)\r	(* big int assert: maxInt64 << 2 equals: 36893488147419103228. *)\r\r	assert: maxInt31 << 33 equals: 9223372028264841216.\r	assert: maxInt32 << 32 equals: 9223372032559808512.\r\r	should: [minInt31 << -1] signal: Error.\r	should: [minInt32 << -1] signal: Error.\r	should: [minInt63 << -1] signal: Error.\r	should: [minInt64 << -1] signal: Error.\r	should: [maxInt31 << -1] signal: Error.\r	should: [maxInt32 << -1] signal: Error.\r	should: [maxInt63 << -1] signal: Error.\r	should: [maxInt64 << -1] signal: Error.\r)",
 "public testMediumIntegerShiftLeftOverflow = (\r	assert: minInt64 << 1 equals: -18446744073709551616.\r	assert: maxInt64 << 1 equals: 18446744073709551614.\r	assert: minInt63 << 2 equals: -18446744073709551616.\r	assert: minInt64 << 2 equals: -36893488147419103232.\r	assert: maxInt63 << 2 equals: 18446744073709551612.\r	assert: maxInt64 << 2 equals: 36893488147419103228.\r)",
 "public testMediumIntegerShiftRight = (\r	assert: minInt31 >> 0 equals: minInt31.\r	assert: minInt32 >> 0 equals: minInt32.\r	assert: minInt63 >> 0 equals: minInt63.\r	assert: minInt64 >> 0 equals: minInt64.\r	assert: maxInt31 >> 0 equals: maxInt31.\r	assert: maxInt32 >> 0 equals: maxInt32.\r	assert: maxInt63 >> 0 equals: maxInt63.\r	assert: maxInt64 >> 0 equals: maxInt64.\r\r	assert: minInt31 >> 1 equals: -536870912.\r	assert: minInt32 >> 1 equals: -1073741824.\r	assert: minInt63 >> 1 equals: -2305843009213693952.\r	assert: minInt64 >> 1 equals: -4611686018427387904.\r	assert: maxInt31 >> 1 equals: 536870911.\r	assert: maxInt32 >> 1 equals: 1073741823.\r	assert: maxInt63 >> 1 equals: 2305843009213693951.\r	assert: maxInt64 >> 1 equals: 4611686018427387903.\r\r	assert: minInt31 >> 2 equals: -268435456.\r	assert: minInt32 >> 2 equals: -536870912.\r	assert: minInt63 >> 2 equals: -1152921504606846976.\r	assert: minInt64 >> 2 equals: -2305843009213693952.\r	assert: maxInt31 >> 2 equals: 268435455.\r	assert: maxInt32 >> 2 equals: 536870911.\r	assert: maxInt63 >> 2 equals: 1152921504606846975.\r	assert: maxInt64 >> 2 equals: 2305843009213693951.\r\r	assert: minInt31 >> 29 equals: -2.\r	assert: minInt32 >> 30 equals: -2.\r	assert: minInt63 >> 61 equals: -2.\r	assert: minInt64 >> 62 equals: -2.\r	assert: maxInt31 >> 29 equals: 1.\r	assert: maxInt32 >> 30 equals: 1.\r	assert: maxInt63 >> 61 equals: 1.\r	assert: maxInt64 >> 62 equals: 1.\r\r	assert: minInt31 >> 30 equals: -1.\r	assert: minInt32 >> 31 equals: -1.\r	assert: minInt63 >> 62 equals: -1.\r	assert: minInt64 >> 63 equals: -1.\r	assert: maxInt31 >> 30 equals: 0.\r	assert: maxInt32 >> 31 equals: 0.\r	assert: maxInt63 >> 62 equals: 0.\r	assert: maxInt64 >> 63 equals: 0.\r\r	assert: minInt31 >> 31 equals: -1.\r	assert: minInt32 >> 32 equals: -1.\r	assert: minInt63 >> 63 equals: -1.\r	assert: minInt64 >> 64 equals: -1.\r	assert: maxInt31 >> 31 equals: 0.\r	assert: maxInt32 >> 32 equals: 0.\r	assert: maxInt63 >> 63 equals: 0.\r	assert: maxInt64 >> 64 equals: 0.\r\r	assert: minInt31 >> maxInt64 equals: -1.\r	assert: minInt32 >> maxInt64 equals: -1.\r	assert: minInt63 >> maxInt64 equals: -1.\r	assert: minInt64 >> maxInt64 equals: -1.\r	assert: maxInt31 >> maxInt64 equals: 0.\r	assert: maxInt32 >> maxInt64 equals: 0.\r	assert: maxInt63 >> maxInt64 equals: 0.\r	assert: maxInt64 >> maxInt64 equals: 0.\r\r	should: [minInt31 >> -1] signal: Error.\r	should: [minInt32 >> -1] signal: Error.\r	should: [minInt63 >> -1] signal: Error.\r	should: [minInt64 >> -1] signal: Error.\r	should: [maxInt31 >> -1] signal: Error.\r	should: [maxInt32 >> -1] signal: Error.\r	should: [maxInt63 >> -1] signal: Error.\r	should: [maxInt64 >> -1] signal: Error.\r	should: [minInt31 >> minInt31] signal: Error.\r	should: [minInt32 >> minInt31] signal: Error.\r	should: [minInt63 >> minInt31] signal: Error.\r	should: [minInt64 >> minInt31] signal: Error.\r	should: [maxInt31 >> minInt31] signal: Error.\r	should: [maxInt32 >> minInt31] signal: Error.\r	should: [maxInt63 >> minInt31] signal: Error.\r	should: [maxInt64 >> minInt31] signal: Error.\r	should: [minInt31 >> minInt64] signal: Error.\r	should: [minInt32 >> minInt64] signal: Error.\r	should: [minInt63 >> minInt64] signal: Error.\r	should: [minInt64 >> minInt64] signal: Error.\r	should: [maxInt31 >> minInt64] signal: Error.\r	should: [maxInt32 >> minInt64] signal: Error.\r	should: [maxInt63 >> minInt64] signal: Error.\r	should: [maxInt64 >> minInt64] signal: Error.\r)",
 "public testMediumIntegerSubtractOverflow = (\r	assert: minInt64 - 1 equals: -9223372036854775809.\r	assert: maxInt64 - -1 equals: 9223372036854775808.\r	assert: -2 - maxInt64 equals: -9223372036854775809.\r	assert: 0 - minInt64 equals: 9223372036854775808.\r)",
 "public testMediumIntegerXor = (\r	assert: (minInt31 bitXor: 0) equals: minInt31.\r	assert: (minInt32 bitXor: 0) equals: minInt32.\r	assert: (minInt63 bitXor: 0) equals: minInt63.\r	assert: (minInt64 bitXor: 0) equals: minInt64.\r	assert: (maxInt31 bitXor: 0) equals: maxInt31.\r	assert: (maxInt32 bitXor: 0) equals: maxInt32.\r	assert: (maxInt63 bitXor: 0) equals: maxInt63.\r	assert: (maxInt64 bitXor: 0) equals: maxInt64.\r\r	assert: (minInt31 bitXor: minInt31) equals: 0.\r	assert: (minInt32 bitXor: minInt32) equals: 0.\r	assert: (minInt63 bitXor: minInt63) equals: 0.\r	assert: (minInt64 bitXor: minInt64) equals: 0.\r	assert: (maxInt31 bitXor: maxInt31) equals: 0.\r	assert: (maxInt32 bitXor: maxInt32) equals: 0.\r	assert: (maxInt63 bitXor: maxInt63) equals: 0.\r	assert: (maxInt64 bitXor: maxInt64) equals: 0.\r\r	assert: (minInt31 bitXor: maxInt31) equals: -1.\r	assert: (minInt32 bitXor: maxInt32) equals: -1.\r	assert: (minInt63 bitXor: maxInt63) equals: -1.\r	assert: (minInt64 bitXor: maxInt64) equals: -1.\r\r	assert: (maxInt32 bitXor: maxInt31) equals: 1073741824.\r	assert: (maxInt63 bitXor: maxInt31) equals: 4611686017353646080.\r	assert: (maxInt64 bitXor: maxInt31) equals: 9223372035781033984.\r\r	assert: (maxInt63 bitXor: maxInt32) equals: 4611686016279904256.\r	assert: (maxInt64 bitXor: maxInt32) equals: 9223372034707292160.\r\r	assert: (maxInt64 bitXor: maxInt63) equals: 4611686018427387904.\r)",
 "public testSmallIntegerAnd = (\r	assert: (1 bitAnd: 0) equals: 0.\r	assert: (-1 bitAnd: 0) equals: 0.\r\r	assert: (3 bitAnd: 1) equals: 1.\r	assert: (-3 bitAnd: 1) equals: 1.\r\r	assert: (3 bitAnd: 2) equals: 2.\r	assert: (-3 bitAnd: 2) equals: 0.\r\r	assert: (3 bitAnd: -1) equals: 3.\r	assert: (-3 bitAnd: -1) equals: -3.\r)",
 "public testSmallIntegerAsFloat = (\r	assert: 7 asFloat equals: (Float parse: '7.0').\r\r	assert: maxInt31 asFloat equals: (Float parse: '1073741823.0').\r	assert: minInt31 asFloat equals: (Float parse: '-1073741824.0').\r\r	assert: 16rCAFECAFE asFloat equals: (Float parse: '3405695742.0').\r)",
 "public testSmallIntegerAsString = (\r	assert: 3 asString equals: '3'.\r	assert: -4 asString equals: '-4'.\r	assert: 16rF asString equals: '15'.\r	assert: maxInt31 asString equals: '1073741823'.\r	assert: minInt31 asString equals: '-1073741824'.\r)",
 "public testSmallIntegerComparisonErrors = (\r	deny: 42 = '42'.\r	should: [42 < '42'] signal: Error.\r	should: [42 > '42'] signal: Error.\r	should: [42 <= '42'] signal: Error.\r	should: [42 >= '42'] signal: Error.\r\r	deny: 42 = {42}.\r	should: [42 < {42}] signal: Error.\r	should: [42 > {42}] signal: Error.\r	should: [42 <= {42}] signal: Error.\r	should: [42 >= {42}] signal: Error.\r)",
 "public testSmallIntegerComparisons = (\r	assert: 42 = 42.\r	deny: 42 < 42.\r	deny: 42 > 42.\r	assert: 42 <= 42.\r	assert: 42 >= 42.\r\r	deny: 3 = 4.\r	assert: 3 < 4.\r	deny: 3 > 4.\r	assert: 3 <= 4.\r	deny: 3 >= 4.\r\r	deny: 5 = 7.\r	assert: 5 < 7.\r	deny: 5 > 7.\r	assert: 5 <= 7.\r	deny: 5 >= 7.\r\r	deny: -5 = 7.\r	assert: -5 < 7.\r	deny: -5 > 7.\r	assert: -5 <= 7.\r	deny: -5 >= 7.\r\r	deny: 5 = -7.\r	deny: 5 < -7.\r	assert: 5 > -7.\r	deny: 5 <= -7.\r	assert: 5 >= -7.\r\r	deny: -5 = -7.\r	deny: -5 < -7.\r	assert: -5 > -7.\r	deny: -5 <= -7.\r	assert: -5 >= -7.\r)",
 "public testSmallIntegerDiv = (\r	assert: -3 // 7 equals: -1.\r	assert: 3 // -7 equals: -1.\r	assert: -3 // -7 equals: 0.\r	assert: 3 // 7 equals: 0.\r	assert: -7 // 3 equals: -3.\r	assert: 7 // -3 equals: -3.\r	assert: -7 // -3 equals: 2.\r	assert: 7 // 3  equals: 2.\r\r	should: [42 // 0] signal: Error.\r\r	assert: 0 // 42 equals: 0.\r)",
 "public testSmallIntegerDivideExact = (\r	assert: 8 / 4 equals: 2.\r	assert: 8 / 1 equals: 8.\r	should: [8 / 0] signal: Error.\r	assert: 0 / 8 equals: 0.\r\r	assert: 3 / 3 equals: 1.\r	assert: -3 / 3 equals: -1.\r	assert: 3 / -3 equals: -1.\r	assert: -3 / -3 equals: 1.\r)",
 "public testSmallIntegerDivideFraction = (\r	assert: 4 / 6 equals: 2 / 3.\r)",
 "public testSmallIntegerInvert = (\r	assert: 42 bitInvert equals: -43.\r	assert: 1 bitInvert equals: -2.\r	assert: 0 bitInvert equals: -1.\r	assert: -1 bitInvert equals: 0.\r	assert: -42 bitInvert equals: 41.\r)",
 "public testSmallIntegerMod = (\r	assert: -3 \\\\ 7 equals: 4.\r	assert: 3 \\\\ -7 equals: -4.\r	assert: -3 \\\\ -7 equals: -3.\r	assert: 3 \\\\ 7 equals: 3.\r	assert: -7 \\\\ 3 equals: 2.\r	assert: 7 \\\\ -3 equals: -2.\r	assert: -7 \\\\ -3 equals: -1.\r	assert: 7 \\\\ 3 equals: 1.\r\r	should: [42 \\\\ 0] signal: Error.\r\r	assert: 0 \\\\ 42 equals: 0.\r)",
 "public testSmallIntegerMultiplyOverflow = (\r	(* On 64 bit: smi * smi -> large *)\r	assert: minInt63 * 3 equals: -13835058055282163712.\r	assert: maxInt63 * 3 equals: 13835058055282163709.\r\r	assert: minInt63 * -3 equals: 13835058055282163712.\r	assert: maxInt63 * -3 equals: -13835058055282163709.\r\r	assert: minInt63 * minInt63 equals: 21267647932558653966460912964485513216.\r	assert: maxInt63 * maxInt63 equals: 21267647932558653957237540927630737409.\r)",
 "public testSmallIntegerOperatorsInvalidArgument = (\r	should: [0 + nil] signal: Error.\r	should: [0 - nil] signal: Error.\r	should: [0 / nil] signal: Error.\r	should: [0 * nil] signal: Error.\r	should: [0 // nil] signal: Error.\r	should: [0 \\\\ nil] signal: Error.\r	should: [0 quo: nil] signal: Error.\r	should: [0 rem: nil] signal: Error.\r	should: [0 << nil] signal: Error.\r	should: [0 >> nil] signal: Error.\r	should: [0 bitAnd: nil] signal: Error.\r	should: [0 bitOr: nil] signal: Error.\r	should: [0 bitXor: nil] signal: Error.\r)",
 "public testSmallIntegerOr = (\r	assert: (1 bitOr: 0) equals: 1.\r	assert: (-1 bitOr: 0) equals: -1.\r\r	assert: (3 bitOr: 1) equals: 3.\r	assert: (-3 bitOr: 1) equals: -3.\r\r	assert: (3 bitOr: 2) equals: 3.\r	assert: (-3 bitOr: 2) equals: -1.\r\r	assert: (3 bitOr: -1) equals: -1.\r	assert: (-3 bitOr: -1) equals: -1.\r)",
 "public testSmallIntegerQuo = (\r	assert: (-3 quo: 7) equals: 0.\r	assert: (3 quo: -7) equals: 0.\r	assert: (-3 quo: -7) equals: 0.\r	assert: (3 quo: 7) equals: 0.\r	assert: (-7 quo: 3) equals: -2.\r	assert: (7 quo: -3) equals: -2.\r	assert: (-7 quo: -3) equals: 2.\r	assert: (7 quo: 3) equals: 2.\r\r	should: [42 quo: 0] signal: Error.\r\r	assert: (0 quo: 42) equals: 0.\r)",
 "public testSmallIntegerRem = (\r	assert: (-3 rem: 7) equals: -3.\r	assert: (3 rem: -7) equals: 3.\r	assert: (-3 rem: -7) equals: -3.\r	assert: (3 rem: 7) equals: 3.\r	assert: (-7 rem: 3) equals: -1.\r	assert: (7 rem: -3) equals: 1.\r	assert: (-7 rem: -3) equals: -1.\r	assert: (7 rem: 3) equals: 1.\r\r	should: [42 rem: 0] signal: Error.\r\r	assert: (0 rem: 42) equals: 0.\r)",
 "public testSmallIntegerShiftLeft = (\r	assert: 1 << 2 equals: 4.\r	assert: -1 << 2 equals: -4.\r\r	assert: 0 << 2 equals: 0.\r\r	assert: 1 << 0 equals: 1.\r	assert: -1 << 0 equals: -1.\r\r	should: [4 << -1] signal: Error.\r	should: [-4 << -1] signal: Error.\r)",
 "public testSmallIntegerShiftRight = (\r	assert: 4 >> 2 equals: 1.\r	assert: 4 >> 3 equals: 0. (* A bad implementation will put value bits into the tag bit. *)\r	assert: 4 >> 31 equals: 0.\r	assert: 4 >> 32 equals: 0.\r	assert: 4 >> 33 equals: 0.\r	assert: 4 >> 63 equals: 0.\r	assert: 4 >> 64 equals: 0.\r	assert: 4 >> 65 equals: 0.\r	assert: 4 >> maxInt31 equals: 0.\r\r	assert: -4 >> 2 equals: -1.\r	assert: -4 >> 3 equals: -1.\r	assert: -4 >> 31 equals: -1.\r	assert: -4 >> 32 equals: -1.\r	assert: -4 >> 33 equals: -1.\r	assert: -4 >> 63 equals: -1.\r	assert: -4 >> 64 equals: -1.\r	assert: -4 >> 65 equals: -1.\r	assert: -4 >> maxInt31 equals: -1.\r\r	assert: 0 >> 2 equals: 0.\r\r	assert: 4 >> 0 equals: 4.\r	assert: -4 >> 0 equals: -4.\r\r	should: [4 >> -1] signal: Error.\r	should: [-4 >> -1] signal: Error.\r	should: [4 >> minInt31] signal: Error.\r	should: [-4 >> minInt31] signal: Error.\r)",
 "public testSmallIntegerXor = (\r	assert: (42 bitXor: 42) equals: 0.\r\r	assert: (1 bitXor: 0) equals: 1.\r	assert: (-1 bitXor: 0) equals: -1.\r\r	assert: (3 bitXor: 1) equals: 2.\r	assert: (-3 bitXor: 1) equals: -4.\r\r	assert: (3 bitXor: 2) equals: 1.\r	assert: (-3 bitXor: 2) equals: -1.\r\r	assert: (3 bitXor: -1) equals: -4.\r	assert: (-3 bitXor: -1) equals: 2.\r)",
 "TEST_CONTEXT = ()",
 "public class ObjectTests = TestContext ()",
 "TestContext",
 "TestContext",
 "public testClassProtected = (\r	| o = Object new. |\r	should: [o class] signal: MessageNotUnderstood.\r	shouldnt: [self class] signal: MessageNotUnderstood.\r)",
 "public testDoesNotUnderstand = (\r	| o = Object new. p = DnuAnswerMessage new. |\r	should: [o foobar] signal: MessageNotUnderstood.\r\r	assert: p foobar selector equals: #foobar.\r	assert: p foobar arguments isKindOfArray.\r	assert: p foobar arguments size equals: 0.\r\r	assert: (p + 42) selector equals: #+.\r	assert: (p + 42) arguments isKindOfArray.\r	assert: (p + 42) arguments size equals: 1.\r	assert: ((p + 42) arguments at: 1) equals: 42.\r\r	assert: (p with: 3 with: 4) selector equals: #with:with:.\r	assert: (p with: 3 with: 4) arguments isKindOfArray.\r	assert: (p with: 3 with: 4) arguments size equals: 2.\r	assert: ((p with: 3 with: 4) arguments at: 1) equals: 3.\r	assert: ((p with: 3 with: 4) arguments at: 2) equals: 4.\r)",
 "public testEquals = (\r	| a b |\r	a:: Object new.\r	b:: Object new.\r\r	assert: a = a.\r	assert: b = b.\r	deny: a = b.\r	deny: b = a.\r)",
 "public testGlobalsProtected = (\r	| o = Object new. |\r	should: [o Array] signal: MessageNotUnderstood.\r	should: [o ByteArray] signal: MessageNotUnderstood.\r	should: [o Error] signal: MessageNotUnderstood.\r	should: [o Exception] signal: MessageNotUnderstood.\r	should: [o Float] signal: MessageNotUnderstood.\r	should: [o Integer] signal: MessageNotUnderstood.\r	should: [o Object] signal: MessageNotUnderstood.\r	should: [o String] signal: MessageNotUnderstood.\r	should: [o Symbol] signal: MessageNotUnderstood.\r	should: [o Future] signal: MessageNotUnderstood.\r	should: [o Delay] signal: MessageNotUnderstood.\r	should: [o WeakArray] signal: MessageNotUnderstood.\r)",
 "public testHash = (\r	| o = Object new. |\r	assert: o hash isKindOfInteger.\r	assert: o hash > 0.\r)",
 "public testNonBooleanIfFalse = (\r	(* According to the language, this ought to signal MessageNotUnderstood. However, our implementations do the standard cheat that compiles various control messages without creating their closure arguments, and raises NonBooleanReceiver if the receiver ends being something other than true or false. This test checks this is at least not fatal. *)\r	| o = Object new. |\r	should: [o ifFalse: []] signal: Exception.\r)",
 "public testNonBooleanIfTrue = (\r	(* According to the language, this ought to signal MessageNotUnderstood. However, our implementations do the standard cheat that compiles various control messages without creating their closure arguments, and raises NonBooleanReceiver if the receiver ends being something other than true or false. This test checks this is at least not fatal. *)\r	| o = Object new. |\r	should: [o ifTrue: []] signal: Exception.\r)",
 "public testNonBooleanWhileFalse = (\r	(* According to the language, this ought to signal MessageNotUnderstood. However, our implementations do the standard cheat that compiles various control messages without creating their closure arguments, and raises NonBooleanReceiver if the receiver ends being something other than true or false. This test checks this is at least not fatal. *)\r	| o = Object new. |\r	should: [[o] whileFalse: []] signal: Exception.\r)",
 "public testNonBooleanWhileTrue = (\r	(* According to the language, this ought to signal MessageNotUnderstood. However, our implementations do the standard cheat that compiles various control messages without creating their closure arguments, and raises NonBooleanReceiver if the receiver ends being something other than true or false. This test checks this is at least not fatal. *)\r	| o = Object new. |\r	should: [[o] whileTrue: []] signal: Exception.\r)",
 "public testNotPolymorphicWithClosure = (\r	| o = Object new. |\r	should: [o value] signal: MessageNotUnderstood.\r)",
 "public testPrintString = (\r	| o = Object new. |\r	assert: o printString isKindOfString.\r	assert: o printString size > 0.\r)",
 "public testYourself = (\r	| o = Object new. |\r	assert: o yourself equals: o.\r)",
 "TEST_CONTEXT = ()",
 "public class StopwatchTests = TestContext ()",
 "TestContext",
 "TestContext",
 "busyMilliseconds: millis = (\r	| stopwatch = Stopwatch new. |\r	stopwatch start.\r	[stopwatch elapsedMilliseconds < millis] whileTrue.\r)",
 "public testStopwatchAccumulate = (\r	| stopwatch = Stopwatch new. |\r	stopwatch start.\r	busyMilliseconds: 5.\r	stopwatch stop.\r	assert: [stopwatch elapsedMilliseconds >= 5].\r	assert: [stopwatch elapsedMicroseconds >= 5000].\r\r	busyMilliseconds: 5.\r\r	stopwatch start.\r	busyMilliseconds: 5.\r	stopwatch stop.\r	assert: [stopwatch elapsedMilliseconds >= 10].\r	assert: [stopwatch elapsedMicroseconds >= 10000].\r\r	busyMilliseconds: 5.\r\r	stopwatch start.\r	busyMilliseconds: 5.\r	stopwatch stop.\r	assert: [stopwatch elapsedMilliseconds >= 15].\r	assert: [stopwatch elapsedMicroseconds >= 15000].\r)",
 "public testStopwatchDoubleStart = (\r	| stopwatch = Stopwatch new. |\r	stopwatch start.\r\r	busyMilliseconds: 5.\r\r	stopwatch start. (* Should not reset the elapsed time. *)\r\r	busyMilliseconds: 5.\r\r	assert: [stopwatch elapsedMilliseconds >= 10].\r	assert: [stopwatch elapsedMicroseconds >= 10000].\r	stopwatch stop.\r	assert: [stopwatch elapsedMilliseconds >= 10].\r	assert: [stopwatch elapsedMicroseconds >= 10000].\r)",
 "public testStopwatchEqualityIsIdentity = (\r	|\r	stopwatch1 = Stopwatch new.\r	stopwatch2 = Stopwatch new.\r	|\r	assert: stopwatch1 elapsedMilliseconds equals: stopwatch2 elapsedMilliseconds.\r	assert: stopwatch1 elapsedMicroseconds equals: stopwatch2 elapsedMicroseconds.\r	deny: stopwatch1 equals: stopwatch2.\r)",
 "public testStopwatchInitialState = (\r	| stopwatch = Stopwatch new. |\r	assert: stopwatch elapsedMilliseconds equals: 0.\r	assert: stopwatch elapsedMicroseconds equals: 0.\r)",
 "public testStopwatchInitiallyStopped = (\r	| stopwatch = Stopwatch new. |\r	busyMilliseconds: 5.\r\r	assert: stopwatch elapsedMilliseconds equals: 0.\r	assert: stopwatch elapsedMicroseconds equals: 0.\r)",
 "public testStopwatchMovesAfterStarted = (\r	| stopwatch |\r	stopwatch:: Stopwatch new.\r	stopwatch start.\r	[stopwatch elapsedMilliseconds < 5] whileTrue.\r\r	stopwatch:: Stopwatch new.\r	stopwatch start.\r	[stopwatch elapsedMicroseconds < 5] whileTrue.\r)",
 "public testStopwatchStartStopValues = (\r	| stopwatch = Stopwatch new. |\r	assert: stopwatch start equals: stopwatch.\r	assert: stopwatch stop equals: stopwatch.\r)",
 "TEST_CONTEXT = ()",
 "public class StringTests = TestContext ()",
 "TestContext",
 "TestContext",
 "public testIsKindOfString = (\r	assert: 'foo' isKindOfString.\r	assert: #foo isKindOfString.\r	assert: ('foo', 'bar') isKindOfString.\r	assert: 'r' isKindOfString.\r	deny: 1 isKindOfString.\r	deny: 1.5 isKindOfString.\r	deny: 1.5 asFloat isKindOfString.\r	deny: true isKindOfString.\r	deny: nil isKindOfString.\r	deny: {} isKindOfString.\r	deny: [] isKindOfString.\r)",
 "public testStringAdd = (\r	should: ['foo' + 'bar'] signal: MessageNotUnderstood.\r)",
 "public testStringAsString = (\r	assert: 'foo' asString equals: 'foo'.\r	assert: #foo asString equals: 'foo'.\r)",
 "public testStringAt = (\r	assert: ('foo' at: 1) equals: 102.\r	assert: ('foo' at: 2) equals: 111.\r	assert: ('foo' at: 3) equals: 111.\r\r	should: ['foo' at: 0] signal: Error.\r	should: ['foo' at: 4] signal: Error.\r\r	should: ['' at: 0] signal: Error.\r\r	should: ['foo' at: -1] signal: Error.\r	should: ['foo' at: nil] signal: Error.\r	should: ['foo' at: 1 asFloat] signal: Error.\r)",
 "public testStringConcatenation = (\r	assert: 'foo' , 'bar' equals: 'foobar'.\r	assert: 'foo' , 'bar', '' equals: 'foobar'.\r	assert: ('foo' , 'bar') size equals: 6.\r\r	should: ['foo', 3] signal: Error.\r	should: ['foo', true] signal: Error.\r	should: ['foo', nil] signal: Error.\r	should: [3, 'foo'] signal: MessageNotUnderstood.\r	should: [true, 'foo'] signal: MessageNotUnderstood.\r	should: [nil, 'foo'] signal: MessageNotUnderstood.\r)",
 "public testStringCopyFromTo = (\r	assert: ('Hello, world!' copyFrom: 8 to: 12) equals: 'world'.\r	assert: ('Hello, world!' copyFrom: 5 to: 5) equals: 'o'.\r\r	1 to: 5 do:\r		[:start | assert: ('Hello' copyFrom: start to: start - 1) equals: ''].\r\r	assert: ('' copyFrom: 1 to: 0) equals: ''.\r\r	should: ['' copyFrom: 0 to: 0] signal: Error.\r	should: ['' copyFrom: 2 to: 0] signal: Error.\r	should: ['' copyFrom: 1 to: 1] signal: Error.\r\r	should: ['Hello, world!' copyFrom: 13 to: 14] signal: Error.\r	should: ['Hello, world!' copyFrom: 0 to: 1] signal: Error.\r	should: ['Hello, world!' copyFrom: 8 to: nil] signal: Error.\r	should: ['Hello, world!' copyFrom: nil to: 9] signal: Error.\r	should: ['Hello, world!' copyFrom: 2 to: 90] signal: Error.\r	should: ['Hello, world!' copyFrom: 80 to: 90] signal: Error.\r	should: ['Hello, world!' copyFrom: 2 to: 5 asFloat] signal: Error.\r	should: ['Hello, world!' copyFrom: 2 asFloat to: 5] signal: Error.\r)",
 "public testStringEndsWith = (\r	| foo empty |\r	foo:: ByteArray new: 3.\r	foo at: 1 put: 102.\r	foo at: 2 put: 111.\r	foo at: 3 put: 111.\r	empty:: ByteArray new: 0.\r\r	assert: ('foo' endsWith: 'o').\r	assert: ('foo' endsWith: 'foo').\r	assert: ('foo' endsWith: foo).\r	assert: ('foo' endsWith: '').\r	assert: ('foo' endsWith: empty).\r	assert: ('' endsWith: '').\r	assert: ('' endsWith: empty).\r	deny: ('foo' endsWith: 'toolongfoo').\r	deny: ('foo' endsWith: 'boo').\r	deny: ('foo' endsWith: 'bar').\r	deny: ('' endsWith: 'foo').\r	deny: ('' endsWith: foo).\r\r	should: ['0' endsWith: 0] signal: Error.\r	should: ['foo' endsWith: true] signal: Error.\r	should: ['foo' endsWith: nil] signal: Error.\r)",
 "public testStringEquals = (\r	assert: 'foo' equals: 'foo'.\r	assert: #foo equals: 'foo'.\r	assert: 'foo' equals: #foo.\r\r	deny: 'foo' = 'bar'.\r	deny: '3' = 3.\r	deny: 3 = '3'.\r)",
 "public testStringFirstLast = (\r	assert: ('bar' first) equals: 98.\r	assert: ('bar' last) equals: 114.\r\r	should: ['' first] signal: Error.\r	should: ['' last] signal: Error.\r)",
 "public testStringFloatIndex = (\r	should: ['foo' at: 1 asFloat] signal: Error.\r)",
 "public testStringHash = (\r	assert: 'foo' hash isKindOfInteger.\r	assert: 'foo' hash > 0.\r\r	assert: 'foobar' hash equals: ('foo', 'bar') hash.\r\r	assert: '' hash isKindOfInteger.\r	assert: '' hash > 0.\r)",
 "public testStringImmutable = (\r	| nonSymbol |\r	nonSymbol:: 'foo' , 'bar'.\r\r	should: [nonSymbol at: 1 put: \"w\"] signal: MessageNotUnderstood.\r	assert: nonSymbol equals: 'foobar'.\r\r	should: [nonSymbol at: 1 put: 65] signal: MessageNotUnderstood.\r	assert: nonSymbol equals: 'foobar'.\r)",
 "public testStringIndexOf = (\r	assert: ('fofofobar' indexOf: 'fofo') equals: 1.\r	assert: ('fofofobar' indexOf: 'bar') equals: 7.\r	assert: ('fofofobar' indexOf: 'barr') equals: 0.\r	assert: ('fofofobar' indexOf: 'fob') equals: 5.\r	assert: ('fofofobar' indexOf: 'baz') equals: 0.\r	assert: ('fofofobar' indexOf: 'f') equals: 1.\r	assert: ('fofofobar' indexOf: 'r') equals: 9.\r	assert: ('fofofobar' indexOf: '') equals: 1.\r\r	assert: ('tiny' indexOf: 'toolong') equals: 0.\r\r	assert: ('' indexOf: '') equals: 1.\r	assert: ('' indexOf: 'baz') equals: 0.\r\r	should: ['fofofobar' indexOf: 0] signal: Error.\r	should: ['' indexOf: Object new] signal: Error.\r)",
 "public testStringIndexOfStartingAt = (\r	assert: ('fofofobar' indexOf: 'fofo' startingAt: 1) equals: 1.\r	assert: ('fofofobar' indexOf: 'fofo' startingAt: 2) equals: 3.\r	assert: ('fofofobar' indexOf: 'fofo' startingAt: 3) equals: 3.\r	assert: ('fofofobar' indexOf: 'fofo' startingAt: 4) equals: 0.\r	assert: ('fofofobar' indexOf: 'bar' startingAt: 1) equals: 7.\r	assert: ('fofofobar' indexOf: 'bar' startingAt: 7) equals: 7.\r	assert: ('fofofobar' indexOf: 'bar' startingAt: 8) equals: 0.\r	assert: ('fofofobar' indexOf: 'barr' startingAt: 6) equals: 0.\r	assert: ('fofofobar' indexOf: 'fob' startingAt: 5) equals: 5.\r	assert: ('fofofobar' indexOf: 'fob' startingAt: 6) equals: 0.\r	assert: ('fofofobar' indexOf: 'baz' startingAt: 1) equals: 0.\r	assert: ('fofofobar' indexOf: 'f' startingAt: 1) equals: 1.\r	assert: ('fofofobar' indexOf: 'f' startingAt: 2) equals: 3.\r	assert: ('fofofobar' indexOf: 'r' startingAt: 1) equals: 9.\r	assert: ('fofofobar' indexOf: 'r' startingAt: 9) equals: 9.\r	assert: ('fofofobar' indexOf: '' startingAt: 1) equals: 1.\r	assert: ('fofofobar' indexOf: '' startingAt: 5) equals: 5.\r	assert: ('fofofobar' indexOf: '' startingAt: 9) equals: 9.\r\r	assert: ('tiny' indexOf: 'toolong' startingAt: 1) equals: 0.\r	assert: ('tiny' indexOf: 'toolong' startingAt: 3) equals: 0.\r\r	assert: ('' indexOf: '' startingAt: 1) equals: 1.\r	assert: ('' indexOf: 'baz' startingAt: 1) equals: 0.\r\r	should: ['fofofobar' indexOf: 0 startingAt: 1] signal: Error.\r	should: ['fofobobar' indexOf: Object new startingAt: 1] signal: Error.\r\r	should: ['fofofobar' indexOf: 'foo' startingAt: 0] signal: Error.\r	should: ['fofofobar' indexOf: 'foo' startingAt: 11] signal: Error.\r	should: ['' indexOf: '' startingAt: 0] signal: Error.\r	should: ['' indexOf: '' startingAt: 2] signal: Error.\r)",
 "public testStringIsEmpty = (\r	assert: '' isEmpty.\r	deny: 'zebra' isEmpty.\r)",
 "public testStringLastIndexOf = (\r	assert: ('fofofobar' lastIndexOf: 'fofo') equals: 3.\r	assert: ('fofofobar' lastIndexOf: 'bar') equals: 7.\r	assert: ('fofofobar' lastIndexOf: 'barr') equals: 0.\r	assert: ('fofofobar' lastIndexOf: 'fob') equals: 5.\r	assert: ('fofofobar' lastIndexOf: 'baz') equals: 0.\r	assert: ('fofofobar' lastIndexOf: 'f') equals: 5.\r	assert: ('fofofobar' lastIndexOf: 'r') equals: 9.\r	assert: ('fofofobar' lastIndexOf: '') equals: 10.\r\r	assert: ('tiny' lastIndexOf: 'toolong') equals: 0.\r\r	assert: ('' lastIndexOf: '') equals: 1.\r	assert: ('' lastIndexOf: 'baz') equals: 0.\r\r	should: ['fofofobar' lastIndexOf: 0] signal: Error.\r	should: ['' lastIndexOf: Object new] signal: Error.\r)",
 "public testStringLastIndexOfStartingAt = (\r	assert: ('fofofobar' lastIndexOf: 'fofo' startingAt: 10) equals: 3.\r	assert: ('fofofobar' lastIndexOf: 'fofo' startingAt: 4) equals: 3.\r	assert: ('fofofobar' lastIndexOf: 'fofo' startingAt: 3) equals: 3.\r	assert: ('fofofobar' lastIndexOf: 'fofo' startingAt: 1) equals: 1.\r	assert: ('fofofobar' lastIndexOf: 'bar' startingAt: 10) equals: 7.\r	assert: ('fofofobar' lastIndexOf: 'bar' startingAt: 7) equals: 7.\r	assert: ('fofofobar' lastIndexOf: 'bar' startingAt: 6) equals: 0.\r	assert: ('fofofobar' lastIndexOf: 'barr' startingAt: 10) equals: 0.\r	assert: ('fofofobar' lastIndexOf: 'fob' startingAt: 10) equals: 5.\r	assert: ('fofofobar' lastIndexOf: 'fob' startingAt: 4) equals: 0.\r	assert: ('fofofobar' lastIndexOf: 'baz' startingAt: 10) equals: 0.\r	assert: ('fofofobar' lastIndexOf: 'f' startingAt: 10) equals: 5.\r	assert: ('fofofobar' lastIndexOf: 'f' startingAt: 4) equals: 3.\r	assert: ('fofofobar' lastIndexOf: 'f' startingAt: 2) equals: 1.\r	assert: ('fofofobar' lastIndexOf: 'r' startingAt: 10) equals: 9.\r	assert: ('fofofobar' lastIndexOf: 'r' startingAt: 9) equals: 9.\r	assert: ('fofofobar' lastIndexOf: 'r' startingAt: 8) equals: 0.\r	assert: ('fofofobar' lastIndexOf: '' startingAt: 10) equals: 10.\r	assert: ('fofofobar' lastIndexOf: '' startingAt: 5) equals: 5.\r	assert: ('fofofobar' lastIndexOf: '' startingAt: 1) equals: 1.\r\r	assert: ('tiny' lastIndexOf: 'toolong' startingAt: 4) equals: 0.\r	assert: ('tiny' lastIndexOf: 'toolong' startingAt: 2) equals: 0.\r\r	assert: ('' lastIndexOf: '' startingAt: 1) equals: 1.\r	assert: ('' lastIndexOf: 'baz' startingAt: 1) equals: 0.\r\r	should: ['fofofobar' lastIndexOf: 0 startingAt: 1] signal: Error.\r	should: ['' lastIndexOf: Object new startingAt: 1] signal: Error.\r\r	should: ['fofofobar' lastIndexOf: 'foo' startingAt: 0] signal: Error.\r	should: ['fofofobar' lastIndexOf: 'foo' startingAt: 11] signal: Error.\r	should: ['' lastIndexOf: '' startingAt: 0] signal: Error.\r	should: ['' lastIndexOf: '' startingAt: 2] signal: Error.\r)",
 "public testStringSize = (\r	assert: 'foo' size equals: 3.\r	assert: #foo size equals: 3.\r	assert: '' size equals: 0.\r)",
 "public testStringStartsWith = (\r	| foo empty |\r	foo:: ByteArray new: 3.\r	foo at: 1 put: 102.\r	foo at: 2 put: 111.\r	foo at: 3 put: 111.\r	empty:: ByteArray new: 0.\r\r	assert: ('foo' startsWith: 'f').\r	assert: ('foo' startsWith: 'foo').\r	assert: ('foo' startsWith: foo).\r	assert: ('foo' startsWith: '').\r	assert: ('foo' startsWith: empty).\r	assert: ('' startsWith: '').\r	assert: ('' startsWith: empty).\r	deny: ('foo' startsWith: 'toolong').\r	deny: ('foo' startsWith: 'fob').\r	deny: ('foo' startsWith: 'bar').\r	deny: ('' startsWith: 'foo').\r	deny: ('' startsWith: foo).\r\r	should: ['0' startsWith: 0] signal: Error.\r	should: ['foo' startsWith: true] signal: Error.\r	should: ['foo' startsWith: nil] signal: Error.\r)",
 "public testStringWith = (\r	assert: (String with: 122) equals: 'z'.\r	assert: ((String with: 0) at: 1) equals: 0.\r\r	should: [String with: -1] signal: Error.\r	should: [String with: 16r110000] signal: Error.\r	should: [String with: nil] signal: Error.\r	should: [String with: 122 asFloat] signal: Error.\r	should: [String with: 'z'] signal: Error.\r)",
 "public testStringWithAll = (\r	| bytearray list result |\r	result:: String withAll: {122}.\r	assert: result size equals: 1.\r	assert: result equals: 'z'.\r\r	result:: String withAll: {122. 101. 98. 114. 97}.\r	assert: result size equals: 5.\r	assert: result equals: 'zebra'.\r	assert: (result at: 1) equals: 122.\r	assert: (result at: 2) equals: 101.\r	assert: (result at: 3) equals: 98.\r	assert: (result at: 4) equals: 114.\r	assert: (result at: 5) equals: 97.\r\r	bytearray:: ByteArray new: 0.\r	result:: String withAll: bytearray.\r	assert: result size equals: 0.\r	assert: result equals: ''.\r\r	bytearray:: ByteArray new: 1.\r	bytearray at: 1 put: 122.\r	result:: String withAll: bytearray.\r	assert: result size equals: 1.\r	assert: result equals: 'z'.\r\r	bytearray:: ByteArray new: 5.\r	bytearray at: 1 put: 122.\r	bytearray at: 2 put: 101.\r	bytearray at: 3 put: 98.\r	bytearray at: 4 put: 114.\r	bytearray at: 5 put: 97.\r	result:: String withAll: bytearray.\r	assert: result size equals: 5.\r	assert: result equals: 'zebra'.\r	assert: (result at: 1) equals: 122.\r	assert: (result at: 2) equals: 101.\r	assert: (result at: 3) equals: 98.\r	assert: (result at: 4) equals: 114.\r	assert: (result at: 5) equals: 97.\r\r	result:: String withAll: ''.\r	assert: result size equals: 0.\r	assert: result equals: ''.\r\r	result:: String withAll: 'soup'.\r	assert: result size equals: 4.\r	assert: result equals: 'soup'.\r	assert: (result at: 1) equals: 115.\r	assert: (result at: 2) equals: 111.\r	assert: (result at: 3) equals: 117.\r	assert: (result at: 4) equals: 112.\r\r	list:: List new.\r	list add: 102.\r	list add: 111.\r	list add: 120.\r	result:: String withAll: list.\r	assert: result size equals: 3.\r	assert: result equals: 'fox'.\r	assert: (result at: 1) equals: 102.\r	assert: (result at: 2) equals: 111.\r	assert: (result at: 3) equals: 120.\r\r	should: [String withAll: -1] signal: Error.\r	should: [String withAll: 16r110000] signal: Error.\r	should: [String withAll: nil] signal: Error.\r	should: [String withAll: 122 asFloat] signal: Error.\r\r	should: [String withAll: {-1}] signal: Error.\r	should: [String withAll: {16r256}] signal: Error.\r	should: [String withAll: {nil}] signal: Error.\r	should: [String withAll: {122 asFloat}] signal: Error.\r	should: [String withAll: {'z'}] signal: Error.\r\r	list:: List new.\r	list add: 256.\r	should: [String withAll: list] signal: Error.\r)",
 "public testWideStringAsString = (\r	assert: 'r' asString equals: 'r'.\r	assert: #'r' asString equals: 'r'.\r)",
 "public testWideStringAt = (\r	assert: ('r' at: 1) equals: 195.\r	assert: ('r' at: 2) equals: 142.\r	assert: ('r' at: 3) equals: 195.\r	assert: ('r' at: 15) equals: 163.\r	assert: ('r' at: 20) equals: 195.\r	assert: ('r' at: 36) equals: 225.\r	assert: ('r' at: 37) equals: 187.\r	assert: ('r' at: 38) equals: 157.\r	assert: ('r' at: 40) equals: 177.\r\r	should: ['r' at: 0] signal: Error.\r	should: ['r' at: 41] signal: Error.\r\r	should: ['r' at: -1] signal: Error.\r	should: ['r' at: nil] signal: Error.\r	should: ['r' at: 1 asFloat] signal: Error.\r)",
 "public testWideStringConcatenation = (\r	assert: 'r' , '' equals: 'r'.\r	assert: 'r' , '', '' equals: 'r'.\r	assert: ('r' , '') size equals: 40.\r\r	assert: 'r' , 'ASCII' equals: 'rASCII'.\r	assert: 'r' , 'ASCII', '' equals: 'rASCII'.\r	assert: ('r' , 'ASCII') size equals: 30.\r\r	assert: 'ASCII' , 'r' equals: 'ASCIIr'.\r	assert: 'ASCII' , 'r', '' equals: 'ASCIIr'.\r	assert: ('ASCII' , 'r') size equals: 30.\r\r	should: ['r', 3] signal: Error.\r	should: ['r', true] signal: Error.\r	should: ['r', nil] signal: Error.\r	should: [3, 'r'] signal: MessageNotUnderstood.\r	should: [true, 'r'] signal: MessageNotUnderstood.\r	should: [nil, 'r'] signal: MessageNotUnderstood.\r)",
 "public testWideStringCopyFromTo = (\r	assert: ('r' copyFrom: 10 to: 25) equals: ''.\r	assert: ('r' copyFrom: 5 to: 6) equals: ''.\r	assert: ('r ASCII' copyFrom: 42 to: 46) equals: 'ASCII'.\r\r	should: ['r' copyFrom: 8 to: nil] signal: Error.\r	should: ['r' copyFrom: nil to: 9] signal: Error.\r	should: ['r' copyFrom: 80 to: 90] signal: Error.\r)",
 "public testWideStringEndsWith = (\r	assert: ('r' endsWith: '').\r	assert: ('r' endsWith: 'r').\r	assert: ('r' endsWith: '').\r	deny: ('r' endsWith: 'rr').\r	deny: ('r' endsWith: 'r').\r	deny: ('r' endsWith: 'r').\r	deny: ('' endsWith: 'r').\r\r	assert: ('rASCII' endsWith: 'I').\r	assert: ('rASCII' endsWith: 'rASCII').\r	assert: ('rASCII' endsWith: '').\r	deny: ('rASCII' endsWith: 'rrASCII').\r	deny: ('rASCII' endsWith: 'rASCII').\r	deny: ('rASCII' endsWith: 'foobar').\r	deny: ('rASCII' endsWith: 'rASCII').\r\r	deny: ('ASCII' endsWith: 'rASCII').\r	deny: ('ASCII' endsWith: 'r').\r\r	should: ['r' endsWith: 0] signal: Error.\r	should: ['r' endsWith: true] signal: Error.\r	should: ['r' endsWith: nil] signal: Error.\r)",
 "public testWideStringSize = (\r	(* :todo: It's not clear that being able to quickly iterate code points is actually that useful. *)\r	assert: 'r' size equals: 40.\r	assert: #'r' size equals: 40.\r)",
 "public testWideStringStartsWith = (\r	assert: ('r' startsWith: '').\r	assert: ('r' startsWith: 'r').\r	assert: ('r' startsWith: '').\r	deny: ('r' startsWith: 'rr').\r	deny: ('r' startsWith: 'r').\r	deny: ('r' startsWith: 'r').\r\r	assert: ('ASCIIr' startsWith: 'A').\r	assert: ('ASCIIr' startsWith: 'ASCIIr').\r	assert: ('ASCIIr' startsWith: '').\r	deny: ('ASCIIr' startsWith: 'ASCIIrr').\r	deny: ('ASCIIr' startsWith: 'ASCIIr').\r	deny: ('ASCIIr' startsWith: 'foobar').\r	deny: ('ASCIIr' startsWith: 'ASCIIr').\r\r	deny: ('ASCII' startsWith: 'ASCIIr').\r	deny: ('ASCII' startsWith: 'r').\r\r	should: ['r' startsWith: 0] signal: Error.\r	should: ['r' startsWith: true] signal: Error.\r	should: ['r' startsWith: nil] signal: Error.\r)",
 "TEST_CONTEXT = ()",
 "class TestException = Exception ()",
 "Exception",
 "Exception",
 "class KernelTestsConfiguration packageTestsUsing: manifest = (|\rprivate KernelTests = manifest KernelTests.\r|)",
 " ",
 " ",
 "public testModulesUsingPlatform: platform minitest: minitest = (\r	^{KernelTests\r		usingPlatform: platform\r		minitest: minitest}\r)",
 "class MinitestTests usingPlatform: platform testFramework: minitest = (\r(* Tests of the Minitest framework (that is, meta-tests). *)\r|\r	private Exception = platform kernel Exception.\r	private testFramework = minitest.\r	private TestContext = minitest TestContext.\r	private TestCatalog = minitest TestCatalog.\r	private Tester = minitest Tester.\r|)",
 " ",
 " ",
 "public class AssertionTests = TestContext (\r|\r	guineaPig = GuineaPigTestModule testFramework: testFramework.\r	catalog = TestCatalog forModule: guineaPig.\r	tester\r|)",
 "TestContext",
 "TestContext",
 "assert: testResults containsSelector: selector = (\r	deny: (resultForSelector: selector in: testResults) equals: nil.\r)",
 "resultForSelector: selector in: collection = (\r	^collection\r		detect: [:some | some testCase selector = selector]\r		ifNone: [nil]\r)",
 "public testAssertEquals = (\r	tester:: Tester testSuite: (catalog testSuiteNamed: 'AssertEqualsTestContext').\r	tester runAll.\r	assert: tester errors size equals: 0.\r	assert: tester failures size equals: 2.\r	assert: tester failures containsSelector: #testAssertEqualsFail.\r	assert: tester failures containsSelector: #testAssertEqualsFailWithDescription.\r	assert: (resultForSelector: #testAssertEqualsFailWithDescription in: tester failures) description\r		equals: 'custom description'.\r	assert: tester successes size equals: 1.\r	assert: tester successes containsSelector: #testAssertEqualsPass.\r)",
 "public testAsserts = (\r	tester:: Tester testSuite: (catalog testSuiteNamed: 'AssertTestContext').\r	tester runAll.\r	assert: tester errors size equals: 2.\r	assert: tester errors containsSelector: #testAssertErrorBlock.\r	assert: tester errors containsSelector: #testAssertErrorExpression.\r	assert: tester failures size equals: 3.\r	assert: tester failures containsSelector: #testAssertFailBlock.\r	assert: tester failures containsSelector: #testAssertFailExpression.\r	assert: tester failures containsSelector: #testAssertFailWithDescription.\r	assert: (resultForSelector: #testAssertFailWithDescription in: tester failures) description\r		equals: 'custom description'.\r	assert: tester successes size equals: 2.\r	assert: tester successes containsSelector: #testAssertPassBlock.\r	assert: tester successes containsSelector: #testAssertPassExpression.\r)",
 "public testDenials = (\r	tester:: Tester testSuite: (catalog testSuiteNamed: 'DenyTestContext').\r	tester runAll.\r	assert: tester errors size equals: 2.\r	assert: tester errors containsSelector: #testDenyErrorBlock.\r	assert: tester errors containsSelector: #testDenyErrorExpression.\r	assert: tester failures size equals: 3.\r	assert: tester failures containsSelector: #testDenyFailBlock.\r	assert: tester failures containsSelector: #testDenyFailExpression.\r	assert: tester failures containsSelector: #testDenyFailWithDescription.\r	assert: (resultForSelector: #testDenyFailWithDescription in: tester failures) description\r		equals: 'custom description'.\r	assert: tester successes size equals: 2.\r	assert: tester successes containsSelector: #testDenyPassBlock.\r	assert: tester successes containsSelector: #testDenyPassExpression.\r)",
 "public testResultCreation = (\r	tester:: Tester testSuite: (catalog testSuiteNamed: 'ResultCreationTestContext').\r	tester runAll.\r\r	assert: tester failures size equals: 1.\r	assert: tester failures first description = 'created here'.\r\r	assert: tester errors size equals: 1.\r	assert: tester errors first exception messageText = 'created here'.\r\r	assert: tester successes size equals: 1.\r	assert: tester successes first message = 'all good here'.\r)",
 "public testShouldShouldnt = (\r	tester:: Tester testSuite: (catalog testSuiteNamed: 'ShouldShouldntTestContext').\r	tester runAll.\r	assert: tester errors size equals: 0.\r	assert: tester failures size equals: 4.\r	assert: tester failures containsSelector: #testShouldFail.\r	assert: tester failures containsSelector: #testShouldFailWithDescription.\r	assert: tester failures containsSelector: #testShouldntFail.\r	assert: tester failures containsSelector: #testShouldntFailWithDescription.\r	assert: tester successes size equals: 3.\r	assert: tester successes containsSelector: #testShouldPassExceptionSubclass.\r	assert: tester successes containsSelector: #testShouldPassSameExceptionClass.\r	assert: tester successes containsSelector: #testShouldntPass.\r)",
 "public class GuineaPigTestModule testFramework: testFramework = (|\r	private TestContext = testFramework TestContext.\r|)",
 " ",
 " ",
 "public class AssertEqualsTestContext = TestContext (\r)",
 "TestContext",
 "TestContext",
 "public testAssertEqualsFail = (\r	assert: 3 equals: 4\r)",
 "public testAssertEqualsFailWithDescription = (\r	assert: 3 equals: 4 description: 'custom description'\r)",
 "public testAssertEqualsPass = (\r	assert: 3 equals: 3\r)",
 "TEST_CONTEXT = (\r)",
 "public class AssertTestContext = TestContext (\r)",
 "TestContext",
 "TestContext",
 "public testAssertErrorBlock = (\r	assert: [3 zork]\r)",
 "public testAssertErrorExpression = (\r	assert: 3 zork\r)",
 "public testAssertFailBlock = (\r	assert: [false]\r)",
 "public testAssertFailExpression = (\r	assert: false\r)",
 "public testAssertFailWithDescription = (\r	assert: false description: 'custom description'\r)",
 "public testAssertPassBlock = (\r	assert: [true]\r)",
 "public testAssertPassExpression = (\r	assert: true\r)",
 "TEST_CONTEXT = (\r)",
 "public class DenyTestContext = TestContext (\r(* Trial tests to verify that the various #deny... messages work correctly. *)\r)",
 "TestContext",
 "TestContext",
 "public testDenyErrorBlock = (\r	deny: [3 zork]\r)",
 "public testDenyErrorExpression = (\r	deny: 3 zork\r)",
 "public testDenyFailBlock = (\r	deny: [true]\r)",
 "public testDenyFailExpression = (\r	deny: true\r)",
 "public testDenyFailWithDescription = (\r	deny: true description: 'custom description'\r)",
 "public testDenyPassBlock = (\r	deny: [false]\r)",
 "public testDenyPassExpression = (\r	deny: false\r)",
 "TEST_CONTEXT = (\r)",
 "public class ResultCreationTestContext = TestContext (\r(* This helps test to see if TestContext was deferred to for the creation of the TestFailure and TestError result. *)\r|\r	private TestFailure = testFramework TestFailure.\r	private TestError = testFramework TestError.\r|)",
 "TestContext",
 "TestContext",
 "public createErrorResultFor: testCase <TestCase> exception: ex <Error> = (\r	| exception |\r	exception:: TestException1 new.\r	exception messageText: 'created here'.\r	^TestError case: testCase exception: exception\r)",
 "public createFailureResultFor: testCase <TestCase> description: description <String> = (\r	^TestFailure case: testCase description: 'created here'\r)",
 "public createSuccessResultFor: testCase <TestCase> = (\r	^CustomTestSuccess case: testCase.\r)",
 "public testErrorCreation = (\r	assert: [1 zork]\r)",
 "public testFailureCreation = (\r	assert: false description: 'better not see this'\r)",
 "public testSuccess = (\r	assert: true\r)",
 "class CustomTestSuccess case: testCase = (\r(* A custom TestSuccess *)\r|\r	public case ::= testCase.\r	public message = 'all good here'.\r|)",
 " ",
 " ",
 "public isError = (\r	^false\r)",
 "public isFailure = (\r	^false\r)",
 "public isSuccess = (\r	^true\r)",
 "TEST_CONTEXT = ()",
 "public class ShouldShouldntTestContext = TestContext (\r|\r|)",
 "TestContext",
 "TestContext",
 "public testShouldFail = (\r	[should: [TestException1 new signal] signal: TestException2]\r		on: TestException1\r		do: [:ex | ex resume: nil]\r)",
 "public testShouldFailWithDescription = (\r	[should: [TestException1 new signal]\r	signal: TestException2\r	description: 'custom description']\r		on: TestException1\r		do: [:ex | ex resume: nil]\r)",
 "public testShouldPassExceptionSubclass = (\r	should: [TestException1 new signal] signal: Exception\r)",
 "public testShouldPassSameExceptionClass = (\r	should: [TestException1 new signal] signal: TestException1\r)",
 "public testShouldntFail = (\r	shouldnt: [TestException1 new signal] signal: TestException1\r)",
 "public testShouldntFailWithDescription = (\r	shouldnt: [TestException1 new signal]\r		signal: TestException1\r		description: 'custom description'\r)",
 "public testShouldntPass = (\r	[shouldnt: [TestException1 new signal] signal: TestException2]\r		on: TestException1\r		do: [:ex | ex resume: nil]\r)",
 "TEST_CONTEXT = (\r)",
 "class TestException1 = Exception (\r)",
 "Exception",
 "Exception",
 "class TestException2 = Exception (\r)",
 "Exception",
 "Exception",
 "TEST_CONTEXT = (\r)",
 "public class TestLifecycleTests = TestContext (\r(* Tests to verify that test cases are collected and grouped into test suites correctly across test contexts, and that test contexts and their enclosing shared state classes are instantiated the correct number of times. *)\r|\r	guineaPig = GuineaPigTestModule minitest: testFramework.\r	catalog = TestCatalog forModule: guineaPig.\r|)",
 "TestContext",
 "TestContext",
 "public testCatalogContentsForDirectlyNested = (\r	assert: (catalog testSuiteNames includes: 'DirectlyNestedTestContext').\r	assert: (catalog testSuiteNamed: 'DirectlyNestedTestContext') size equals: 3.\r)",
 "public testCatalogContentsForInnerContext = (\r	assert: (catalog testSuiteNames includes: 'InnerTestContext').\r	assert: (catalog testSuiteNamed: 'InnerTestContext') size equals: 2.\r)",
 "public testCatalogSize = (\r	assert: catalog testSuiteNames size equals: 2.\r)",
 "public testInstantiationCounts = (\r	| tester |\r	tester:: Tester testSuite: catalog allTests.\r	tester runAll.\r	assert: guineaPig DirectlyNestedTestContextInstantiationCount equals: 3.\r	assert: guineaPig OuterSharedStateClassInstantiationCount equals: 1.\r	assert: guineaPig InnerSharedStateClassInstantiationCount equals: 1.\r	assert: guineaPig InnerTestContextInstantiationCount equals: 2.\r)",
 "public testSharedStateCleanUp = (\r	| tester |\r	tester:: Tester testSuite: catalog allTests.\r	tester runAll.\r	assert: guineaPig OuterSharedStateCleanedUp.\r	assert: guineaPig InnerSharedStateCleanedUp.\r)",
 "public testSuiteSizes = (\r	assert: (catalog testSuiteNamed: 'DirectlyNestedTestContext') testCases size\r	equals: 3.\r	assert: (catalog testSuiteNamed: 'InnerTestContext') testCases size\r	equals: 2.\r)",
 "public class GuineaPigTestModule minitest: testFramework = (\r(* A fake test module for the use by tests of the enclosing class.\r\rBecause this module is nested inside a test context, the test contexts and methods it contains are not included in the test catalog created for the enclosing test module. *)\r|\r	private TestContext = testFramework TestContext.\r	public DirectlyNestedTestContextInstantiationCount ::= 0.\r	public OuterSharedStateClassInstantiationCount ::= 0.\r	public InnerSharedStateClassInstantiationCount ::= 0.\r	public InnerTestContextInstantiationCount ::= 0.\r	public OuterSharedStateCleanedUp ::= false.\r	public InnerSharedStateCleanedUp ::= false.\r|)",
 " ",
 " ",
 "public class DirectlyNestedTestContext = TestContext (\r(* A test context class directly nested inside its test module. The tests expect this class to have 3 test methods. *)\r|\r|DirectlyNestedTestContextInstantiationCount: DirectlyNestedTestContextInstantiationCount + 1)",
 "TestContext",
 "TestContext",
 "public testCase1 = (\r)",
 "public testCase2 = (\r)",
 "public testCase3 = (\r)",
 "testFoo: bar = (\r	(* A keyword method like this should not be recognized as a test. *)\r)",
 "public class DoublyNestedTestContextWhichShouldBeIgnored = TestContext (\r(* A test context inside a test context, should be ignored by the catalog building logic. *)\r)",
 "TestContext",
 "TestContext",
 "public testCase1 = (\r)",
 "TEST_CONTEXT = (\r)",
 "TEST_CONTEXT = (\r)",
 "public class OuterSharedStateClass = (\r(* A non-test context class that serves as a container of shared state for its nested test contexts. *)\r|\r	outerSharedState = 42.\r|OuterSharedStateClassInstantiationCount: OuterSharedStateClassInstantiationCount + 1)",
 " ",
 " ",
 "public cleanUp = (\r	OuterSharedStateCleanedUp: true.\r)",
 "public class InnerSharedStateClass = (\r(* Another non-test context class. *)\r|\r	innerSharedState = 24.\r|InnerSharedStateClassInstantiationCount: InnerSharedStateClassInstantiationCount + 1)",
 " ",
 " ",
 "public cleanUp = (\r	InnerSharedStateCleanedUp: true.\r)",
 "public class InnerTestContext = TestContext (\r(* A test context class nested in some shared state classes. The tests expect this class to have 2 test methods. *)\r|\r|InnerTestContextInstantiationCount: InnerTestContextInstantiationCount + 1)",
 "TestContext",
 "TestContext",
 "public testCase1 = (\r)",
 "public testCase2 = (\r)",
 "TEST_CONTEXT = (\r)",
 "TEST_CONTEXT = (\r(* Marking this class as a test context. *)\r)",
 "class MinitestTestsConfiguration packageTestsUsing: ideNamespace = (\r(* Runs MinitestTests. *)\r|\r	Minitest = ideNamespace Minitest.\r	MinitestTests = ideNamespace MinitestTests.\r|)",
 " ",
 " ",
 "public testModulesUsingPlatform: platform minitest: minitest ^<{MiniTests}> = (\r	^{MinitestTests usingPlatform: platform testFramework: minitest}\r)",
 "class MirrorTesting usingPlatform: p minitest: m model: md = (|\rprivate ObjectMirror = p mirrors ObjectMirror.\rprivate ClassMirror = p mirrors ClassMirror.\rprivate Map = p collections Map.\rprivate Set = p collections Set.\rprivate TestContext = m TestContext.\rprivate model = md.\r|)",
 " ",
 " ",
 "public class ClassDeclarationMirrorTests = TestBase ()",
 "TestBase",
 "TestBase",
 "public testClassDeclarationMirrorEnclosingClass = (\r	| mirror mirror2 |\r	mirror:: (ClassMirror reflecting: model Klass) mixin declaration.\r	mirror2:: (ObjectMirror reflecting: model) getClass mixin declaration.\r	assert: mirror enclosingClass equals: mirror2.\r	assert: mirror2 enclosingClass equals: nil.\r)",
 "public testClassDeclarationMirrorEquality = (\r	| mirror mirror2 |\r	mirror:: (ClassMirror reflecting: model Klass) mixin declaration.\r	mirror2:: (ClassMirror reflecting: model Klass) mixin declaration.\r	assert: mirror equals: mirror2.\r	assert: mirror hash equals: mirror2 hash.\r	deny: mirror equals: mirror instanceSide.\r	deny: mirror equals: mirror classSide.\r	deny: mirror equals: mirror header.\r\r	mirror:: (ObjectMirror reflecting: model) getClass mixin declaration.\r	mirror2:: (ObjectMirror reflecting: model) getClass mixin declaration.\r	assert: mirror equals: mirror2.\r	assert: mirror hash equals: mirror2 hash.\r	deny: mirror equals: mirror instanceSide.\r	deny: mirror equals: mirror classSide.\r	deny: mirror equals: mirror header.\r\r	mirror:: (ClassMirror reflecting: model Klass) mixin declaration.\r	mirror2:: (ObjectMirror reflecting: model) getClass mixin declaration.\r	deny: mirror equals: mirror2.\r)",
 "public testClassDeclarationMirrorName = (\r	| mirror |\r	mirror:: (ClassMirror reflecting: model Klass) mixin declaration.\r	assert: mirror name equals: 'Klass'. (* Not MirrorTestingModel`Klass *)\r\r	mirror:: (ObjectMirror reflecting: model) getClass mixin declaration.\r	assert: mirror name equals: 'MirrorTestingModel'.\r)",
 "public testIsKindOfClassDeclarationMirror = (\r	|\r	objectMirror = ObjectMirror reflecting: model.\r	classMirror = objectMirror getClass.\r	instanceMixinMirror = classMirror mixin.\r	classDeclarationMirror = instanceMixinMirror declaration.\r	classHeaderMirror = classDeclarationMirror header.\r	classMixinMirror = classDeclarationMirror classSide.\r	|\r\r	deny: objectMirror isKindOfClassDeclarationMirror.\r	deny: classMirror isKindOfClassDeclarationMirror.\r	deny: instanceMixinMirror isKindOfClassDeclarationMirror.\r	assert: classDeclarationMirror isKindOfClassDeclarationMirror.\r	deny: classHeaderMirror isKindOfClassDeclarationMirror.\r	deny: classMixinMirror isKindOfClassDeclarationMirror.\r	classMirror slots do:\r		[:slotMirror | deny: slotMirror isKindOfClassDeclarationMirror].\r	classMirror methods do:\r		[:methodMirror | deny: methodMirror isKindOfClassDeclarationMirror].\r	classMirror nestedClasses do:\r		[:nestedClassMirror | assert: nestedClassMirror isKindOfClassDeclarationMirror].\r)",
 "TEST_CONTEXT = ()",
 "public class ClassHeaderMirrorTests = TestBase ()",
 "TestBase",
 "TestBase",
 "public testClassHeaderMirrorEquality = (\r	| mirror mirror2 |\r	mirror:: (ClassMirror reflecting: model Klass) mixin declaration header.\r	mirror2:: (ClassMirror reflecting: model Klass) mixin declaration header.\r	assert: mirror equals: mirror2.\r	assert: mirror hash equals: mirror2 hash.\r\r	mirror:: (ObjectMirror reflecting: model) getClass mixin declaration header.\r	mirror2:: (ObjectMirror reflecting: model) getClass mixin declaration header.\r	assert: mirror equals: mirror2.\r	assert: mirror hash equals: mirror2 hash.\r\r	mirror:: (ClassMirror reflecting: model Klass) mixin declaration header.\r	mirror2:: (ObjectMirror reflecting: model) getClass mixin declaration header.\r	deny: mirror equals: mirror2.\r)",
 "public testClassHeaderMirrorName = (\r	| mirror |\r	mirror:: (ClassMirror reflecting: model Klass) mixin declaration header.\r	assert: mirror name equals: 'Klass'. (* Not MirrorTestingModel`Klass *)\r\r	mirror:: (ObjectMirror reflecting: model) getClass mixin declaration header.\r	assert: mirror name equals: 'MirrorTestingModel'.\r)",
 "public testIsKindOfClassHeaderMirror = (\r	|\r	objectMirror = ObjectMirror reflecting: model.\r	classMirror = objectMirror getClass.\r	instanceMixinMirror = classMirror mixin.\r	classDeclarationMirror = instanceMixinMirror declaration.\r	classHeaderMirror = classDeclarationMirror header.\r	classMixinMirror = classDeclarationMirror classSide.\r	|\r\r	deny: objectMirror isKindOfClassHeaderMirror.\r	deny: classMirror isKindOfClassHeaderMirror.\r	deny: instanceMixinMirror isKindOfClassHeaderMirror.\r	deny: classDeclarationMirror isKindOfClassHeaderMirror.\r	assert: classHeaderMirror isKindOfClassHeaderMirror.\r	deny: classMixinMirror isKindOfClassHeaderMirror.\r	classMirror slots do:\r		[:slotMirror | deny: slotMirror isKindOfClassHeaderMirror].\r	classMirror methods do:\r		[:methodMirror | deny: methodMirror isKindOfClassHeaderMirror].\r	classMirror nestedClasses do:\r		[:nestedClassMirror | deny: nestedClassMirror isKindOfClassHeaderMirror].\r)",
 "TEST_CONTEXT = ()",
 "public class ClassMirrorTests = TestBase ()",
 "TestBase",
 "TestBase",
 "classOf: classMirror = (\r	^(ObjectMirror reflecting: classMirror reflectee) getClass\r)",
 "public testClassMirrorEnclosingObject = (\r	assert: (ClassMirror reflecting: model Klass) enclosingObject\r	equals: (ObjectMirror reflecting: model).\r\r	assert: (ObjectMirror reflecting: model) getClass enclosingObject\r	equals: (ObjectMirror reflecting: nil).\r\r	(* :todo: Cases with generalized mixin application *)\r)",
 "public testClassMirrorEquality = (\r	| mirror mirror2 |\r	mirror:: ClassMirror reflecting: model Klass.\r	mirror2:: (ObjectMirror reflecting: (model Klass factory: 2)) getClass.\r	assert: mirror equals: mirror2.\r	assert: mirror2 equals: mirror.\r	assert: mirror hash equals: mirror2 hash.\r	deny: mirror equals: mirror mixin.\r	deny: mirror2 equals: mirror2 mixin.\r	deny: mirror equals: nil.\r	deny: mirror2 equals: nil.\r	deny: nil equals: mirror.\r	deny: nil equals: mirror2.\r\r	mirror:: (ObjectMirror reflecting: model) getClass.\r	mirror2:: (ClassMirror reflecting: model Klass) enclosingObject getClass.\r	assert: mirror equals: mirror2.\r	assert: mirror2 equals: mirror.\r	assert: mirror hash equals: mirror2 hash.\r	deny: mirror equals: mirror mixin.\r	deny: mirror2 equals: mirror2 mixin.\r	deny: mirror equals: nil.\r	deny: mirror2 equals: nil.\r	deny: nil equals: mirror.\r	deny: nil equals: mirror2.\r\r	mirror:: ClassMirror reflecting: model Klass.\r	mirror2:: (ObjectMirror reflecting: model) getClass.\r	deny: mirror equals: mirror2.\r	deny: mirror equals: mirror mixin.\r	deny: mirror2 equals: mirror2 mixin.\r	deny: mirror equals: nil.\r	deny: mirror2 equals: nil.\r	deny: nil equals: mirror.\r	deny: nil equals: mirror2.\r\r	(* Same mixin, same superclass, different enclosing object. *)\r	mirror:: ClassMirror reflecting: (model Klass factory: 2) Nested.\r	mirror2:: ClassMirror reflecting: (model Klass factory: 2) Nested.\r	assert: mirror mixin equals: mirror2 mixin.\r	deny: mirror equals: mirror2.\r	deny: mirror2 equals: mirror.\r)",
 "public testClassMirrorIsMeta = (\r	| mirror mirror2 |\r	mirror:: ClassMirror reflecting: model Klass.\r	deny: mirror isMeta.\r\r	mirror:: (ObjectMirror reflecting: model Klass) getClass.\r	assert: mirror isMeta.\r\r	mirror:: (ObjectMirror reflecting: model) getClass.\r	deny: mirror isMeta.\r\r	mirror:: (ClassMirror reflecting: model Klass) enclosingObject getClass.\r	deny: mirror isMeta.\r\r	mirror:: ClassMirror reflecting: self class yourclass.\r	assert: mirror isMeta.\r)",
 "public testClassMirrorMethods = (\r	| object mirror |\r	(* Fails because of all the stuff from ImplementationBase in Squeak *)\r	object:: (ClassMirror reflecting: Object) mixin.\r	mirror:: ClassMirror reflecting: model Klass.\r	assertSet: ((mirror methods reject: [:method | method definingMixin = object])\r		collect: [:method | method name])\r	equals: {'superMethod'. '>>>'. 'defaultMethod'. 'keyword:method:'. 'privateMethod'. 'protectedMethod'. 'publicMethod'}.\r\r	mirror:: classOf: mirror.\r	mirror methods.\r)",
 "public testClassMirrorName = (\r	(* :todo: Should we answer the name with or without the hash?\r\r	| mirror |\r	mirror:: ClassMirror reflecting: model Klass.\r	assert: mirror name equals: 'Klass'.\r\r	mirror:: (ObjectMirror reflecting: (model Klass factory: 2)) getClass.\r	assert: mirror name equals: 'Klass'.\r\r	mirror:: (ObjectMirror reflecting: model) getClass.\r	assert: mirror name equals: 'MirrorTestingModel'.\r\r	mirror:: (ClassMirror reflecting: model Klass) enclosingObject getClass.\r	assert: mirror name equals: 'MirrorTestingModel'.\r\r	mirror:: ClassMirror reflecting: model Klass.\r	assert: mirror name equals: 'Klass'.\r\r	mirror:: (ObjectMirror reflecting: model) getClass.\r	assert: mirror name equals: 'MirrorTestingModel'.\r\r	mirror:: ClassMirror reflecting: (model Klass factory: 2) Nested.\r	assert: mirror name equals: 'Nested'.\r\r	mirror:: ClassMirror reflecting: (model Klass factory: 2) Nested.\r	assert: mirror name equals: 'Nested'. *)\r)",
 "public testClassMirrorNestedClasses = (\r	| mirror |\r	mirror:: ClassMirror reflecting: model Klass.\r	assertSet: (mirror nestedClasses collect: [:klass | klass name])\r	equals: {'SuperNestedClass'. 'DefaultNestedClass'. 'Nested'. 'PrivateNestedClass'. 'ProtectedNestedClass'. 'PublicNestedClass'}.\r\r	mirror:: classOf: mirror.\r	mirror nestedClasses.\r)",
 "public testClassMirrorNonBehavior = (\r	should: [ClassMirror reflecting: 'Not a behavior'] signal: Error\r)",
 "public testClassMirrorSlots = (\r	| mirror |\r	mirror:: ClassMirror reflecting: model Klass.\r	assertList: (mirror slots collect: [:slot | slot name])\r	equals: {'superSlot'. 'publicSlot'. 'protectedSlot'. 'defaultSlot'. 'privateSlot'. 'mutableSlot'. 'immutableSlot'. 'uninitializedSlot'}.\r\r	mirror:: classOf: mirror.\r	mirror slots.\r)",
 "public testClassMirrorSuperclass = (\r	assert: (ClassMirror reflecting: model Klass) superclass\r	equals: (ClassMirror reflecting: model SuperKlass).\r\r	assert: (ClassMirror reflecting: model SuperKlass) superclass\r	equals: (ClassMirror reflecting: Object).\r\r	assert: (ClassMirror reflecting: Object) superclass\r	equals: nil. (* fails in Squeak because the superclass of Object is ImplementationBase *)\r\r	(* :todo: Cases with generalized mixin application *)\r)",
 "public testIsKindOfClassMirror = (\r	|\r	objectMirror = ObjectMirror reflecting: model.\r	classMirror = objectMirror getClass.\r	instanceMixinMirror = classMirror mixin.\r	classDeclarationMirror = instanceMixinMirror declaration.\r	classHeaderMirror = classDeclarationMirror header.\r	classMixinMirror = classDeclarationMirror classSide.\r	|\r\r	deny: objectMirror isKindOfClassMirror.\r	assert: classMirror isKindOfClassMirror.\r	deny: instanceMixinMirror isKindOfClassMirror.\r	deny: classDeclarationMirror isKindOfClassMirror.\r	deny: classHeaderMirror isKindOfClassMirror.\r	deny: classMixinMirror isKindOfClassMirror.\r	classMirror slots do:\r		[:slotMirror | deny: slotMirror isKindOfClassMirror].\r	classMirror methods do:\r		[:methodMirror | deny: methodMirror isKindOfClassMirror].\r	classMirror nestedClasses do:\r		[:nestedClassMirror | deny: nestedClassMirror isKindOfClassMirror].\r)",
 "public testMetaRelationships = (\r	|\r	mClassMirrorTests = ClassMirror reflecting: class.\r	mObject = ClassMirror reflecting: Object.\r	mClass = (classOf: mClassMirrorTests) superclass.\r	mMetaclass = classOf: (classOf: mClassMirrorTests).\r	|\r	assert: [mObject mixin name = 'Object' or: [mObject mixin name = '_Object']].\r	assert: mClass mixin name equals: 'Class'.\r	assert: mMetaclass mixin name equals: 'Metaclass'.\r\r	assert: [mClass superclass = mObject\r			or: [mClass superclass superclass = mObject]]\r	description: 'Class superclass [superclass] = Object'.\r\r	assert: (classOf: mObject) superclass equals: mClass.\r	assert: (classOf: mClass) superclass equals: mClass.\r	assert: (classOf: mClassMirrorTests) superclass equals: mClass.\r	assert: (classOf: mMetaclass) superclass equals: mClass.\r\r	assert: (classOf: (classOf: mObject)) equals: mMetaclass.\r	assert: (classOf: (classOf: mClass)) equals: mMetaclass.\r	assert: (classOf: (classOf: mMetaclass)) equals: mMetaclass.\r	assert: (classOf: (classOf: mClassMirrorTests)) equals: mMetaclass.\r)",
 "TEST_CONTEXT = ()",
 "public yourclass = (\r	^self class\r)",
 "class ErrorOnEquals = ()",
 " ",
 " ",
 "public = other = (\r	^Error new signal\r)",
 "public class = (\r	^Error new signal\r)",
 "public hash = (\r	^Error new signal\r)",
 "public class MethodMirrorTests = TestBase ()",
 "TestBase",
 "TestBase",
 "public testIsKindOfMethodMirror = (\r	|\r	objectMirror = ObjectMirror reflecting: model.\r	classMirror = objectMirror getClass.\r	instanceMixinMirror = classMirror mixin.\r	classDeclarationMirror = instanceMixinMirror declaration.\r	classHeaderMirror = classDeclarationMirror header.\r	classMixinMirror = classDeclarationMirror classSide.\r	|\r\r	deny: objectMirror isKindOfMethodMirror.\r	deny: classMirror isKindOfMethodMirror.\r	deny: instanceMixinMirror isKindOfMethodMirror.\r	deny: classDeclarationMirror isKindOfMethodMirror.\r	deny: classHeaderMirror isKindOfMethodMirror.\r	deny: classMixinMirror isKindOfMethodMirror.\r	classMirror slots do:\r		[:slotMirror | deny: slotMirror isKindOfMethodMirror].\r	classMirror methods do:\r		[:methodMirror | assert: methodMirror isKindOfMethodMirror].\r	classMirror nestedClasses do:\r		[:nestedClassMirror | deny: nestedClassMirror isKindOfMethodMirror].\r)",
 "public testMethodMirrorAccessModifier = (\r	| methods |\r	methods:: (ClassMirror reflecting: model Klass) mixin methods.\r	assert: (in: methods findMirrorNamed: 'defaultMethod') accessModifier equals: #protected.\r	assert: (in: methods findMirrorNamed: 'privateMethod') accessModifier equals: #private.\r	assert: (in: methods findMirrorNamed: 'protectedMethod') accessModifier equals: #protected.\r	assert: (in: methods findMirrorNamed: 'publicMethod') accessModifier equals: #public.\r)",
 "public testMethodMirrorEquality = (\r	| mirror mirror2 mirror3 methods |\r\r	(* Different applications of the same mixin. *)\r	mirror:: ClassMirror reflecting: (model Klass factory: 2) Nested.\r	mirror:: in: mirror methods findMirrorNamed: 'nestedMethod'.\r\r	mirror2:: ClassMirror reflecting: (model Klass factory: 2) Nested.\r	mirror2:: in: mirror2 methods findMirrorNamed: 'nestedMethod'.\r\r	mirror3:: (ClassMirror reflecting: model Klass).\r	mirror3:: in: mirror3 nestedClasses findMirrorNamed: 'Nested'.\r	mirror3:: in: mirror3 instanceSide methods findMirrorNamed: 'nestedMethod'.\r\r	assert: mirror equals: mirror2.\r	assert: mirror2 equals: mirror3.\r	assert: mirror3 equals: mirror.\r\r	assert: mirror hash equals: mirror2 hash.\r	assert: mirror2 hash equals: mirror3 hash.\r	assert: mirror3 hash equals: mirror hash.\r\r	(* Different methods. *)\r	methods:: (ClassMirror reflecting: model Klass) mixin methods.\r	mirror:: in: methods findMirrorNamed: 'protectedMethod'.\r	mirror2:: in: methods findMirrorNamed: 'privateMethod'.\r	mirror3:: in: methods findMirrorNamed: 'publicMethod'.\r\r	deny: mirror equals: mirror2.\r	deny: mirror2 equals: mirror3.\r	deny: mirror3 equals: mirror.\r	deny: mirror equals: nil.\r	deny: nil equals: mirror.\r)",
 "TEST_CONTEXT = ()",
 "public class MixinMirrorTests = TestBase ()",
 "TestBase",
 "TestBase",
 "public testIsKindOfMixinMirror = (\r	|\r	objectMirror = ObjectMirror reflecting: model.\r	classMirror = objectMirror getClass.\r	instanceMixinMirror = classMirror mixin.\r	classDeclarationMirror = instanceMixinMirror declaration.\r	classHeaderMirror = classDeclarationMirror header.\r	classMixinMirror = classDeclarationMirror classSide.\r	|\r\r	deny: objectMirror isKindOfMixinMirror.\r	deny: classMirror isKindOfMixinMirror.\r	assert: instanceMixinMirror isKindOfMixinMirror.\r	deny: classDeclarationMirror isKindOfMixinMirror.\r	deny: classHeaderMirror isKindOfMixinMirror.\r	assert: classMixinMirror isKindOfMixinMirror.\r	classMirror slots do:\r		[:slotMirror | deny: slotMirror isKindOfMixinMirror].\r	classMirror methods do:\r		[:methodMirror | deny: methodMirror isKindOfMixinMirror].\r	classMirror nestedClasses do:\r		[:nestedClassMirror | deny: nestedClassMirror isKindOfMixinMirror].\r)",
 "public testMixinMirrorDeclaration = (\r	| mirror |\r	mirror:: (ClassMirror reflecting: model Klass) mixin.\r	assert: mirror declaration name equals: 'Klass'.\r	assert: mirror declaration instanceSide equals: mirror.\r\r	deny: mirror declaration equals: mirror. (* Even though they have the same reflectee. *)\r\r	mirror:: (ObjectMirror reflecting: model Klass) getClass mixin.\r	assert: mirror declaration name equals: 'Klass'.\r	assert: mirror declaration classSide equals: mirror.\r\r	deny: mirror declaration equals: mirror.\r)",
 "public testMixinMirrorEnclosingMixin = (\r	| mirror mirror2 |\r	mirror:: (ClassMirror reflecting: model Klass) mixin.\r	mirror2:: (ObjectMirror reflecting: model) getClass mixin.\r	assert: mirror enclosingMixin equals: mirror2.\r	assert: mirror2 enclosingMixin equals: nil.\r)",
 "public testMixinMirrorEquality = (\r	| mirror mirror2 |\r	mirror:: (ClassMirror reflecting: model Klass) mixin.\r	mirror2:: (ClassMirror reflecting: model Klass) mixin.\r	assert: mirror equals: mirror2.\r	assert: mirror hash equals: mirror2 hash.\r\r	mirror:: (ObjectMirror reflecting: model) getClass mixin.\r	mirror2:: (ObjectMirror reflecting: model) getClass mixin.\r	assert: mirror equals: mirror2.\r	assert: mirror hash equals: mirror2 hash.\r\r	mirror:: (ClassMirror reflecting: model Klass) mixin.\r	mirror2:: (ObjectMirror reflecting: model) getClass mixin.\r	deny: mirror equals: mirror2.\r)",
 "public testMixinMirrorIsMeta = (\r	| mirror |\r	mirror:: (ClassMirror reflecting: model Klass) mixin.\r	deny: mirror isMeta.\r\r	mirror:: mirror declaration classSide.\r	assert: mirror isMeta.\r)",
 "public testMixinMirrorMethods = (\r	| mirror |\r	mirror:: (ClassMirror reflecting: model Klass) mixin.\r	assertSet: (mirror methods collect: [:method | method name])\r	equals: {'>>>'. 'defaultMethod'. 'keyword:method:'. 'privateMethod'. 'protectedMethod'. 'publicMethod'}.\r	mirror methods do: [:method | assert: method definingMixin equals: mirror].\r\r	mirror:: mirror declaration classSide.\r	assertSet: (mirror methods collect: [:method | method name])\r	equals: {'classMethod'}.\r	mirror methods do: [:method | assert: method definingMixin equals: mirror].\r)",
 "public testMixinMirrorName = (\r	| mirror |\r	mirror:: (ClassMirror reflecting: model Klass) mixin.\r	assert: mirror name equals: 'Klass'. (* Not MirrorTestingModel`Klass *)\r	mirror:: mirror declaration classSide.\r	assert: mirror name equals: 'Klass class'.\r\r	mirror:: (ObjectMirror reflecting: model) getClass mixin.\r	assert: mirror name equals: 'MirrorTestingModel'.\r	mirror:: mirror declaration classSide.\r	assert: mirror name equals: 'MirrorTestingModel class'.\r)",
 "public testMixinMirrorNestedClasses = (\r	| mirror |\r	mirror:: (ClassMirror reflecting: model Klass) mixin.\r	assertSet: (mirror nestedClasses collect: [:klass | klass name])\r	equals: {'DefaultNestedClass'. 'Nested'. 'PrivateNestedClass'. 'ProtectedNestedClass'. 'PublicNestedClass'}.\r	mirror nestedClasses do: [:klass | assert: klass definingMixin equals: mirror].\r\r	mirror:: mirror declaration classSide.\r	assertSet: (mirror nestedClasses collect: [:klass | klass name])\r	equals: {}.\r	mirror nestedClasses do: [:klass | assert: klass definingMixin equals: mirror].\r)",
 "public testMixinMirrorSlots = (\r	| mirror |\r	mirror:: (ClassMirror reflecting: model Klass) mixin.\r	assertList: (mirror slots collect: [:slot | slot name])\r	equals: {'publicSlot'. 'protectedSlot'. 'defaultSlot'. 'privateSlot'. 'mutableSlot'. 'immutableSlot'. 'uninitializedSlot'}.\r	mirror slots do: [:slot | assert: slot definingMixin equals: mirror].\r\r	mirror:: mirror declaration classSide.\r	assertList: (mirror slots collect: [:slot | slot name])\r	equals: {}.\r	mirror slots do: [:slot | assert: slot definingMixin equals: mirror].\r)",
 "TEST_CONTEXT = ()",
 "public class ObjectMirrorTests = TestBase ()",
 "TestBase",
 "TestBase",
 "public testIsKindOfObjectMirror = (\r	|\r	objectMirror = ObjectMirror reflecting: model.\r	classMirror = objectMirror getClass.\r	instanceMixinMirror = classMirror mixin.\r	classDeclarationMirror = instanceMixinMirror declaration.\r	classHeaderMirror = classDeclarationMirror header.\r	classMixinMirror = classDeclarationMirror classSide.\r	|\r\r	assert: objectMirror isKindOfObjectMirror.\r	deny: classMirror isKindOfObjectMirror.\r	deny: instanceMixinMirror isKindOfObjectMirror.\r	deny: classDeclarationMirror isKindOfObjectMirror.\r	deny: classHeaderMirror isKindOfObjectMirror.\r	deny: classMixinMirror isKindOfObjectMirror.\r	classMirror slots do:\r		[:slotMirror | deny: slotMirror isKindOfObjectMirror].\r	classMirror methods do:\r		[:methodMirror | deny: methodMirror isKindOfObjectMirror].\r	classMirror nestedClasses do:\r		[:nestedClassMirror | deny: nestedClassMirror isKindOfObjectMirror].\r)",
 "public testObjectMirrorEquality = (\r	| a b |\r	a:: ErrorOnEquals new.\r	b:: ErrorOnEquals new.\r\r	assert: (ObjectMirror reflecting: a) equals: (ObjectMirror reflecting: a).\r	assert: (ObjectMirror reflecting: a) hash equals: (ObjectMirror reflecting: a) hash.\r\r	deny: (ObjectMirror reflecting: a) equals: (ObjectMirror reflecting: b).\r\r	deny: (ObjectMirror reflecting: a) equals: nil.\r	deny: nil equals: (ObjectMirror reflecting: a).\r)",
 "public testObjectMirrorEvaluate = (\r	| c mirror thread |\r	c:: C new.\r	mirror:: ObjectMirror reflecting: c.\r	thread:: mirror evaluate: 'foo'.\r	assert: thread isFulfilled.\r	assert: thread result reflectee equals: 'C'.\r\r	should: [mirror evaluate: '--parse--error--'] signal: Error.\r)",
 "public testObjectMirrorEvaluateEmpty = (\r	| c mirror thread |\r	c:: C new.\r	mirror:: ObjectMirror reflecting: c.\r	thread:: mirror evaluate: ''.\r	assert: thread isFulfilled.\r	assert: thread result reflectee equals: c.\r)",
 "public testObjectMirrorEvaluateWithScope = (\r	| c mirror scope thread |\r	c:: C new.\r	c a1: 3.\r	c c1: 4.\r	mirror:: ObjectMirror reflecting: c.\r	scope:: Map new.\r	scope at: #w put: (ObjectMirror reflecting: 10).\r	thread:: mirror evaluate: 'a1 + c1 + w' with: scope.\r	assert: thread isFulfilled.\r	assert: thread result reflectee equals: 17.\r)",
 "public testObjectMirrorGetClass = (\r	| a |\r	a:: ErrorOnEquals new.\r\r	assert: (ObjectMirror reflecting: a) getClass equals: (ClassMirror reflecting: ErrorOnEquals).\r	assert: (ObjectMirror reflecting: a) getClass reflectee equals: ErrorOnEquals.\r)",
 "public testObjectMirrorGetSlot = (\r	| c mirror result |\r	c:: C new.\r	c a1: 10.\r	c a2: 20.\r	c c1: 30.\r	c c2: 40.\r	mirror:: ObjectMirror reflecting: c.\r	result:: mirror getSlot: #a1.\r	assert: result reflectee equals: 10.\r	result:: mirror getSlot: #a2.\r	assert: result reflectee equals: 20.\r	result:: mirror getSlot: #c1.\r	assert: result reflectee equals: 30.\r	result:: mirror getSlot: #c2.\r	assert: result reflectee equals: 40.\r)",
 "public testObjectMirrorPerform = (\r)",
 "public testObjectMirrorReflectee = (\r	| obj |\r	obj:: Object new.\r	assert: (ObjectMirror reflecting: obj) reflectee equals: obj.\r)",
 "public testObjectMirrorSetClass = (\r)",
 "public testObjectMirrorSetClassShapeChange = (\r)",
 "public testObjectMirrorSetSlot = (\r	| c mirror result |\r	c:: C new.\r	c a1: 10.\r	c a2: 20.\r	c c1: 30.\r	c c2: 40.\r	mirror:: ObjectMirror reflecting: c.\r\r	mirror setSlot: #a1 to: 100.\r	assert: c a1 equals: 100.\r	assert: c a2 equals: 20.\r	assert: c c1 equals: 30.\r	assert: c c2 equals: 40.\r\r	mirror setSlot: #a2 to: 200.\r	assert: c a1 equals: 100.\r	assert: c a2 equals: 200.\r	assert: c c1 equals: 30.\r	assert: c c2 equals: 40.\r\r	mirror setSlot: #c1 to: 300.\r	assert: c a1 equals: 100.\r	assert: c a2 equals: 200.\r	assert: c c1 equals: 300.\r	assert: c c2 equals: 40.\r\r	mirror setSlot: #c2 to: 400.\r	assert: c a1 equals: 100.\r	assert: c a2 equals: 200.\r	assert: c c1 equals: 300.\r	assert: c c2 equals: 400.\r)",
 "public testObjectMirrorSetSlotImmutable = (\r)",
 "class A = (\r|\r	public a1\r	public a2\r|\r)",
 " ",
 " ",
 "foo = ( ^'A' )",
 "class B = A ()",
 "A",
 "A",
 "foo = ( ^'B' )",
 "class C = B (\r|\r	public c1\r	public c2\r|\r)",
 "B",
 "B",
 "foo = ( ^'C' )",
 "TEST_CONTEXT = ()",
 "public class SlotDeclarationMirrorTests = TestBase ()",
 "TestBase",
 "TestBase",
 "public testIsKindOfSlotDeclarationMirror = (\r	|\r	objectMirror = ObjectMirror reflecting: model.\r	classMirror = objectMirror getClass.\r	instanceMixinMirror = classMirror mixin.\r	classDeclarationMirror = instanceMixinMirror declaration.\r	classHeaderMirror = classDeclarationMirror header.\r	classMixinMirror = classDeclarationMirror classSide.\r	|\r\r	deny: objectMirror isKindOfSlotDeclarationMirror.\r	deny: classMirror isKindOfSlotDeclarationMirror.\r	deny: instanceMixinMirror isKindOfSlotDeclarationMirror.\r	deny: classDeclarationMirror isKindOfSlotDeclarationMirror.\r	deny: classHeaderMirror isKindOfSlotDeclarationMirror.\r	deny: classMixinMirror isKindOfSlotDeclarationMirror.\r	classMirror slots do:\r		[:slotMirror | assert: slotMirror isKindOfSlotDeclarationMirror].\r	classMirror methods do:\r		[:methodMirror | deny: methodMirror isKindOfSlotDeclarationMirror].\r	classMirror nestedClasses do:\r		[:nestedClassMirror | deny: nestedClassMirror isKindOfSlotDeclarationMirror].\r)",
 "public testSlotDeclarationMirrorAccessModifier = (\r	| slots |\r	slots:: (ClassMirror reflecting: model Klass) mixin slots.\r	assert: (in: slots findMirrorNamed: 'defaultSlot') accessModifier equals: #protected.\r	assert: (in: slots findMirrorNamed: 'privateSlot') accessModifier equals: #private.\r	assert: (in: slots findMirrorNamed: 'protectedSlot') accessModifier equals: #protected.\r	assert: (in: slots findMirrorNamed: 'publicSlot') accessModifier equals: #public.\r)",
 "public testSlotDeclarationMirrorIsMutable = (\r	| slots |\r	slots:: (ClassMirror reflecting: model Klass) mixin slots.\r	assert: (in: slots findMirrorNamed: 'mutableSlot') isMutable.\r	deny: (in: slots findMirrorNamed: 'immutableSlot') isMutable.\r	assert: (in: slots findMirrorNamed: 'uninitializedSlot') isMutable.\r)",
 "TEST_CONTEXT = ()",
 "class TestBase = TestContext ()",
 "TestContext",
 "TestContext",
 "assertSet: actual equals: expected = (\r	| missing extra missingString extraString |\r	missing:: Set new.\r	missing addAll: expected.\r	actual do: [:element | missing remove: element ifAbsent: []].\r	extra:: Set new.\r	extra addAll: actual.\r	expected do: [:element | extra remove: element ifAbsent: []].\r	(missing isEmpty and: [extra isEmpty]) ifTrue: [^self].\r\r	missingString: ''.\r	missing do: [:element | missingString: missingString, ' ', element printString].\r	extraString: ''.\r	extra do: [:element | extraString: extraString, ' ', element printString].\r\r	failWithMessage: 'Missing:', missingString, ' Extra:', extraString.\r)",
 "in: collection findMirrorNamed: name = (\r	collection do: [:mirror | mirror name = name ifTrue: [^mirror]].\r	^nil\r)",
 "class MirrorTestingConfiguration packageTestsUsing: manifest = (|\rprivate MirrorTesting = manifest MirrorTesting.\rprivate MirrorTestingModel = manifest MirrorTestingModel.\r|)",
 " ",
 " ",
 "public testModulesUsingPlatform: p minitest: m = (\r	^{MirrorTesting usingPlatform: p minitest: m model: MirrorTestingModel new}\r)",
 "class MirrorTestingModel = ()",
 " ",
 " ",
 "public class Klass factory: arg = SuperKlass superFactory: arg (|\rpublic publicSlot = 1.\rprotected protectedSlot = 2.\rdefaultSlot = 3.\rprivate privateSlot = 4.\rmutableSlot ::= 5.\rimmutableSlot = 6.\runinitializedSlot\r|)",
 "superFactory: arg",
 "superFactory: arg",
 ">>> binaryMethod = (\r)",
 "defaultMethod = (\r)",
 "keyword: kw1 method: kw2 = (\r)",
 "private privateMethod = (\r)",
 "protected protectedMethod = (\r)",
 "public publicMethod = (\r)",
 "class DefaultNestedClass = ()",
 " ",
 " ",
 "public class Nested = ()",
 " ",
 " ",
 "nestedMethod = (\r)",
 "private class PrivateNestedClass = ()",
 " ",
 " ",
 "protected class ProtectedNestedClass = ()",
 " ",
 " ",
 "public class PublicNestedClass = ()",
 " ",
 " ",
 "public classMethod = (\r)",
 "public class SuperKlass superFactory: arg = (|\rsuperSlot = arg.\r|)",
 " ",
 " ",
 "superMethod = (\r)",
 "class SuperNestedClass = ()",
 " ",
 " ",
 "superClassMethod = (\r)",
 "class MirrorBuilderTesting usingPlatform: p minitest: m = (|\rprivate ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.\rprivate ClassMirror = p mirrors ClassMirror.\rprivate ObjectMirror = p mirrors ObjectMirror.\rprivate MessageNotUnderstood = p kernel MessageNotUnderstood.\rprivate Map = p collections Map.\rprivate TestContext = m TestContext.\r|)",
 " ",
 " ",
 "public class ClassDeclarationBuilderTests = TestContext ()",
 "TestContext",
 "TestContext",
 "classFromSource: src <String> ^<Class> = (\r	^(ClassDeclarationBuilder fromSource: src) install applyToObject reflectee\r)",
 "conflictError = (\r	^Error\r)",
 "in: collection findMirrorNamed: name = (\r	collection do: [:mirror | mirror name = name ifTrue: [^mirror]].\r	^nil\r)",
 "syntaxError = (\r	^Error\r)",
 "public testAccessModifiersFromClass = (\r	| klass builder |\r	klass:: classFromSource:\r		'class Top = (| public slotA protected slotB private slotC slotD |)(\r			public class ClassA = ()()\r			protected class ClassB = ()()\r			private class ClassC = ()()\r			class ClassD = ()()\r			public methodA = ()\r			protected methodB = ()\r			private methodC = ()\r			methodD = ()\r		)'.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r\r	assert: builder accessModifier equals: #public.\r	assert: (in: builder instanceSide slots findMirrorNamed: #slotA) accessModifier equals: #public.\r	assert: (in: builder instanceSide slots findMirrorNamed: #slotB) accessModifier equals: #protected.\r	assert: (in: builder instanceSide slots findMirrorNamed: #slotC) accessModifier equals: #private.\r	assert: (in: builder instanceSide slots findMirrorNamed: #slotD) accessModifier equals: #protected.\r	assert: (in: builder instanceSide nestedClasses findMirrorNamed: #ClassA) accessModifier equals: #public.\r	assert: (in: builder instanceSide nestedClasses findMirrorNamed: #ClassB) accessModifier equals: #protected.\r	assert: (in: builder instanceSide nestedClasses findMirrorNamed: #ClassC) accessModifier equals: #private.\r	assert: (in: builder instanceSide nestedClasses findMirrorNamed: #ClassD) accessModifier equals: #protected.\r	assert: (in: builder instanceSide methods findMirrorNamed: #methodA) accessModifier equals: #public.\r	assert: (in: builder instanceSide methods findMirrorNamed: #methodB) accessModifier equals: #protected.\r	assert: (in: builder instanceSide methods findMirrorNamed: #methodC) accessModifier equals: #private.\r	assert: (in: builder instanceSide methods findMirrorNamed: #methodD) accessModifier equals: #protected.\r)",
 "public testAccessModifiersFromSource = (\r	| builder |\r	builder:: ClassDeclarationBuilder fromSource:\r		'class Top = (| public slotA protected slotB private slotC slotD |)(\r			public class ClassA = ()()\r			protected class ClassB = ()()\r			private class ClassC = ()()\r			class ClassD = ()()\r			public methodA = ()\r			protected methodB = ()\r			private methodC = ()\r			methodD = ()\r		)'.\r\r	assert: builder accessModifier equals: #public.\r	assert: (in: builder instanceSide slots findMirrorNamed: #slotA) accessModifier equals: #public.\r	assert: (in: builder instanceSide slots findMirrorNamed: #slotB) accessModifier equals: #protected.\r	assert: (in: builder instanceSide slots findMirrorNamed: #slotC) accessModifier equals: #private.\r	assert: (in: builder instanceSide slots findMirrorNamed: #slotD) accessModifier equals: #protected.\r	assert: (in: builder instanceSide nestedClasses findMirrorNamed: #ClassA) accessModifier equals: #public.\r	assert: (in: builder instanceSide nestedClasses findMirrorNamed: #ClassB) accessModifier equals: #protected.\r	assert: (in: builder instanceSide nestedClasses findMirrorNamed: #ClassC) accessModifier equals: #private.\r	assert: (in: builder instanceSide nestedClasses findMirrorNamed: #ClassD) accessModifier equals: #protected.\r	assert: (in: builder instanceSide methods findMirrorNamed: #methodA) accessModifier equals: #public.\r	assert: (in: builder instanceSide methods findMirrorNamed: #methodB) accessModifier equals: #protected.\r	assert: (in: builder instanceSide methods findMirrorNamed: #methodC) accessModifier equals: #private.\r	assert: (in: builder instanceSide methods findMirrorNamed: #methodD) accessModifier equals: #protected.\r)",
 "public testClassDeclAddMethod = (\r	(* add a new method *)\r	|\r	klass <Class>\r	instance\r	builder <ClassDeclarationBuilder>\r	|\r	klass:: classFromSource: 'class EmptyClass = ()()'.\r	instance:: klass new.\r	should: [instance foo: 3] signal: MessageNotUnderstood.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	builder instanceSide methods addFromSource: 'public foo: x = (^x * x)'.\r	should: [instance foo: 3] signal: MessageNotUnderstood.\r	builder install.\r	assert: (instance foo: 3) equals: 9.\r)",
 "public testClassDeclAddNestedClass = (\r	(* add a new nested class decl *)\r	|\r	klass <Class>\r	instance\r	builder <ClassDeclarationBuilder>\r	|\r	klass:: classFromSource: 'class EmptyClass = ()()'.\r	instance:: klass new.\r	should: [instance Nested] signal: MessageNotUnderstood.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	builder instanceSide nestedClasses addFromSource: 'public class Nested = ()( public foo = (^91) )'.\r	should: [instance Nested] signal: MessageNotUnderstood.\r	builder install.\r	assert: instance Nested new foo equals: 91.\r)",
 "public testClassDeclAddSlot = (\r	(* add a new slot *)\r	|\r	klass <Class>\r	instance <Object>\r	builder <ClassDeclarationBuilder>\r	|\r	klass:: classFromSource: 'class EmptyClass = ()()'.\r	instance:: klass new.\r	should: [instance newSlot] signal: MessageNotUnderstood.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	builder header source: 'class EmptyClass = ( | public newSlot ::= 91. | )'.\r	should: [instance newSlot] signal: MessageNotUnderstood.\r	builder install.\r	instance:: klass new.\r	assert: instance newSlot equals: 91.\r	instance newSlot: 101.\r	assert: instance newSlot equals: 101.\r)",
 "public testClassDeclCopyNested = (\r	(* The bug here seems to be the copy doesn't get its qualified name patched. *)\r	|\r	topBuilder <ClassDeclarationBuilder>\r	topClass\r	origBuilder\r	origMirror\r	copyBuilder\r	copySource\r	copyMirror\r	topMirror\r	|\r	topBuilder:: ClassDeclarationBuilder fromSource: 'class Top = ()()'.\r	topClass:: topBuilder install applyToObject reflectee.\r\r	origBuilder:: topBuilder instanceSide nestedClasses addFromSource: 'class TheOriginal = ()()'.\r	origMirror:: origBuilder install.\r	assert: origMirror name equals: 'TheOriginal'.\r	assert: origMirror accessModifier equals: #protected.\r\r	copyBuilder:: ClassDeclarationBuilder fromSource: origMirror source.\r	copyBuilder header name: 'TheCopy'.\r	copySource:: copyBuilder source.\r	copyBuilder:: topBuilder instanceSide nestedClasses addFromSource: copySource.\r	copyMirror:: copyBuilder install.\r	assert: copyMirror name equals: 'TheCopy'.\r	assert: copyMirror accessModifier equals: #protected.\r\r	assert: origMirror name equals: 'TheOriginal'. (* Unchanged *)\r	assert: origMirror accessModifier equals: #protected.\r\r	topMirror:: (ClassMirror reflecting: topClass) mixin declaration.\r	(* Both nested classes are present. *)\r	assert: (in: topMirror instanceSide nestedClasses findMirrorNamed: #TheOriginal) accessModifier equals: #protected.\r	assert: (in: topMirror instanceSide nestedClasses findMirrorNamed: #TheCopy) accessModifier equals: #protected.\r)",
 "public testClassDeclCopyTopLevel = (\r	|\r	origBuilder\r	origMirror\r	origClass\r	copyBuilder\r	copyMirror\r	copyClass\r	|\r	origBuilder:: ClassDeclarationBuilder fromSource: 'class TheOriginal = ()()'.\r	origClass:: origBuilder install applyToObject reflectee.\r	origMirror:: (ClassMirror reflecting: origClass) mixin declaration.\r	assert: origMirror name equals: 'TheOriginal'.\r	assert: origMirror accessModifier equals: #public.\r\r	copyBuilder:: ClassDeclarationBuilder fromSource: origMirror source.\r	copyBuilder header name: 'TheCopy'.\r	copyClass:: copyBuilder install applyToObject reflectee.\r	copyMirror:: (ClassMirror reflecting: copyClass) mixin declaration.\r	assert: copyMirror name equals: 'TheCopy'.\r	assert: copyMirror accessModifier equals: #public.\r\r	assert: origMirror name equals: 'TheOriginal'. (* Unchanged *)\r	assert: origMirror accessModifier equals: #public.\r)",
 "public testClassDeclModifySlot = (\r	(* modify the declaration of an existing slot *)\r	|\r	klass <Class>\r	instance <Object>\r	builder <ClassDeclarationBuilder>\r	|\r	klass:: classFromSource: 'class TestClassDeclModifySlot = ( | public x ::= 117. public y = 0. public z | )()'.\r	instance:: klass new.\r	assert: instance x equals: 117.\r	assert: instance y equals: 0.\r	assert: instance z equals: nil.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	builder header source: 'class TestClassDeclModifySlot = ( | public x ::= 120. public y = 0. public z | )'.\r	assert: instance x equals: 117.\r	assert: instance y equals: 0.\r	assert: instance z equals: nil.\r	builder install.\r	assert: instance x equals: 117.\r	assert: instance y equals: 0.\r	assert: instance z equals: nil.\r	instance:: klass new.\r	assert: instance x equals: 120.\r	assert: instance y equals: 0.\r	assert: instance z equals: nil.\r)",
 "public testClassDeclRemoveMethod = (\r	(* remove an existing method *)\r	|\r	klass <Class>\r	instance\r	builder <ClassDeclarationBuilder>\r	|\r	klass:: classFromSource: 'class TestClassDeclRemoveMethod = ()(\r		public foo = (^91)\r		public bar = (^42)\r	)'.\r	instance:: klass new.\r	assert: instance foo equals: 91.\r	assert: instance bar equals: 42.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	builder instanceSide methods removeMirrorNamed: #foo.\r	assert: instance foo equals: 91.\r	assert: instance bar equals: 42.\r	builder install.\r	should: [instance foo] signal: MessageNotUnderstood.\r	assert: instance bar equals: 42.\r)",
 "public testClassDeclRemoveNestedClass = (\r	(* remove an existing nested class *)\r	|\r	klass <Class>\r	instance\r	builder <ClassDeclarationBuilder>\r	|\r	klass:: classFromSource: 'class TestClassDeclRemoveNestedClass = ()(\r		public class Nested = ()() : ( public foo = (^70) )\r	)'.\r	instance:: klass new.\r	assert: instance Nested foo equals: 70.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	builder instanceSide nestedClasses removeMirrorNamed: #Nested.\r	assert: instance Nested foo equals: 70.\r	builder install.\r	should: [instance Nested] signal: MessageNotUnderstood.\r)",
 "public testClassDeclRemoveNonExistentMethod = (\r	(* remove a non-existing method. The effect should be to do nothing, so our only goal here is to run without error *)\r	|\r	klass <Class>\r	builder <ClassDeclarationBuilder>\r	|\r	klass:: classFromSource: 'class TestClassDeclRemoveMethod = ()(\r		foo = (^91)\r	      bar = (^42)\r	)'.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	builder instanceSide methods removeMirrorNamed: #baz.\r)",
 "public testClassDeclRemoveNonExistentNestedClass = (\r	(* remove a non-existing nested class. The effect should be to do nothing, so our only goal here is to run without error *)\r	|\r	klass <Class>\r	builder <ClassDeclarationBuilder>\r	|\r	klass:: classFromSource: 'class TestClassDeclRemoveNonExistantNestedClass = ()()'.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	builder instanceSide nestedClasses removeMirrorNamed: #Nested.\r)",
 "public testClassDeclRemoveSlot = (\r	(* remove an existing slot *)\r	|\r	klass <Class>\r	instance\r	builder <ClassDeclarationBuilder>\r	|\r	klass:: classFromSource: 'class TestClassDeclRemoveSlot = ( | public x ::= 117. public y = 0. public z | )()'.\r	instance:: klass new.\r	assert: instance x equals: 117.\r	assert: instance y equals: 0.\r	assert: instance z equals: nil.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	builder header source: 'class TestClassDeclRemoveSlot = ( | public x ::= 117. public y = 0. | )'.\r	assert: instance x equals: 117.\r	assert: instance y equals: 0.\r	assert: instance z equals: nil.\r	builder install.\r	assert: instance x equals: 117.\r	assert: instance y equals: 0.\r	should: [instance z] signal: MessageNotUnderstood.\r)",
 "public testClassDeclRenameNested = (\r	|\r	enclosingBuilder <ClassDeclarationBuilder>\r	enclosingClass\r	cls\r	builder\r	|\r	enclosingBuilder:: ClassDeclarationBuilder fromSource:\r'class Enclosing = ()(\r	class OldName = ()()\r	public getOldName = (^self OldName)\r)'.\r	enclosingClass:: enclosingBuilder install applyToObject reflectee.\r	cls:: enclosingClass new getOldName.\r\r	assert: (ClassMirror reflecting: cls) mixin name equals: 'OldName'.\r	assert: (ClassMirror reflecting: cls) mixin declaration accessModifier equals: #protected.\r\r	builder:: (ClassMirror reflecting: cls) mixin declaration asBuilder.\r	builder header name: 'NewName'.\r	builder install.\r\r	assert: (ClassMirror reflecting: cls) mixin name equals: 'NewName'.\r	assert: (ClassMirror reflecting: cls) mixin declaration accessModifier equals: #protected.\r)",
 "public testClassDeclRenameNestedPrivate = (\r	|\r	enclosingBuilder <ClassDeclarationBuilder>\r	enclosingClass\r	cls\r	builder\r	|\r	enclosingBuilder:: ClassDeclarationBuilder fromSource:\r'class Enclosing = ()(\r	private class OldName = ()()\r	public getOldName = (^self OldName)\r)'.\r	enclosingClass:: enclosingBuilder install applyToObject reflectee.\r	cls:: enclosingClass new getOldName.\r\r	assert: (ClassMirror reflecting: cls) mixin name equals: 'OldName'.\r	assert: (ClassMirror reflecting: cls) mixin declaration accessModifier equals: #private.\r\r	builder:: (ClassMirror reflecting: cls) mixin declaration asBuilder.\r	builder header name: 'NewName'.\r	builder install.\r\r	assert: (ClassMirror reflecting: cls) mixin name equals: 'NewName'.\r	assert: (ClassMirror reflecting: cls) mixin declaration accessModifier equals: #private.\r)",
 "public testClassDeclRenameTopLevel = (\r	|\r	builder <ClassDeclarationBuilder>\r	cls\r	builder2\r	|\r	builder:: ClassDeclarationBuilder fromSource: 'class OldName = ()()'.\r	cls:: builder install applyToObject reflectee.\r\r	assert: (ClassMirror reflecting: cls) mixin name equals: 'OldName'.\r	assert: (ClassMirror reflecting: cls) mixin declaration accessModifier equals: #public.\r\r	builder2:: (ClassMirror reflecting: cls) mixin declaration asBuilder.\r	builder2 header name: 'NewName'.\r	builder2 install.\r\r	assert: (ClassMirror reflecting: cls) mixin name equals: 'NewName'.\r	assert: (ClassMirror reflecting: cls) mixin declaration accessModifier equals: #public.\r)",
 "public testClassDeclReplaceMethod = (\r	(* replace an existing method *)\r	|\r	klass <Class>\r	instance\r	builder <ClassDeclarationBuilder>\r	|\r	klass:: classFromSource: 'class TestClassDeclReplaceMethod = ()(\r		public foo = (^#before)\r	)'.\r	instance:: klass new.\r	assert: instance foo equals: #before.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	builder instanceSide methods addFromSource: 'public foo = (^#after)'.\r	assert: instance foo equals: #before.\r	builder install.\r	assert: instance foo equals: #after.\r)",
 "public testClassDeclReplaceNestedClass = (\r	(* replace an existing nested class *)\r	|\r	builder\r	klass\r	instance\r	nestedKlass\r	|\r\r	klass:: classFromSource: 'class TestClassDeclReplaceNestedClass = ()(\r		public class Nested = ()() : ( public foo = (^#before) )\r	)'.\r	instance:: klass new.\r	nestedKlass:: instance Nested.\r	assert: nestedKlass foo equals: #before.\r	assert: instance Nested foo equals: #before.\r\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	builder instanceSide nestedClasses addFromSource:\r'public class Nested = ()() : ( public foo = (^#after) )'.\r	assert: nestedKlass foo equals: #before.\r	assert: instance Nested foo equals: #before.\r\r	builder install.\r	assert: nestedKlass foo equals: #before.\r	assert: instance Nested foo equals: #before.\r\r	assert: klass new Nested foo equals: #after.\r)",
 "public testClassDeclReplaceSlot = (\r	(* replace an existing slot *)\r	|\r	klass <Class>\r	instance <Object>\r	builder <ClassDeclarationBuilder>\r	|\r	klass:: classFromSource: 'class TestClassDeclReplaceSlot = ( | public x ::= 117. public y = 0. public z | )()'.\r	instance:: klass new.\r	assert: instance x equals: 117.\r	assert: instance y equals: 0.\r	assert: instance z equals: nil.\r	should: [instance a] signal: MessageNotUnderstood.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	builder header source: 'class TestClassDeclReplaceSlot = ( | public a ::= 120. public y = 0. public z | )'.\r	assert: instance x equals: 117.\r	assert: instance y equals: 0.\r	assert: instance z equals: nil.\r	should: [instance a] signal: MessageNotUnderstood.\r	builder install.\r	should: [instance x] signal: MessageNotUnderstood.\r	assert: instance y equals: 0.\r	assert: instance z equals: nil.\r	assert: instance a equals: nil.\r	instance:: klass new.\r	should: [instance x] signal: MessageNotUnderstood.\r	assert: instance y equals: 0.\r	assert: instance z equals: nil.\r	assert: instance a equals: 120.\r)",
 "public testClassDeclSource = (\r	(* Note: We preserve exact class headers and methods, but not whole class declarations. *)\r	|\r	headerSource\r	nestedHeaderSource\r	methodSource\r	klass <Class>\r	builder <ClassDeclarationBuilder>\r	mirror <ClassMirror>\r	|\r\r	headerSource:: 'class Foo = (\r		|\r		bar\r		baz\r		|\r	)'.\r	nestedHeaderSource:: 'class Nested = (\r		| hest fisk |\r	)'.\r	methodSource:: 'public main = ()'.\r\r	builder:: ClassDeclarationBuilder fromSource:\r		headerSource, '(', nestedHeaderSource, '()', methodSource, ')'.\r	assert: (builder source indexOf: headerSource) > 0.\r	assert: (builder source indexOf: nestedHeaderSource) > 0.\r	assert: (builder source indexOf: methodSource) > 0.\r\r	klass:: builder install applyToObject reflectee.\r	mirror:: ClassMirror reflecting: klass.\r	assert: (mirror mixin declaration source indexOf: headerSource) > 0.\r	assert: (mirror mixin declaration source indexOf: nestedHeaderSource) > 0.\r	assert: (mirror mixin declaration source indexOf: methodSource) > 0.\r\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	assert: (builder source indexOf: headerSource) > 0.\r	assert: (builder source indexOf: nestedHeaderSource) > 0.\r	assert: (builder source indexOf: methodSource) > 0.\r)",
 "public testClassHeaderComment = (\r	(* Note: We preserve exact class headers and methods, but not whole class declarations. *)\r	|\r	comment\r	headerSource\r	klass <Class>\r	builder <ClassDeclarationBuilder>\r	mirror <ClassMirror>\r	|\r\r	comment:: ' This is the (* nested *) comment. '.\r	headerSource:: 'class Foo = (\r		(*', comment, '*)\r	)'.\r\r	builder:: ClassDeclarationBuilder fromSource: headerSource, '()'.\r	assert: builder header classComment equals: comment.\r\r	klass:: builder install applyToObject reflectee.\r	mirror:: ClassMirror reflecting: klass.\r	assert: mirror mixin declaration header classComment equals: comment.\r\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	assert: builder header classComment equals: comment.\r)",
 "public testClassHeaderPreamble = (\r	(* Note: We preserve exact class headers and methods, but not whole class declarations. *)\r	|\r	preamble\r	headerSource\r	klass <Class>\r	builder <ClassDeclarationBuilder>\r	mirror <ClassMirror>\r	|\r\r	preamble:: 'class Foo foo: x = Bar bar: x'.\r	headerSource:: preamble, ' (\r		|\r		bar\r		baz\r		|\r	)'.\r\r	builder:: ClassDeclarationBuilder fromSource: headerSource, '()'.\r	assert: builder header preamble equals: preamble.\r\r	klass:: builder install applyToObject reflectee.\r	mirror:: ClassMirror reflecting: klass.\r	assert: mirror mixin declaration header preamble equals: preamble.\r\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	assert: builder header preamble equals: preamble.\r)",
 "public testClassHeaderSource = (\r	(* Note: We preserve exact class headers and methods, but not whole class declarations. *)\r	|\r	headerSource\r	klass <Class>\r	builder <ClassDeclarationBuilder>\r	mirror <ClassMirror>\r	|\r\r	headerSource:: 'class Foo = (\r		|\r		bar\r		baz\r		|\r	)'.\r\r	builder:: ClassDeclarationBuilder fromSource: headerSource, '()'.\r	assert: builder header source equals: headerSource.\r\r	klass:: builder install applyToObject reflectee.\r	mirror:: ClassMirror reflecting: klass.\r	assert: mirror mixin declaration header source equals: headerSource.\r\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	assert: builder header source equals: headerSource.\r)",
 "public testConflictingFactoryOverMethod = (\r	| builder |\r	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = ()() : ( foo = () )'.\r	should: [builder header source: 'class Conflicted foo = ()'] signal: conflictError.\r)",
 "public testConflictingMethodOverFactory = (\r	| builder |\r	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted foo = ()()'.\r	should: [builder classSide methods addFromSource: 'foo = ()'] signal: conflictError.\r)",
 "public testConflictingMethodOverNestedClass = (\r	| builder |\r	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = ()(\r		class foo = ()()\r	)'.\r	should: [builder instanceSide methods addFromSource: 'foo = ()'] signal: conflictError.\r)",
 "public testConflictingMethodOverSlot = (\r	| builder |\r	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = (| foo bar = 1. |)()'.\r	should: [builder instanceSide methods addFromSource: 'foo = ()'] signal: conflictError.\r	should: [builder instanceSide methods addFromSource: 'foo: x = ()'] signal: conflictError.\r	should: [builder instanceSide methods addFromSource: 'bar = ()'] signal: conflictError.\r	builder instanceSide methods addFromSource: 'bar: x = ()'.\r)",
 "public testConflictingNestedClassFromRename = (\r	| builder nested |\r	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = ()(\r		class Nested1 = ()()\r		class Nested2 = ()()\r	)'.\r	nested:: in: builder instanceSide nestedClasses findMirrorNamed: #Nested1.\r	should: [nested name: #Nested1] signal: conflictError.\r)",
 "public testConflictingNestedClassOverMethod = (\r	| builder |\r	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = ()( foo = () )'.\r	should: [builder instanceSide nestedClasses addFromSource: 'class foo = ()()'] signal: conflictError.\r)",
 "public testConflictingNestedClassOverMethodFromRename = (\r	| builder nested |\r	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = ()(\r		class Nested = ()()\r		foo = ()\r	)'.\r	nested:: in: builder instanceSide nestedClasses findMirrorNamed: #Nested.\r	should: [nested name: #foo] signal: conflictError.\r)",
 "public testConflictingNestedClassOverSlot = (\r	| builder |\r	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = (| foo |)()'.\r	should: [builder instanceSide nestedClasses addFromSource: 'class foo = ()()'] signal: conflictError.\r)",
 "public testConflictingNestedClassOverSlotFromRename = (\r	| builder nested |\r	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = (| foo |)(\r		class Nested = ()()\r	)'.\r	nested:: in: builder instanceSide nestedClasses findMirrorNamed: #Nested.\r	should: [nested name: #foo] signal: conflictError.\r)",
 "public testConflictingSlotOverMethod = (\r	| builder |\r	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = ()(\r		foo = ()\r	)'.\r	should: [builder header source: 'Conflicted = (| foo |)'] signal: conflictError.\r)",
 "public testConflictingSlotOverNestedClass = (\r	| builder |\r	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = ()(\r		class foo = ()()\r	)'.\r	should: [builder header source: 'Conflicted = (| foo |)'] signal: conflictError.\r)",
 "public testEvaluateEmptyString = (\r	| thread |\r	thread:: (ObjectMirror reflecting: self) evaluate: ''.\r	assert: thread isFulfilled.\r	assert: thread result reflectee equals: self.\r)",
 "public testEvaluateWithScope = (\r	| scope thread |\r	scope:: Map new.\r	scope at: #x put: (ObjectMirror reflecting: 42).\r	scope at: #y put: (ObjectMirror reflecting: 2).\r	thread:: (ObjectMirror reflecting: self) evaluate: 'x - y' with: scope.\r	assert: thread isFulfilled.\r	assert: thread result reflectee equals: 40.\r)",
 "public testIncrementalScopeBuilding = (\r	(* add a new method *)\r	|\r	builder <ClassDeclarationBuilder>\r	klass <Class>\r	ooter\r	inner\r	thread\r	|\r	builder:: ClassDeclarationBuilder fromSource:\r'class Outer = ( | public outerSlot = 1. | )(\r	public class Inner = ( | public innerSlot = 3. | )(\r		public class InnerInner = ()()\r		public innerMethod = (^4)\r	)\r	public class Sibling = ()()\r	public outerMethod = (^2)\r)'.\r	klass:: builder install applyToObject reflectee.\r	ooter:: klass new.\r	inner:: ooter Inner new.\r\r	(* Incremental eval *)\r	thread:: (ObjectMirror reflecting: inner) evaluate:\r		'{outer Outer. outerSlot. outerMethod. outer Inner. innerSlot. innerMethod. Inner. Sibling. InnerInner}'.\r	assert: thread isFulfilled.\r	assertList: thread result reflectee equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner. ooter Sibling. inner InnerInner.}.\r\r	(* Incremental method *)\r	(in: builder instanceSide nestedClasses findMirrorNamed: #Inner) instanceSide methods addFromSource: 'public testMethod = (^{outer Outer. outerSlot. outerMethod. outer Inner. innerSlot. innerMethod. Inner. Sibling. InnerInner})'.\r	builder install.\r	assertList: inner testMethod equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner. ooter Sibling. inner InnerInner.}.\r\r	(* Incremental header *)\r	(in: builder instanceSide nestedClasses findMirrorNamed: #Inner) header source: 'public class Inner = ( | public innerSlot = 33. public testSlot = {outer Outer. outerSlot. outerMethod. outer Inner. innerSlot. innerMethod. Inner. Sibling. InnerInner}. |)'.\r	builder install.\r	inner:: ooter Inner new.\r	assertList: inner testSlot equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner. ooter Sibling. inner InnerInner.}.\r\r	(* Incremental nested class *)\r	builder instanceSide nestedClasses addFromSource: 'public class Inner2 = ( | public innerSlot = 333. | )(\r		public class InnerInner = ()()\r		public innerMethod = (^444)\r		public testMethod = (^{outer Outer. outerSlot. outerMethod. outer Inner2. innerSlot. innerMethod. Inner2. Sibling. InnerInner})\r	)'.\r	builder install.\r	inner:: ooter Inner2 new.\r	assertList: inner testMethod equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner2. ooter Sibling. inner InnerInner.}.\r)",
 "public testInstallAfterConflictErrorFactory = (\r	| klass builder |\r	klass:: classFromSource: 'class TestInstallAfterConflictErrorFactory factory = ()( public foo = (^1) )'.\r	assert: klass factory foo equals: 1.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	should: [builder classSide methods addFromSource: 'public factory = (^#wrong)'] signal: conflictError.\r	builder install.\r	assert: klass factory foo equals: 1. (* Unchanged. *)\r)",
 "public testInstallAfterConflictErrorMethod = (\r	| klass instance builder |\r	klass:: classFromSource: 'class TestInstallAfterConflictErrorMethod = ()( public foo = (^1) )'.\r	instance:: klass new.\r	assert: instance foo equals: 1.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	should: [builder header source: 'TestInstallAfterConflictErrorMethod = (| foo |)'] signal: conflictError.\r	builder install.\r	assert: instance foo equals: 1. (* Unchanged. *)\r)",
 "public testInstallAfterConflictErrorNestedClass = (\r	| klass instance builder |\r	klass:: classFromSource: 'class TestInstallAfterConflictErrorNestedClass = ()(\r		public class Nested = ()() : ( public foo = (^1) )\r	)'.\r	instance:: klass new.\r	assert: instance Nested foo equals: 1.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	should: [builder instanceSide addFromSource: 'public Nested = (^#wrong)'] signal: conflictError.\r	builder install.\r	assert: instance Nested foo equals: 1. (* Unchanged. *)\r)",
 "public testInstallAfterConflictErrorSlot = (\r	| klass instance builder |\r	klass:: classFromSource: 'class TestInstallAfterConflictErrorSlot = (| public foo = 1. |)()'.\r	instance:: klass new.\r	assert: instance foo equals: 1.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	should: [builder header source: 'TestInstallAfterConflictErrorSlot = (| foo |)'] signal: conflictError.\r	builder install.\r	assert: instance foo equals: 1. (* Unchanged. *)\r)",
 "public testInstallAfterSyntaxErrorHeader = (\r	| klass instance builder |\r	klass:: classFromSource: 'class TestInstallAfterSyntaxErrorHeader = (| public foo = 1. |)()'.\r	instance:: klass new.\r	assert: instance foo equals: 1.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	should: [builder header source: 'class TestInstallAfterSyntaxErrorHeader = (;;syntax error;;)()'] signal: syntaxError.\r	builder install.\r	assert: instance foo equals: 1. (* Unchanged. *)\r)",
 "public testInstallAfterSyntaxErrorMethod = (\r	| klass instance builder |\r	klass:: classFromSource: 'class TestInstallAfterSyntaxErrorMethod = ()( public foo = (^1) )'.\r	instance:: klass new.\r	assert: instance foo equals: 1.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	should: [builder instanceSide methods addFromSource: 'public foo = (^2 ;;syntax error;;)'] signal: syntaxError.\r	builder install.\r	assert: instance foo equals: 1. (* Unchanged. *)\r)",
 "public testInstallAfterSyntaxErrorNestedClass = (\r	| klass builder |\r	klass:: classFromSource: 'class TestInstallAfterSyntaxErrorNestedClass = ()(\r		public class Nested = ()() : ( public foo = (^1) )\r	)'.\r	assert: klass new Nested foo equals: 1.\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	should: [builder instanceSide nestedClasses addFromSource: 'class Nested = (;;syntax error;;)()'] signal: syntaxError.\r	builder install.\r	assert: klass new Nested foo equals: 1. (* Unchanged. *)\r)",
 "public testMethodSource = (\r	(* Note: We preserve exact class headers and methods, but not whole class declarations. *)\r	|\r	methodSource\r	klass <Class>\r	builder <ClassDeclarationBuilder>\r	mirror <ClassMirror>\r	|\r\r	methodSource:: 'private foo = (\r		^bar baz\r	)'.\r\r	builder:: ClassDeclarationBuilder fromSource: 'class C = ()(', methodSource, ')'.\r	assert: (in: builder instanceSide methods findMirrorNamed: #foo) source equals: methodSource.\r\r	klass:: builder install applyToObject reflectee.\r	mirror:: ClassMirror reflecting: klass.\r	assert: (in: mirror mixin methods findMirrorNamed: #foo) source equals: methodSource.\r\r	builder:: (ClassMirror reflecting: klass) mixin declaration asBuilder.\r	assert: (in: builder instanceSide methods findMirrorNamed: #foo) source equals: methodSource.\r)",
 "public testNewNestedClassSeenInSubclass = (\r	(* Note that the superclass and subclass must be part of separate modules. Otherwise this test will pass by virtue of the common enclosing class being dirty, and here we want to test that subclasses tracking is working. *)\r	|\r	Super <Class>\r	enclosing <Class>\r	klass <Class>\r	instance <Object>\r	builder <ClassDeclarationBuilder>\r	|\r	Super:: classFromSource: 'class Super = ()()'.\r	enclosing:: classFromSource: 'class Enclosing withSuper: s = ( | Super = s. | )(\r		public class Sub = Super ()(\r			public class OldNested = ()()\r		)\r	)'.\r	klass:: (enclosing withSuper: Super) Sub.\r	instance:: klass new.\r	assert: instance OldNested isKindOfBehavior.\r	should: [instance NewNested] signal: MessageNotUnderstood.\r\r	builder:: (ClassMirror reflecting: klass) superclass mixin declaration asBuilder.\r	builder instanceSide nestedClasses addFromSource: 'public class NewNested = ()()'.\r\r	assert: instance OldNested isKindOfBehavior.\r	should: [instance NewNested] signal: MessageNotUnderstood.\r\r	builder install.\r\r	assert: instance OldNested isKindOfBehavior.\r	assert: instance NewNested isKindOfBehavior.\r	deny: instance OldNested equals: instance NewNested. (* Should not alias slot. *)\r\r	instance:: klass new.\r	assert: instance OldNested isKindOfBehavior.\r	assert: instance NewNested isKindOfBehavior.\r	deny: instance OldNested equals: instance NewNested. (* Should not alias slot. *)\r)",
 "public testNewSlotSeenInSubclass = (\r	(* Note that the superclass and subclass must be part of separate modules. Otherwise this test will pass by virtue of the common enclosing class being dirty, and here we want to test that subclasses tracking is working. *)\r	|\r	Super <Class>\r	enclosing <Class>\r	klass <Class>\r	instance <Object>\r	builder <ClassDeclarationBuilder>\r	|\r	Super:: classFromSource: 'class Super = ()()'.\r	enclosing:: classFromSource: 'class Enclosing withSuper: s = ( | Super = s. | )(\r		public class Sub = Super ( | public oldSlot ::= 43. | )()\r	)'.\r	klass:: (enclosing withSuper: Super) Sub.\r	instance:: klass new.\r	assert: instance oldSlot equals: 43.\r	should: [instance newSlot] signal: MessageNotUnderstood.\r\r	builder:: (ClassMirror reflecting: klass) superclass mixin declaration asBuilder.\r	builder header source: 'class Super = ( | public newSlot ::= 47. | )'.\r\r	assert: instance oldSlot equals: 43.\r	should: [instance newSlot] signal: MessageNotUnderstood.\r\r	builder install.\r\r	assert: instance oldSlot equals: 43.\r	assert: instance newSlot equals: nil.\r	instance newSlot: 98.\r	assert: instance newSlot equals: 98.\r	assert: instance oldSlot equals: 43. (* Not aliased by newSlot. *)\r\r	instance:: klass new.\r	assert: instance oldSlot equals: 43.\r	assert: instance newSlot equals: 47.\r)",
 "TEST_CONTEXT = ()",
 "class MirrorBuilderTestingConfiguration packageTestsUsing: manifest = (|\rprivate MirrorBuilderTesting = manifest MirrorBuilderTesting.\r|)",
 " ",
 " ",
 "public testModulesUsingPlatform: p minitest: m = (\r	^{MirrorBuilderTesting usingPlatform: p minitest: m}\r)",
 "class ActivationMirrorTesting usingPlatform: p minitest: m = (|\rprivate ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.\rprivate ObjectMirror = p mirrors ObjectMirror.\rprivate ActivationMirror = p mirrors ActivationMirror.\rprivate Message = p kernel Message.\rprivate List = p collections List.\rprivate Map = p collections Map.\rprivate TestContext = m TestContext.\r|)",
 " ",
 " ",
 "baz = (\r	^'enclosing'\r)",
 "foo = (\r	^'enclosing'\r)",
 "fooWithArg: n = (\r	^'enclosing'\r)",
 "public class ActivationTests = TestBase ()",
 "TestBase",
 "TestBase",
 "add: x to: y = (\r	| z |\r	z:: x + y.\r	^z\r)",
 "assertSlotsOf: activation haveNamesAndValues: pairs = (\r	| slots success |\r	slots:: activation slots.\r	success:: true.\r	1 to: pairs size / 2 do:\r		[:index | | name value |\r		name:: pairs at: index * 2 - 1.\r		value:: pairs at: index * 2.\r		assert: (slots at: index) name equals: name.\r		assert: (slots at: index) value reflectee equals: value].\r)",
 "assertThread: thread atMethod: expectedMethod snippet: expectedSnippet = (\r	| activation |\r	activation:: thread suspendedActivation.\r	assert: activation method name equals: expectedMethod.\r	assert: (currentSnippet: activation) equals: expectedSnippet.\r)",
 "compilationError = (\r	^Error\r)",
 "currentSnippet: activation = (\r	| range |\r	range:: activation sourceRange.\r	nil = range ifTrue: [^nil].\r	^activation method source copyFrom: range start to: range stop\r)",
 "deadHomeWithLocals: a = (\r	| b c d |\r	b:: 2. (* Not copied *)\r	c:: 3. (* Copied *)\r	d:: 4. (* Indirect *)\r	^[d:: d + c]\r)",
 "liveHomeWithLocals: a = (\r	| b c d |\r	b:: 2. (* Not copied *)\r	c:: 3. (* Copied *)\r	d:: 4. (* Indirect *)\r	^[d:: d + c] value\r)",
 "nlr1 = (\r	^nlr2\r)",
 "nlr2 = (\r	nlr3: [^2].\r	^20\r)",
 "nlr3: block = (\r	block value.\r	^3\r)",
 "quickResumeReturnAcrossBoundry = (\r	| closure thread activation |\r	closure:: [^'escaping simulation!'].\r	thread:: ActivationMirror invokeSuspended: closure.\r	assert: thread isSuspended.\r	activation:: thread suspendedActivation.\r	assert: activation closure equals: (ObjectMirror reflecting: closure).\r	assert: activation receiver equals: (ObjectMirror reflecting: self).\r	assert: activation method name equals: #quickResumeReturnAcrossBoundry.\r	assert: activation sender equals: nil.\r\r	thread resume.\r\r	assert: thread isBroken.\r	assert: (thread result reflectee printString startsWith: 'CannotReturn').\r	assert: thread suspendedActivation method name equals: #cannotReturn:.\r	assert: thread suspendedActivation sender equals: activation.\r\r	^'expected return'\r)",
 "seven = (\r	^[3 + 4]\r)",
 "seventySeven = (\r	^[(add: 3 to: 4) + (add: 30 to: 40)]\r)",
 "stackOf: thread = (\r	| names activation |\r	names:: List new.\r	activation:: thread suspendedActivation.\r	[nil = activation] whileFalse:\r		[names add: activation method name.\r		 activation:: activation sender].\r	^names\r)",
 "public testActivationEquality = (\r	| closure thread activation1 activation2 activation3 |\r	closure:: [seven].\r	thread:: ActivationMirror invokeSuspended: closure.\r	assert: thread isSuspended.\r	activation1:: thread suspendedActivation.\r\r	thread stepInto. (* Send seven *)\r\r	activation2:: thread suspendedActivation.\r	activation3:: activation2 sender.\r\r	assert: activation1 method name equals: #testActivationEquality.\r	assert: activation2 method name equals: #seven.\r	assert: activation3 method name equals: #testActivationEquality.\r\r	assert: activation1 equals: activation3.\r	assert: activation1 hash equals: activation3 hash.\r\r	deny: activation1 equals: activation2.\r	deny: activation2 equals: activation3.\r)",
 "public testActivationEvaluate = (\r	| closure thread activation eval |\r	closure:: [add: 3 to: 4].\r	thread:: ActivationMirror invokeSuspended: closure.\r	assert: thread isSuspended.\r	thread stepInto. (* Push 3 *)\r	thread stepInto. (* Push 4 *)\r	thread stepInto. (* Send add:to: *)\r	activation:: thread suspendedActivation.\r	assert: activation receiver equals: (ObjectMirror reflecting: self).\r	assert: activation method name equals: #add:to:.\r\r	eval:: activation evaluate: 'x'.\r	assert: eval isFulfilled.\r	assert: eval result reflectee equals: 3.\r\r	eval:: activation evaluate: 'y'.\r	assert: eval isFulfilled.\r	assert: eval result reflectee equals: 4.\r\r	eval:: activation evaluate: 'z'.\r	assert: eval isFulfilled.\r	assert: eval result reflectee equals: nil.\r\r	eval:: activation evaluate: 'self'.\r	assert: eval isFulfilled.\r	assert: eval result reflectee equals: self.\r\r	should: [activation evaluate: '++'] signal: compilationError.\r\r	eval:: activation evaluate: 'w'.\r	assert: eval isBroken.\r	assert: eval result getClass mixin name equals: 'MessageNotUnderstood'.\r)",
 "public testActivationEvaluateEnclosingLocals = (\r	| x closure thread activation eval |\r	x:: 3. (* Not captured *)\r	closure:: [nil].\r	thread:: ActivationMirror invokeSuspended: closure.\r\r	activation:: thread suspendedActivation.\r	assert: activation receiver equals: (ObjectMirror reflecting: self).\r	assert: activation closure equals: (ObjectMirror reflecting: closure).\r	assert: activation method name equals: #testActivationEvaluateEnclosingLocals.\r\r	eval:: activation evaluate: 'x'.\r	assert: eval isFulfilled.\r	assert: eval result reflectee equals: 3.\r\r	eval:: activation evaluate: 'x: 4'.\r	assert: eval isFulfilled.\r	assert: eval result reflectee equals: 4.\r	assert: x equals: 4.\r)",
 "public testActivationEvaluateWithScope = (\r	| closure thread activation scope eval |\r	closure:: [add: 3 to: 4].\r	thread:: ActivationMirror invokeSuspended: closure.\r	assert: thread isSuspended.\r	thread stepInto. (* Push 3 *)\r	thread stepInto. (* Push 4 *)\r	thread stepInto. (* Send add:to: *)\r	activation:: thread suspendedActivation.\r	assert: activation receiver equals: (ObjectMirror reflecting: self).\r	assert: activation method name equals: #add:to:.\r\r	scope:: Map new.\r	scope at: #w put: (ObjectMirror reflecting: 10).\r	eval:: activation evaluate: 'x + y + w' with: scope.\r	assert: eval isFulfilled.\r	assert: eval result reflectee equals: 17.\r)",
 "public testActivationLocals = (\r	| closure thread activation locals |\r	closure:: [add: 3 to: 4].\r	thread:: ActivationMirror invokeSuspended: closure.\r	assert: thread isSuspended.\r\r	thread stepInto. (* Push 3 *)\r	thread stepInto. (* Push 4 *)\r	thread stepInto. (* Send add:to: *)\r\r	assertSlotsOf: thread suspendedActivation\r		haveNamesAndValues: {#x. 3. #y. 4. #z. nil}.\r\r	thread stepInto. (* Send x *)\r\r	assertSlotsOf: thread suspendedActivation\r		haveNamesAndValues: {#x. 3. #y. 4. #z. nil}.\r\r	thread stepInto. (* Send y *)\r\r	assertSlotsOf: thread suspendedActivation\r		haveNamesAndValues: {#x. 3. #y. 4. #z. nil}.\r\r	thread stepInto. (* Send + y *)\r\r	assertSlotsOf: thread suspendedActivation\r		haveNamesAndValues: {#x. 3. #y. 4. #z. nil}.\r\r	thread stepInto. (* Send z: *)\r\r	assertSlotsOf: thread suspendedActivation\r		haveNamesAndValues: {#x. 3. #y. 4. #z. 7}.\r\r	thread stepInto. (* Send z *)\r\r	assertSlotsOf: thread suspendedActivation\r		haveNamesAndValues: {#x. 3. #y. 4. #z. 7}.\r\r	thread stepInto. (* Return top *)\r	thread stepInto. (* Return top *)\r\r	assert: thread isFulfilled.\r)",
 "public testActivationLocalsDeadHome = (\r	| closure thread activation locals |\r	closure:: deadHomeWithLocals: 1.\r	thread:: ActivationMirror invokeSuspended: closure.\r	assert: thread isSuspended.\r\r	assertSlotsOf: thread suspendedActivation\r		haveNamesAndValues: {#a. nil. #b. nil. #c. nil. #d. nil}.\r\r	thread stepInto. (* Push d *)\r	thread stepInto. (* Push c *)\r	thread stepInto. (* Send + *)\r	thread stepInto. (* Store d *)\r\r	assertSlotsOf: thread suspendedActivation\r		haveNamesAndValues: {#a. nil. #b. nil. #c. nil. #d. nil}.\r\r	thread stepInto. (* Return top *)\r\r	assert: thread isFulfilled.\r)",
 "public testActivationLocalsLiveHome = (\r	| closure thread activation locals |\r	closure:: [liveHomeWithLocals: 1].\r	thread:: ActivationMirror invokeSuspended: closure.\r	assert: thread isSuspended.\r\r	thread stepInto. (* Push 1 *)\r	thread stepInto. (* Send liveHomeWithLocals: *)\r\r	assertSlotsOf: thread suspendedActivation\r		haveNamesAndValues: {#a. 1. #b. nil. #c. nil. #d. nil}.\r\r	thread stepInto. (* Push new array *)\r	thread stepInto. (* PopInto vector *)\r	thread stepInto. (* Push 2 *)\r	thread stepInto. (* PopInto b *)\r	thread stepInto. (* Push 3 *)\r	thread stepInto. (* PopInto c *)\r	thread stepInto. (* Push 4 *)\r	thread stepInto. (* PopIntoVector d *)\r\r	assertSlotsOf: thread suspendedActivation\r		haveNamesAndValues: {#a. 1. #b. 2. #c. 3. #d. 4}.\r\r	thread stepInto. (* Push vector (copied) *)\r	thread stepInto. (* Push c (copied) *)\r	thread stepInto. (* Push closure *)\r	thread stepInto. (* Send value *)\r\r	assertSlotsOf: thread suspendedActivation\r		haveNamesAndValues: {#a. 1. #b. 2. #c. 3. #d. 4}.\r\r	thread stepInto. (* Push d *)\r	thread stepInto. (* Push c *)\r	thread stepInto. (* Send + *)\r	thread stepInto. (* Store d *)\r\r	assertSlotsOf: thread suspendedActivation\r		haveNamesAndValues: {#a. 1. #b. 2. #c. 3. #d. 7}.\r\r	thread stepInto. (* Return top *)\r	thread stepInto. (* Return top *)\r	thread stepInto. (* Return top *)\r\r	assert: thread isFulfilled.\r)",
 "public testActivationSourceRange = (\r	| closure thread activation |\r	closure:: [add: 3 to: 4].\r	thread:: ActivationMirror invokeSuspended: closure.\r	assert: thread isSuspended.\r\r	assert: (currentSnippet: thread suspendedActivation) equals: '3'.\r	thread stepInto. (* Push 3 *)\r\r	assert: (currentSnippet: thread suspendedActivation) equals: '4'.\r	thread stepInto. (* Push 4 *)\r\r	assert: (currentSnippet: thread suspendedActivation) equals: 'add: 3 to: 4'.\r	thread stepInto. (* Send add:to: *)\r\r	assert: (currentSnippet: thread suspendedActivation) equals: 'x'.\r	assert: (currentSnippet: thread suspendedActivation sender) equals: 'add: 3 to: 4'.\r	thread stepInto. (* Send x *)\r\r	assert: (currentSnippet: thread suspendedActivation) equals: 'y'.\r	assert: (currentSnippet: thread suspendedActivation sender) equals: 'add: 3 to: 4'.\r	thread stepInto. (* Send y *)\r\r	assert: (currentSnippet: thread suspendedActivation) equals: '+ y'.\r	assert: (currentSnippet: thread suspendedActivation sender) equals: 'add: 3 to: 4'.\r	thread stepInto. (* Send + y *)\r\r	assert: (currentSnippet: thread suspendedActivation) equals: 'z:: x + y'.\r	assert: (currentSnippet: thread suspendedActivation sender) equals: 'add: 3 to: 4'.\r	thread stepInto. (* Send z: *)\r\r	assert: (currentSnippet: thread suspendedActivation) equals: 'z'.\r	assert: (currentSnippet: thread suspendedActivation sender) equals: 'add: 3 to: 4'.\r	thread stepInto. (* Send z *)\r\r	assert: (currentSnippet: thread suspendedActivation) equals: '^z'.\r	assert: (currentSnippet: thread suspendedActivation sender) equals: 'add: 3 to: 4'.\r	thread stepInto. (* Return top *)\r\r	assert: (currentSnippet: thread suspendedActivation) equals: 'add: 3 to: 4'.\r	thread stepInto. (* Return top *)\r\r	assert: thread isFulfilled.\r)",
 "public testActivationStepInto = (\r	| thread activation |\r	thread:: ActivationMirror invokeSuspended: seven.\r	assert: thread isSuspended.\r	thread stepInto. (* Push 3 *)\r	assert: thread isSuspended.\r	assertList: (stackOf: thread) equals: {#seven}.\r	thread stepInto. (* Push 4 *)\r	assert: thread isSuspended.\r	assertList: (stackOf: thread) equals: {#seven}.\r	thread stepInto. (* Send + *)\r	assert: thread isSuspended.\r	assertList: (stackOf: thread) equals: {#seven}.\r	thread stepInto. (* Return 7 *)\r	assert: thread isFulfilled.\r	assert: thread result equals: (ObjectMirror reflecting: 7).\r	assertList: (stackOf: thread) equals: {}.\r)",
 "public testActivationStepOut = (\r	| thread activation |\r	thread:: ActivationMirror invokeSuspended: seventySeven.\r\r	assertThread: thread atMethod: #seventySeven snippet: '3'.\r	thread suspendedActivation stepOver. (* Push 3 *)\r	assertThread: thread atMethod: #seventySeven snippet: '4'.\r	thread suspendedActivation stepOver. (* Push 4 *)\r	assertThread: thread atMethod: #seventySeven snippet:  'add: 3 to: 4'.\r	thread suspendedActivation stepInto. (* Send add:to: *)\r	assertThread: thread atMethod: #add:to: snippet:  'x'.\r	thread suspendedActivation stepOut.\r	assertThread: thread atMethod: #seventySeven snippet:  '30'.\r	thread suspendedActivation stepOver. (* Push 30 *)\r	assertThread: thread atMethod: #seventySeven snippet:  '40'.\r	thread suspendedActivation stepOver. (* Push 40 *)\r	assertThread: thread atMethod: #seventySeven snippet:  'add: 30 to: 40'.\r	thread suspendedActivation stepInto. (* Send add:to: *)\r	assertThread: thread atMethod: #add:to: snippet:  'x'.\r	thread suspendedActivation stepOut.\r	assertThread: thread atMethod: #seventySeven snippet:  '+ (add: 30 to: 40)'.\r	thread suspendedActivation stepOut.\r\r	assert: thread isFulfilled.\r	assert: thread result equals: (ObjectMirror reflecting: 77).\r	assert: thread suspendedActivation equals: nil.\r)",
 "public testActivationStepOutNLRSkipsGoal = (\r	| thread activation |\r	thread:: ActivationMirror invokeSuspended: [nlr1].\r\r	assertThread: thread atMethod: #testActivationStepOutNLRSkipsGoal snippet: 'nlr1'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr1 snippet: 'nlr2'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr2 snippet: '[^2]'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr2 snippet: 'nlr3: [^2]'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr3: snippet: 'block'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr3: snippet: 'value'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr2 snippet: '2'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr2 snippet: '^2'.\r\r	thread suspendedActivation stepOut.\r	assertThread: thread atMethod: #nlr1 snippet: '^nlr2'.\r\r	thread resume.\r	assert: thread isFulfilled.\r	assert: thread result equals: (ObjectMirror reflecting: 2).\r	assert: thread suspendedActivation equals: nil.\r)",
 "public testActivationStepOver = (\r	| thread activation |\r	thread:: ActivationMirror invokeSuspended: seventySeven.\r\r	assertThread: thread atMethod: #seventySeven snippet: '3'.\r	thread suspendedActivation stepOver. (* Push 3 *)\r	assertThread: thread atMethod: #seventySeven snippet: '4'.\r	thread suspendedActivation stepOver. (* Push 4 *)\r	assertThread: thread atMethod: #seventySeven snippet: 'add: 3 to: 4'.\r	thread suspendedActivation stepOver. (* Send add:to: *)\r	assertThread: thread atMethod: #seventySeven snippet: '30'.\r	thread suspendedActivation stepOver. (* Push 30 *)\r	assertThread: thread atMethod: #seventySeven snippet: '40'.\r	thread suspendedActivation stepOver. (* Push 40 *)\r	assertThread: thread atMethod: #seventySeven snippet: 'add: 30 to: 40'.\r	thread suspendedActivation stepOver. (* Send add:to: *)\r	assertThread: thread atMethod: #seventySeven snippet: '+ (add: 30 to: 40)'.\r	thread suspendedActivation stepOver. (* Send + *)\r	assertThread: thread atMethod: #seventySeven snippet: '(add: 3 to: 4) + (add: 30 to: 40)'.\r	thread suspendedActivation stepOver. (* Return 77 *)\r\r	assert: thread isFulfilled.\r	assert: thread result equals: (ObjectMirror reflecting: 77).\r	assert: thread suspendedActivation equals: nil.\r)",
 "public testActivationStepOverNLRSkipsGoal = (\r	| thread activation |\r	thread:: ActivationMirror invokeSuspended: [nlr1].\r\r	assertThread: thread atMethod: #testActivationStepOverNLRSkipsGoal snippet: 'nlr1'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr1 snippet: 'nlr2'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr2 snippet: '[^2]'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr2 snippet: 'nlr3: [^2]'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr3: snippet: 'block'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr3: snippet: 'value'.\r\r	thread suspendedActivation stepOver.\r	assertThread: thread atMethod: #nlr1 snippet: '^nlr2'.\r\r	thread resume.\r	assert: thread isFulfilled.\r	assert: thread result equals: (ObjectMirror reflecting: 2).\r	assert: thread suspendedActivation equals: nil.\r)",
 "public testActivationStepThrough = (\r	| thread activation |\r	thread:: ActivationMirror invokeSuspended: [nlr1].\r\r	assertThread: thread atMethod: #testActivationStepThrough snippet: 'nlr1'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr1 snippet: 'nlr2'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr2 snippet: '[^2]'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr2 snippet: 'nlr3: [^2]'.\r\r	thread suspendedActivation stepThrough.\r	assertThread: thread atMethod: #nlr2 snippet: '2'.\r\r	thread resume.\r	assert: thread isFulfilled.\r	assert: thread result equals: (ObjectMirror reflecting: 2).\r	assert: thread suspendedActivation equals: nil.\r)",
 "public testActivationStepThroughNLRSkipsGoal = (\r	| thread activation |\r	thread:: ActivationMirror invokeSuspended: [nlr1].\r\r	assertThread: thread atMethod: #testActivationStepThroughNLRSkipsGoal snippet: 'nlr1'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr1 snippet: 'nlr2'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr2 snippet: '[^2]'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr2 snippet: 'nlr3: [^2]'.\r	thread suspendedActivation stepThrough.\r	assertThread: thread atMethod: #nlr2 snippet: '2'.\r	thread suspendedActivation stepInto.\r	assertThread: thread atMethod: #nlr2 snippet: '^2'.\r\r	thread suspendedActivation stepThrough.\r	assertThread: thread atMethod: #nlr1 snippet: '^nlr2'.\r\r	thread resume.\r	assert: thread isFulfilled.\r	assert: thread result equals: (ObjectMirror reflecting: 2).\r	assert: thread suspendedActivation equals: nil.\r)",
 "public testBrokenThreadAtSenderOfSignal = (\r	| exception closure thread activation |\r	exception:: Exception new.\r	closure:: [exception signal].\r	thread:: (ActivationMirror invokeSuspended: closure) resume.\r\r	assert: thread isBroken.\r	assert: thread result reflectee equals: exception.\r	assertThread: thread atMethod: #testBrokenThreadAtSenderOfSignal snippet: 'exception signal'.\r)",
 "public testClosureActivation = (\r	| closure thread activation |\r	closure:: seven.\r	thread:: ActivationMirror invokeSuspended: closure.\r	assert: thread isSuspended.\r\r	activation:: thread suspendedActivation.\r	assert: activation closure equals: (ObjectMirror reflecting: closure).\r	assert: activation receiver equals: (ObjectMirror reflecting: self).\r	assert: activation method name equals: #seven.\r	assert: activation sender equals: nil.\r\r	activation:: activation enclosingActivation.\r	assert: activation closure equals: nil.\r	assert: activation receiver equals: (ObjectMirror reflecting: self).\r	assert: activation method name equals: #seven.\r	assert: activation sender equals: nil.\r)",
 "public testEnclosingActivationEquality = (\r	| closure thread activation |\r	thread:: (ObjectMirror reflecting: self) evaluateSuspended: '[1984] value'.\r	thread suspendedActivation stepInto. (* Push closure *)\r	thread suspendedActivation stepInto. (* Send value *)\r	assert: thread isSuspended.\r\r	activation:: thread suspendedActivation.\r	deny: activation closure equals: nil.\r	assert: activation sender equals: activation enclosingActivation.\r)",
 "public testEvaluateActivation = (\r	| closure thread activation |\r	thread:: (ObjectMirror reflecting: self) evaluateSuspended: '3 + 4'.\r	assert: thread isSuspended.\r	activation:: thread suspendedActivation.\r	assert: activation closure equals: nil.\r	assert: activation receiver equals: (ObjectMirror reflecting: self).\r	assert: activation method name equals: #DoItIn:With:.\r	assert: activation method source equals: '3 + 4'.\r	assert: activation sender equals: nil.\r	assert: activation enclosingActivation equals: nil.\r)",
 "public testEvaluateActivationLocals = (\r	| thread activation locals |\r	thread:: (ObjectMirror reflecting: self) evaluateSuspended: ' | seven | seven:: 3 + 4 '.\r	assert: thread isSuspended.\r\r	thread stepInto. (* Push 3 *)\r	thread stepInto. (* Push 4 *)\r	thread stepInto. (* Send + *)\r	thread stepInto. (* Send seven: *)\r\r	activation:: thread suspendedActivation.\r	assert: activation closure equals: nil.\r	assert: activation receiver equals: (ObjectMirror reflecting: self).\r	assert: activation method name equals: #DoItIn:With:.\r	assert: activation method source equals: ' | seven | seven:: 3 + 4 '.\r	assert: activation sender equals: nil.\r	locals:: activation slots.\r	assert: (locals at: 1) name equals: 'seven'.\r	assert: (locals at: 1) value reflectee equals: 7.\r)",
 "public testQuickResumeReturnAcrossBoundry = (\r	assert: quickResumeReturnAcrossBoundry equals: 'expected return'\r)",
 "public testQuickResumeUnhandledException = (\r	| exception = Exception new. closure thread activation |\r	closure:: [exception signal].\r\r	thread:: ActivationMirror invokeSuspended: closure.\r	assert: thread isSuspended.\r\r	thread resume.\r\r	assert: thread isBroken.\r	assert: thread result reflectee equals: exception.\r	activation:: thread suspendedActivation.\r	assert: activation closure equals: (ObjectMirror reflecting: closure).\r	assert: activation receiver equals: (ObjectMirror reflecting: self).\r	assert: activation method name equals: #testQuickResumeUnhandledException.\r	assert: activation sender equals: nil.\r)",
 "TEST_CONTEXT = ()",
 "public class SimulationTests = SuperSimulationTests (\r(* Test that the Newspeak bytecodes run under image-side simulation and return the same results as the VM. *)\r)",
 "SuperSimulationTests",
 "SuperSimulationTests",
 "assertSimulation: block answers: expectedResult = (\r	| thread |\r	thread:: ActivationMirror invokeSuspended: block.\r	thread resumeSlowly.\r	assert: thread isFulfilled message: 'Expected thread fulfilled'.\r	assert: thread result reflectee equals: expectedResult.\r)",
 "assertSimulation: block signals: exceptionTestBlock = (\r	| thread |\r	thread:: ActivationMirror invokeSuspended: block.\r	thread resumeSlowly.\r	assert: thread isBroken message: 'Expected thread broken'.\r	exceptionTestBlock value: thread result reflectee.\r)",
 "public bar = (\r	^'bar'\r)",
 "public barWithArg: n = (\r	^n + 20\r)",
 "cannotReturn = (\r	^[^42]\r)",
 "ensure1 = (\r	[^'try-block'] ensure: [^'ensure-block'].\r	^'afterward'\r)",
 "ensure2 = (\r	^['try-block'] ensure: ['ensure-block'].\r)",
 "ensure3 = (\r	[^'try-block'] ensure: ['ensure-block'].\r	^'afterward'\r)",
 "foo = (\r	^'sub'\r)",
 "fooWithArg: n = (\r	^'sub'\r)",
 "simulationCannotReturnAcrossBoundry = (\r	assertSimulation: [^'escaping simulation!'] signals:\r		[:simulatedException |\r		 assert: (simulatedException printString startsWith: 'CannotReturn').\r		 assert: simulatedException result equals: 'escaping simulation!'].\r	^'expected return'\r)",
 "public testSimulationCannotReturn = (\r	assertSimulation: [cannotReturn value] signals:\r		[:simulatedException |\r		 assert: (simulatedException printString startsWith: 'CannotReturn').\r		 assert: simulatedException result equals: 42].\r)",
 "public testSimulationCannotReturnAcrossBoundry = (\r	assert: simulationCannotReturnAcrossBoundry equals: 'expected return'.\r)",
 "public testSimulationEnclosingObject = (\r	assertSimulation: [outer SimulationTests] answers: outer SimulationTests.\r	assertSimulation: [outer ActivationMirrorTesting] answers: outer ActivationMirrorTesting.\r)",
 "public testSimulationImplicitReceiverSend = (\r	assertSimulation: [foo] answers: 'sub'.\r	assertSimulation: [fooWithArg: 1] answers: 'sub'.\r	assertSimulation: [baz] answers: 'enclosing'.\r)",
 "public testSimulationJump = (\r	| mirror = ObjectMirror reflecting: self. |\r\r	\"a\" isKindOfString ifFalse: [^self]. (* This fails badly enough on Squeak to lock up the UI. *)\r\r	assertSimulation: [(mirror evaluate: 'foo') result] answers: (mirror evaluate: 'foo') result.\r)",
 "public testSimulationNonBooleanReceiver = (\r	assertSimulation: [0 ifTrue: [1]]\r	signals: [:simulatedException | assert: (simulatedException printString startsWith: 'NonBooleanReceiver')].\r\r	assertSimulation: [0 ifFalse: [1]]\r	signals: [:simulatedException | assert: (simulatedException printString startsWith: 'NonBooleanReceiver')].\r)",
 "public testSimulationOuterSend = (\r	assertSimulation: [outer SimulationTests foo] answers: 'sub'.\r	assertSimulation: [outer SimulationTests fooWithArg: 1] answers: 'sub'.\r	assertSimulation: [outer ActivationMirrorTesting foo] answers: 'enclosing'.\r	assertSimulation: [outer ActivationMirrorTesting fooWithArg: 1] answers: 'enclosing'.\r)",
 "public testSimulationPerform0 = (\r	| message = Message selector: #bar arguments: {}. |\r	assertSimulation: [message sendTo: self] answers: (message sendTo: self).\r)",
 "public testSimulationPerform1 = (\r	| message = Message selector: #barWithArg: arguments: {7}. |\r	assertSimulation: [message sendTo: self] answers: (message sendTo: self).\r)",
 "public testSimulationSelfSend = (\r	assertSimulation: [self foo] answers: 'sub'.\r	assertSimulation: [self fooWithArg: 1] answers: 'sub'.\r)",
 "public testSimulationSuperSend = (\r	assertSimulation: [super foo] answers: 'super'.\r	assertSimulation: [super fooWithArg: 1] answers: 'super'.\r)",
 "public testSimulationUnhandledException = (\r	| exception = Exception new. |\r	assertSimulation: [exception signal]\r	signals: [:simulatedException | assert: simulatedException equals: exception].\r)",
 "public testSimulationUnwindProtect = (\r	assertSimulation: [ensure1] answers: 'ensure-block'.\r	assertSimulation: [ensure2] answers: 'try-block'.\r	assertSimulation: [ensure3] answers: 'try-block'.\r)",
 "public testSimulationValue0 = (\r	| copied indirect closure |\r	copied:: 1.\r	indirect:: 2.\r	closure:: [copied + indirect].\r	assertSimulation: [closure value] answers: closure value.\r	indirect:: 4. (* write after capture forces use of indirection vector *)\r)",
 "public testSimulationValue1 = (\r	| copied indirect closure |\r	copied:: 1.\r	indirect:: 2.\r	closure:: [:x | copied + indirect + x].\r	assertSimulation: [closure value: 4] answers: (closure value: 4).\r	indirect:: 4. (* write after capture forces use of indirection vector *)\r)",
 "public testSimulationValue2 = (\r	| copied indirect closure |\r	copied:: 1.\r	indirect:: 2.\r	closure:: [:x :y | copied + indirect + x - y].\r	assertSimulation: [closure value: 4 value: 8] answers: (closure value: 4 value: 8).\r	indirect:: 4. (* write after capture forces use of indirection vector *)\r)",
 "public testSimulationValue3 = (\r	| copied indirect closure |\r	copied:: 1.\r	indirect:: 2.\r	closure:: [:x :y :z | copied + indirect + x - y * z].\r	assertSimulation: [closure value: 4 value: 8 value: 16] answers: (closure value: 4 value: 8 value: 16).\r	indirect:: 4. (* write after capture forces use of indirection vector *)\r)",
 "public testSimulationValueArray = (\r	| copied indirect closure |\r	copied:: 1.\r	indirect:: 2.\r	closure:: [:x :y :z | copied + indirect + x - y * z].\r	assertSimulation: [closure valueWithArguments: {4. 8. 16}] answers: (closure valueWithArguments: {4. 8. 16}).\r	indirect:: 4. (* write after capture forces use of indirection vector *)\r)",
 "TEST_CONTEXT = ()",
 "class SuperSimulationTests = TestContext ()",
 "TestContext",
 "TestContext",
 "foo = (\r	^'super'\r)",
 "fooWithArg: n = (\r	^'super'\r)",
 "class TestBase = TestContext ()",
 "TestContext",
 "TestContext",
 "assertSet: actual equals: expected = (\r	| missing extra missingString extraString |\r	missing:: Set new.\r	missing addAll: expected.\r	actual do: [:element | missing remove: element ifAbsent: []].\r	extra:: Set new.\r	extra addAll: actual.\r	expected do: [:element | extra remove: element ifAbsent: []].\r	(missing isEmpty and: [extra isEmpty]) ifTrue: [^self].\r\r	missingString: ''.\r	missing do: [:element | missingString: missingString, ' ', element printString].\r	extraString: ''.\r	extra do: [:element | extraString: extraString, ' ', element printString].\r\r	failWithMessage: 'Missing:', missingString, ' Extra:', extraString.\r)",
 "in: collection findMirrorNamed: name = (\r	collection do: [:mirror | mirror name = name ifTrue: [^mirror]].\r	^nil\r)",
 "class ActivationMirrorTestingConfiguration packageTestsUsing: manifest = (|\rprivate ActivationMirrorTesting = manifest ActivationMirrorTesting.\r|)",
 " ",
 " ",
 "public testModulesUsingPlatform: p minitest: m = (\r	^{ActivationMirrorTesting usingPlatform: p minitest: m}\r)"
]